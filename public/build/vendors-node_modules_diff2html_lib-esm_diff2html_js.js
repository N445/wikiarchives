(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_diff2html_lib-esm_diff2html_js"],{

/***/ "./node_modules/diff2html/lib-esm/diff-parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/diff-parser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parse": () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/diff2html/lib-esm/types.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/diff2html/lib-esm/utils.js");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};


function getExtension(filename, language) {
    var filenameParts = filename.split('.');
    return filenameParts.length > 1 ? filenameParts[filenameParts.length - 1] : language;
}
function startsWithAny(str, prefixes) {
    return prefixes.reduce(function (startsWith, prefix) { return startsWith || str.startsWith(prefix); }, false);
}
var baseDiffFilenamePrefixes = ['a/', 'b/', 'i/', 'w/', 'c/', 'o/'];
function getFilename(line, linePrefix, extraPrefix) {
    var prefixes = extraPrefix !== undefined ? __spreadArray(__spreadArray([], baseDiffFilenamePrefixes, true), [extraPrefix], false) : baseDiffFilenamePrefixes;
    var FilenameRegExp = linePrefix
        ? new RegExp("^" + (0,_utils__WEBPACK_IMPORTED_MODULE_1__.escapeForRegExp)(linePrefix) + " \"?(.+?)\"?$")
        : new RegExp('^"?(.+?)"?$');
    var _a = FilenameRegExp.exec(line) || [], _b = _a[1], filename = _b === void 0 ? '' : _b;
    var matchingPrefix = prefixes.find(function (p) { return filename.indexOf(p) === 0; });
    var fnameWithoutPrefix = matchingPrefix ? filename.slice(matchingPrefix.length) : filename;
    return fnameWithoutPrefix.replace(/\s+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)? [+-]\d{4}.*$/, '');
}
function getSrcFilename(line, srcPrefix) {
    return getFilename(line, '---', srcPrefix);
}
function getDstFilename(line, dstPrefix) {
    return getFilename(line, '+++', dstPrefix);
}
function parse(diffInput, config) {
    if (config === void 0) { config = {}; }
    var files = [];
    var currentFile = null;
    var currentBlock = null;
    var oldLine = null;
    var oldLine2 = null;
    var newLine = null;
    var possibleOldName = null;
    var possibleNewName = null;
    var oldFileNameHeader = '--- ';
    var newFileNameHeader = '+++ ';
    var hunkHeaderPrefix = '@@';
    var oldMode = /^old mode (\d{6})/;
    var newMode = /^new mode (\d{6})/;
    var deletedFileMode = /^deleted file mode (\d{6})/;
    var newFileMode = /^new file mode (\d{6})/;
    var copyFrom = /^copy from "?(.+)"?/;
    var copyTo = /^copy to "?(.+)"?/;
    var renameFrom = /^rename from "?(.+)"?/;
    var renameTo = /^rename to "?(.+)"?/;
    var similarityIndex = /^similarity index (\d+)%/;
    var dissimilarityIndex = /^dissimilarity index (\d+)%/;
    var index = /^index ([\da-z]+)\.\.([\da-z]+)\s*(\d{6})?/;
    var binaryFiles = /^Binary files (.*) and (.*) differ/;
    var binaryDiff = /^GIT binary patch/;
    var combinedIndex = /^index ([\da-z]+),([\da-z]+)\.\.([\da-z]+)/;
    var combinedMode = /^mode (\d{6}),(\d{6})\.\.(\d{6})/;
    var combinedNewFile = /^new file mode (\d{6})/;
    var combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
    var diffLines = diffInput
        .replace(/\\ No newline at end of file/g, '')
        .replace(/\r\n?/g, '\n')
        .split('\n');
    function saveBlock() {
        if (currentBlock !== null && currentFile !== null) {
            currentFile.blocks.push(currentBlock);
            currentBlock = null;
        }
    }
    function saveFile() {
        if (currentFile !== null) {
            if (!currentFile.oldName && possibleOldName !== null) {
                currentFile.oldName = possibleOldName;
            }
            if (!currentFile.newName && possibleNewName !== null) {
                currentFile.newName = possibleNewName;
            }
            if (currentFile.newName) {
                files.push(currentFile);
                currentFile = null;
            }
        }
        possibleOldName = null;
        possibleNewName = null;
    }
    function startFile() {
        saveBlock();
        saveFile();
        currentFile = {
            blocks: [],
            deletedLines: 0,
            addedLines: 0,
        };
    }
    function startBlock(line) {
        saveBlock();
        var values;
        if (currentFile !== null) {
            if ((values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@.*/.exec(line))) {
                currentFile.isCombined = false;
                oldLine = parseInt(values[1], 10);
                newLine = parseInt(values[2], 10);
            }
            else if ((values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@.*/.exec(line))) {
                currentFile.isCombined = true;
                oldLine = parseInt(values[1], 10);
                oldLine2 = parseInt(values[2], 10);
                newLine = parseInt(values[3], 10);
            }
            else {
                if (line.startsWith(hunkHeaderPrefix)) {
                    console.error('Failed to parse lines, starting in 0!');
                }
                oldLine = 0;
                newLine = 0;
                currentFile.isCombined = false;
            }
        }
        currentBlock = {
            lines: [],
            oldStartLine: oldLine,
            oldStartLine2: oldLine2,
            newStartLine: newLine,
            header: line,
        };
    }
    function createLine(line) {
        if (currentFile === null || currentBlock === null || oldLine === null || newLine === null)
            return;
        var currentLine = {
            content: line,
        };
        var addedPrefixes = currentFile.isCombined ? ['+ ', ' +', '++'] : ['+'];
        var deletedPrefixes = currentFile.isCombined ? ['- ', ' -', '--'] : ['-'];
        if (startsWithAny(line, addedPrefixes)) {
            currentFile.addedLines++;
            currentLine.type = _types__WEBPACK_IMPORTED_MODULE_0__.LineType.INSERT;
            currentLine.oldNumber = undefined;
            currentLine.newNumber = newLine++;
        }
        else if (startsWithAny(line, deletedPrefixes)) {
            currentFile.deletedLines++;
            currentLine.type = _types__WEBPACK_IMPORTED_MODULE_0__.LineType.DELETE;
            currentLine.oldNumber = oldLine++;
            currentLine.newNumber = undefined;
        }
        else {
            currentLine.type = _types__WEBPACK_IMPORTED_MODULE_0__.LineType.CONTEXT;
            currentLine.oldNumber = oldLine++;
            currentLine.newNumber = newLine++;
        }
        currentBlock.lines.push(currentLine);
    }
    function existHunkHeader(line, lineIdx) {
        var idx = lineIdx;
        while (idx < diffLines.length - 3) {
            if (line.startsWith('diff')) {
                return false;
            }
            if (diffLines[idx].startsWith(oldFileNameHeader) &&
                diffLines[idx + 1].startsWith(newFileNameHeader) &&
                diffLines[idx + 2].startsWith(hunkHeaderPrefix)) {
                return true;
            }
            idx++;
        }
        return false;
    }
    diffLines.forEach(function (line, lineIndex) {
        if (!line || line.startsWith('*')) {
            return;
        }
        var values;
        var prevLine = diffLines[lineIndex - 1];
        var nxtLine = diffLines[lineIndex + 1];
        var afterNxtLine = diffLines[lineIndex + 2];
        if (line.startsWith('diff')) {
            startFile();
            var gitDiffStart = /^diff --git "?([a-ciow]\/.+)"? "?([a-ciow]\/.+)"?/;
            if ((values = gitDiffStart.exec(line))) {
                possibleOldName = getFilename(values[1], undefined, config.dstPrefix);
                possibleNewName = getFilename(values[2], undefined, config.srcPrefix);
            }
            if (currentFile === null) {
                throw new Error('Where is my file !!!');
            }
            currentFile.isGitDiff = true;
            return;
        }
        if (!currentFile ||
            (!currentFile.isGitDiff &&
                currentFile &&
                line.startsWith(oldFileNameHeader) &&
                nxtLine.startsWith(newFileNameHeader) &&
                afterNxtLine.startsWith(hunkHeaderPrefix))) {
            startFile();
        }
        if (currentFile === null || currentFile === void 0 ? void 0 : currentFile.isTooBig) {
            return;
        }
        if (currentFile &&
            ((typeof config.diffMaxChanges === 'number' &&
                currentFile.addedLines + currentFile.deletedLines > config.diffMaxChanges) ||
                (typeof config.diffMaxLineLength === 'number' && line.length > config.diffMaxLineLength))) {
            currentFile.isTooBig = true;
            currentFile.addedLines = 0;
            currentFile.deletedLines = 0;
            currentFile.blocks = [];
            currentBlock = null;
            var message = typeof config.diffTooBigMessage === 'function'
                ? config.diffTooBigMessage(files.length)
                : 'Diff too big to be displayed';
            startBlock(message);
            return;
        }
        if ((line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader)) ||
            (line.startsWith(newFileNameHeader) && prevLine.startsWith(oldFileNameHeader))) {
            if (currentFile &&
                !currentFile.oldName &&
                line.startsWith('--- ') &&
                (values = getSrcFilename(line, config.srcPrefix))) {
                currentFile.oldName = values;
                currentFile.language = getExtension(currentFile.oldName, currentFile.language);
                return;
            }
            if (currentFile &&
                !currentFile.newName &&
                line.startsWith('+++ ') &&
                (values = getDstFilename(line, config.dstPrefix))) {
                currentFile.newName = values;
                currentFile.language = getExtension(currentFile.newName, currentFile.language);
                return;
            }
        }
        if (currentFile &&
            (line.startsWith(hunkHeaderPrefix) ||
                (currentFile.isGitDiff && currentFile.oldName && currentFile.newName && !currentBlock))) {
            startBlock(line);
            return;
        }
        if (currentBlock && (line.startsWith('+') || line.startsWith('-') || line.startsWith(' '))) {
            createLine(line);
            return;
        }
        var doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
        if (currentFile === null) {
            throw new Error('Where is my file !!!');
        }
        if ((values = oldMode.exec(line))) {
            currentFile.oldMode = values[1];
        }
        else if ((values = newMode.exec(line))) {
            currentFile.newMode = values[1];
        }
        else if ((values = deletedFileMode.exec(line))) {
            currentFile.deletedFileMode = values[1];
            currentFile.isDeleted = true;
        }
        else if ((values = newFileMode.exec(line))) {
            currentFile.newFileMode = values[1];
            currentFile.isNew = true;
        }
        else if ((values = copyFrom.exec(line))) {
            if (doesNotExistHunkHeader) {
                currentFile.oldName = values[1];
            }
            currentFile.isCopy = true;
        }
        else if ((values = copyTo.exec(line))) {
            if (doesNotExistHunkHeader) {
                currentFile.newName = values[1];
            }
            currentFile.isCopy = true;
        }
        else if ((values = renameFrom.exec(line))) {
            if (doesNotExistHunkHeader) {
                currentFile.oldName = values[1];
            }
            currentFile.isRename = true;
        }
        else if ((values = renameTo.exec(line))) {
            if (doesNotExistHunkHeader) {
                currentFile.newName = values[1];
            }
            currentFile.isRename = true;
        }
        else if ((values = binaryFiles.exec(line))) {
            currentFile.isBinary = true;
            currentFile.oldName = getFilename(values[1], undefined, config.srcPrefix);
            currentFile.newName = getFilename(values[2], undefined, config.dstPrefix);
            startBlock('Binary file');
        }
        else if (binaryDiff.test(line)) {
            currentFile.isBinary = true;
            startBlock(line);
        }
        else if ((values = similarityIndex.exec(line))) {
            currentFile.unchangedPercentage = parseInt(values[1], 10);
        }
        else if ((values = dissimilarityIndex.exec(line))) {
            currentFile.changedPercentage = parseInt(values[1], 10);
        }
        else if ((values = index.exec(line))) {
            currentFile.checksumBefore = values[1];
            currentFile.checksumAfter = values[2];
            values[3] && (currentFile.mode = values[3]);
        }
        else if ((values = combinedIndex.exec(line))) {
            currentFile.checksumBefore = [values[2], values[3]];
            currentFile.checksumAfter = values[1];
        }
        else if ((values = combinedMode.exec(line))) {
            currentFile.oldMode = [values[2], values[3]];
            currentFile.newMode = values[1];
        }
        else if ((values = combinedNewFile.exec(line))) {
            currentFile.newFileMode = values[1];
            currentFile.isNew = true;
        }
        else if ((values = combinedDeletedFile.exec(line))) {
            currentFile.deletedFileMode = values[1];
            currentFile.isDeleted = true;
        }
    });
    saveBlock();
    saveFile();
    return files;
}
//# sourceMappingURL=diff-parser.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/diff2html-templates.js":
/*!***************************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/diff2html-templates.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultTemplates": () => (/* binding */ defaultTemplates)
/* harmony export */ });
/* harmony import */ var hogan_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hogan.js */ "./node_modules/hogan.js/lib/hogan.js");
/* harmony import */ var hogan_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hogan_js__WEBPACK_IMPORTED_MODULE_0__);

var defaultTemplates = {};
defaultTemplates["file-summary-line"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<li class=\"d2h-file-list-line\">"); t.b("\n" + i); t.b("    <span class=\"d2h-file-name-wrapper\">"); t.b("\n" + i); t.b(t.rp("<fileIcon0", c, p, "      ")); t.b("      <a href=\"#"); t.b(t.v(t.f("fileHtmlId", c, p, 0))); t.b("\" class=\"d2h-file-name\">"); t.b(t.v(t.f("fileName", c, p, 0))); t.b("</a>"); t.b("\n" + i); t.b("      <span class=\"d2h-file-stats\">"); t.b("\n" + i); t.b("          <span class=\"d2h-lines-added\">"); t.b(t.v(t.f("addedLines", c, p, 0))); t.b("</span>"); t.b("\n" + i); t.b("          <span class=\"d2h-lines-deleted\">"); t.b(t.v(t.f("deletedLines", c, p, 0))); t.b("</span>"); t.b("\n" + i); t.b("      </span>"); t.b("\n" + i); t.b("    </span>"); t.b("\n" + i); t.b("</li>"); return t.fl(); }, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["file-summary-wrapper"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<div class=\"d2h-file-list-wrapper\">"); t.b("\n" + i); t.b("    <div class=\"d2h-file-list-header\">"); t.b("\n" + i); t.b("        <span class=\"d2h-file-list-title\">Files changed ("); t.b(t.v(t.f("filesNumber", c, p, 0))); t.b(")</span>"); t.b("\n" + i); t.b("        <a class=\"d2h-file-switch d2h-hide\">hide</a>"); t.b("\n" + i); t.b("        <a class=\"d2h-file-switch d2h-show\">show</a>"); t.b("\n" + i); t.b("    </div>"); t.b("\n" + i); t.b("    <ol class=\"d2h-file-list\">"); t.b("\n" + i); t.b("    "); t.b(t.t(t.f("files", c, p, 0))); t.b("\n" + i); t.b("    </ol>"); t.b("\n" + i); t.b("</div>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["generic-block-header"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<tr>"); t.b("\n" + i); t.b("    <td class=\""); t.b(t.v(t.f("lineClass", c, p, 0))); t.b(" "); t.b(t.v(t.d("CSSLineClass.INFO", c, p, 0))); t.b("\"></td>"); t.b("\n" + i); t.b("    <td class=\""); t.b(t.v(t.d("CSSLineClass.INFO", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("        <div class=\""); t.b(t.v(t.f("contentClass", c, p, 0))); t.b("\">"); t.b(t.t(t.f("blockHeader", c, p, 0))); t.b("</div>"); t.b("\n" + i); t.b("    </td>"); t.b("\n" + i); t.b("</tr>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["generic-empty-diff"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<tr>"); t.b("\n" + i); t.b("    <td class=\""); t.b(t.v(t.d("CSSLineClass.INFO", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("        <div class=\""); t.b(t.v(t.f("contentClass", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("            File without changes"); t.b("\n" + i); t.b("        </div>"); t.b("\n" + i); t.b("    </td>"); t.b("\n" + i); t.b("</tr>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["generic-file-path"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<span class=\"d2h-file-name-wrapper\">"); t.b("\n" + i); t.b(t.rp("<fileIcon0", c, p, "    ")); t.b("    <span class=\"d2h-file-name\">"); t.b(t.v(t.f("fileDiffName", c, p, 0))); t.b("</span>"); t.b("\n" + i); t.b(t.rp("<fileTag1", c, p, "    ")); t.b("</span>"); t.b("\n" + i); t.b("<label class=\"d2h-file-collapse\">"); t.b("\n" + i); t.b("    <input class=\"d2h-file-collapse-input\" type=\"checkbox\" name=\"viewed\" value=\"viewed\">"); t.b("\n" + i); t.b("    Viewed"); t.b("\n" + i); t.b("</label>"); return t.fl(); }, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} }, "<fileTag1": { name: "fileTag", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["generic-line"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<tr>"); t.b("\n" + i); t.b("    <td class=\""); t.b(t.v(t.f("lineClass", c, p, 0))); t.b(" "); t.b(t.v(t.f("type", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("      "); t.b(t.t(t.f("lineNumber", c, p, 0))); t.b("\n" + i); t.b("    </td>"); t.b("\n" + i); t.b("    <td class=\""); t.b(t.v(t.f("type", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("        <div class=\""); t.b(t.v(t.f("contentClass", c, p, 0))); t.b("\">"); t.b("\n" + i); if (t.s(t.f("prefix", c, p, 1), c, p, 0, 162, 238, "{{ }}")) {
        t.rs(c, p, function (c, p, t) { t.b("            <span class=\"d2h-code-line-prefix\">"); t.b(t.t(t.f("prefix", c, p, 0))); t.b("</span>"); t.b("\n" + i); });
        c.pop();
    } if (!t.s(t.f("prefix", c, p, 1), c, p, 1, 0, 0, "")) {
        t.b("            <span class=\"d2h-code-line-prefix\">&nbsp;</span>");
        t.b("\n" + i);
    } ; if (t.s(t.f("content", c, p, 1), c, p, 0, 371, 445, "{{ }}")) {
        t.rs(c, p, function (c, p, t) { t.b("            <span class=\"d2h-code-line-ctn\">"); t.b(t.t(t.f("content", c, p, 0))); t.b("</span>"); t.b("\n" + i); });
        c.pop();
    } if (!t.s(t.f("content", c, p, 1), c, p, 1, 0, 0, "")) {
        t.b("            <span class=\"d2h-code-line-ctn\"><br></span>");
        t.b("\n" + i);
    } ; t.b("        </div>"); t.b("\n" + i); t.b("    </td>"); t.b("\n" + i); t.b("</tr>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["generic-wrapper"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<div class=\"d2h-wrapper\">"); t.b("\n" + i); t.b("    "); t.b(t.t(t.f("content", c, p, 0))); t.b("\n" + i); t.b("</div>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["icon-file-added"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-added\" height=\"16\" title=\"added\" version=\"1.1\" viewBox=\"0 0 14 16\""); t.b("\n" + i); t.b("     width=\"14\">"); t.b("\n" + i); t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z\"></path>"); t.b("\n" + i); t.b("</svg>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["icon-file-changed"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-changed\" height=\"16\" title=\"modified\" version=\"1.1\""); t.b("\n" + i); t.b("     viewBox=\"0 0 14 16\" width=\"14\">"); t.b("\n" + i); t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z\"></path>"); t.b("\n" + i); t.b("</svg>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["icon-file-deleted"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-deleted\" height=\"16\" title=\"removed\" version=\"1.1\""); t.b("\n" + i); t.b("     viewBox=\"0 0 14 16\" width=\"14\">"); t.b("\n" + i); t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM11 9H3V7h8v2z\"></path>"); t.b("\n" + i); t.b("</svg>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["icon-file-renamed"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-moved\" height=\"16\" title=\"renamed\" version=\"1.1\""); t.b("\n" + i); t.b("     viewBox=\"0 0 14 16\" width=\"14\">"); t.b("\n" + i); t.b("    <path d=\"M6 9H3V7h3V4l5 4-5 4V9z m8-7v12c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h12c0.55 0 1 0.45 1 1z m-1 0H1v12h12V2z\"></path>"); t.b("\n" + i); t.b("</svg>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["icon-file"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<svg aria-hidden=\"true\" class=\"d2h-icon\" height=\"16\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\">"); t.b("\n" + i); t.b("    <path d=\"M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z\"></path>"); t.b("\n" + i); t.b("</svg>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["line-by-line-file-diff"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<div id=\""); t.b(t.v(t.f("fileHtmlId", c, p, 0))); t.b("\" class=\"d2h-file-wrapper\" data-lang=\""); t.b(t.v(t.d("file.language", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("    <div class=\"d2h-file-header\">"); t.b("\n" + i); t.b("    "); t.b(t.t(t.f("filePath", c, p, 0))); t.b("\n" + i); t.b("    </div>"); t.b("\n" + i); t.b("    <div class=\"d2h-file-diff\">"); t.b("\n" + i); t.b("        <div class=\"d2h-code-wrapper\">"); t.b("\n" + i); t.b("            <table class=\"d2h-diff-table\">"); t.b("\n" + i); t.b("                <tbody class=\"d2h-diff-tbody\">"); t.b("\n" + i); t.b("                "); t.b(t.t(t.f("diffs", c, p, 0))); t.b("\n" + i); t.b("                </tbody>"); t.b("\n" + i); t.b("            </table>"); t.b("\n" + i); t.b("        </div>"); t.b("\n" + i); t.b("    </div>"); t.b("\n" + i); t.b("</div>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["line-by-line-numbers"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<div class=\"line-num1\">"); t.b(t.v(t.f("oldNumber", c, p, 0))); t.b("</div>"); t.b("\n" + i); t.b("<div class=\"line-num2\">"); t.b(t.v(t.f("newNumber", c, p, 0))); t.b("</div>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["side-by-side-file-diff"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<div id=\""); t.b(t.v(t.f("fileHtmlId", c, p, 0))); t.b("\" class=\"d2h-file-wrapper\" data-lang=\""); t.b(t.v(t.d("file.language", c, p, 0))); t.b("\">"); t.b("\n" + i); t.b("    <div class=\"d2h-file-header\">"); t.b("\n" + i); t.b("      "); t.b(t.t(t.f("filePath", c, p, 0))); t.b("\n" + i); t.b("    </div>"); t.b("\n" + i); t.b("    <div class=\"d2h-files-diff\">"); t.b("\n" + i); t.b("        <div class=\"d2h-file-side-diff\">"); t.b("\n" + i); t.b("            <div class=\"d2h-code-wrapper\">"); t.b("\n" + i); t.b("                <table class=\"d2h-diff-table\">"); t.b("\n" + i); t.b("                    <tbody class=\"d2h-diff-tbody\">"); t.b("\n" + i); t.b("                    "); t.b(t.t(t.d("diffs.left", c, p, 0))); t.b("\n" + i); t.b("                    </tbody>"); t.b("\n" + i); t.b("                </table>"); t.b("\n" + i); t.b("            </div>"); t.b("\n" + i); t.b("        </div>"); t.b("\n" + i); t.b("        <div class=\"d2h-file-side-diff\">"); t.b("\n" + i); t.b("            <div class=\"d2h-code-wrapper\">"); t.b("\n" + i); t.b("                <table class=\"d2h-diff-table\">"); t.b("\n" + i); t.b("                    <tbody class=\"d2h-diff-tbody\">"); t.b("\n" + i); t.b("                    "); t.b(t.t(t.d("diffs.right", c, p, 0))); t.b("\n" + i); t.b("                    </tbody>"); t.b("\n" + i); t.b("                </table>"); t.b("\n" + i); t.b("            </div>"); t.b("\n" + i); t.b("        </div>"); t.b("\n" + i); t.b("    </div>"); t.b("\n" + i); t.b("</div>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["tag-file-added"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<span class=\"d2h-tag d2h-added d2h-added-tag\">ADDED</span>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["tag-file-changed"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<span class=\"d2h-tag d2h-changed d2h-changed-tag\">CHANGED</span>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["tag-file-deleted"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<span class=\"d2h-tag d2h-deleted d2h-deleted-tag\">DELETED</span>"); return t.fl(); }, partials: {}, subs: {} });
defaultTemplates["tag-file-renamed"] = new hogan_js__WEBPACK_IMPORTED_MODULE_0__.Template({ code: function (c, p, i) { var t = this; t.b(i = i || ""); t.b("<span class=\"d2h-tag d2h-moved d2h-moved-tag\">RENAMED</span>"); return t.fl(); }, partials: {}, subs: {} });
//# sourceMappingURL=diff2html-templates.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/diff2html.js":
/*!*****************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/diff2html.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultDiff2HtmlConfig": () => (/* binding */ defaultDiff2HtmlConfig),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "html": () => (/* binding */ html)
/* harmony export */ });
/* harmony import */ var _diff_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diff-parser */ "./node_modules/diff2html/lib-esm/diff-parser.js");
/* harmony import */ var _file_list_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./file-list-renderer */ "./node_modules/diff2html/lib-esm/file-list-renderer.js");
/* harmony import */ var _line_by_line_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-by-line-renderer */ "./node_modules/diff2html/lib-esm/line-by-line-renderer.js");
/* harmony import */ var _side_by_side_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./side-by-side-renderer */ "./node_modules/diff2html/lib-esm/side-by-side-renderer.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./node_modules/diff2html/lib-esm/types.js");
/* harmony import */ var _hoganjs_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hoganjs-utils */ "./node_modules/diff2html/lib-esm/hoganjs-utils.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};






var defaultDiff2HtmlConfig = __assign(__assign(__assign({}, _line_by_line_renderer__WEBPACK_IMPORTED_MODULE_2__.defaultLineByLineRendererConfig), _side_by_side_renderer__WEBPACK_IMPORTED_MODULE_3__.defaultSideBySideRendererConfig), { outputFormat: _types__WEBPACK_IMPORTED_MODULE_4__.OutputFormatType.LINE_BY_LINE, drawFileList: true });
function parse(diffInput, configuration) {
    if (configuration === void 0) { configuration = {}; }
    return _diff_parser__WEBPACK_IMPORTED_MODULE_0__.parse(diffInput, __assign(__assign({}, defaultDiff2HtmlConfig), configuration));
}
function html(diffInput, configuration) {
    if (configuration === void 0) { configuration = {}; }
    var config = __assign(__assign({}, defaultDiff2HtmlConfig), configuration);
    var diffJson = typeof diffInput === 'string' ? _diff_parser__WEBPACK_IMPORTED_MODULE_0__.parse(diffInput, config) : diffInput;
    var hoganUtils = new _hoganjs_utils__WEBPACK_IMPORTED_MODULE_5__["default"](config);
    var fileList = config.drawFileList ? _file_list_renderer__WEBPACK_IMPORTED_MODULE_1__.render(diffJson, hoganUtils) : '';
    var diffOutput = config.outputFormat === 'side-by-side'
        ? new _side_by_side_renderer__WEBPACK_IMPORTED_MODULE_3__["default"](hoganUtils, config).render(diffJson)
        : new _line_by_line_renderer__WEBPACK_IMPORTED_MODULE_2__["default"](hoganUtils, config).render(diffJson);
    return fileList + diffOutput;
}
//# sourceMappingURL=diff2html.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/file-list-renderer.js":
/*!**************************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/file-list-renderer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _render_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-utils */ "./node_modules/diff2html/lib-esm/render-utils.js");

var baseTemplatesPath = 'file-summary';
var iconsBaseTemplatesPath = 'icon';
function render(diffFiles, hoganUtils) {
    var files = diffFiles
        .map(function (file) {
        return hoganUtils.render(baseTemplatesPath, 'line', {
            fileHtmlId: _render_utils__WEBPACK_IMPORTED_MODULE_0__.getHtmlId(file),
            oldName: file.oldName,
            newName: file.newName,
            fileName: _render_utils__WEBPACK_IMPORTED_MODULE_0__.filenameDiff(file),
            deletedLines: '-' + file.deletedLines,
            addedLines: '+' + file.addedLines,
        }, {
            fileIcon: hoganUtils.template(iconsBaseTemplatesPath, _render_utils__WEBPACK_IMPORTED_MODULE_0__.getFileIcon(file)),
        });
    })
        .join('\n');
    return hoganUtils.render(baseTemplatesPath, 'wrapper', {
        filesNumber: diffFiles.length,
        files: files,
    });
}
//# sourceMappingURL=file-list-renderer.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/hoganjs-utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/hoganjs-utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hogan_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hogan.js */ "./node_modules/hogan.js/lib/hogan.js");
/* harmony import */ var hogan_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hogan_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _diff2html_templates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diff2html-templates */ "./node_modules/diff2html/lib-esm/diff2html-templates.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var HoganJsUtils = (function () {
    function HoganJsUtils(_a) {
        var _b = _a.compiledTemplates, compiledTemplates = _b === void 0 ? {} : _b, _c = _a.rawTemplates, rawTemplates = _c === void 0 ? {} : _c;
        var compiledRawTemplates = Object.entries(rawTemplates).reduce(function (previousTemplates, _a) {
            var _b;
            var name = _a[0], templateString = _a[1];
            var compiledTemplate = hogan_js__WEBPACK_IMPORTED_MODULE_0__.compile(templateString, { asString: false });
            return __assign(__assign({}, previousTemplates), (_b = {}, _b[name] = compiledTemplate, _b));
        }, {});
        this.preCompiledTemplates = __assign(__assign(__assign({}, _diff2html_templates__WEBPACK_IMPORTED_MODULE_1__.defaultTemplates), compiledTemplates), compiledRawTemplates);
    }
    HoganJsUtils.compile = function (templateString) {
        return hogan_js__WEBPACK_IMPORTED_MODULE_0__.compile(templateString, { asString: false });
    };
    HoganJsUtils.prototype.render = function (namespace, view, params, partials, indent) {
        var templateKey = this.templateKey(namespace, view);
        try {
            var template = this.preCompiledTemplates[templateKey];
            return template.render(params, partials, indent);
        }
        catch (e) {
            throw new Error("Could not find template to render '" + templateKey + "'");
        }
    };
    HoganJsUtils.prototype.template = function (namespace, view) {
        return this.preCompiledTemplates[this.templateKey(namespace, view)];
    };
    HoganJsUtils.prototype.templateKey = function (namespace, view) {
        return namespace + "-" + view;
    };
    return HoganJsUtils;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HoganJsUtils);
//# sourceMappingURL=hoganjs-utils.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/line-by-line-renderer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/line-by-line-renderer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultLineByLineRendererConfig": () => (/* binding */ defaultLineByLineRendererConfig),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rematch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rematch */ "./node_modules/diff2html/lib-esm/rematch.js");
/* harmony import */ var _render_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render-utils */ "./node_modules/diff2html/lib-esm/render-utils.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/diff2html/lib-esm/types.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var defaultLineByLineRendererConfig = __assign(__assign({}, _render_utils__WEBPACK_IMPORTED_MODULE_1__.defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath = 'generic';
var baseTemplatesPath = 'line-by-line';
var iconsBaseTemplatesPath = 'icon';
var tagsBaseTemplatesPath = 'tag';
var LineByLineRenderer = (function () {
    function LineByLineRenderer(hoganUtils, config) {
        if (config === void 0) { config = {}; }
        this.hoganUtils = hoganUtils;
        this.config = __assign(__assign({}, defaultLineByLineRendererConfig), config);
    }
    LineByLineRenderer.prototype.render = function (diffFiles) {
        var _this = this;
        var diffsHtml = diffFiles
            .map(function (file) {
            var diffs;
            if (file.blocks.length) {
                diffs = _this.generateFileHtml(file);
            }
            else {
                diffs = _this.generateEmptyDiff();
            }
            return _this.makeFileDiffHtml(file, diffs);
        })
            .join('\n');
        return this.hoganUtils.render(genericTemplatesPath, 'wrapper', { content: diffsHtml });
    };
    LineByLineRenderer.prototype.makeFileDiffHtml = function (file, diffs) {
        if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
            return '';
        var fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath, 'file-diff');
        var filePathTemplate = this.hoganUtils.template(genericTemplatesPath, 'file-path');
        var fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath, 'file');
        var fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, _render_utils__WEBPACK_IMPORTED_MODULE_1__.getFileIcon(file));
        return fileDiffTemplate.render({
            file: file,
            fileHtmlId: _render_utils__WEBPACK_IMPORTED_MODULE_1__.getHtmlId(file),
            diffs: diffs,
            filePath: filePathTemplate.render({
                fileDiffName: _render_utils__WEBPACK_IMPORTED_MODULE_1__.filenameDiff(file),
            }, {
                fileIcon: fileIconTemplate,
                fileTag: fileTagTemplate,
            }),
        });
    };
    LineByLineRenderer.prototype.generateEmptyDiff = function () {
        return this.hoganUtils.render(genericTemplatesPath, 'empty-diff', {
            contentClass: 'd2h-code-line',
            CSSLineClass: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass,
        });
    };
    LineByLineRenderer.prototype.generateFileHtml = function (file) {
        var _this = this;
        var matcher = _rematch__WEBPACK_IMPORTED_MODULE_0__.newMatcherFn(_rematch__WEBPACK_IMPORTED_MODULE_0__.newDistanceFn(function (e) { return _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(e.content, file.isCombined).content; }));
        return file.blocks
            .map(function (block) {
            var lines = _this.hoganUtils.render(genericTemplatesPath, 'block-header', {
                CSSLineClass: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass,
                blockHeader: file.isTooBig ? block.header : _render_utils__WEBPACK_IMPORTED_MODULE_1__.escapeForHtml(block.header),
                lineClass: 'd2h-code-linenumber',
                contentClass: 'd2h-code-line',
            });
            _this.applyLineGroupping(block).forEach(function (_a) {
                var contextLines = _a[0], oldLines = _a[1], newLines = _a[2];
                if (oldLines.length && newLines.length && !contextLines.length) {
                    _this.applyRematchMatching(oldLines, newLines, matcher).map(function (_a) {
                        var oldLines = _a[0], newLines = _a[1];
                        var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
                        lines += left;
                        lines += right;
                    });
                }
                else if (contextLines.length) {
                    contextLines.forEach(function (line) {
                        var _a = _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(line.content, file.isCombined), prefix = _a.prefix, content = _a.content;
                        lines += _this.generateSingleLineHtml({
                            type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.CONTEXT,
                            prefix: prefix,
                            content: content,
                            oldNumber: line.oldNumber,
                            newNumber: line.newNumber,
                        });
                    });
                }
                else if (oldLines.length || newLines.length) {
                    var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
                    lines += left;
                    lines += right;
                }
                else {
                    console.error('Unknown state reached while processing groups of lines', contextLines, oldLines, newLines);
                }
            });
            return lines;
        })
            .join('\n');
    };
    LineByLineRenderer.prototype.applyLineGroupping = function (block) {
        var blockLinesGroups = [];
        var oldLines = [];
        var newLines = [];
        for (var i = 0; i < block.lines.length; i++) {
            var diffLine = block.lines[i];
            if ((diffLine.type !== _types__WEBPACK_IMPORTED_MODULE_2__.LineType.INSERT && newLines.length) ||
                (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.CONTEXT && oldLines.length > 0)) {
                blockLinesGroups.push([[], oldLines, newLines]);
                oldLines = [];
                newLines = [];
            }
            if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.CONTEXT) {
                blockLinesGroups.push([[diffLine], [], []]);
            }
            else if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.INSERT && oldLines.length === 0) {
                blockLinesGroups.push([[], [], [diffLine]]);
            }
            else if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.INSERT && oldLines.length > 0) {
                newLines.push(diffLine);
            }
            else if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.DELETE) {
                oldLines.push(diffLine);
            }
        }
        if (oldLines.length || newLines.length) {
            blockLinesGroups.push([[], oldLines, newLines]);
            oldLines = [];
            newLines = [];
        }
        return blockLinesGroups;
    };
    LineByLineRenderer.prototype.applyRematchMatching = function (oldLines, newLines, matcher) {
        var comparisons = oldLines.length * newLines.length;
        var maxLineSizeInBlock = Math.max.apply(null, [0].concat(oldLines.concat(newLines).map(function (elem) { return elem.content.length; })));
        var doMatching = comparisons < this.config.matchingMaxComparisons &&
            maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison &&
            (this.config.matching === 'lines' || this.config.matching === 'words');
        return doMatching ? matcher(oldLines, newLines) : [[oldLines, newLines]];
    };
    LineByLineRenderer.prototype.processChangedLines = function (isCombined, oldLines, newLines) {
        var fileHtml = {
            right: '',
            left: '',
        };
        var maxLinesNumber = Math.max(oldLines.length, newLines.length);
        for (var i = 0; i < maxLinesNumber; i++) {
            var oldLine = oldLines[i];
            var newLine = newLines[i];
            var diff = oldLine !== undefined && newLine !== undefined
                ? _render_utils__WEBPACK_IMPORTED_MODULE_1__.diffHighlight(oldLine.content, newLine.content, isCombined, this.config)
                : undefined;
            var preparedOldLine = oldLine !== undefined && oldLine.oldNumber !== undefined
                ? __assign(__assign({}, (diff !== undefined
                    ? {
                        prefix: diff.oldLine.prefix,
                        content: diff.oldLine.content,
                        type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.DELETE_CHANGES,
                    }
                    : __assign(__assign({}, _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(oldLine.content, isCombined)), { type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.toCSSClass(oldLine.type) }))), { oldNumber: oldLine.oldNumber, newNumber: oldLine.newNumber }) : undefined;
            var preparedNewLine = newLine !== undefined && newLine.newNumber !== undefined
                ? __assign(__assign({}, (diff !== undefined
                    ? {
                        prefix: diff.newLine.prefix,
                        content: diff.newLine.content,
                        type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.INSERT_CHANGES,
                    }
                    : __assign(__assign({}, _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(newLine.content, isCombined)), { type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.toCSSClass(newLine.type) }))), { oldNumber: newLine.oldNumber, newNumber: newLine.newNumber }) : undefined;
            var _a = this.generateLineHtml(preparedOldLine, preparedNewLine), left = _a.left, right = _a.right;
            fileHtml.left += left;
            fileHtml.right += right;
        }
        return fileHtml;
    };
    LineByLineRenderer.prototype.generateLineHtml = function (oldLine, newLine) {
        return {
            left: this.generateSingleLineHtml(oldLine),
            right: this.generateSingleLineHtml(newLine),
        };
    };
    LineByLineRenderer.prototype.generateSingleLineHtml = function (line) {
        if (line === undefined)
            return '';
        var lineNumberHtml = this.hoganUtils.render(baseTemplatesPath, 'numbers', {
            oldNumber: line.oldNumber || '',
            newNumber: line.newNumber || '',
        });
        return this.hoganUtils.render(genericTemplatesPath, 'line', {
            type: line.type,
            lineClass: 'd2h-code-linenumber',
            contentClass: 'd2h-code-line',
            prefix: line.prefix === ' ' ? '&nbsp;' : line.prefix,
            content: line.content,
            lineNumber: lineNumberHtml,
        });
    };
    return LineByLineRenderer;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineByLineRenderer);
//# sourceMappingURL=line-by-line-renderer.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/rematch.js":
/*!***************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/rematch.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "levenshtein": () => (/* binding */ levenshtein),
/* harmony export */   "newDistanceFn": () => (/* binding */ newDistanceFn),
/* harmony export */   "newMatcherFn": () => (/* binding */ newMatcherFn)
/* harmony export */ });
function levenshtein(a, b) {
    if (a.length === 0) {
        return b.length;
    }
    if (b.length === 0) {
        return a.length;
    }
    var matrix = [];
    var i;
    for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }
    var j;
    for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            }
            else {
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
            }
        }
    }
    return matrix[b.length][a.length];
}
function newDistanceFn(str) {
    return function (x, y) {
        var xValue = str(x).trim();
        var yValue = str(y).trim();
        var lev = levenshtein(xValue, yValue);
        return lev / (xValue.length + yValue.length);
    };
}
function newMatcherFn(distance) {
    function findBestMatch(a, b, cache) {
        if (cache === void 0) { cache = new Map(); }
        var bestMatchDist = Infinity;
        var bestMatch;
        for (var i = 0; i < a.length; ++i) {
            for (var j = 0; j < b.length; ++j) {
                var cacheKey = JSON.stringify([a[i], b[j]]);
                var md = void 0;
                if (!(cache.has(cacheKey) && (md = cache.get(cacheKey)))) {
                    md = distance(a[i], b[j]);
                    cache.set(cacheKey, md);
                }
                if (md < bestMatchDist) {
                    bestMatchDist = md;
                    bestMatch = { indexA: i, indexB: j, score: bestMatchDist };
                }
            }
        }
        return bestMatch;
    }
    function group(a, b, level, cache) {
        if (level === void 0) { level = 0; }
        if (cache === void 0) { cache = new Map(); }
        var bm = findBestMatch(a, b, cache);
        if (!bm || a.length + b.length < 3) {
            return [[a, b]];
        }
        var a1 = a.slice(0, bm.indexA);
        var b1 = b.slice(0, bm.indexB);
        var aMatch = [a[bm.indexA]];
        var bMatch = [b[bm.indexB]];
        var tailA = bm.indexA + 1;
        var tailB = bm.indexB + 1;
        var a2 = a.slice(tailA);
        var b2 = b.slice(tailB);
        var group1 = group(a1, b1, level + 1, cache);
        var groupMatch = group(aMatch, bMatch, level + 1, cache);
        var group2 = group(a2, b2, level + 1, cache);
        var result = groupMatch;
        if (bm.indexA > 0 || bm.indexB > 0) {
            result = group1.concat(result);
        }
        if (a.length > tailA || b.length > tailB) {
            result = result.concat(group2);
        }
        return result;
    }
    return group;
}
//# sourceMappingURL=rematch.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/render-utils.js":
/*!********************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/render-utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSLineClass": () => (/* binding */ CSSLineClass),
/* harmony export */   "defaultRenderConfig": () => (/* binding */ defaultRenderConfig),
/* harmony export */   "toCSSClass": () => (/* binding */ toCSSClass),
/* harmony export */   "escapeForHtml": () => (/* binding */ escapeForHtml),
/* harmony export */   "deconstructLine": () => (/* binding */ deconstructLine),
/* harmony export */   "filenameDiff": () => (/* binding */ filenameDiff),
/* harmony export */   "getHtmlId": () => (/* binding */ getHtmlId),
/* harmony export */   "getFileIcon": () => (/* binding */ getFileIcon),
/* harmony export */   "diffHighlight": () => (/* binding */ diffHighlight)
/* harmony export */ });
/* harmony import */ var diff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diff */ "./node_modules/diff/lib/index.mjs");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/diff2html/lib-esm/utils.js");
/* harmony import */ var _rematch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rematch */ "./node_modules/diff2html/lib-esm/rematch.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/diff2html/lib-esm/types.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




var CSSLineClass = {
    INSERTS: 'd2h-ins',
    DELETES: 'd2h-del',
    CONTEXT: 'd2h-cntx',
    INFO: 'd2h-info',
    INSERT_CHANGES: 'd2h-ins d2h-change',
    DELETE_CHANGES: 'd2h-del d2h-change',
};
var defaultRenderConfig = {
    matching: _types__WEBPACK_IMPORTED_MODULE_3__.LineMatchingType.NONE,
    matchWordsThreshold: 0.25,
    maxLineLengthHighlight: 10000,
    diffStyle: _types__WEBPACK_IMPORTED_MODULE_3__.DiffStyleType.WORD,
};
var separator = '/';
var distance = _rematch__WEBPACK_IMPORTED_MODULE_2__.newDistanceFn(function (change) { return change.value; });
var matcher = _rematch__WEBPACK_IMPORTED_MODULE_2__.newMatcherFn(distance);
function isDevNullName(name) {
    return name.indexOf('dev/null') !== -1;
}
function removeInsElements(line) {
    return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, '');
}
function removeDelElements(line) {
    return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, '');
}
function toCSSClass(lineType) {
    switch (lineType) {
        case _types__WEBPACK_IMPORTED_MODULE_3__.LineType.CONTEXT:
            return CSSLineClass.CONTEXT;
        case _types__WEBPACK_IMPORTED_MODULE_3__.LineType.INSERT:
            return CSSLineClass.INSERTS;
        case _types__WEBPACK_IMPORTED_MODULE_3__.LineType.DELETE:
            return CSSLineClass.DELETES;
    }
}
function prefixLength(isCombined) {
    return isCombined ? 2 : 1;
}
function escapeForHtml(str) {
    return str
        .slice(0)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/\//g, '&#x2F;');
}
function deconstructLine(line, isCombined, escape) {
    if (escape === void 0) { escape = true; }
    var indexToSplit = prefixLength(isCombined);
    return {
        prefix: line.substring(0, indexToSplit),
        content: escape ? escapeForHtml(line.substring(indexToSplit)) : line.substring(indexToSplit),
    };
}
function filenameDiff(file) {
    var oldFilename = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.unifyPath)(file.oldName);
    var newFilename = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.unifyPath)(file.newName);
    if (oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
        var prefixPaths = [];
        var suffixPaths = [];
        var oldFilenameParts = oldFilename.split(separator);
        var newFilenameParts = newFilename.split(separator);
        var oldFilenamePartsSize = oldFilenameParts.length;
        var newFilenamePartsSize = newFilenameParts.length;
        var i = 0;
        var j = oldFilenamePartsSize - 1;
        var k = newFilenamePartsSize - 1;
        while (i < j && i < k) {
            if (oldFilenameParts[i] === newFilenameParts[i]) {
                prefixPaths.push(newFilenameParts[i]);
                i += 1;
            }
            else {
                break;
            }
        }
        while (j > i && k > i) {
            if (oldFilenameParts[j] === newFilenameParts[k]) {
                suffixPaths.unshift(newFilenameParts[k]);
                j -= 1;
                k -= 1;
            }
            else {
                break;
            }
        }
        var finalPrefix = prefixPaths.join(separator);
        var finalSuffix = suffixPaths.join(separator);
        var oldRemainingPath = oldFilenameParts.slice(i, j + 1).join(separator);
        var newRemainingPath = newFilenameParts.slice(i, k + 1).join(separator);
        if (finalPrefix.length && finalSuffix.length) {
            return (finalPrefix + separator + '{' + oldRemainingPath + '  ' + newRemainingPath + '}' + separator + finalSuffix);
        }
        else if (finalPrefix.length) {
            return finalPrefix + separator + '{' + oldRemainingPath + '  ' + newRemainingPath + '}';
        }
        else if (finalSuffix.length) {
            return '{' + oldRemainingPath + '  ' + newRemainingPath + '}' + separator + finalSuffix;
        }
        return oldFilename + '  ' + newFilename;
    }
    else if (!isDevNullName(newFilename)) {
        return newFilename;
    }
    else {
        return oldFilename;
    }
}
function getHtmlId(file) {
    return "d2h-" + (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hashCode)(filenameDiff(file)).toString().slice(-6);
}
function getFileIcon(file) {
    var templateName = 'file-changed';
    if (file.isRename) {
        templateName = 'file-renamed';
    }
    else if (file.isCopy) {
        templateName = 'file-renamed';
    }
    else if (file.isNew) {
        templateName = 'file-added';
    }
    else if (file.isDeleted) {
        templateName = 'file-deleted';
    }
    else if (file.newName !== file.oldName) {
        templateName = 'file-renamed';
    }
    return templateName;
}
function diffHighlight(diffLine1, diffLine2, isCombined, config) {
    if (config === void 0) { config = {}; }
    var _a = __assign(__assign({}, defaultRenderConfig), config), matching = _a.matching, maxLineLengthHighlight = _a.maxLineLengthHighlight, matchWordsThreshold = _a.matchWordsThreshold, diffStyle = _a.diffStyle;
    var line1 = deconstructLine(diffLine1, isCombined, false);
    var line2 = deconstructLine(diffLine2, isCombined, false);
    if (line1.content.length > maxLineLengthHighlight || line2.content.length > maxLineLengthHighlight) {
        return {
            oldLine: {
                prefix: line1.prefix,
                content: escapeForHtml(line1.content),
            },
            newLine: {
                prefix: line2.prefix,
                content: escapeForHtml(line2.content),
            },
        };
    }
    var diff = diffStyle === 'char'
        ? diff__WEBPACK_IMPORTED_MODULE_0__.diffChars(line1.content, line2.content)
        : diff__WEBPACK_IMPORTED_MODULE_0__.diffWordsWithSpace(line1.content, line2.content);
    var changedWords = [];
    if (diffStyle === 'word' && matching === 'words') {
        var removed = diff.filter(function (element) { return element.removed; });
        var added = diff.filter(function (element) { return element.added; });
        var chunks = matcher(added, removed);
        chunks.forEach(function (chunk) {
            if (chunk[0].length === 1 && chunk[1].length === 1) {
                var dist = distance(chunk[0][0], chunk[1][0]);
                if (dist < matchWordsThreshold) {
                    changedWords.push(chunk[0][0]);
                    changedWords.push(chunk[1][0]);
                }
            }
        });
    }
    var highlightedLine = diff.reduce(function (highlightedLine, part) {
        var elemType = part.added ? 'ins' : part.removed ? 'del' : null;
        var addClass = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : '';
        var escapedValue = escapeForHtml(part.value);
        return elemType !== null
            ? highlightedLine + "<" + elemType + addClass + ">" + escapedValue + "</" + elemType + ">"
            : "" + highlightedLine + escapedValue;
    }, '');
    return {
        oldLine: {
            prefix: line1.prefix,
            content: removeInsElements(highlightedLine),
        },
        newLine: {
            prefix: line2.prefix,
            content: removeDelElements(highlightedLine),
        },
    };
}
//# sourceMappingURL=render-utils.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/side-by-side-renderer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/side-by-side-renderer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultSideBySideRendererConfig": () => (/* binding */ defaultSideBySideRendererConfig),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rematch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rematch */ "./node_modules/diff2html/lib-esm/rematch.js");
/* harmony import */ var _render_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render-utils */ "./node_modules/diff2html/lib-esm/render-utils.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/diff2html/lib-esm/types.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var defaultSideBySideRendererConfig = __assign(__assign({}, _render_utils__WEBPACK_IMPORTED_MODULE_1__.defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath = 'generic';
var baseTemplatesPath = 'side-by-side';
var iconsBaseTemplatesPath = 'icon';
var tagsBaseTemplatesPath = 'tag';
var SideBySideRenderer = (function () {
    function SideBySideRenderer(hoganUtils, config) {
        if (config === void 0) { config = {}; }
        this.hoganUtils = hoganUtils;
        this.config = __assign(__assign({}, defaultSideBySideRendererConfig), config);
    }
    SideBySideRenderer.prototype.render = function (diffFiles) {
        var _this = this;
        var diffsHtml = diffFiles
            .map(function (file) {
            var diffs;
            if (file.blocks.length) {
                diffs = _this.generateFileHtml(file);
            }
            else {
                diffs = _this.generateEmptyDiff();
            }
            return _this.makeFileDiffHtml(file, diffs);
        })
            .join('\n');
        return this.hoganUtils.render(genericTemplatesPath, 'wrapper', { content: diffsHtml });
    };
    SideBySideRenderer.prototype.makeFileDiffHtml = function (file, diffs) {
        if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
            return '';
        var fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath, 'file-diff');
        var filePathTemplate = this.hoganUtils.template(genericTemplatesPath, 'file-path');
        var fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath, 'file');
        var fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, _render_utils__WEBPACK_IMPORTED_MODULE_1__.getFileIcon(file));
        return fileDiffTemplate.render({
            file: file,
            fileHtmlId: _render_utils__WEBPACK_IMPORTED_MODULE_1__.getHtmlId(file),
            diffs: diffs,
            filePath: filePathTemplate.render({
                fileDiffName: _render_utils__WEBPACK_IMPORTED_MODULE_1__.filenameDiff(file),
            }, {
                fileIcon: fileIconTemplate,
                fileTag: fileTagTemplate,
            }),
        });
    };
    SideBySideRenderer.prototype.generateEmptyDiff = function () {
        return {
            right: '',
            left: this.hoganUtils.render(genericTemplatesPath, 'empty-diff', {
                contentClass: 'd2h-code-side-line',
                CSSLineClass: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass,
            }),
        };
    };
    SideBySideRenderer.prototype.generateFileHtml = function (file) {
        var _this = this;
        var matcher = _rematch__WEBPACK_IMPORTED_MODULE_0__.newMatcherFn(_rematch__WEBPACK_IMPORTED_MODULE_0__.newDistanceFn(function (e) { return _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(e.content, file.isCombined).content; }));
        return file.blocks
            .map(function (block) {
            var fileHtml = {
                left: _this.makeHeaderHtml(block.header, file),
                right: _this.makeHeaderHtml(''),
            };
            _this.applyLineGroupping(block).forEach(function (_a) {
                var contextLines = _a[0], oldLines = _a[1], newLines = _a[2];
                if (oldLines.length && newLines.length && !contextLines.length) {
                    _this.applyRematchMatching(oldLines, newLines, matcher).map(function (_a) {
                        var oldLines = _a[0], newLines = _a[1];
                        var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
                        fileHtml.left += left;
                        fileHtml.right += right;
                    });
                }
                else if (contextLines.length) {
                    contextLines.forEach(function (line) {
                        var _a = _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(line.content, file.isCombined), prefix = _a.prefix, content = _a.content;
                        var _b = _this.generateLineHtml({
                            type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.CONTEXT,
                            prefix: prefix,
                            content: content,
                            number: line.oldNumber,
                        }, {
                            type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.CONTEXT,
                            prefix: prefix,
                            content: content,
                            number: line.newNumber,
                        }), left = _b.left, right = _b.right;
                        fileHtml.left += left;
                        fileHtml.right += right;
                    });
                }
                else if (oldLines.length || newLines.length) {
                    var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
                    fileHtml.left += left;
                    fileHtml.right += right;
                }
                else {
                    console.error('Unknown state reached while processing groups of lines', contextLines, oldLines, newLines);
                }
            });
            return fileHtml;
        })
            .reduce(function (accomulated, html) {
            return { left: accomulated.left + html.left, right: accomulated.right + html.right };
        }, { left: '', right: '' });
    };
    SideBySideRenderer.prototype.applyLineGroupping = function (block) {
        var blockLinesGroups = [];
        var oldLines = [];
        var newLines = [];
        for (var i = 0; i < block.lines.length; i++) {
            var diffLine = block.lines[i];
            if ((diffLine.type !== _types__WEBPACK_IMPORTED_MODULE_2__.LineType.INSERT && newLines.length) ||
                (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.CONTEXT && oldLines.length > 0)) {
                blockLinesGroups.push([[], oldLines, newLines]);
                oldLines = [];
                newLines = [];
            }
            if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.CONTEXT) {
                blockLinesGroups.push([[diffLine], [], []]);
            }
            else if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.INSERT && oldLines.length === 0) {
                blockLinesGroups.push([[], [], [diffLine]]);
            }
            else if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.INSERT && oldLines.length > 0) {
                newLines.push(diffLine);
            }
            else if (diffLine.type === _types__WEBPACK_IMPORTED_MODULE_2__.LineType.DELETE) {
                oldLines.push(diffLine);
            }
        }
        if (oldLines.length || newLines.length) {
            blockLinesGroups.push([[], oldLines, newLines]);
            oldLines = [];
            newLines = [];
        }
        return blockLinesGroups;
    };
    SideBySideRenderer.prototype.applyRematchMatching = function (oldLines, newLines, matcher) {
        var comparisons = oldLines.length * newLines.length;
        var maxLineSizeInBlock = Math.max.apply(null, [0].concat(oldLines.concat(newLines).map(function (elem) { return elem.content.length; })));
        var doMatching = comparisons < this.config.matchingMaxComparisons &&
            maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison &&
            (this.config.matching === 'lines' || this.config.matching === 'words');
        return doMatching ? matcher(oldLines, newLines) : [[oldLines, newLines]];
    };
    SideBySideRenderer.prototype.makeHeaderHtml = function (blockHeader, file) {
        return this.hoganUtils.render(genericTemplatesPath, 'block-header', {
            CSSLineClass: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass,
            blockHeader: (file === null || file === void 0 ? void 0 : file.isTooBig) ? blockHeader : _render_utils__WEBPACK_IMPORTED_MODULE_1__.escapeForHtml(blockHeader),
            lineClass: 'd2h-code-side-linenumber',
            contentClass: 'd2h-code-side-line',
        });
    };
    SideBySideRenderer.prototype.processChangedLines = function (isCombined, oldLines, newLines) {
        var fileHtml = {
            right: '',
            left: '',
        };
        var maxLinesNumber = Math.max(oldLines.length, newLines.length);
        for (var i = 0; i < maxLinesNumber; i++) {
            var oldLine = oldLines[i];
            var newLine = newLines[i];
            var diff = oldLine !== undefined && newLine !== undefined
                ? _render_utils__WEBPACK_IMPORTED_MODULE_1__.diffHighlight(oldLine.content, newLine.content, isCombined, this.config)
                : undefined;
            var preparedOldLine = oldLine !== undefined && oldLine.oldNumber !== undefined
                ? __assign(__assign({}, (diff !== undefined
                    ? {
                        prefix: diff.oldLine.prefix,
                        content: diff.oldLine.content,
                        type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.DELETE_CHANGES,
                    }
                    : __assign(__assign({}, _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(oldLine.content, isCombined)), { type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.toCSSClass(oldLine.type) }))), { number: oldLine.oldNumber }) : undefined;
            var preparedNewLine = newLine !== undefined && newLine.newNumber !== undefined
                ? __assign(__assign({}, (diff !== undefined
                    ? {
                        prefix: diff.newLine.prefix,
                        content: diff.newLine.content,
                        type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.INSERT_CHANGES,
                    }
                    : __assign(__assign({}, _render_utils__WEBPACK_IMPORTED_MODULE_1__.deconstructLine(newLine.content, isCombined)), { type: _render_utils__WEBPACK_IMPORTED_MODULE_1__.toCSSClass(newLine.type) }))), { number: newLine.newNumber }) : undefined;
            var _a = this.generateLineHtml(preparedOldLine, preparedNewLine), left = _a.left, right = _a.right;
            fileHtml.left += left;
            fileHtml.right += right;
        }
        return fileHtml;
    };
    SideBySideRenderer.prototype.generateLineHtml = function (oldLine, newLine) {
        return {
            left: this.generateSingleHtml(oldLine),
            right: this.generateSingleHtml(newLine),
        };
    };
    SideBySideRenderer.prototype.generateSingleHtml = function (line) {
        var lineClass = 'd2h-code-side-linenumber';
        var contentClass = 'd2h-code-side-line';
        return this.hoganUtils.render(genericTemplatesPath, 'line', {
            type: (line === null || line === void 0 ? void 0 : line.type) || _render_utils__WEBPACK_IMPORTED_MODULE_1__.CSSLineClass.CONTEXT + " d2h-emptyplaceholder",
            lineClass: line !== undefined ? lineClass : lineClass + " d2h-code-side-emptyplaceholder",
            contentClass: line !== undefined ? contentClass : contentClass + " d2h-code-side-emptyplaceholder",
            prefix: (line === null || line === void 0 ? void 0 : line.prefix) === ' ' ? '&nbsp;' : line === null || line === void 0 ? void 0 : line.prefix,
            content: line === null || line === void 0 ? void 0 : line.content,
            lineNumber: line === null || line === void 0 ? void 0 : line.number,
        });
    };
    return SideBySideRenderer;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SideBySideRenderer);
//# sourceMappingURL=side-by-side-renderer.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/types.js":
/*!*************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineType": () => (/* binding */ LineType),
/* harmony export */   "OutputFormatType": () => (/* binding */ OutputFormatType),
/* harmony export */   "LineMatchingType": () => (/* binding */ LineMatchingType),
/* harmony export */   "DiffStyleType": () => (/* binding */ DiffStyleType)
/* harmony export */ });
var LineType;
(function (LineType) {
    LineType["INSERT"] = "insert";
    LineType["DELETE"] = "delete";
    LineType["CONTEXT"] = "context";
})(LineType || (LineType = {}));
var OutputFormatType = {
    LINE_BY_LINE: 'line-by-line',
    SIDE_BY_SIDE: 'side-by-side',
};
var LineMatchingType = {
    LINES: 'lines',
    WORDS: 'words',
    NONE: 'none',
};
var DiffStyleType = {
    WORD: 'word',
    CHAR: 'char',
};
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/diff2html/lib-esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/diff2html/lib-esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeForRegExp": () => (/* binding */ escapeForRegExp),
/* harmony export */   "unifyPath": () => (/* binding */ unifyPath),
/* harmony export */   "hashCode": () => (/* binding */ hashCode)
/* harmony export */ });
var specials = [
    '-',
    '[',
    ']',
    '/',
    '{',
    '}',
    '(',
    ')',
    '*',
    '+',
    '?',
    '.',
    '\\',
    '^',
    '$',
    '|',
];
var regex = RegExp('[' + specials.join('\\') + ']', 'g');
function escapeForRegExp(str) {
    return str.replace(regex, '\\$&');
}
function unifyPath(path) {
    return path ? path.replace(/\\/g, '/') : path;
}
function hashCode(text) {
    var i, chr, len;
    var hash = 0;
    for (i = 0, len = text.length; i < len; i++) {
        chr = text.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
    }
    return hash;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/hogan.js/lib/compiler.js":
/*!***********************************************!*\
  !*** ./node_modules/hogan.js/lib/compiler.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\"/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  Hogan.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)});
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag == '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Hogan.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType == '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == '{') {
            if (ctag == '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag == '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag == '\n') {
        token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o == token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c == close && tags[i].o == open) {
        return true;
      }
    }
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return "{ " + items.join(",") + " }";
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
    }
    return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
  }

  Hogan.stringify = function(codeObj, text, options) {
    return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
  }

  var serialNo = 0;
  Hogan.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Hogan.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  }

  Hogan.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  }

  Hogan.template = Hogan.Template;

  Hogan.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
    return new this.template(template, text, this, options);
  }

  Hogan.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
    }
    return template;
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = "<" + (context.prefix || "");
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  Hogan.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Hogan.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Hogan.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Hogan.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Hogan.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  Hogan.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Hogan.codegen[nodelist[i].tag];
      func && func(nodelist[i], context);
    }
    return context;
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  }

  Hogan.cache = {};

  Hogan.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  }

  Hogan.compile = function(text, options) {
    options = options || {};
    var key = Hogan.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = template;
  }
})( true ? exports : 0);


/***/ }),

/***/ "./node_modules/hogan.js/lib/hogan.js":
/*!********************************************!*\
  !*** ./node_modules/hogan.js/lib/hogan.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// This file is for use with Node.js. See dist/ for browser files.

var Hogan = __webpack_require__(/*! ./compiler */ "./node_modules/hogan.js/lib/compiler.js");
Hogan.Template = __webpack_require__(/*! ./template */ "./node_modules/hogan.js/lib/template.js").Template;
Hogan.template = Hogan.Template;
module.exports = Hogan;


/***/ }),

/***/ "./node_modules/hogan.js/lib/template.js":
/*!***********************************************!*\
  !*** ./node_modules/hogan.js/lib/template.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var Hogan = {};

(function (Hogan) {
  Hogan.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base == template) {
        return partial.instance;
      }

      if (typeof template == 'string') {
        if (!this.c) {
          throw new Error("No compiler available.");
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) partials.stackText = {};
        for (key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result == 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result == 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }

  };

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope == 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get == 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {};
    PartialTemplate.prototype = instance;
    function Substitutions() {};
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) stackSubs[key] = subs[key];
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) stackPartials[key] = partials[key];
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})( true ? exports : 0);


/***/ }),

/***/ "./node_modules/diff/lib/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/diff/lib/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Diff": () => (/* binding */ Diff),
/* harmony export */   "applyPatch": () => (/* binding */ applyPatch),
/* harmony export */   "applyPatches": () => (/* binding */ applyPatches),
/* harmony export */   "canonicalize": () => (/* binding */ canonicalize),
/* harmony export */   "convertChangesToDMP": () => (/* binding */ convertChangesToDMP),
/* harmony export */   "convertChangesToXML": () => (/* binding */ convertChangesToXML),
/* harmony export */   "createPatch": () => (/* binding */ createPatch),
/* harmony export */   "createTwoFilesPatch": () => (/* binding */ createTwoFilesPatch),
/* harmony export */   "diffArrays": () => (/* binding */ diffArrays),
/* harmony export */   "diffChars": () => (/* binding */ diffChars),
/* harmony export */   "diffCss": () => (/* binding */ diffCss),
/* harmony export */   "diffJson": () => (/* binding */ diffJson),
/* harmony export */   "diffLines": () => (/* binding */ diffLines),
/* harmony export */   "diffSentences": () => (/* binding */ diffSentences),
/* harmony export */   "diffTrimmedLines": () => (/* binding */ diffTrimmedLines),
/* harmony export */   "diffWords": () => (/* binding */ diffWords),
/* harmony export */   "diffWordsWithSpace": () => (/* binding */ diffWordsWithSpace),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "parsePatch": () => (/* binding */ parsePatch),
/* harmony export */   "structuredPatch": () => (/* binding */ structuredPatch)
/* harmony export */ });
function Diff() {}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split('');
  },
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}

var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}

//
// Ranges and exceptions:
// Latin-1 Supplement, 008000FF
//  - U+00D7   Multiplication sign
//  - U+00F7   Division sign
// Latin Extended-A, 0100017F
// Latin Extended-B, 0180024F
// IPA Extensions, 025002AF
// Spacing Modifier Letters, 02B002FF
//  - U+02C7   &#711;  Caron
//  - U+02D8   &#728;  Breve
//  - U+02D9   &#729;  Dot Above
//  - U+02DA   &#730;  Ring Above
//  - U+02DB   &#731;  Ogonek
//  - U+02DC   &#732;  Small Tilde
//  - U+02DD   &#733;  Double Acute Accent
// Latin Extended Additional, 1E001EFF

var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();

wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  // All whitespace symbols except newline group into one token, each newline - in separate token
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}

var lineDiff = new Diff();

lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
  var options = generateOptions(callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}

var sentenceDiff = new Diff();

sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}

var cssDiff = new Diff();

cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;

jsonDiff.castInput = function (value) {
  var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
    return typeof v === 'undefined' ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer

function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (_typeof(obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}

var arrayDiff = new Diff();

arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

function parsePatch(uniDiff) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
      lines: [],
      linedelimiters: []
    }; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }

    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}

// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function distanceIterator (start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}

function applyPatch(source, uniDiff) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
    return line === patchContent;
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator = distanceIterator(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters[j];

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.

function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}

function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff = diffLines(oldStr, newStr, options);
  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  var _loop = function _loop(i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      var _curRange;

      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          var _curRange2;

          // Overlapping
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3;

          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              // however, if the old file is empty, do not output the no-nl line
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    _loop(i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}
function formatPatch(diff) {
  var ret = [];

  if (diff.oldFileName == diff.newFileName) {
    ret.push('Index: ' + diff.oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }

    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}

function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}
function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}

function calcLineCount(hunk) {
  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}
function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return parsePatch(param)[0];
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return structuredPatch(undefined, undefined, base, param);
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      var _hunk$lines;

      // Mine inserted
      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      var _hunk$lines2;

      // Theirs inserted
      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      var _hunk$lines3;

      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));

      return;
    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      var _hunk$lines4;

      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));

      return;
    }
  } else if (arrayEqual(myChanges, theirChanges)) {
    var _hunk$lines5;

    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    var _hunk$lines6;

    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}

// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}

function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZGlmZjJodG1sX2xpYi1lc21fZGlmZjJodG1sX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFCQUFxQixTQUFJLElBQUksU0FBSTtBQUNqQyw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtQztBQUNPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsOENBQThDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQWU7QUFDMUM7QUFDQTtBQUNBLHNEQUFzRCxtQ0FBbUM7QUFDekY7QUFDQSw2Q0FBNkMsRUFBRSxJQUFJLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFO0FBQ25DLGlDQUFpQyxFQUFFO0FBQ25DLGtEQUFrRCxFQUFFO0FBQ3BELDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUU7QUFDdkQsOENBQThDLEVBQUU7QUFDaEQsc0RBQXNELEVBQUUsTUFBTSxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtREFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvREFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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c0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxQkFBcUIsZ0JBQWdCOztBQUVyQyxxQkFBcUIsa0JBQWtCLGVBQWUsV0FBVzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0osa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxrQkFBa0IsV0FBVztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRTZSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYyaHRtbC9saWItZXNtL2RpZmYtcGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmMmh0bWwvbGliLWVzbS9kaWZmMmh0bWwtdGVtcGxhdGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmMmh0bWwvbGliLWVzbS9kaWZmMmh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYyaHRtbC9saWItZXNtL2ZpbGUtbGlzdC1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZjJodG1sL2xpYi1lc20vaG9nYW5qcy11dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZjJodG1sL2xpYi1lc20vbGluZS1ieS1saW5lLXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmMmh0bWwvbGliLWVzbS9yZW1hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmMmh0bWwvbGliLWVzbS9yZW5kZXItdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYyaHRtbC9saWItZXNtL3NpZGUtYnktc2lkZS1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZjJodG1sL2xpYi1lc20vdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYyaHRtbC9saWItZXNtL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ob2dhbi5qcy9saWIvY29tcGlsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hvZ2FuLmpzL2xpYi9ob2dhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9nYW4uanMvbGliL3RlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuaW1wb3J0IHsgTGluZVR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGVzY2FwZUZvclJlZ0V4cCB9IGZyb20gJy4vdXRpbHMnO1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKGZpbGVuYW1lLCBsYW5ndWFnZSkge1xuICAgIHZhciBmaWxlbmFtZVBhcnRzID0gZmlsZW5hbWUuc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZmlsZW5hbWVQYXJ0cy5sZW5ndGggPiAxID8gZmlsZW5hbWVQYXJ0c1tmaWxlbmFtZVBhcnRzLmxlbmd0aCAtIDFdIDogbGFuZ3VhZ2U7XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoQW55KHN0ciwgcHJlZml4ZXMpIHtcbiAgICByZXR1cm4gcHJlZml4ZXMucmVkdWNlKGZ1bmN0aW9uIChzdGFydHNXaXRoLCBwcmVmaXgpIHsgcmV0dXJuIHN0YXJ0c1dpdGggfHwgc3RyLnN0YXJ0c1dpdGgocHJlZml4KTsgfSwgZmFsc2UpO1xufVxudmFyIGJhc2VEaWZmRmlsZW5hbWVQcmVmaXhlcyA9IFsnYS8nLCAnYi8nLCAnaS8nLCAndy8nLCAnYy8nLCAnby8nXTtcbmZ1bmN0aW9uIGdldEZpbGVuYW1lKGxpbmUsIGxpbmVQcmVmaXgsIGV4dHJhUHJlZml4KSB7XG4gICAgdmFyIHByZWZpeGVzID0gZXh0cmFQcmVmaXggIT09IHVuZGVmaW5lZCA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYmFzZURpZmZGaWxlbmFtZVByZWZpeGVzLCB0cnVlKSwgW2V4dHJhUHJlZml4XSwgZmFsc2UpIDogYmFzZURpZmZGaWxlbmFtZVByZWZpeGVzO1xuICAgIHZhciBGaWxlbmFtZVJlZ0V4cCA9IGxpbmVQcmVmaXhcbiAgICAgICAgPyBuZXcgUmVnRXhwKFwiXlwiICsgZXNjYXBlRm9yUmVnRXhwKGxpbmVQcmVmaXgpICsgXCIgXFxcIj8oLis/KVxcXCI/JFwiKVxuICAgICAgICA6IG5ldyBSZWdFeHAoJ15cIj8oLis/KVwiPyQnKTtcbiAgICB2YXIgX2EgPSBGaWxlbmFtZVJlZ0V4cC5leGVjKGxpbmUpIHx8IFtdLCBfYiA9IF9hWzFdLCBmaWxlbmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xuICAgIHZhciBtYXRjaGluZ1ByZWZpeCA9IHByZWZpeGVzLmZpbmQoZnVuY3Rpb24gKHApIHsgcmV0dXJuIGZpbGVuYW1lLmluZGV4T2YocCkgPT09IDA7IH0pO1xuICAgIHZhciBmbmFtZVdpdGhvdXRQcmVmaXggPSBtYXRjaGluZ1ByZWZpeCA/IGZpbGVuYW1lLnNsaWNlKG1hdGNoaW5nUHJlZml4Lmxlbmd0aCkgOiBmaWxlbmFtZTtcbiAgICByZXR1cm4gZm5hbWVXaXRob3V0UHJlZml4LnJlcGxhY2UoL1xccytcXGR7NH0tXFxkezJ9LVxcZHsyfSBcXGR7Mn06XFxkezJ9OlxcZHsyfSg/OlxcLlxcZCspPyBbKy1dXFxkezR9LiokLywgJycpO1xufVxuZnVuY3Rpb24gZ2V0U3JjRmlsZW5hbWUobGluZSwgc3JjUHJlZml4KSB7XG4gICAgcmV0dXJuIGdldEZpbGVuYW1lKGxpbmUsICctLS0nLCBzcmNQcmVmaXgpO1xufVxuZnVuY3Rpb24gZ2V0RHN0RmlsZW5hbWUobGluZSwgZHN0UHJlZml4KSB7XG4gICAgcmV0dXJuIGdldEZpbGVuYW1lKGxpbmUsICcrKysnLCBkc3RQcmVmaXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKGRpZmZJbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgdmFyIGN1cnJlbnRGaWxlID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsb2NrID0gbnVsbDtcbiAgICB2YXIgb2xkTGluZSA9IG51bGw7XG4gICAgdmFyIG9sZExpbmUyID0gbnVsbDtcbiAgICB2YXIgbmV3TGluZSA9IG51bGw7XG4gICAgdmFyIHBvc3NpYmxlT2xkTmFtZSA9IG51bGw7XG4gICAgdmFyIHBvc3NpYmxlTmV3TmFtZSA9IG51bGw7XG4gICAgdmFyIG9sZEZpbGVOYW1lSGVhZGVyID0gJy0tLSAnO1xuICAgIHZhciBuZXdGaWxlTmFtZUhlYWRlciA9ICcrKysgJztcbiAgICB2YXIgaHVua0hlYWRlclByZWZpeCA9ICdAQCc7XG4gICAgdmFyIG9sZE1vZGUgPSAvXm9sZCBtb2RlIChcXGR7Nn0pLztcbiAgICB2YXIgbmV3TW9kZSA9IC9ebmV3IG1vZGUgKFxcZHs2fSkvO1xuICAgIHZhciBkZWxldGVkRmlsZU1vZGUgPSAvXmRlbGV0ZWQgZmlsZSBtb2RlIChcXGR7Nn0pLztcbiAgICB2YXIgbmV3RmlsZU1vZGUgPSAvXm5ldyBmaWxlIG1vZGUgKFxcZHs2fSkvO1xuICAgIHZhciBjb3B5RnJvbSA9IC9eY29weSBmcm9tIFwiPyguKylcIj8vO1xuICAgIHZhciBjb3B5VG8gPSAvXmNvcHkgdG8gXCI/KC4rKVwiPy87XG4gICAgdmFyIHJlbmFtZUZyb20gPSAvXnJlbmFtZSBmcm9tIFwiPyguKylcIj8vO1xuICAgIHZhciByZW5hbWVUbyA9IC9ecmVuYW1lIHRvIFwiPyguKylcIj8vO1xuICAgIHZhciBzaW1pbGFyaXR5SW5kZXggPSAvXnNpbWlsYXJpdHkgaW5kZXggKFxcZCspJS87XG4gICAgdmFyIGRpc3NpbWlsYXJpdHlJbmRleCA9IC9eZGlzc2ltaWxhcml0eSBpbmRleCAoXFxkKyklLztcbiAgICB2YXIgaW5kZXggPSAvXmluZGV4IChbXFxkYS16XSspXFwuXFwuKFtcXGRhLXpdKylcXHMqKFxcZHs2fSk/LztcbiAgICB2YXIgYmluYXJ5RmlsZXMgPSAvXkJpbmFyeSBmaWxlcyAoLiopIGFuZCAoLiopIGRpZmZlci87XG4gICAgdmFyIGJpbmFyeURpZmYgPSAvXkdJVCBiaW5hcnkgcGF0Y2gvO1xuICAgIHZhciBjb21iaW5lZEluZGV4ID0gL15pbmRleCAoW1xcZGEtel0rKSwoW1xcZGEtel0rKVxcLlxcLihbXFxkYS16XSspLztcbiAgICB2YXIgY29tYmluZWRNb2RlID0gL15tb2RlIChcXGR7Nn0pLChcXGR7Nn0pXFwuXFwuKFxcZHs2fSkvO1xuICAgIHZhciBjb21iaW5lZE5ld0ZpbGUgPSAvXm5ldyBmaWxlIG1vZGUgKFxcZHs2fSkvO1xuICAgIHZhciBjb21iaW5lZERlbGV0ZWRGaWxlID0gL15kZWxldGVkIGZpbGUgbW9kZSAoXFxkezZ9KSwoXFxkezZ9KS87XG4gICAgdmFyIGRpZmZMaW5lcyA9IGRpZmZJbnB1dFxuICAgICAgICAucmVwbGFjZSgvXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJylcbiAgICAgICAgLnNwbGl0KCdcXG4nKTtcbiAgICBmdW5jdGlvbiBzYXZlQmxvY2soKSB7XG4gICAgICAgIGlmIChjdXJyZW50QmxvY2sgIT09IG51bGwgJiYgY3VycmVudEZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9jayk7XG4gICAgICAgICAgICBjdXJyZW50QmxvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhdmVGaWxlKCkge1xuICAgICAgICBpZiAoY3VycmVudEZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudEZpbGUub2xkTmFtZSAmJiBwb3NzaWJsZU9sZE5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZS5vbGROYW1lID0gcG9zc2libGVPbGROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RmlsZS5uZXdOYW1lICYmIHBvc3NpYmxlTmV3TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlLm5ld05hbWUgPSBwb3NzaWJsZU5ld05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEZpbGUubmV3TmFtZSkge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goY3VycmVudEZpbGUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NzaWJsZU9sZE5hbWUgPSBudWxsO1xuICAgICAgICBwb3NzaWJsZU5ld05hbWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEZpbGUoKSB7XG4gICAgICAgIHNhdmVCbG9jaygpO1xuICAgICAgICBzYXZlRmlsZSgpO1xuICAgICAgICBjdXJyZW50RmlsZSA9IHtcbiAgICAgICAgICAgIGJsb2NrczogW10sXG4gICAgICAgICAgICBkZWxldGVkTGluZXM6IDAsXG4gICAgICAgICAgICBhZGRlZExpbmVzOiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEJsb2NrKGxpbmUpIHtcbiAgICAgICAgc2F2ZUJsb2NrKCk7XG4gICAgICAgIHZhciB2YWx1ZXM7XG4gICAgICAgIGlmIChjdXJyZW50RmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCh2YWx1ZXMgPSAvXkBAIC0oXFxkKykoPzosXFxkKyk/IFxcKyhcXGQrKSg/OixcXGQrKT8gQEAuKi8uZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZS5pc0NvbWJpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb2xkTGluZSA9IHBhcnNlSW50KHZhbHVlc1sxXSwgMTApO1xuICAgICAgICAgICAgICAgIG5ld0xpbmUgPSBwYXJzZUludCh2YWx1ZXNbMl0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZXMgPSAvXkBAQCAtKFxcZCspKD86LFxcZCspPyAtKFxcZCspKD86LFxcZCspPyBcXCsoXFxkKykoPzosXFxkKyk/IEBAQC4qLy5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzQ29tYmluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9sZExpbmUgPSBwYXJzZUludCh2YWx1ZXNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICBvbGRMaW5lMiA9IHBhcnNlSW50KHZhbHVlc1syXSwgMTApO1xuICAgICAgICAgICAgICAgIG5ld0xpbmUgPSBwYXJzZUludCh2YWx1ZXNbM10sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoaHVua0hlYWRlclByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGxpbmVzLCBzdGFydGluZyBpbiAwIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRMaW5lID0gMDtcbiAgICAgICAgICAgICAgICBuZXdMaW5lID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZS5pc0NvbWJpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJsb2NrID0ge1xuICAgICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgICAgb2xkU3RhcnRMaW5lOiBvbGRMaW5lLFxuICAgICAgICAgICAgb2xkU3RhcnRMaW5lMjogb2xkTGluZTIsXG4gICAgICAgICAgICBuZXdTdGFydExpbmU6IG5ld0xpbmUsXG4gICAgICAgICAgICBoZWFkZXI6IGxpbmUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmUobGluZSkge1xuICAgICAgICBpZiAoY3VycmVudEZpbGUgPT09IG51bGwgfHwgY3VycmVudEJsb2NrID09PSBudWxsIHx8IG9sZExpbmUgPT09IG51bGwgfHwgbmV3TGluZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0ge1xuICAgICAgICAgICAgY29udGVudDogbGluZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkZGVkUHJlZml4ZXMgPSBjdXJyZW50RmlsZS5pc0NvbWJpbmVkID8gWycrICcsICcgKycsICcrKyddIDogWycrJ107XG4gICAgICAgIHZhciBkZWxldGVkUHJlZml4ZXMgPSBjdXJyZW50RmlsZS5pc0NvbWJpbmVkID8gWyctICcsICcgLScsICctLSddIDogWyctJ107XG4gICAgICAgIGlmIChzdGFydHNXaXRoQW55KGxpbmUsIGFkZGVkUHJlZml4ZXMpKSB7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5hZGRlZExpbmVzKys7XG4gICAgICAgICAgICBjdXJyZW50TGluZS50eXBlID0gTGluZVR5cGUuSU5TRVJUO1xuICAgICAgICAgICAgY3VycmVudExpbmUub2xkTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY3VycmVudExpbmUubmV3TnVtYmVyID0gbmV3TGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGhBbnkobGluZSwgZGVsZXRlZFByZWZpeGVzKSkge1xuICAgICAgICAgICAgY3VycmVudEZpbGUuZGVsZXRlZExpbmVzKys7XG4gICAgICAgICAgICBjdXJyZW50TGluZS50eXBlID0gTGluZVR5cGUuREVMRVRFO1xuICAgICAgICAgICAgY3VycmVudExpbmUub2xkTnVtYmVyID0gb2xkTGluZSsrO1xuICAgICAgICAgICAgY3VycmVudExpbmUubmV3TnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudExpbmUudHlwZSA9IExpbmVUeXBlLkNPTlRFWFQ7XG4gICAgICAgICAgICBjdXJyZW50TGluZS5vbGROdW1iZXIgPSBvbGRMaW5lKys7XG4gICAgICAgICAgICBjdXJyZW50TGluZS5uZXdOdW1iZXIgPSBuZXdMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEJsb2NrLmxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleGlzdEh1bmtIZWFkZXIobGluZSwgbGluZUlkeCkge1xuICAgICAgICB2YXIgaWR4ID0gbGluZUlkeDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGRpZmZMaW5lcy5sZW5ndGggLSAzKSB7XG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkaWZmJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZkxpbmVzW2lkeF0uc3RhcnRzV2l0aChvbGRGaWxlTmFtZUhlYWRlcikgJiZcbiAgICAgICAgICAgICAgICBkaWZmTGluZXNbaWR4ICsgMV0uc3RhcnRzV2l0aChuZXdGaWxlTmFtZUhlYWRlcikgJiZcbiAgICAgICAgICAgICAgICBkaWZmTGluZXNbaWR4ICsgMl0uc3RhcnRzV2l0aChodW5rSGVhZGVyUHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkaWZmTGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgbGluZUluZGV4KSB7XG4gICAgICAgIGlmICghbGluZSB8fCBsaW5lLnN0YXJ0c1dpdGgoJyonKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXM7XG4gICAgICAgIHZhciBwcmV2TGluZSA9IGRpZmZMaW5lc1tsaW5lSW5kZXggLSAxXTtcbiAgICAgICAgdmFyIG54dExpbmUgPSBkaWZmTGluZXNbbGluZUluZGV4ICsgMV07XG4gICAgICAgIHZhciBhZnRlck54dExpbmUgPSBkaWZmTGluZXNbbGluZUluZGV4ICsgMl07XG4gICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2RpZmYnKSkge1xuICAgICAgICAgICAgc3RhcnRGaWxlKCk7XG4gICAgICAgICAgICB2YXIgZ2l0RGlmZlN0YXJ0ID0gL15kaWZmIC0tZ2l0IFwiPyhbYS1jaW93XVxcLy4rKVwiPyBcIj8oW2EtY2lvd11cXC8uKylcIj8vO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZXMgPSBnaXREaWZmU3RhcnQuZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU9sZE5hbWUgPSBnZXRGaWxlbmFtZSh2YWx1ZXNbMV0sIHVuZGVmaW5lZCwgY29uZmlnLmRzdFByZWZpeCk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVOZXdOYW1lID0gZ2V0RmlsZW5hbWUodmFsdWVzWzJdLCB1bmRlZmluZWQsIGNvbmZpZy5zcmNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVyZSBpcyBteSBmaWxlICEhIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEZpbGUuaXNHaXREaWZmID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRGaWxlIHx8XG4gICAgICAgICAgICAoIWN1cnJlbnRGaWxlLmlzR2l0RGlmZiAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlICYmXG4gICAgICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKG9sZEZpbGVOYW1lSGVhZGVyKSAmJlxuICAgICAgICAgICAgICAgIG54dExpbmUuc3RhcnRzV2l0aChuZXdGaWxlTmFtZUhlYWRlcikgJiZcbiAgICAgICAgICAgICAgICBhZnRlck54dExpbmUuc3RhcnRzV2l0aChodW5rSGVhZGVyUHJlZml4KSkpIHtcbiAgICAgICAgICAgIHN0YXJ0RmlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50RmlsZSA9PT0gbnVsbCB8fCBjdXJyZW50RmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZpbGUuaXNUb29CaWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEZpbGUgJiZcbiAgICAgICAgICAgICgodHlwZW9mIGNvbmZpZy5kaWZmTWF4Q2hhbmdlcyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZS5hZGRlZExpbmVzICsgY3VycmVudEZpbGUuZGVsZXRlZExpbmVzID4gY29uZmlnLmRpZmZNYXhDaGFuZ2VzKSB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uZmlnLmRpZmZNYXhMaW5lTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsaW5lLmxlbmd0aCA+IGNvbmZpZy5kaWZmTWF4TGluZUxlbmd0aCkpKSB7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5pc1Rvb0JpZyA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5hZGRlZExpbmVzID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmRlbGV0ZWRMaW5lcyA9IDA7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5ibG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGN1cnJlbnRCbG9jayA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHR5cGVvZiBjb25maWcuZGlmZlRvb0JpZ01lc3NhZ2UgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5kaWZmVG9vQmlnTWVzc2FnZShmaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiAnRGlmZiB0b28gYmlnIHRvIGJlIGRpc3BsYXllZCc7XG4gICAgICAgICAgICBzdGFydEJsb2NrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobGluZS5zdGFydHNXaXRoKG9sZEZpbGVOYW1lSGVhZGVyKSAmJiBueHRMaW5lLnN0YXJ0c1dpdGgobmV3RmlsZU5hbWVIZWFkZXIpKSB8fFxuICAgICAgICAgICAgKGxpbmUuc3RhcnRzV2l0aChuZXdGaWxlTmFtZUhlYWRlcikgJiYgcHJldkxpbmUuc3RhcnRzV2l0aChvbGRGaWxlTmFtZUhlYWRlcikpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZpbGUgJiZcbiAgICAgICAgICAgICAgICAhY3VycmVudEZpbGUub2xkTmFtZSAmJlxuICAgICAgICAgICAgICAgIGxpbmUuc3RhcnRzV2l0aCgnLS0tICcpICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlcyA9IGdldFNyY0ZpbGVuYW1lKGxpbmUsIGNvbmZpZy5zcmNQcmVmaXgpKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlLm9sZE5hbWUgPSB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUubGFuZ3VhZ2UgPSBnZXRFeHRlbnNpb24oY3VycmVudEZpbGUub2xkTmFtZSwgY3VycmVudEZpbGUubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RmlsZSAmJlxuICAgICAgICAgICAgICAgICFjdXJyZW50RmlsZS5uZXdOYW1lICYmXG4gICAgICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKCcrKysgJykgJiZcbiAgICAgICAgICAgICAgICAodmFsdWVzID0gZ2V0RHN0RmlsZW5hbWUobGluZSwgY29uZmlnLmRzdFByZWZpeCkpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUubmV3TmFtZSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZS5sYW5ndWFnZSA9IGdldEV4dGVuc2lvbihjdXJyZW50RmlsZS5uZXdOYW1lLCBjdXJyZW50RmlsZS5sYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50RmlsZSAmJlxuICAgICAgICAgICAgKGxpbmUuc3RhcnRzV2l0aChodW5rSGVhZGVyUHJlZml4KSB8fFxuICAgICAgICAgICAgICAgIChjdXJyZW50RmlsZS5pc0dpdERpZmYgJiYgY3VycmVudEZpbGUub2xkTmFtZSAmJiBjdXJyZW50RmlsZS5uZXdOYW1lICYmICFjdXJyZW50QmxvY2spKSkge1xuICAgICAgICAgICAgc3RhcnRCbG9jayhsaW5lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJsb2NrICYmIChsaW5lLnN0YXJ0c1dpdGgoJysnKSB8fCBsaW5lLnN0YXJ0c1dpdGgoJy0nKSB8fCBsaW5lLnN0YXJ0c1dpdGgoJyAnKSkpIHtcbiAgICAgICAgICAgIGNyZWF0ZUxpbmUobGluZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvZXNOb3RFeGlzdEh1bmtIZWFkZXIgPSAhZXhpc3RIdW5rSGVhZGVyKGxpbmUsIGxpbmVJbmRleCk7XG4gICAgICAgIGlmIChjdXJyZW50RmlsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVyZSBpcyBteSBmaWxlICEhIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodmFsdWVzID0gb2xkTW9kZS5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgY3VycmVudEZpbGUub2xkTW9kZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVzID0gbmV3TW9kZS5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgY3VycmVudEZpbGUubmV3TW9kZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVzID0gZGVsZXRlZEZpbGVNb2RlLmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5kZWxldGVkRmlsZU1vZGUgPSB2YWx1ZXNbMV07XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5pc0RlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2YWx1ZXMgPSBuZXdGaWxlTW9kZS5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgY3VycmVudEZpbGUubmV3RmlsZU1vZGUgPSB2YWx1ZXNbMV07XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5pc05ldyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZhbHVlcyA9IGNvcHlGcm9tLmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICBpZiAoZG9lc05vdEV4aXN0SHVua0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlLm9sZE5hbWUgPSB2YWx1ZXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5pc0NvcHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2YWx1ZXMgPSBjb3B5VG8uZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgIGlmIChkb2VzTm90RXhpc3RIdW5rSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUubmV3TmFtZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzQ29weSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZhbHVlcyA9IHJlbmFtZUZyb20uZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgIGlmIChkb2VzTm90RXhpc3RIdW5rSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUub2xkTmFtZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzUmVuYW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVzID0gcmVuYW1lVG8uZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgIGlmIChkb2VzTm90RXhpc3RIdW5rSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUubmV3TmFtZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzUmVuYW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVzID0gYmluYXJ5RmlsZXMuZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzQmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLm9sZE5hbWUgPSBnZXRGaWxlbmFtZSh2YWx1ZXNbMV0sIHVuZGVmaW5lZCwgY29uZmlnLnNyY1ByZWZpeCk7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5uZXdOYW1lID0gZ2V0RmlsZW5hbWUodmFsdWVzWzJdLCB1bmRlZmluZWQsIGNvbmZpZy5kc3RQcmVmaXgpO1xuICAgICAgICAgICAgc3RhcnRCbG9jaygnQmluYXJ5IGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiaW5hcnlEaWZmLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzQmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0QmxvY2sobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZhbHVlcyA9IHNpbWlsYXJpdHlJbmRleC5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgY3VycmVudEZpbGUudW5jaGFuZ2VkUGVyY2VudGFnZSA9IHBhcnNlSW50KHZhbHVlc1sxXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2YWx1ZXMgPSBkaXNzaW1pbGFyaXR5SW5kZXguZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmNoYW5nZWRQZXJjZW50YWdlID0gcGFyc2VJbnQodmFsdWVzWzFdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZhbHVlcyA9IGluZGV4LmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5jaGVja3N1bUJlZm9yZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmNoZWNrc3VtQWZ0ZXIgPSB2YWx1ZXNbMl07XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgKGN1cnJlbnRGaWxlLm1vZGUgPSB2YWx1ZXNbM10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2YWx1ZXMgPSBjb21iaW5lZEluZGV4LmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5jaGVja3N1bUJlZm9yZSA9IFt2YWx1ZXNbMl0sIHZhbHVlc1szXV07XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5jaGVja3N1bUFmdGVyID0gdmFsdWVzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2YWx1ZXMgPSBjb21iaW5lZE1vZGUuZXhlYyhsaW5lKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLm9sZE1vZGUgPSBbdmFsdWVzWzJdLCB2YWx1ZXNbM11dO1xuICAgICAgICAgICAgY3VycmVudEZpbGUubmV3TW9kZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVzID0gY29tYmluZWROZXdGaWxlLmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5uZXdGaWxlTW9kZSA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmlzTmV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVzID0gY29tYmluZWREZWxldGVkRmlsZS5leGVjKGxpbmUpKSkge1xuICAgICAgICAgICAgY3VycmVudEZpbGUuZGVsZXRlZEZpbGVNb2RlID0gdmFsdWVzWzFdO1xuICAgICAgICAgICAgY3VycmVudEZpbGUuaXNEZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNhdmVCbG9jaygpO1xuICAgIHNhdmVGaWxlKCk7XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlmZi1wYXJzZXIuanMubWFwIiwiaW1wb3J0ICogYXMgSG9nYW4gZnJvbSBcImhvZ2FuLmpzXCI7XG5leHBvcnQgdmFyIGRlZmF1bHRUZW1wbGF0ZXMgPSB7fTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJmaWxlLXN1bW1hcnktbGluZVwiXSA9IG5ldyBIb2dhbi5UZW1wbGF0ZSh7IGNvZGU6IGZ1bmN0aW9uIChjLCBwLCBpKSB7IHZhciB0ID0gdGhpczsgdC5iKGkgPSBpIHx8IFwiXCIpOyB0LmIoXCI8bGkgY2xhc3M9XFxcImQyaC1maWxlLWxpc3QtbGluZVxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPHNwYW4gY2xhc3M9XFxcImQyaC1maWxlLW5hbWUtd3JhcHBlclxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIodC5ycChcIjxmaWxlSWNvbjBcIiwgYywgcCwgXCIgICAgICBcIikpOyB0LmIoXCIgICAgICA8YSBocmVmPVxcXCIjXCIpOyB0LmIodC52KHQuZihcImZpbGVIdG1sSWRcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxcIiBjbGFzcz1cXFwiZDJoLWZpbGUtbmFtZVxcXCI+XCIpOyB0LmIodC52KHQuZihcImZpbGVOYW1lXCIsIGMsIHAsIDApKSk7IHQuYihcIjwvYT5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgIDxzcGFuIGNsYXNzPVxcXCJkMmgtZmlsZS1zdGF0c1xcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImQyaC1saW5lcy1hZGRlZFxcXCI+XCIpOyB0LmIodC52KHQuZihcImFkZGVkTGluZXNcIiwgYywgcCwgMCkpKTsgdC5iKFwiPC9zcGFuPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJkMmgtbGluZXMtZGVsZXRlZFxcXCI+XCIpOyB0LmIodC52KHQuZihcImRlbGV0ZWRMaW5lc1wiLCBjLCBwLCAwKSkpOyB0LmIoXCI8L3NwYW4+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICA8L3NwYW4+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPC9zcGFuPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiPC9saT5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7IFwiPGZpbGVJY29uMFwiOiB7IG5hbWU6IFwiZmlsZUljb25cIiwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9IH0sIHN1YnM6IHt9IH0pO1xuZGVmYXVsdFRlbXBsYXRlc1tcImZpbGUtc3VtbWFyeS13cmFwcGVyXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxkaXYgY2xhc3M9XFxcImQyaC1maWxlLWxpc3Qtd3JhcHBlclxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPGRpdiBjbGFzcz1cXFwiZDJoLWZpbGUtbGlzdC1oZWFkZXJcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZDJoLWZpbGUtbGlzdC10aXRsZVxcXCI+RmlsZXMgY2hhbmdlZCAoXCIpOyB0LmIodC52KHQuZihcImZpbGVzTnVtYmVyXCIsIGMsIHAsIDApKSk7IHQuYihcIik8L3NwYW4+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDxhIGNsYXNzPVxcXCJkMmgtZmlsZS1zd2l0Y2ggZDJoLWhpZGVcXFwiPmhpZGU8L2E+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDxhIGNsYXNzPVxcXCJkMmgtZmlsZS1zd2l0Y2ggZDJoLXNob3dcXFwiPnNob3c8L2E+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPG9sIGNsYXNzPVxcXCJkMmgtZmlsZS1saXN0XFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICBcIik7IHQuYih0LnQodC5mKFwiZmlsZXNcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDwvb2w+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L2Rpdj5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSk7XG5kZWZhdWx0VGVtcGxhdGVzW1wiZ2VuZXJpYy1ibG9jay1oZWFkZXJcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPHRyPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDx0ZCBjbGFzcz1cXFwiXCIpOyB0LmIodC52KHQuZihcImxpbmVDbGFzc1wiLCBjLCBwLCAwKSkpOyB0LmIoXCIgXCIpOyB0LmIodC52KHQuZChcIkNTU0xpbmVDbGFzcy5JTkZPXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcXCI+PC90ZD5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8dGQgY2xhc3M9XFxcIlwiKTsgdC5iKHQudih0LmQoXCJDU1NMaW5lQ2xhc3MuSU5GT1wiLCBjLCBwLCAwKSkpOyB0LmIoXCJcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIik7IHQuYih0LnYodC5mKFwiY29udGVudENsYXNzXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcXCI+XCIpOyB0LmIodC50KHQuZihcImJsb2NrSGVhZGVyXCIsIGMsIHAsIDApKSk7IHQuYihcIjwvZGl2PlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDwvdGQ+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L3RyPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJnZW5lcmljLWVtcHR5LWRpZmZcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPHRyPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDx0ZCBjbGFzcz1cXFwiXCIpOyB0LmIodC52KHQuZChcIkNTU0xpbmVDbGFzcy5JTkZPXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiKTsgdC5iKHQudih0LmYoXCJjb250ZW50Q2xhc3NcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgICAgIEZpbGUgd2l0aG91dCBjaGFuZ2VzXCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDwvZGl2PlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDwvdGQ+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L3RyPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJnZW5lcmljLWZpbGUtcGF0aFwiXSA9IG5ldyBIb2dhbi5UZW1wbGF0ZSh7IGNvZGU6IGZ1bmN0aW9uIChjLCBwLCBpKSB7IHZhciB0ID0gdGhpczsgdC5iKGkgPSBpIHx8IFwiXCIpOyB0LmIoXCI8c3BhbiBjbGFzcz1cXFwiZDJoLWZpbGUtbmFtZS13cmFwcGVyXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYih0LnJwKFwiPGZpbGVJY29uMFwiLCBjLCBwLCBcIiAgICBcIikpOyB0LmIoXCIgICAgPHNwYW4gY2xhc3M9XFxcImQyaC1maWxlLW5hbWVcXFwiPlwiKTsgdC5iKHQudih0LmYoXCJmaWxlRGlmZk5hbWVcIiwgYywgcCwgMCkpKTsgdC5iKFwiPC9zcGFuPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKHQucnAoXCI8ZmlsZVRhZzFcIiwgYywgcCwgXCIgICAgXCIpKTsgdC5iKFwiPC9zcGFuPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiPGxhYmVsIGNsYXNzPVxcXCJkMmgtZmlsZS1jb2xsYXBzZVxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPGlucHV0IGNsYXNzPVxcXCJkMmgtZmlsZS1jb2xsYXBzZS1pbnB1dFxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInZpZXdlZFxcXCIgdmFsdWU9XFxcInZpZXdlZFxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgVmlld2VkXCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L2xhYmVsPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHsgXCI8ZmlsZUljb24wXCI6IHsgbmFtZTogXCJmaWxlSWNvblwiLCBwYXJ0aWFsczoge30sIHN1YnM6IHt9IH0sIFwiPGZpbGVUYWcxXCI6IHsgbmFtZTogXCJmaWxlVGFnXCIsIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSB9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJnZW5lcmljLWxpbmVcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPHRyPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDx0ZCBjbGFzcz1cXFwiXCIpOyB0LmIodC52KHQuZihcImxpbmVDbGFzc1wiLCBjLCBwLCAwKSkpOyB0LmIoXCIgXCIpOyB0LmIodC52KHQuZihcInR5cGVcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgIFwiKTsgdC5iKHQudCh0LmYoXCJsaW5lTnVtYmVyXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8L3RkPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIDx0ZCBjbGFzcz1cXFwiXCIpOyB0LmIodC52KHQuZihcInR5cGVcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIpOyB0LmIodC52KHQuZihcImNvbnRlbnRDbGFzc1wiLCBjLCBwLCAwKSkpOyB0LmIoXCJcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgaWYgKHQucyh0LmYoXCJwcmVmaXhcIiwgYywgcCwgMSksIGMsIHAsIDAsIDE2MiwgMjM4LCBcInt7IH19XCIpKSB7XG4gICAgICAgIHQucnMoYywgcCwgZnVuY3Rpb24gKGMsIHAsIHQpIHsgdC5iKFwiICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImQyaC1jb2RlLWxpbmUtcHJlZml4XFxcIj5cIik7IHQuYih0LnQodC5mKFwicHJlZml4XCIsIGMsIHAsIDApKSk7IHQuYihcIjwvc3Bhbj5cIik7IHQuYihcIlxcblwiICsgaSk7IH0pO1xuICAgICAgICBjLnBvcCgpO1xuICAgIH0gaWYgKCF0LnModC5mKFwicHJlZml4XCIsIGMsIHAsIDEpLCBjLCBwLCAxLCAwLCAwLCBcIlwiKSkge1xuICAgICAgICB0LmIoXCIgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZDJoLWNvZGUtbGluZS1wcmVmaXhcXFwiPiZuYnNwOzwvc3Bhbj5cIik7XG4gICAgICAgIHQuYihcIlxcblwiICsgaSk7XG4gICAgfSA7IGlmICh0LnModC5mKFwiY29udGVudFwiLCBjLCBwLCAxKSwgYywgcCwgMCwgMzcxLCA0NDUsIFwie3sgfX1cIikpIHtcbiAgICAgICAgdC5ycyhjLCBwLCBmdW5jdGlvbiAoYywgcCwgdCkgeyB0LmIoXCIgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZDJoLWNvZGUtbGluZS1jdG5cXFwiPlwiKTsgdC5iKHQudCh0LmYoXCJjb250ZW50XCIsIGMsIHAsIDApKSk7IHQuYihcIjwvc3Bhbj5cIik7IHQuYihcIlxcblwiICsgaSk7IH0pO1xuICAgICAgICBjLnBvcCgpO1xuICAgIH0gaWYgKCF0LnModC5mKFwiY29udGVudFwiLCBjLCBwLCAxKSwgYywgcCwgMSwgMCwgMCwgXCJcIikpIHtcbiAgICAgICAgdC5iKFwiICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImQyaC1jb2RlLWxpbmUtY3RuXFxcIj48YnI+PC9zcGFuPlwiKTtcbiAgICAgICAgdC5iKFwiXFxuXCIgKyBpKTtcbiAgICB9IDsgdC5iKFwiICAgICAgICA8L2Rpdj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8L3RkPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiPC90cj5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSk7XG5kZWZhdWx0VGVtcGxhdGVzW1wiZ2VuZXJpYy13cmFwcGVyXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxkaXYgY2xhc3M9XFxcImQyaC13cmFwcGVyXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICBcIik7IHQuYih0LnQodC5mKFwiY29udGVudFwiLCBjLCBwLCAwKSkpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L2Rpdj5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSk7XG5kZWZhdWx0VGVtcGxhdGVzW1wiaWNvbi1maWxlLWFkZGVkXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxzdmcgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJkMmgtaWNvbiBkMmgtYWRkZWRcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHRpdGxlPVxcXCJhZGRlZFxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMTZcXFwiXCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgIHdpZHRoPVxcXCIxNFxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPHBhdGggZD1cXFwiTTEzIDFIMUMwLjQ1IDEgMCAxLjQ1IDAgMnYxMmMwIDAuNTUgMC40NSAxIDEgMWgxMmMwLjU1IDAgMS0wLjQ1IDEtMVYyYzAtMC41NS0wLjQ1LTEtMS0xeiBtMCAxM0gxVjJoMTJ2MTJ6TTYgOUgzVjdoM1Y0aDJ2M2gzdjJIOHYzSDZWOXpcXFwiPjwvcGF0aD5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIjwvc3ZnPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJpY29uLWZpbGUtY2hhbmdlZFwiXSA9IG5ldyBIb2dhbi5UZW1wbGF0ZSh7IGNvZGU6IGZ1bmN0aW9uIChjLCBwLCBpKSB7IHZhciB0ID0gdGhpczsgdC5iKGkgPSBpIHx8IFwiXCIpOyB0LmIoXCI8c3ZnIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZDJoLWljb24gZDJoLWNoYW5nZWRcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHRpdGxlPVxcXCJtb2RpZmllZFxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICB2aWV3Qm94PVxcXCIwIDAgMTQgMTZcXFwiIHdpZHRoPVxcXCIxNFxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPHBhdGggZD1cXFwiTTEzIDFIMUMwLjQ1IDEgMCAxLjQ1IDAgMnYxMmMwIDAuNTUgMC40NSAxIDEgMWgxMmMwLjU1IDAgMS0wLjQ1IDEtMVYyYzAtMC41NS0wLjQ1LTEtMS0xeiBtMCAxM0gxVjJoMTJ2MTJ6TTQgOGMwLTEuNjYgMS4zNC0zIDMtM3MzIDEuMzQgMyAzLTEuMzQgMy0zIDMtMy0xLjM0LTMtM3pcXFwiPjwvcGF0aD5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIjwvc3ZnPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJpY29uLWZpbGUtZGVsZXRlZFwiXSA9IG5ldyBIb2dhbi5UZW1wbGF0ZSh7IGNvZGU6IGZ1bmN0aW9uIChjLCBwLCBpKSB7IHZhciB0ID0gdGhpczsgdC5iKGkgPSBpIHx8IFwiXCIpOyB0LmIoXCI8c3ZnIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZDJoLWljb24gZDJoLWRlbGV0ZWRcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHRpdGxlPVxcXCJyZW1vdmVkXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiXCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgIHZpZXdCb3g9XFxcIjAgMCAxNCAxNlxcXCIgd2lkdGg9XFxcIjE0XFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8cGF0aCBkPVxcXCJNMTMgMUgxQzAuNDUgMSAwIDEuNDUgMCAydjEyYzAgMC41NSAwLjQ1IDEgMSAxaDEyYzAuNTUgMCAxLTAuNDUgMS0xVjJjMC0wLjU1LTAuNDUtMS0xLTF6IG0wIDEzSDFWMmgxMnYxMnpNMTEgOUgzVjdoOHYyelxcXCI+PC9wYXRoPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiPC9zdmc+XCIpOyByZXR1cm4gdC5mbCgpOyB9LCBwYXJ0aWFsczoge30sIHN1YnM6IHt9IH0pO1xuZGVmYXVsdFRlbXBsYXRlc1tcImljb24tZmlsZS1yZW5hbWVkXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxzdmcgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJkMmgtaWNvbiBkMmgtbW92ZWRcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHRpdGxlPVxcXCJyZW5hbWVkXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiXCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgIHZpZXdCb3g9XFxcIjAgMCAxNCAxNlxcXCIgd2lkdGg9XFxcIjE0XFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8cGF0aCBkPVxcXCJNNiA5SDNWN2gzVjRsNSA0LTUgNFY5eiBtOC03djEyYzAgMC41NS0wLjQ1IDEtMSAxSDFjLTAuNTUgMC0xLTAuNDUtMS0xVjJjMC0wLjU1IDAuNDUtMSAxLTFoMTJjMC41NSAwIDEgMC40NSAxIDF6IG0tMSAwSDF2MTJoMTJWMnpcXFwiPjwvcGF0aD5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIjwvc3ZnPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJpY29uLWZpbGVcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPHN2ZyBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImQyaC1pY29uXFxcIiBoZWlnaHQ9XFxcIjE2XFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMiAxNlxcXCIgd2lkdGg9XFxcIjEyXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8cGF0aCBkPVxcXCJNNiA1SDJ2LTFoNHYxek0yIDhoN3YtMUgydjF6IG0wIDJoN3YtMUgydjF6IG0wIDJoN3YtMUgydjF6IG0xMC03LjV2OS41YzAgMC41NS0wLjQ1IDEtMSAxSDFjLTAuNTUgMC0xLTAuNDUtMS0xVjJjMC0wLjU1IDAuNDUtMSAxLTFoNy41bDMuNSAzLjV6IG0tMSAwLjVMOCAySDF2MTJoMTBWNXpcXFwiPjwvcGF0aD5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIjwvc3ZnPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJsaW5lLWJ5LWxpbmUtZmlsZS1kaWZmXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxkaXYgaWQ9XFxcIlwiKTsgdC5iKHQudih0LmYoXCJmaWxlSHRtbElkXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcXCIgY2xhc3M9XFxcImQyaC1maWxlLXdyYXBwZXJcXFwiIGRhdGEtbGFuZz1cXFwiXCIpOyB0LmIodC52KHQuZChcImZpbGUubGFuZ3VhZ2VcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8ZGl2IGNsYXNzPVxcXCJkMmgtZmlsZS1oZWFkZXJcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgIFwiKTsgdC5iKHQudCh0LmYoXCJmaWxlUGF0aFwiLCBjLCBwLCAwKSkpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPGRpdiBjbGFzcz1cXFwiZDJoLWZpbGUtZGlmZlxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDxkaXYgY2xhc3M9XFxcImQyaC1jb2RlLXdyYXBwZXJcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJkMmgtZGlmZi10YWJsZVxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICAgICAgPHRib2R5IGNsYXNzPVxcXCJkMmgtZGlmZi10Ym9keVxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICAgICAgXCIpOyB0LmIodC50KHQuZihcImRpZmZzXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgICAgICAgICA8L3Rib2R5PlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgPC90YWJsZT5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L2Rpdj5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSk7XG5kZWZhdWx0VGVtcGxhdGVzW1wibGluZS1ieS1saW5lLW51bWJlcnNcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPGRpdiBjbGFzcz1cXFwibGluZS1udW0xXFxcIj5cIik7IHQuYih0LnYodC5mKFwib2xkTnVtYmVyXCIsIGMsIHAsIDApKSk7IHQuYihcIjwvZGl2PlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiPGRpdiBjbGFzcz1cXFwibGluZS1udW0yXFxcIj5cIik7IHQuYih0LnYodC5mKFwibmV3TnVtYmVyXCIsIGMsIHAsIDApKSk7IHQuYihcIjwvZGl2PlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJzaWRlLWJ5LXNpZGUtZmlsZS1kaWZmXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxkaXYgaWQ9XFxcIlwiKTsgdC5iKHQudih0LmYoXCJmaWxlSHRtbElkXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcXCIgY2xhc3M9XFxcImQyaC1maWxlLXdyYXBwZXJcXFwiIGRhdGEtbGFuZz1cXFwiXCIpOyB0LmIodC52KHQuZChcImZpbGUubGFuZ3VhZ2VcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8ZGl2IGNsYXNzPVxcXCJkMmgtZmlsZS1oZWFkZXJcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgXCIpOyB0LmIodC50KHQuZihcImZpbGVQYXRoXCIsIGMsIHAsIDApKSk7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8L2Rpdj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICA8ZGl2IGNsYXNzPVxcXCJkMmgtZmlsZXMtZGlmZlxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDxkaXYgY2xhc3M9XFxcImQyaC1maWxlLXNpZGUtZGlmZlxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkMmgtY29kZS13cmFwcGVyXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XFxcImQyaC1kaWZmLXRhYmxlXFxcIj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgICAgICAgICAgICAgPHRib2R5IGNsYXNzPVxcXCJkMmgtZGlmZi10Ym9keVxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICAgICAgICAgIFwiKTsgdC5iKHQudCh0LmQoXCJkaWZmcy5sZWZ0XCIsIGMsIHAsIDApKSk7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgICAgICAgICA8L3RhYmxlPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgIDwvZGl2PlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkMmgtZmlsZS1zaWRlLWRpZmZcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZDJoLWNvZGUtd3JhcHBlclxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJkMmgtZGlmZi10YWJsZVxcXCI+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICAgICAgICAgIDx0Ym9keSBjbGFzcz1cXFwiZDJoLWRpZmYtdGJvZHlcXFwiPlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgICAgICAgICBcIik7IHQuYih0LnQodC5kKFwiZGlmZnMucmlnaHRcIiwgYywgcCwgMCkpKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlwiKTsgdC5iKFwiXFxuXCIgKyBpKTsgdC5iKFwiICAgICAgICAgICAgICAgIDwvdGFibGU+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgICAgICAgICA8L2Rpdj5cIik7IHQuYihcIlxcblwiICsgaSk7IHQuYihcIiAgICAgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCIgICAgPC9kaXY+XCIpOyB0LmIoXCJcXG5cIiArIGkpOyB0LmIoXCI8L2Rpdj5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSk7XG5kZWZhdWx0VGVtcGxhdGVzW1widGFnLWZpbGUtYWRkZWRcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPHNwYW4gY2xhc3M9XFxcImQyaC10YWcgZDJoLWFkZGVkIGQyaC1hZGRlZC10YWdcXFwiPkFEREVEPC9zcGFuPlwiKTsgcmV0dXJuIHQuZmwoKTsgfSwgcGFydGlhbHM6IHt9LCBzdWJzOiB7fSB9KTtcbmRlZmF1bHRUZW1wbGF0ZXNbXCJ0YWctZmlsZS1jaGFuZ2VkXCJdID0gbmV3IEhvZ2FuLlRlbXBsYXRlKHsgY29kZTogZnVuY3Rpb24gKGMsIHAsIGkpIHsgdmFyIHQgPSB0aGlzOyB0LmIoaSA9IGkgfHwgXCJcIik7IHQuYihcIjxzcGFuIGNsYXNzPVxcXCJkMmgtdGFnIGQyaC1jaGFuZ2VkIGQyaC1jaGFuZ2VkLXRhZ1xcXCI+Q0hBTkdFRDwvc3Bhbj5cIik7IHJldHVybiB0LmZsKCk7IH0sIHBhcnRpYWxzOiB7fSwgc3Viczoge30gfSk7XG5kZWZhdWx0VGVtcGxhdGVzW1widGFnLWZpbGUtZGVsZXRlZFwiXSA9IG5ldyBIb2dhbi5UZW1wbGF0ZSh7IGNvZGU6IGZ1bmN0aW9uIChjLCBwLCBpKSB7IHZhciB0ID0gdGhpczsgdC5iKGkgPSBpIHx8IFwiXCIpOyB0LmIoXCI8c3BhbiBjbGFzcz1cXFwiZDJoLXRhZyBkMmgtZGVsZXRlZCBkMmgtZGVsZXRlZC10YWdcXFwiPkRFTEVURUQ8L3NwYW4+XCIpOyByZXR1cm4gdC5mbCgpOyB9LCBwYXJ0aWFsczoge30sIHN1YnM6IHt9IH0pO1xuZGVmYXVsdFRlbXBsYXRlc1tcInRhZy1maWxlLXJlbmFtZWRcIl0gPSBuZXcgSG9nYW4uVGVtcGxhdGUoeyBjb2RlOiBmdW5jdGlvbiAoYywgcCwgaSkgeyB2YXIgdCA9IHRoaXM7IHQuYihpID0gaSB8fCBcIlwiKTsgdC5iKFwiPHNwYW4gY2xhc3M9XFxcImQyaC10YWcgZDJoLW1vdmVkIGQyaC1tb3ZlZC10YWdcXFwiPlJFTkFNRUQ8L3NwYW4+XCIpOyByZXR1cm4gdC5mbCgpOyB9LCBwYXJ0aWFsczoge30sIHN1YnM6IHt9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlmZjJodG1sLXRlbXBsYXRlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0ICogYXMgRGlmZlBhcnNlciBmcm9tICcuL2RpZmYtcGFyc2VyJztcbmltcG9ydCAqIGFzIGZpbGVMaXN0UHJpbnRlciBmcm9tICcuL2ZpbGUtbGlzdC1yZW5kZXJlcic7XG5pbXBvcnQgTGluZUJ5TGluZVJlbmRlcmVyLCB7IGRlZmF1bHRMaW5lQnlMaW5lUmVuZGVyZXJDb25maWcgfSBmcm9tICcuL2xpbmUtYnktbGluZS1yZW5kZXJlcic7XG5pbXBvcnQgU2lkZUJ5U2lkZVJlbmRlcmVyLCB7IGRlZmF1bHRTaWRlQnlTaWRlUmVuZGVyZXJDb25maWcgfSBmcm9tICcuL3NpZGUtYnktc2lkZS1yZW5kZXJlcic7XG5pbXBvcnQgeyBPdXRwdXRGb3JtYXRUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgSG9nYW5Kc1V0aWxzIGZyb20gJy4vaG9nYW5qcy11dGlscyc7XG5leHBvcnQgdmFyIGRlZmF1bHREaWZmMkh0bWxDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdExpbmVCeUxpbmVSZW5kZXJlckNvbmZpZyksIGRlZmF1bHRTaWRlQnlTaWRlUmVuZGVyZXJDb25maWcpLCB7IG91dHB1dEZvcm1hdDogT3V0cHV0Rm9ybWF0VHlwZS5MSU5FX0JZX0xJTkUsIGRyYXdGaWxlTGlzdDogdHJ1ZSB9KTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShkaWZmSW5wdXQsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwKSB7IGNvbmZpZ3VyYXRpb24gPSB7fTsgfVxuICAgIHJldHVybiBEaWZmUGFyc2VyLnBhcnNlKGRpZmZJbnB1dCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHREaWZmMkh0bWxDb25maWcpLCBjb25maWd1cmF0aW9uKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaHRtbChkaWZmSW5wdXQsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwKSB7IGNvbmZpZ3VyYXRpb24gPSB7fTsgfVxuICAgIHZhciBjb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdERpZmYySHRtbENvbmZpZyksIGNvbmZpZ3VyYXRpb24pO1xuICAgIHZhciBkaWZmSnNvbiA9IHR5cGVvZiBkaWZmSW5wdXQgPT09ICdzdHJpbmcnID8gRGlmZlBhcnNlci5wYXJzZShkaWZmSW5wdXQsIGNvbmZpZykgOiBkaWZmSW5wdXQ7XG4gICAgdmFyIGhvZ2FuVXRpbHMgPSBuZXcgSG9nYW5Kc1V0aWxzKGNvbmZpZyk7XG4gICAgdmFyIGZpbGVMaXN0ID0gY29uZmlnLmRyYXdGaWxlTGlzdCA/IGZpbGVMaXN0UHJpbnRlci5yZW5kZXIoZGlmZkpzb24sIGhvZ2FuVXRpbHMpIDogJyc7XG4gICAgdmFyIGRpZmZPdXRwdXQgPSBjb25maWcub3V0cHV0Rm9ybWF0ID09PSAnc2lkZS1ieS1zaWRlJ1xuICAgICAgICA/IG5ldyBTaWRlQnlTaWRlUmVuZGVyZXIoaG9nYW5VdGlscywgY29uZmlnKS5yZW5kZXIoZGlmZkpzb24pXG4gICAgICAgIDogbmV3IExpbmVCeUxpbmVSZW5kZXJlcihob2dhblV0aWxzLCBjb25maWcpLnJlbmRlcihkaWZmSnNvbik7XG4gICAgcmV0dXJuIGZpbGVMaXN0ICsgZGlmZk91dHB1dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpZmYyaHRtbC5qcy5tYXAiLCJpbXBvcnQgKiBhcyByZW5kZXJVdGlscyBmcm9tICcuL3JlbmRlci11dGlscyc7XG52YXIgYmFzZVRlbXBsYXRlc1BhdGggPSAnZmlsZS1zdW1tYXJ5JztcbnZhciBpY29uc0Jhc2VUZW1wbGF0ZXNQYXRoID0gJ2ljb24nO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihkaWZmRmlsZXMsIGhvZ2FuVXRpbHMpIHtcbiAgICB2YXIgZmlsZXMgPSBkaWZmRmlsZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gaG9nYW5VdGlscy5yZW5kZXIoYmFzZVRlbXBsYXRlc1BhdGgsICdsaW5lJywge1xuICAgICAgICAgICAgZmlsZUh0bWxJZDogcmVuZGVyVXRpbHMuZ2V0SHRtbElkKGZpbGUpLFxuICAgICAgICAgICAgb2xkTmFtZTogZmlsZS5vbGROYW1lLFxuICAgICAgICAgICAgbmV3TmFtZTogZmlsZS5uZXdOYW1lLFxuICAgICAgICAgICAgZmlsZU5hbWU6IHJlbmRlclV0aWxzLmZpbGVuYW1lRGlmZihmaWxlKSxcbiAgICAgICAgICAgIGRlbGV0ZWRMaW5lczogJy0nICsgZmlsZS5kZWxldGVkTGluZXMsXG4gICAgICAgICAgICBhZGRlZExpbmVzOiAnKycgKyBmaWxlLmFkZGVkTGluZXMsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGZpbGVJY29uOiBob2dhblV0aWxzLnRlbXBsYXRlKGljb25zQmFzZVRlbXBsYXRlc1BhdGgsIHJlbmRlclV0aWxzLmdldEZpbGVJY29uKGZpbGUpKSxcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiBob2dhblV0aWxzLnJlbmRlcihiYXNlVGVtcGxhdGVzUGF0aCwgJ3dyYXBwZXInLCB7XG4gICAgICAgIGZpbGVzTnVtYmVyOiBkaWZmRmlsZXMubGVuZ3RoLFxuICAgICAgICBmaWxlczogZmlsZXMsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLWxpc3QtcmVuZGVyZXIuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCAqIGFzIEhvZ2FuIGZyb20gJ2hvZ2FuLmpzJztcbmltcG9ydCB7IGRlZmF1bHRUZW1wbGF0ZXMgfSBmcm9tICcuL2RpZmYyaHRtbC10ZW1wbGF0ZXMnO1xudmFyIEhvZ2FuSnNVdGlscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSG9nYW5Kc1V0aWxzKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmNvbXBpbGVkVGVtcGxhdGVzLCBjb21waWxlZFRlbXBsYXRlcyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBfYyA9IF9hLnJhd1RlbXBsYXRlcywgcmF3VGVtcGxhdGVzID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2M7XG4gICAgICAgIHZhciBjb21waWxlZFJhd1RlbXBsYXRlcyA9IE9iamVjdC5lbnRyaWVzKHJhd1RlbXBsYXRlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1RlbXBsYXRlcywgX2EpIHtcbiAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2FbMF0sIHRlbXBsYXRlU3RyaW5nID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IEhvZ2FuLmNvbXBpbGUodGVtcGxhdGVTdHJpbmcsIHsgYXNTdHJpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2aW91c1RlbXBsYXRlcyksIChfYiA9IHt9LCBfYltuYW1lXSA9IGNvbXBpbGVkVGVtcGxhdGUsIF9iKSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy5wcmVDb21waWxlZFRlbXBsYXRlcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0VGVtcGxhdGVzKSwgY29tcGlsZWRUZW1wbGF0ZXMpLCBjb21waWxlZFJhd1RlbXBsYXRlcyk7XG4gICAgfVxuICAgIEhvZ2FuSnNVdGlscy5jb21waWxlID0gZnVuY3Rpb24gKHRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBIb2dhbi5jb21waWxlKHRlbXBsYXRlU3RyaW5nLCB7IGFzU3RyaW5nOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIEhvZ2FuSnNVdGlscy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgdmlldywgcGFyYW1zLCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZUtleSA9IHRoaXMudGVtcGxhdGVLZXkobmFtZXNwYWNlLCB2aWV3KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMucHJlQ29tcGlsZWRUZW1wbGF0ZXNbdGVtcGxhdGVLZXldO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlbmRlcihwYXJhbXMsIHBhcnRpYWxzLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSB0byByZW5kZXIgJ1wiICsgdGVtcGxhdGVLZXkgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhvZ2FuSnNVdGlscy5wcm90b3R5cGUudGVtcGxhdGUgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCB2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZUNvbXBpbGVkVGVtcGxhdGVzW3RoaXMudGVtcGxhdGVLZXkobmFtZXNwYWNlLCB2aWV3KV07XG4gICAgfTtcbiAgICBIb2dhbkpzVXRpbHMucHJvdG90eXBlLnRlbXBsYXRlS2V5ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgdmlldykge1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlICsgXCItXCIgKyB2aWV3O1xuICAgIH07XG4gICAgcmV0dXJuIEhvZ2FuSnNVdGlscztcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBIb2dhbkpzVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2dhbmpzLXV0aWxzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgKiBhcyBSZW1hdGNoIGZyb20gJy4vcmVtYXRjaCc7XG5pbXBvcnQgKiBhcyByZW5kZXJVdGlscyBmcm9tICcuL3JlbmRlci11dGlscyc7XG5pbXBvcnQgeyBMaW5lVHlwZSwgfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB2YXIgZGVmYXVsdExpbmVCeUxpbmVSZW5kZXJlckNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZW5kZXJVdGlscy5kZWZhdWx0UmVuZGVyQ29uZmlnKSwgeyByZW5kZXJOb3RoaW5nV2hlbkVtcHR5OiBmYWxzZSwgbWF0Y2hpbmdNYXhDb21wYXJpc29uczogMjUwMCwgbWF4TGluZVNpemVJbkJsb2NrRm9yQ29tcGFyaXNvbjogMjAwIH0pO1xudmFyIGdlbmVyaWNUZW1wbGF0ZXNQYXRoID0gJ2dlbmVyaWMnO1xudmFyIGJhc2VUZW1wbGF0ZXNQYXRoID0gJ2xpbmUtYnktbGluZSc7XG52YXIgaWNvbnNCYXNlVGVtcGxhdGVzUGF0aCA9ICdpY29uJztcbnZhciB0YWdzQmFzZVRlbXBsYXRlc1BhdGggPSAndGFnJztcbnZhciBMaW5lQnlMaW5lUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVCeUxpbmVSZW5kZXJlcihob2dhblV0aWxzLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHRoaXMuaG9nYW5VdGlscyA9IGhvZ2FuVXRpbHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRMaW5lQnlMaW5lUmVuZGVyZXJDb25maWcpLCBjb25maWcpO1xuICAgIH1cbiAgICBMaW5lQnlMaW5lUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkaWZmRmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRpZmZzSHRtbCA9IGRpZmZGaWxlc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgdmFyIGRpZmZzO1xuICAgICAgICAgICAgaWYgKGZpbGUuYmxvY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRpZmZzID0gX3RoaXMuZ2VuZXJhdGVGaWxlSHRtbChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzID0gX3RoaXMuZ2VuZXJhdGVFbXB0eURpZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5tYWtlRmlsZURpZmZIdG1sKGZpbGUsIGRpZmZzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9nYW5VdGlscy5yZW5kZXIoZ2VuZXJpY1RlbXBsYXRlc1BhdGgsICd3cmFwcGVyJywgeyBjb250ZW50OiBkaWZmc0h0bWwgfSk7XG4gICAgfTtcbiAgICBMaW5lQnlMaW5lUmVuZGVyZXIucHJvdG90eXBlLm1ha2VGaWxlRGlmZkh0bWwgPSBmdW5jdGlvbiAoZmlsZSwgZGlmZnMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlck5vdGhpbmdXaGVuRW1wdHkgJiYgQXJyYXkuaXNBcnJheShmaWxlLmJsb2NrcykgJiYgZmlsZS5ibG9ja3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB2YXIgZmlsZURpZmZUZW1wbGF0ZSA9IHRoaXMuaG9nYW5VdGlscy50ZW1wbGF0ZShiYXNlVGVtcGxhdGVzUGF0aCwgJ2ZpbGUtZGlmZicpO1xuICAgICAgICB2YXIgZmlsZVBhdGhUZW1wbGF0ZSA9IHRoaXMuaG9nYW5VdGlscy50ZW1wbGF0ZShnZW5lcmljVGVtcGxhdGVzUGF0aCwgJ2ZpbGUtcGF0aCcpO1xuICAgICAgICB2YXIgZmlsZUljb25UZW1wbGF0ZSA9IHRoaXMuaG9nYW5VdGlscy50ZW1wbGF0ZShpY29uc0Jhc2VUZW1wbGF0ZXNQYXRoLCAnZmlsZScpO1xuICAgICAgICB2YXIgZmlsZVRhZ1RlbXBsYXRlID0gdGhpcy5ob2dhblV0aWxzLnRlbXBsYXRlKHRhZ3NCYXNlVGVtcGxhdGVzUGF0aCwgcmVuZGVyVXRpbHMuZ2V0RmlsZUljb24oZmlsZSkpO1xuICAgICAgICByZXR1cm4gZmlsZURpZmZUZW1wbGF0ZS5yZW5kZXIoe1xuICAgICAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgICAgIGZpbGVIdG1sSWQ6IHJlbmRlclV0aWxzLmdldEh0bWxJZChmaWxlKSxcbiAgICAgICAgICAgIGRpZmZzOiBkaWZmcyxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlUGF0aFRlbXBsYXRlLnJlbmRlcih7XG4gICAgICAgICAgICAgICAgZmlsZURpZmZOYW1lOiByZW5kZXJVdGlscy5maWxlbmFtZURpZmYoZmlsZSksXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZmlsZUljb246IGZpbGVJY29uVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgZmlsZVRhZzogZmlsZVRhZ1RlbXBsYXRlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGluZUJ5TGluZVJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUVtcHR5RGlmZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9nYW5VdGlscy5yZW5kZXIoZ2VuZXJpY1RlbXBsYXRlc1BhdGgsICdlbXB0eS1kaWZmJywge1xuICAgICAgICAgICAgY29udGVudENsYXNzOiAnZDJoLWNvZGUtbGluZScsXG4gICAgICAgICAgICBDU1NMaW5lQ2xhc3M6IHJlbmRlclV0aWxzLkNTU0xpbmVDbGFzcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaW5lQnlMaW5lUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlRmlsZUh0bWwgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWF0Y2hlciA9IFJlbWF0Y2gubmV3TWF0Y2hlckZuKFJlbWF0Y2gubmV3RGlzdGFuY2VGbihmdW5jdGlvbiAoZSkgeyByZXR1cm4gcmVuZGVyVXRpbHMuZGVjb25zdHJ1Y3RMaW5lKGUuY29udGVudCwgZmlsZS5pc0NvbWJpbmVkKS5jb250ZW50OyB9KSk7XG4gICAgICAgIHJldHVybiBmaWxlLmJsb2Nrc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IF90aGlzLmhvZ2FuVXRpbHMucmVuZGVyKGdlbmVyaWNUZW1wbGF0ZXNQYXRoLCAnYmxvY2staGVhZGVyJywge1xuICAgICAgICAgICAgICAgIENTU0xpbmVDbGFzczogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLFxuICAgICAgICAgICAgICAgIGJsb2NrSGVhZGVyOiBmaWxlLmlzVG9vQmlnID8gYmxvY2suaGVhZGVyIDogcmVuZGVyVXRpbHMuZXNjYXBlRm9ySHRtbChibG9jay5oZWFkZXIpLFxuICAgICAgICAgICAgICAgIGxpbmVDbGFzczogJ2QyaC1jb2RlLWxpbmVudW1iZXInLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRDbGFzczogJ2QyaC1jb2RlLWxpbmUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5hcHBseUxpbmVHcm91cHBpbmcoYmxvY2spLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRMaW5lcyA9IF9hWzBdLCBvbGRMaW5lcyA9IF9hWzFdLCBuZXdMaW5lcyA9IF9hWzJdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRMaW5lcy5sZW5ndGggJiYgbmV3TGluZXMubGVuZ3RoICYmICFjb250ZXh0TGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFwcGx5UmVtYXRjaE1hdGNoaW5nKG9sZExpbmVzLCBuZXdMaW5lcywgbWF0Y2hlcikubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZExpbmVzID0gX2FbMF0sIG5ld0xpbmVzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9jZXNzQ2hhbmdlZExpbmVzKGZpbGUuaXNDb21iaW5lZCwgb2xkTGluZXMsIG5ld0xpbmVzKSwgbGVmdCA9IF9iLmxlZnQsIHJpZ2h0ID0gX2IucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0TGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZW5kZXJVdGlscy5kZWNvbnN0cnVjdExpbmUobGluZS5jb250ZW50LCBmaWxlLmlzQ29tYmluZWQpLCBwcmVmaXggPSBfYS5wcmVmaXgsIGNvbnRlbnQgPSBfYS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gX3RoaXMuZ2VuZXJhdGVTaW5nbGVMaW5lSHRtbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLkNPTlRFWFQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGROdW1iZXI6IGxpbmUub2xkTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld051bWJlcjogbGluZS5uZXdOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZExpbmVzLmxlbmd0aCB8fCBuZXdMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvY2Vzc0NoYW5nZWRMaW5lcyhmaWxlLmlzQ29tYmluZWQsIG9sZExpbmVzLCBuZXdMaW5lcyksIGxlZnQgPSBfYi5sZWZ0LCByaWdodCA9IF9iLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gc3RhdGUgcmVhY2hlZCB3aGlsZSBwcm9jZXNzaW5nIGdyb3VwcyBvZiBsaW5lcycsIGNvbnRleHRMaW5lcywgb2xkTGluZXMsIG5ld0xpbmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9O1xuICAgIExpbmVCeUxpbmVSZW5kZXJlci5wcm90b3R5cGUuYXBwbHlMaW5lR3JvdXBwaW5nID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBibG9ja0xpbmVzR3JvdXBzID0gW107XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IFtdO1xuICAgICAgICB2YXIgbmV3TGluZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZmZMaW5lID0gYmxvY2subGluZXNbaV07XG4gICAgICAgICAgICBpZiAoKGRpZmZMaW5lLnR5cGUgIT09IExpbmVUeXBlLklOU0VSVCAmJiBuZXdMaW5lcy5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgKGRpZmZMaW5lLnR5cGUgPT09IExpbmVUeXBlLkNPTlRFWFQgJiYgb2xkTGluZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICBibG9ja0xpbmVzR3JvdXBzLnB1c2goW1tdLCBvbGRMaW5lcywgbmV3TGluZXNdKTtcbiAgICAgICAgICAgICAgICBvbGRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld0xpbmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZkxpbmUudHlwZSA9PT0gTGluZVR5cGUuQ09OVEVYVCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTGluZXNHcm91cHMucHVzaChbW2RpZmZMaW5lXSwgW10sIFtdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaWZmTGluZS50eXBlID09PSBMaW5lVHlwZS5JTlNFUlQgJiYgb2xkTGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tMaW5lc0dyb3Vwcy5wdXNoKFtbXSwgW10sIFtkaWZmTGluZV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpZmZMaW5lLnR5cGUgPT09IExpbmVUeXBlLklOU0VSVCAmJiBvbGRMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbmV3TGluZXMucHVzaChkaWZmTGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaWZmTGluZS50eXBlID09PSBMaW5lVHlwZS5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICBvbGRMaW5lcy5wdXNoKGRpZmZMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkTGluZXMubGVuZ3RoIHx8IG5ld0xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYmxvY2tMaW5lc0dyb3Vwcy5wdXNoKFtbXSwgb2xkTGluZXMsIG5ld0xpbmVzXSk7XG4gICAgICAgICAgICBvbGRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgbmV3TGluZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tMaW5lc0dyb3VwcztcbiAgICB9O1xuICAgIExpbmVCeUxpbmVSZW5kZXJlci5wcm90b3R5cGUuYXBwbHlSZW1hdGNoTWF0Y2hpbmcgPSBmdW5jdGlvbiAob2xkTGluZXMsIG5ld0xpbmVzLCBtYXRjaGVyKSB7XG4gICAgICAgIHZhciBjb21wYXJpc29ucyA9IG9sZExpbmVzLmxlbmd0aCAqIG5ld0xpbmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heExpbmVTaXplSW5CbG9jayA9IE1hdGgubWF4LmFwcGx5KG51bGwsIFswXS5jb25jYXQob2xkTGluZXMuY29uY2F0KG5ld0xpbmVzKS5tYXAoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0uY29udGVudC5sZW5ndGg7IH0pKSk7XG4gICAgICAgIHZhciBkb01hdGNoaW5nID0gY29tcGFyaXNvbnMgPCB0aGlzLmNvbmZpZy5tYXRjaGluZ01heENvbXBhcmlzb25zICYmXG4gICAgICAgICAgICBtYXhMaW5lU2l6ZUluQmxvY2sgPCB0aGlzLmNvbmZpZy5tYXhMaW5lU2l6ZUluQmxvY2tGb3JDb21wYXJpc29uICYmXG4gICAgICAgICAgICAodGhpcy5jb25maWcubWF0Y2hpbmcgPT09ICdsaW5lcycgfHwgdGhpcy5jb25maWcubWF0Y2hpbmcgPT09ICd3b3JkcycpO1xuICAgICAgICByZXR1cm4gZG9NYXRjaGluZyA/IG1hdGNoZXIob2xkTGluZXMsIG5ld0xpbmVzKSA6IFtbb2xkTGluZXMsIG5ld0xpbmVzXV07XG4gICAgfTtcbiAgICBMaW5lQnlMaW5lUmVuZGVyZXIucHJvdG90eXBlLnByb2Nlc3NDaGFuZ2VkTGluZXMgPSBmdW5jdGlvbiAoaXNDb21iaW5lZCwgb2xkTGluZXMsIG5ld0xpbmVzKSB7XG4gICAgICAgIHZhciBmaWxlSHRtbCA9IHtcbiAgICAgICAgICAgIHJpZ2h0OiAnJyxcbiAgICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbWF4TGluZXNOdW1iZXIgPSBNYXRoLm1heChvbGRMaW5lcy5sZW5ndGgsIG5ld0xpbmVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGluZXNOdW1iZXI7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9sZExpbmUgPSBvbGRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBuZXdMaW5lID0gbmV3TGluZXNbaV07XG4gICAgICAgICAgICB2YXIgZGlmZiA9IG9sZExpbmUgIT09IHVuZGVmaW5lZCAmJiBuZXdMaW5lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHJlbmRlclV0aWxzLmRpZmZIaWdobGlnaHQob2xkTGluZS5jb250ZW50LCBuZXdMaW5lLmNvbnRlbnQsIGlzQ29tYmluZWQsIHRoaXMuY29uZmlnKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHByZXBhcmVkT2xkTGluZSA9IG9sZExpbmUgIT09IHVuZGVmaW5lZCAmJiBvbGRMaW5lLm9sZE51bWJlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKGRpZmYgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogZGlmZi5vbGRMaW5lLnByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGRpZmYub2xkTGluZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLkRFTEVURV9DSEFOR0VTLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlbmRlclV0aWxzLmRlY29uc3RydWN0TGluZShvbGRMaW5lLmNvbnRlbnQsIGlzQ29tYmluZWQpKSwgeyB0eXBlOiByZW5kZXJVdGlscy50b0NTU0NsYXNzKG9sZExpbmUudHlwZSkgfSkpKSwgeyBvbGROdW1iZXI6IG9sZExpbmUub2xkTnVtYmVyLCBuZXdOdW1iZXI6IG9sZExpbmUubmV3TnVtYmVyIH0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHByZXBhcmVkTmV3TGluZSA9IG5ld0xpbmUgIT09IHVuZGVmaW5lZCAmJiBuZXdMaW5lLm5ld051bWJlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKGRpZmYgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogZGlmZi5uZXdMaW5lLnByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGRpZmYubmV3TGluZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLklOU0VSVF9DSEFOR0VTLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlbmRlclV0aWxzLmRlY29uc3RydWN0TGluZShuZXdMaW5lLmNvbnRlbnQsIGlzQ29tYmluZWQpKSwgeyB0eXBlOiByZW5kZXJVdGlscy50b0NTU0NsYXNzKG5ld0xpbmUudHlwZSkgfSkpKSwgeyBvbGROdW1iZXI6IG5ld0xpbmUub2xkTnVtYmVyLCBuZXdOdW1iZXI6IG5ld0xpbmUubmV3TnVtYmVyIH0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5nZW5lcmF0ZUxpbmVIdG1sKHByZXBhcmVkT2xkTGluZSwgcHJlcGFyZWROZXdMaW5lKSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgICAgICBmaWxlSHRtbC5sZWZ0ICs9IGxlZnQ7XG4gICAgICAgICAgICBmaWxlSHRtbC5yaWdodCArPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZUh0bWw7XG4gICAgfTtcbiAgICBMaW5lQnlMaW5lUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlTGluZUh0bWwgPSBmdW5jdGlvbiAob2xkTGluZSwgbmV3TGluZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5nZW5lcmF0ZVNpbmdsZUxpbmVIdG1sKG9sZExpbmUpLFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuZ2VuZXJhdGVTaW5nbGVMaW5lSHRtbChuZXdMaW5lKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpbmVCeUxpbmVSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVTaW5nbGVMaW5lSHRtbCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIHZhciBsaW5lTnVtYmVySHRtbCA9IHRoaXMuaG9nYW5VdGlscy5yZW5kZXIoYmFzZVRlbXBsYXRlc1BhdGgsICdudW1iZXJzJywge1xuICAgICAgICAgICAgb2xkTnVtYmVyOiBsaW5lLm9sZE51bWJlciB8fCAnJyxcbiAgICAgICAgICAgIG5ld051bWJlcjogbGluZS5uZXdOdW1iZXIgfHwgJycsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ob2dhblV0aWxzLnJlbmRlcihnZW5lcmljVGVtcGxhdGVzUGF0aCwgJ2xpbmUnLCB7XG4gICAgICAgICAgICB0eXBlOiBsaW5lLnR5cGUsXG4gICAgICAgICAgICBsaW5lQ2xhc3M6ICdkMmgtY29kZS1saW5lbnVtYmVyJyxcbiAgICAgICAgICAgIGNvbnRlbnRDbGFzczogJ2QyaC1jb2RlLWxpbmUnLFxuICAgICAgICAgICAgcHJlZml4OiBsaW5lLnByZWZpeCA9PT0gJyAnID8gJyZuYnNwOycgOiBsaW5lLnByZWZpeCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGxpbmUuY29udGVudCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXJIdG1sLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5lQnlMaW5lUmVuZGVyZXI7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgTGluZUJ5TGluZVJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluZS1ieS1saW5lLXJlbmRlcmVyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBsZXZlbnNodGVpbihhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXRyaXhbaV0gPSBbaV07XG4gICAgfVxuICAgIHZhciBqO1xuICAgIGZvciAoaiA9IDA7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICBtYXRyaXhbMF1bal0gPSBqO1xuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoYi5jaGFyQXQoaSAtIDEpID09PSBhLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKG1hdHJpeFtpIC0gMV1baiAtIDFdICsgMSwgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsIG1hdHJpeFtpIC0gMV1bal0gKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeFtiLmxlbmd0aF1bYS5sZW5ndGhdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5ld0Rpc3RhbmNlRm4oc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB4VmFsdWUgPSBzdHIoeCkudHJpbSgpO1xuICAgICAgICB2YXIgeVZhbHVlID0gc3RyKHkpLnRyaW0oKTtcbiAgICAgICAgdmFyIGxldiA9IGxldmVuc2h0ZWluKHhWYWx1ZSwgeVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxldiAvICh4VmFsdWUubGVuZ3RoICsgeVZhbHVlLmxlbmd0aCk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuZXdNYXRjaGVyRm4oZGlzdGFuY2UpIHtcbiAgICBmdW5jdGlvbiBmaW5kQmVzdE1hdGNoKGEsIGIsIGNhY2hlKSB7XG4gICAgICAgIGlmIChjYWNoZSA9PT0gdm9pZCAwKSB7IGNhY2hlID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHZhciBiZXN0TWF0Y2hEaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBiZXN0TWF0Y2g7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoW2FbaV0sIGJbal1dKTtcbiAgICAgICAgICAgICAgICB2YXIgbWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGUuaGFzKGNhY2hlS2V5KSAmJiAobWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWQgPSBkaXN0YW5jZShhW2ldLCBiW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBtZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZCA8IGJlc3RNYXRjaERpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoRGlzdCA9IG1kO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSB7IGluZGV4QTogaSwgaW5kZXhCOiBqLCBzY29yZTogYmVzdE1hdGNoRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBncm91cChhLCBiLCBsZXZlbCwgY2FjaGUpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSAwOyB9XG4gICAgICAgIGlmIChjYWNoZSA9PT0gdm9pZCAwKSB7IGNhY2hlID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHZhciBibSA9IGZpbmRCZXN0TWF0Y2goYSwgYiwgY2FjaGUpO1xuICAgICAgICBpZiAoIWJtIHx8IGEubGVuZ3RoICsgYi5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1thLCBiXV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGExID0gYS5zbGljZSgwLCBibS5pbmRleEEpO1xuICAgICAgICB2YXIgYjEgPSBiLnNsaWNlKDAsIGJtLmluZGV4Qik7XG4gICAgICAgIHZhciBhTWF0Y2ggPSBbYVtibS5pbmRleEFdXTtcbiAgICAgICAgdmFyIGJNYXRjaCA9IFtiW2JtLmluZGV4Ql1dO1xuICAgICAgICB2YXIgdGFpbEEgPSBibS5pbmRleEEgKyAxO1xuICAgICAgICB2YXIgdGFpbEIgPSBibS5pbmRleEIgKyAxO1xuICAgICAgICB2YXIgYTIgPSBhLnNsaWNlKHRhaWxBKTtcbiAgICAgICAgdmFyIGIyID0gYi5zbGljZSh0YWlsQik7XG4gICAgICAgIHZhciBncm91cDEgPSBncm91cChhMSwgYjEsIGxldmVsICsgMSwgY2FjaGUpO1xuICAgICAgICB2YXIgZ3JvdXBNYXRjaCA9IGdyb3VwKGFNYXRjaCwgYk1hdGNoLCBsZXZlbCArIDEsIGNhY2hlKTtcbiAgICAgICAgdmFyIGdyb3VwMiA9IGdyb3VwKGEyLCBiMiwgbGV2ZWwgKyAxLCBjYWNoZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBncm91cE1hdGNoO1xuICAgICAgICBpZiAoYm0uaW5kZXhBID4gMCB8fCBibS5pbmRleEIgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBncm91cDEuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoID4gdGFpbEEgfHwgYi5sZW5ndGggPiB0YWlsQikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChncm91cDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBncm91cDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbWF0Y2guanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCAqIGFzIGpzRGlmZiBmcm9tICdkaWZmJztcbmltcG9ydCB7IHVuaWZ5UGF0aCwgaGFzaENvZGUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCAqIGFzIHJlbWF0Y2ggZnJvbSAnLi9yZW1hdGNoJztcbmltcG9ydCB7IExpbmVNYXRjaGluZ1R5cGUsIERpZmZTdHlsZVR5cGUsIExpbmVUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgdmFyIENTU0xpbmVDbGFzcyA9IHtcbiAgICBJTlNFUlRTOiAnZDJoLWlucycsXG4gICAgREVMRVRFUzogJ2QyaC1kZWwnLFxuICAgIENPTlRFWFQ6ICdkMmgtY250eCcsXG4gICAgSU5GTzogJ2QyaC1pbmZvJyxcbiAgICBJTlNFUlRfQ0hBTkdFUzogJ2QyaC1pbnMgZDJoLWNoYW5nZScsXG4gICAgREVMRVRFX0NIQU5HRVM6ICdkMmgtZGVsIGQyaC1jaGFuZ2UnLFxufTtcbmV4cG9ydCB2YXIgZGVmYXVsdFJlbmRlckNvbmZpZyA9IHtcbiAgICBtYXRjaGluZzogTGluZU1hdGNoaW5nVHlwZS5OT05FLFxuICAgIG1hdGNoV29yZHNUaHJlc2hvbGQ6IDAuMjUsXG4gICAgbWF4TGluZUxlbmd0aEhpZ2hsaWdodDogMTAwMDAsXG4gICAgZGlmZlN0eWxlOiBEaWZmU3R5bGVUeXBlLldPUkQsXG59O1xudmFyIHNlcGFyYXRvciA9ICcvJztcbnZhciBkaXN0YW5jZSA9IHJlbWF0Y2gubmV3RGlzdGFuY2VGbihmdW5jdGlvbiAoY2hhbmdlKSB7IHJldHVybiBjaGFuZ2UudmFsdWU7IH0pO1xudmFyIG1hdGNoZXIgPSByZW1hdGNoLm5ld01hdGNoZXJGbihkaXN0YW5jZSk7XG5mdW5jdGlvbiBpc0Rldk51bGxOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5pbmRleE9mKCdkZXYvbnVsbCcpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUluc0VsZW1lbnRzKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5yZXBsYWNlKC8oPGluc1tePl0qPigoLnxcXG4pKj8pPFxcL2lucz4pL2csICcnKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZURlbEVsZW1lbnRzKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5yZXBsYWNlKC8oPGRlbFtePl0qPigoLnxcXG4pKj8pPFxcL2RlbD4pL2csICcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0NTU0NsYXNzKGxpbmVUeXBlKSB7XG4gICAgc3dpdGNoIChsaW5lVHlwZSkge1xuICAgICAgICBjYXNlIExpbmVUeXBlLkNPTlRFWFQ6XG4gICAgICAgICAgICByZXR1cm4gQ1NTTGluZUNsYXNzLkNPTlRFWFQ7XG4gICAgICAgIGNhc2UgTGluZVR5cGUuSU5TRVJUOlxuICAgICAgICAgICAgcmV0dXJuIENTU0xpbmVDbGFzcy5JTlNFUlRTO1xuICAgICAgICBjYXNlIExpbmVUeXBlLkRFTEVURTpcbiAgICAgICAgICAgIHJldHVybiBDU1NMaW5lQ2xhc3MuREVMRVRFUztcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVmaXhMZW5ndGgoaXNDb21iaW5lZCkge1xuICAgIHJldHVybiBpc0NvbWJpbmVkID8gMiA6IDE7XG59XG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRm9ySHRtbChzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5zbGljZSgwKVxuICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiN4Mjc7JylcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnJiN4MkY7Jyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb25zdHJ1Y3RMaW5lKGxpbmUsIGlzQ29tYmluZWQsIGVzY2FwZSkge1xuICAgIGlmIChlc2NhcGUgPT09IHZvaWQgMCkgeyBlc2NhcGUgPSB0cnVlOyB9XG4gICAgdmFyIGluZGV4VG9TcGxpdCA9IHByZWZpeExlbmd0aChpc0NvbWJpbmVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXg6IGxpbmUuc3Vic3RyaW5nKDAsIGluZGV4VG9TcGxpdCksXG4gICAgICAgIGNvbnRlbnQ6IGVzY2FwZSA/IGVzY2FwZUZvckh0bWwobGluZS5zdWJzdHJpbmcoaW5kZXhUb1NwbGl0KSkgOiBsaW5lLnN1YnN0cmluZyhpbmRleFRvU3BsaXQpLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZmlsZW5hbWVEaWZmKGZpbGUpIHtcbiAgICB2YXIgb2xkRmlsZW5hbWUgPSB1bmlmeVBhdGgoZmlsZS5vbGROYW1lKTtcbiAgICB2YXIgbmV3RmlsZW5hbWUgPSB1bmlmeVBhdGgoZmlsZS5uZXdOYW1lKTtcbiAgICBpZiAob2xkRmlsZW5hbWUgIT09IG5ld0ZpbGVuYW1lICYmICFpc0Rldk51bGxOYW1lKG9sZEZpbGVuYW1lKSAmJiAhaXNEZXZOdWxsTmFtZShuZXdGaWxlbmFtZSkpIHtcbiAgICAgICAgdmFyIHByZWZpeFBhdGhzID0gW107XG4gICAgICAgIHZhciBzdWZmaXhQYXRocyA9IFtdO1xuICAgICAgICB2YXIgb2xkRmlsZW5hbWVQYXJ0cyA9IG9sZEZpbGVuYW1lLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIHZhciBuZXdGaWxlbmFtZVBhcnRzID0gbmV3RmlsZW5hbWUuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIG9sZEZpbGVuYW1lUGFydHNTaXplID0gb2xkRmlsZW5hbWVQYXJ0cy5sZW5ndGg7XG4gICAgICAgIHZhciBuZXdGaWxlbmFtZVBhcnRzU2l6ZSA9IG5ld0ZpbGVuYW1lUGFydHMubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBqID0gb2xkRmlsZW5hbWVQYXJ0c1NpemUgLSAxO1xuICAgICAgICB2YXIgayA9IG5ld0ZpbGVuYW1lUGFydHNTaXplIC0gMTtcbiAgICAgICAgd2hpbGUgKGkgPCBqICYmIGkgPCBrKSB7XG4gICAgICAgICAgICBpZiAob2xkRmlsZW5hbWVQYXJ0c1tpXSA9PT0gbmV3RmlsZW5hbWVQYXJ0c1tpXSkge1xuICAgICAgICAgICAgICAgIHByZWZpeFBhdGhzLnB1c2gobmV3RmlsZW5hbWVQYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGogPiBpICYmIGsgPiBpKSB7XG4gICAgICAgICAgICBpZiAob2xkRmlsZW5hbWVQYXJ0c1tqXSA9PT0gbmV3RmlsZW5hbWVQYXJ0c1trXSkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeFBhdGhzLnVuc2hpZnQobmV3RmlsZW5hbWVQYXJ0c1trXSk7XG4gICAgICAgICAgICAgICAgaiAtPSAxO1xuICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5hbFByZWZpeCA9IHByZWZpeFBhdGhzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGZpbmFsU3VmZml4ID0gc3VmZml4UGF0aHMuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgb2xkUmVtYWluaW5nUGF0aCA9IG9sZEZpbGVuYW1lUGFydHMuc2xpY2UoaSwgaiArIDEpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIG5ld1JlbWFpbmluZ1BhdGggPSBuZXdGaWxlbmFtZVBhcnRzLnNsaWNlKGksIGsgKyAxKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChmaW5hbFByZWZpeC5sZW5ndGggJiYgZmluYWxTdWZmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZpbmFsUHJlZml4ICsgc2VwYXJhdG9yICsgJ3snICsgb2xkUmVtYWluaW5nUGF0aCArICcg4oaSICcgKyBuZXdSZW1haW5pbmdQYXRoICsgJ30nICsgc2VwYXJhdG9yICsgZmluYWxTdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbmFsUHJlZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJlZml4ICsgc2VwYXJhdG9yICsgJ3snICsgb2xkUmVtYWluaW5nUGF0aCArICcg4oaSICcgKyBuZXdSZW1haW5pbmdQYXRoICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbmFsU3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIG9sZFJlbWFpbmluZ1BhdGggKyAnIOKGkiAnICsgbmV3UmVtYWluaW5nUGF0aCArICd9JyArIHNlcGFyYXRvciArIGZpbmFsU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGRGaWxlbmFtZSArICcg4oaSICcgKyBuZXdGaWxlbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRGV2TnVsbE5hbWUobmV3RmlsZW5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuZXdGaWxlbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvbGRGaWxlbmFtZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SHRtbElkKGZpbGUpIHtcbiAgICByZXR1cm4gXCJkMmgtXCIgKyBoYXNoQ29kZShmaWxlbmFtZURpZmYoZmlsZSkpLnRvU3RyaW5nKCkuc2xpY2UoLTYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVJY29uKGZpbGUpIHtcbiAgICB2YXIgdGVtcGxhdGVOYW1lID0gJ2ZpbGUtY2hhbmdlZCc7XG4gICAgaWYgKGZpbGUuaXNSZW5hbWUpIHtcbiAgICAgICAgdGVtcGxhdGVOYW1lID0gJ2ZpbGUtcmVuYW1lZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbGUuaXNDb3B5KSB7XG4gICAgICAgIHRlbXBsYXRlTmFtZSA9ICdmaWxlLXJlbmFtZWQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWxlLmlzTmV3KSB7XG4gICAgICAgIHRlbXBsYXRlTmFtZSA9ICdmaWxlLWFkZGVkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsZS5pc0RlbGV0ZWQpIHtcbiAgICAgICAgdGVtcGxhdGVOYW1lID0gJ2ZpbGUtZGVsZXRlZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbGUubmV3TmFtZSAhPT0gZmlsZS5vbGROYW1lKSB7XG4gICAgICAgIHRlbXBsYXRlTmFtZSA9ICdmaWxlLXJlbmFtZWQnO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGVOYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZIaWdobGlnaHQoZGlmZkxpbmUxLCBkaWZmTGluZTIsIGlzQ29tYmluZWQsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgIHZhciBfYSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0UmVuZGVyQ29uZmlnKSwgY29uZmlnKSwgbWF0Y2hpbmcgPSBfYS5tYXRjaGluZywgbWF4TGluZUxlbmd0aEhpZ2hsaWdodCA9IF9hLm1heExpbmVMZW5ndGhIaWdobGlnaHQsIG1hdGNoV29yZHNUaHJlc2hvbGQgPSBfYS5tYXRjaFdvcmRzVGhyZXNob2xkLCBkaWZmU3R5bGUgPSBfYS5kaWZmU3R5bGU7XG4gICAgdmFyIGxpbmUxID0gZGVjb25zdHJ1Y3RMaW5lKGRpZmZMaW5lMSwgaXNDb21iaW5lZCwgZmFsc2UpO1xuICAgIHZhciBsaW5lMiA9IGRlY29uc3RydWN0TGluZShkaWZmTGluZTIsIGlzQ29tYmluZWQsIGZhbHNlKTtcbiAgICBpZiAobGluZTEuY29udGVudC5sZW5ndGggPiBtYXhMaW5lTGVuZ3RoSGlnaGxpZ2h0IHx8IGxpbmUyLmNvbnRlbnQubGVuZ3RoID4gbWF4TGluZUxlbmd0aEhpZ2hsaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2xkTGluZToge1xuICAgICAgICAgICAgICAgIHByZWZpeDogbGluZTEucHJlZml4LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVzY2FwZUZvckh0bWwobGluZTEuY29udGVudCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV3TGluZToge1xuICAgICAgICAgICAgICAgIHByZWZpeDogbGluZTIucHJlZml4LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVzY2FwZUZvckh0bWwobGluZTIuY29udGVudCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgZGlmZiA9IGRpZmZTdHlsZSA9PT0gJ2NoYXInXG4gICAgICAgID8ganNEaWZmLmRpZmZDaGFycyhsaW5lMS5jb250ZW50LCBsaW5lMi5jb250ZW50KVxuICAgICAgICA6IGpzRGlmZi5kaWZmV29yZHNXaXRoU3BhY2UobGluZTEuY29udGVudCwgbGluZTIuY29udGVudCk7XG4gICAgdmFyIGNoYW5nZWRXb3JkcyA9IFtdO1xuICAgIGlmIChkaWZmU3R5bGUgPT09ICd3b3JkJyAmJiBtYXRjaGluZyA9PT0gJ3dvcmRzJykge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGRpZmYuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnJlbW92ZWQ7IH0pO1xuICAgICAgICB2YXIgYWRkZWQgPSBkaWZmLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5hZGRlZDsgfSk7XG4gICAgICAgIHZhciBjaHVua3MgPSBtYXRjaGVyKGFkZGVkLCByZW1vdmVkKTtcbiAgICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtbMF0ubGVuZ3RoID09PSAxICYmIGNodW5rWzFdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gZGlzdGFuY2UoY2h1bmtbMF1bMF0sIGNodW5rWzFdWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1hdGNoV29yZHNUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFdvcmRzLnB1c2goY2h1bmtbMF1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkV29yZHMucHVzaChjaHVua1sxXVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGhpZ2hsaWdodGVkTGluZSA9IGRpZmYucmVkdWNlKGZ1bmN0aW9uIChoaWdobGlnaHRlZExpbmUsIHBhcnQpIHtcbiAgICAgICAgdmFyIGVsZW1UeXBlID0gcGFydC5hZGRlZCA/ICdpbnMnIDogcGFydC5yZW1vdmVkID8gJ2RlbCcgOiBudWxsO1xuICAgICAgICB2YXIgYWRkQ2xhc3MgPSBjaGFuZ2VkV29yZHMuaW5kZXhPZihwYXJ0KSA+IC0xID8gJyBjbGFzcz1cImQyaC1jaGFuZ2VcIicgOiAnJztcbiAgICAgICAgdmFyIGVzY2FwZWRWYWx1ZSA9IGVzY2FwZUZvckh0bWwocGFydC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBlbGVtVHlwZSAhPT0gbnVsbFxuICAgICAgICAgICAgPyBoaWdobGlnaHRlZExpbmUgKyBcIjxcIiArIGVsZW1UeXBlICsgYWRkQ2xhc3MgKyBcIj5cIiArIGVzY2FwZWRWYWx1ZSArIFwiPC9cIiArIGVsZW1UeXBlICsgXCI+XCJcbiAgICAgICAgICAgIDogXCJcIiArIGhpZ2hsaWdodGVkTGluZSArIGVzY2FwZWRWYWx1ZTtcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2xkTGluZToge1xuICAgICAgICAgICAgcHJlZml4OiBsaW5lMS5wcmVmaXgsXG4gICAgICAgICAgICBjb250ZW50OiByZW1vdmVJbnNFbGVtZW50cyhoaWdobGlnaHRlZExpbmUpLFxuICAgICAgICB9LFxuICAgICAgICBuZXdMaW5lOiB7XG4gICAgICAgICAgICBwcmVmaXg6IGxpbmUyLnByZWZpeCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlbW92ZURlbEVsZW1lbnRzKGhpZ2hsaWdodGVkTGluZSksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci11dGlscy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0ICogYXMgUmVtYXRjaCBmcm9tICcuL3JlbWF0Y2gnO1xuaW1wb3J0ICogYXMgcmVuZGVyVXRpbHMgZnJvbSAnLi9yZW5kZXItdXRpbHMnO1xuaW1wb3J0IHsgTGluZVR5cGUsIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgdmFyIGRlZmF1bHRTaWRlQnlTaWRlUmVuZGVyZXJDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVuZGVyVXRpbHMuZGVmYXVsdFJlbmRlckNvbmZpZyksIHsgcmVuZGVyTm90aGluZ1doZW5FbXB0eTogZmFsc2UsIG1hdGNoaW5nTWF4Q29tcGFyaXNvbnM6IDI1MDAsIG1heExpbmVTaXplSW5CbG9ja0ZvckNvbXBhcmlzb246IDIwMCB9KTtcbnZhciBnZW5lcmljVGVtcGxhdGVzUGF0aCA9ICdnZW5lcmljJztcbnZhciBiYXNlVGVtcGxhdGVzUGF0aCA9ICdzaWRlLWJ5LXNpZGUnO1xudmFyIGljb25zQmFzZVRlbXBsYXRlc1BhdGggPSAnaWNvbic7XG52YXIgdGFnc0Jhc2VUZW1wbGF0ZXNQYXRoID0gJ3RhZyc7XG52YXIgU2lkZUJ5U2lkZVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaWRlQnlTaWRlUmVuZGVyZXIoaG9nYW5VdGlscywgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB0aGlzLmhvZ2FuVXRpbHMgPSBob2dhblV0aWxzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0U2lkZUJ5U2lkZVJlbmRlcmVyQ29uZmlnKSwgY29uZmlnKTtcbiAgICB9XG4gICAgU2lkZUJ5U2lkZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGlmZkZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkaWZmc0h0bWwgPSBkaWZmRmlsZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIHZhciBkaWZmcztcbiAgICAgICAgICAgIGlmIChmaWxlLmJsb2Nrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkaWZmcyA9IF90aGlzLmdlbmVyYXRlRmlsZUh0bWwoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWZmcyA9IF90aGlzLmdlbmVyYXRlRW1wdHlEaWZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubWFrZUZpbGVEaWZmSHRtbChmaWxlLCBkaWZmcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmhvZ2FuVXRpbHMucmVuZGVyKGdlbmVyaWNUZW1wbGF0ZXNQYXRoLCAnd3JhcHBlcicsIHsgY29udGVudDogZGlmZnNIdG1sIH0pO1xuICAgIH07XG4gICAgU2lkZUJ5U2lkZVJlbmRlcmVyLnByb3RvdHlwZS5tYWtlRmlsZURpZmZIdG1sID0gZnVuY3Rpb24gKGZpbGUsIGRpZmZzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJOb3RoaW5nV2hlbkVtcHR5ICYmIEFycmF5LmlzQXJyYXkoZmlsZS5ibG9ja3MpICYmIGZpbGUuYmxvY2tzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgdmFyIGZpbGVEaWZmVGVtcGxhdGUgPSB0aGlzLmhvZ2FuVXRpbHMudGVtcGxhdGUoYmFzZVRlbXBsYXRlc1BhdGgsICdmaWxlLWRpZmYnKTtcbiAgICAgICAgdmFyIGZpbGVQYXRoVGVtcGxhdGUgPSB0aGlzLmhvZ2FuVXRpbHMudGVtcGxhdGUoZ2VuZXJpY1RlbXBsYXRlc1BhdGgsICdmaWxlLXBhdGgnKTtcbiAgICAgICAgdmFyIGZpbGVJY29uVGVtcGxhdGUgPSB0aGlzLmhvZ2FuVXRpbHMudGVtcGxhdGUoaWNvbnNCYXNlVGVtcGxhdGVzUGF0aCwgJ2ZpbGUnKTtcbiAgICAgICAgdmFyIGZpbGVUYWdUZW1wbGF0ZSA9IHRoaXMuaG9nYW5VdGlscy50ZW1wbGF0ZSh0YWdzQmFzZVRlbXBsYXRlc1BhdGgsIHJlbmRlclV0aWxzLmdldEZpbGVJY29uKGZpbGUpKTtcbiAgICAgICAgcmV0dXJuIGZpbGVEaWZmVGVtcGxhdGUucmVuZGVyKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICBmaWxlSHRtbElkOiByZW5kZXJVdGlscy5nZXRIdG1sSWQoZmlsZSksXG4gICAgICAgICAgICBkaWZmczogZGlmZnMsXG4gICAgICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGhUZW1wbGF0ZS5yZW5kZXIoe1xuICAgICAgICAgICAgICAgIGZpbGVEaWZmTmFtZTogcmVuZGVyVXRpbHMuZmlsZW5hbWVEaWZmKGZpbGUpLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGZpbGVJY29uOiBmaWxlSWNvblRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIGZpbGVUYWc6IGZpbGVUYWdUZW1wbGF0ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZGVCeVNpZGVSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVFbXB0eURpZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByaWdodDogJycsXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmhvZ2FuVXRpbHMucmVuZGVyKGdlbmVyaWNUZW1wbGF0ZXNQYXRoLCAnZW1wdHktZGlmZicsIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q2xhc3M6ICdkMmgtY29kZS1zaWRlLWxpbmUnLFxuICAgICAgICAgICAgICAgIENTU0xpbmVDbGFzczogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTaWRlQnlTaWRlUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlRmlsZUh0bWwgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWF0Y2hlciA9IFJlbWF0Y2gubmV3TWF0Y2hlckZuKFJlbWF0Y2gubmV3RGlzdGFuY2VGbihmdW5jdGlvbiAoZSkgeyByZXR1cm4gcmVuZGVyVXRpbHMuZGVjb25zdHJ1Y3RMaW5lKGUuY29udGVudCwgZmlsZS5pc0NvbWJpbmVkKS5jb250ZW50OyB9KSk7XG4gICAgICAgIHJldHVybiBmaWxlLmJsb2Nrc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgIHZhciBmaWxlSHRtbCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBfdGhpcy5tYWtlSGVhZGVySHRtbChibG9jay5oZWFkZXIsIGZpbGUpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBfdGhpcy5tYWtlSGVhZGVySHRtbCgnJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuYXBwbHlMaW5lR3JvdXBwaW5nKGJsb2NrKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0TGluZXMgPSBfYVswXSwgb2xkTGluZXMgPSBfYVsxXSwgbmV3TGluZXMgPSBfYVsyXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkTGluZXMubGVuZ3RoICYmIG5ld0xpbmVzLmxlbmd0aCAmJiAhY29udGV4dExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hcHBseVJlbWF0Y2hNYXRjaGluZyhvbGRMaW5lcywgbmV3TGluZXMsIG1hdGNoZXIpLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRMaW5lcyA9IF9hWzBdLCBuZXdMaW5lcyA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvY2Vzc0NoYW5nZWRMaW5lcyhmaWxlLmlzQ29tYmluZWQsIG9sZExpbmVzLCBuZXdMaW5lcyksIGxlZnQgPSBfYi5sZWZ0LCByaWdodCA9IF9iLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUh0bWwubGVmdCArPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUh0bWwucmlnaHQgKz0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0TGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZW5kZXJVdGlscy5kZWNvbnN0cnVjdExpbmUobGluZS5jb250ZW50LCBmaWxlLmlzQ29tYmluZWQpLCBwcmVmaXggPSBfYS5wcmVmaXgsIGNvbnRlbnQgPSBfYS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMuZ2VuZXJhdGVMaW5lSHRtbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLkNPTlRFWFQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXI6IGxpbmUub2xkTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJlbmRlclV0aWxzLkNTU0xpbmVDbGFzcy5DT05URVhULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBsaW5lLm5ld051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBsZWZ0ID0gX2IubGVmdCwgcmlnaHQgPSBfYi5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVIdG1sLmxlZnQgKz0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVIdG1sLnJpZ2h0ICs9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkTGluZXMubGVuZ3RoIHx8IG5ld0xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9jZXNzQ2hhbmdlZExpbmVzKGZpbGUuaXNDb21iaW5lZCwgb2xkTGluZXMsIG5ld0xpbmVzKSwgbGVmdCA9IF9iLmxlZnQsIHJpZ2h0ID0gX2IucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVIdG1sLmxlZnQgKz0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZmlsZUh0bWwucmlnaHQgKz0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIHN0YXRlIHJlYWNoZWQgd2hpbGUgcHJvY2Vzc2luZyBncm91cHMgb2YgbGluZXMnLCBjb250ZXh0TGluZXMsIG9sZExpbmVzLCBuZXdMaW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZUh0bWw7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2NvbXVsYXRlZCwgaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogYWNjb211bGF0ZWQubGVmdCArIGh0bWwubGVmdCwgcmlnaHQ6IGFjY29tdWxhdGVkLnJpZ2h0ICsgaHRtbC5yaWdodCB9O1xuICAgICAgICB9LCB7IGxlZnQ6ICcnLCByaWdodDogJycgfSk7XG4gICAgfTtcbiAgICBTaWRlQnlTaWRlUmVuZGVyZXIucHJvdG90eXBlLmFwcGx5TGluZUdyb3VwcGluZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgYmxvY2tMaW5lc0dyb3VwcyA9IFtdO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0xpbmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmTGluZSA9IGJsb2NrLmxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKChkaWZmTGluZS50eXBlICE9PSBMaW5lVHlwZS5JTlNFUlQgJiYgbmV3TGluZXMubGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAgIChkaWZmTGluZS50eXBlID09PSBMaW5lVHlwZS5DT05URVhUICYmIG9sZExpbmVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tMaW5lc0dyb3Vwcy5wdXNoKFtbXSwgb2xkTGluZXMsIG5ld0xpbmVzXSk7XG4gICAgICAgICAgICAgICAgb2xkTGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBuZXdMaW5lcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmZMaW5lLnR5cGUgPT09IExpbmVUeXBlLkNPTlRFWFQpIHtcbiAgICAgICAgICAgICAgICBibG9ja0xpbmVzR3JvdXBzLnB1c2goW1tkaWZmTGluZV0sIFtdLCBbXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlmZkxpbmUudHlwZSA9PT0gTGluZVR5cGUuSU5TRVJUICYmIG9sZExpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTGluZXNHcm91cHMucHVzaChbW10sIFtdLCBbZGlmZkxpbmVdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaWZmTGluZS50eXBlID09PSBMaW5lVHlwZS5JTlNFUlQgJiYgb2xkTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5ld0xpbmVzLnB1c2goZGlmZkxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlmZkxpbmUudHlwZSA9PT0gTGluZVR5cGUuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgb2xkTGluZXMucHVzaChkaWZmTGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZExpbmVzLmxlbmd0aCB8fCBuZXdMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJsb2NrTGluZXNHcm91cHMucHVzaChbW10sIG9sZExpbmVzLCBuZXdMaW5lc10pO1xuICAgICAgICAgICAgb2xkTGluZXMgPSBbXTtcbiAgICAgICAgICAgIG5ld0xpbmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrTGluZXNHcm91cHM7XG4gICAgfTtcbiAgICBTaWRlQnlTaWRlUmVuZGVyZXIucHJvdG90eXBlLmFwcGx5UmVtYXRjaE1hdGNoaW5nID0gZnVuY3Rpb24gKG9sZExpbmVzLCBuZXdMaW5lcywgbWF0Y2hlcikge1xuICAgICAgICB2YXIgY29tcGFyaXNvbnMgPSBvbGRMaW5lcy5sZW5ndGggKiBuZXdMaW5lcy5sZW5ndGg7XG4gICAgICAgIHZhciBtYXhMaW5lU2l6ZUluQmxvY2sgPSBNYXRoLm1heC5hcHBseShudWxsLCBbMF0uY29uY2F0KG9sZExpbmVzLmNvbmNhdChuZXdMaW5lcykubWFwKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLmNvbnRlbnQubGVuZ3RoOyB9KSkpO1xuICAgICAgICB2YXIgZG9NYXRjaGluZyA9IGNvbXBhcmlzb25zIDwgdGhpcy5jb25maWcubWF0Y2hpbmdNYXhDb21wYXJpc29ucyAmJlxuICAgICAgICAgICAgbWF4TGluZVNpemVJbkJsb2NrIDwgdGhpcy5jb25maWcubWF4TGluZVNpemVJbkJsb2NrRm9yQ29tcGFyaXNvbiAmJlxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLm1hdGNoaW5nID09PSAnbGluZXMnIHx8IHRoaXMuY29uZmlnLm1hdGNoaW5nID09PSAnd29yZHMnKTtcbiAgICAgICAgcmV0dXJuIGRvTWF0Y2hpbmcgPyBtYXRjaGVyKG9sZExpbmVzLCBuZXdMaW5lcykgOiBbW29sZExpbmVzLCBuZXdMaW5lc11dO1xuICAgIH07XG4gICAgU2lkZUJ5U2lkZVJlbmRlcmVyLnByb3RvdHlwZS5tYWtlSGVhZGVySHRtbCA9IGZ1bmN0aW9uIChibG9ja0hlYWRlciwgZmlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob2dhblV0aWxzLnJlbmRlcihnZW5lcmljVGVtcGxhdGVzUGF0aCwgJ2Jsb2NrLWhlYWRlcicsIHtcbiAgICAgICAgICAgIENTU0xpbmVDbGFzczogcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLFxuICAgICAgICAgICAgYmxvY2tIZWFkZXI6IChmaWxlID09PSBudWxsIHx8IGZpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGUuaXNUb29CaWcpID8gYmxvY2tIZWFkZXIgOiByZW5kZXJVdGlscy5lc2NhcGVGb3JIdG1sKGJsb2NrSGVhZGVyKSxcbiAgICAgICAgICAgIGxpbmVDbGFzczogJ2QyaC1jb2RlLXNpZGUtbGluZW51bWJlcicsXG4gICAgICAgICAgICBjb250ZW50Q2xhc3M6ICdkMmgtY29kZS1zaWRlLWxpbmUnLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZGVCeVNpZGVSZW5kZXJlci5wcm90b3R5cGUucHJvY2Vzc0NoYW5nZWRMaW5lcyA9IGZ1bmN0aW9uIChpc0NvbWJpbmVkLCBvbGRMaW5lcywgbmV3TGluZXMpIHtcbiAgICAgICAgdmFyIGZpbGVIdG1sID0ge1xuICAgICAgICAgICAgcmlnaHQ6ICcnLFxuICAgICAgICAgICAgbGVmdDogJycsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYXhMaW5lc051bWJlciA9IE1hdGgubWF4KG9sZExpbmVzLmxlbmd0aCwgbmV3TGluZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMaW5lc051bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2xkTGluZSA9IG9sZExpbmVzW2ldO1xuICAgICAgICAgICAgdmFyIG5ld0xpbmUgPSBuZXdMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBkaWZmID0gb2xkTGluZSAhPT0gdW5kZWZpbmVkICYmIG5ld0xpbmUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gcmVuZGVyVXRpbHMuZGlmZkhpZ2hsaWdodChvbGRMaW5lLmNvbnRlbnQsIG5ld0xpbmUuY29udGVudCwgaXNDb21iaW5lZCwgdGhpcy5jb25maWcpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgcHJlcGFyZWRPbGRMaW5lID0gb2xkTGluZSAhPT0gdW5kZWZpbmVkICYmIG9sZExpbmUub2xkTnVtYmVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoZGlmZiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBkaWZmLm9sZExpbmUucHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZGlmZi5vbGRMaW5lLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZW5kZXJVdGlscy5DU1NMaW5lQ2xhc3MuREVMRVRFX0NIQU5HRVMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVuZGVyVXRpbHMuZGVjb25zdHJ1Y3RMaW5lKG9sZExpbmUuY29udGVudCwgaXNDb21iaW5lZCkpLCB7IHR5cGU6IHJlbmRlclV0aWxzLnRvQ1NTQ2xhc3Mob2xkTGluZS50eXBlKSB9KSkpLCB7IG51bWJlcjogb2xkTGluZS5vbGROdW1iZXIgfSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgcHJlcGFyZWROZXdMaW5lID0gbmV3TGluZSAhPT0gdW5kZWZpbmVkICYmIG5ld0xpbmUubmV3TnVtYmVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoZGlmZiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBkaWZmLm5ld0xpbmUucHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZGlmZi5uZXdMaW5lLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZW5kZXJVdGlscy5DU1NMaW5lQ2xhc3MuSU5TRVJUX0NIQU5HRVMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVuZGVyVXRpbHMuZGVjb25zdHJ1Y3RMaW5lKG5ld0xpbmUuY29udGVudCwgaXNDb21iaW5lZCkpLCB7IHR5cGU6IHJlbmRlclV0aWxzLnRvQ1NTQ2xhc3MobmV3TGluZS50eXBlKSB9KSkpLCB7IG51bWJlcjogbmV3TGluZS5uZXdOdW1iZXIgfSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmdlbmVyYXRlTGluZUh0bWwocHJlcGFyZWRPbGRMaW5lLCBwcmVwYXJlZE5ld0xpbmUpLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgICAgIGZpbGVIdG1sLmxlZnQgKz0gbGVmdDtcbiAgICAgICAgICAgIGZpbGVIdG1sLnJpZ2h0ICs9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlSHRtbDtcbiAgICB9O1xuICAgIFNpZGVCeVNpZGVSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVMaW5lSHRtbCA9IGZ1bmN0aW9uIChvbGRMaW5lLCBuZXdMaW5lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmdlbmVyYXRlU2luZ2xlSHRtbChvbGRMaW5lKSxcbiAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmdlbmVyYXRlU2luZ2xlSHRtbChuZXdMaW5lKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNpZGVCeVNpZGVSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVTaW5nbGVIdG1sID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGxpbmVDbGFzcyA9ICdkMmgtY29kZS1zaWRlLWxpbmVudW1iZXInO1xuICAgICAgICB2YXIgY29udGVudENsYXNzID0gJ2QyaC1jb2RlLXNpZGUtbGluZSc7XG4gICAgICAgIHJldHVybiB0aGlzLmhvZ2FuVXRpbHMucmVuZGVyKGdlbmVyaWNUZW1wbGF0ZXNQYXRoLCAnbGluZScsIHtcbiAgICAgICAgICAgIHR5cGU6IChsaW5lID09PSBudWxsIHx8IGxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmUudHlwZSkgfHwgcmVuZGVyVXRpbHMuQ1NTTGluZUNsYXNzLkNPTlRFWFQgKyBcIiBkMmgtZW1wdHlwbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgbGluZUNsYXNzOiBsaW5lICE9PSB1bmRlZmluZWQgPyBsaW5lQ2xhc3MgOiBsaW5lQ2xhc3MgKyBcIiBkMmgtY29kZS1zaWRlLWVtcHR5cGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnRDbGFzczogbGluZSAhPT0gdW5kZWZpbmVkID8gY29udGVudENsYXNzIDogY29udGVudENsYXNzICsgXCIgZDJoLWNvZGUtc2lkZS1lbXB0eXBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICBwcmVmaXg6IChsaW5lID09PSBudWxsIHx8IGxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmUucHJlZml4KSA9PT0gJyAnID8gJyZuYnNwOycgOiBsaW5lID09PSBudWxsIHx8IGxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmUucHJlZml4LFxuICAgICAgICAgICAgY29udGVudDogbGluZSA9PT0gbnVsbCB8fCBsaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5lLmNvbnRlbnQsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lID09PSBudWxsIHx8IGxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmUubnVtYmVyLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTaWRlQnlTaWRlUmVuZGVyZXI7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgU2lkZUJ5U2lkZVJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lkZS1ieS1zaWRlLXJlbmRlcmVyLmpzLm1hcCIsImV4cG9ydCB2YXIgTGluZVR5cGU7XG4oZnVuY3Rpb24gKExpbmVUeXBlKSB7XG4gICAgTGluZVR5cGVbXCJJTlNFUlRcIl0gPSBcImluc2VydFwiO1xuICAgIExpbmVUeXBlW1wiREVMRVRFXCJdID0gXCJkZWxldGVcIjtcbiAgICBMaW5lVHlwZVtcIkNPTlRFWFRcIl0gPSBcImNvbnRleHRcIjtcbn0pKExpbmVUeXBlIHx8IChMaW5lVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIE91dHB1dEZvcm1hdFR5cGUgPSB7XG4gICAgTElORV9CWV9MSU5FOiAnbGluZS1ieS1saW5lJyxcbiAgICBTSURFX0JZX1NJREU6ICdzaWRlLWJ5LXNpZGUnLFxufTtcbmV4cG9ydCB2YXIgTGluZU1hdGNoaW5nVHlwZSA9IHtcbiAgICBMSU5FUzogJ2xpbmVzJyxcbiAgICBXT1JEUzogJ3dvcmRzJyxcbiAgICBOT05FOiAnbm9uZScsXG59O1xuZXhwb3J0IHZhciBEaWZmU3R5bGVUeXBlID0ge1xuICAgIFdPUkQ6ICd3b3JkJyxcbiAgICBDSEFSOiAnY2hhcicsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwidmFyIHNwZWNpYWxzID0gW1xuICAgICctJyxcbiAgICAnWycsXG4gICAgJ10nLFxuICAgICcvJyxcbiAgICAneycsXG4gICAgJ30nLFxuICAgICcoJyxcbiAgICAnKScsXG4gICAgJyonLFxuICAgICcrJyxcbiAgICAnPycsXG4gICAgJy4nLFxuICAgICdcXFxcJyxcbiAgICAnXicsXG4gICAgJyQnLFxuICAgICd8Jyxcbl07XG52YXIgcmVnZXggPSBSZWdFeHAoJ1snICsgc3BlY2lhbHMuam9pbignXFxcXCcpICsgJ10nLCAnZycpO1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsICdcXFxcJCYnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bmlmeVBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoID8gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykgOiBwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hDb2RlKHRleHQpIHtcbiAgICB2YXIgaSwgY2hyLCBsZW47XG4gICAgdmFyIGhhc2ggPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hyID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgICAgICBoYXNoIHw9IDA7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiLypcbiAqICBDb3B5cmlnaHQgMjAxMSBUd2l0dGVyLCBJbmMuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24gKEhvZ2FuKSB7XG4gIC8vIFNldHVwIHJlZ2V4ICBhc3NpZ25tZW50c1xuICAvLyByZW1vdmUgd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gTXVzdGFjaGUgc3BlY1xuICB2YXIgcklzV2hpdGVzcGFjZSA9IC9cXFMvLFxuICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgck5ld2xpbmUgPSAgL1xcbi9nLFxuICAgICAgckNyID0gL1xcci9nLFxuICAgICAgclNsYXNoID0gL1xcXFwvZyxcbiAgICAgIHJMaW5lU2VwID0gL1xcdTIwMjgvLFxuICAgICAgclBhcmFncmFwaFNlcCA9IC9cXHUyMDI5LztcblxuICBIb2dhbi50YWdzID0ge1xuICAgICcjJzogMSwgJ14nOiAyLCAnPCc6IDMsICckJzogNCxcbiAgICAnLyc6IDUsICchJzogNiwgJz4nOiA3LCAnPSc6IDgsICdfdic6IDksXG4gICAgJ3snOiAxMCwgJyYnOiAxMSwgJ190JzogMTJcbiAgfTtcblxuICBIb2dhbi5zY2FuID0gZnVuY3Rpb24gc2Nhbih0ZXh0LCBkZWxpbWl0ZXJzKSB7XG4gICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJTl9URVhUID0gMCxcbiAgICAgICAgSU5fVEFHX1RZUEUgPSAxLFxuICAgICAgICBJTl9UQUcgPSAyLFxuICAgICAgICBzdGF0ZSA9IElOX1RFWFQsXG4gICAgICAgIHRhZ1R5cGUgPSBudWxsLFxuICAgICAgICB0YWcgPSBudWxsLFxuICAgICAgICBidWYgPSAnJyxcbiAgICAgICAgdG9rZW5zID0gW10sXG4gICAgICAgIHNlZW5UYWcgPSBmYWxzZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxpbmVTdGFydCA9IDAsXG4gICAgICAgIG90YWcgPSAne3snLFxuICAgICAgICBjdGFnID0gJ319JztcblxuICAgIGZ1bmN0aW9uIGFkZEJ1ZigpIHtcbiAgICAgIGlmIChidWYubGVuZ3RoID4gMCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7dGFnOiAnX3QnLCB0ZXh0OiBuZXcgU3RyaW5nKGJ1Zil9KTtcbiAgICAgICAgYnVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUlzV2hpdGVzcGFjZSgpIHtcbiAgICAgIHZhciBpc0FsbFdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IGxpbmVTdGFydDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpc0FsbFdoaXRlc3BhY2UgPVxuICAgICAgICAgIChIb2dhbi50YWdzW3Rva2Vuc1tqXS50YWddIDwgSG9nYW4udGFnc1snX3YnXSkgfHxcbiAgICAgICAgICAodG9rZW5zW2pdLnRhZyA9PSAnX3QnICYmIHRva2Vuc1tqXS50ZXh0Lm1hdGNoKHJJc1doaXRlc3BhY2UpID09PSBudWxsKTtcbiAgICAgICAgaWYgKCFpc0FsbFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzQWxsV2hpdGVzcGFjZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJMaW5lKGhhdmVTZWVuVGFnLCBub05ld0xpbmUpIHtcbiAgICAgIGFkZEJ1ZigpO1xuXG4gICAgICBpZiAoaGF2ZVNlZW5UYWcgJiYgbGluZUlzV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBsaW5lU3RhcnQsIG5leHQ7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnRleHQpIHtcbiAgICAgICAgICAgIGlmICgobmV4dCA9IHRva2Vuc1tqKzFdKSAmJiBuZXh0LnRhZyA9PSAnPicpIHtcbiAgICAgICAgICAgICAgLy8gc2V0IGluZGVudCB0byB0b2tlbiB2YWx1ZVxuICAgICAgICAgICAgICBuZXh0LmluZGVudCA9IHRva2Vuc1tqXS50ZXh0LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFub05ld0xpbmUpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe3RhZzonXFxuJ30pO1xuICAgICAgfVxuXG4gICAgICBzZWVuVGFnID0gZmFsc2U7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZURlbGltaXRlcnModGV4dCwgaW5kZXgpIHtcbiAgICAgIHZhciBjbG9zZSA9ICc9JyArIGN0YWcsXG4gICAgICAgICAgY2xvc2VJbmRleCA9IHRleHQuaW5kZXhPZihjbG9zZSwgaW5kZXgpLFxuICAgICAgICAgIGRlbGltaXRlcnMgPSB0cmltKFxuICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcodGV4dC5pbmRleE9mKCc9JywgaW5kZXgpICsgMSwgY2xvc2VJbmRleClcbiAgICAgICAgICApLnNwbGl0KCcgJyk7XG5cbiAgICAgIG90YWcgPSBkZWxpbWl0ZXJzWzBdO1xuICAgICAgY3RhZyA9IGRlbGltaXRlcnNbZGVsaW1pdGVycy5sZW5ndGggLSAxXTtcblxuICAgICAgcmV0dXJuIGNsb3NlSW5kZXggKyBjbG9zZS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICBkZWxpbWl0ZXJzID0gZGVsaW1pdGVycy5zcGxpdCgnICcpO1xuICAgICAgb3RhZyA9IGRlbGltaXRlcnNbMF07XG4gICAgICBjdGFnID0gZGVsaW1pdGVyc1sxXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChzdGF0ZSA9PSBJTl9URVhUKSB7XG4gICAgICAgIGlmICh0YWdDaGFuZ2Uob3RhZywgdGV4dCwgaSkpIHtcbiAgICAgICAgICAtLWk7XG4gICAgICAgICAgYWRkQnVmKCk7XG4gICAgICAgICAgc3RhdGUgPSBJTl9UQUdfVFlQRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGZpbHRlckxpbmUoc2VlblRhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiArPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gSU5fVEFHX1RZUEUpIHtcbiAgICAgICAgaSArPSBvdGFnLmxlbmd0aCAtIDE7XG4gICAgICAgIHRhZyA9IEhvZ2FuLnRhZ3NbdGV4dC5jaGFyQXQoaSArIDEpXTtcbiAgICAgICAgdGFnVHlwZSA9IHRhZyA/IHRleHQuY2hhckF0KGkgKyAxKSA6ICdfdic7XG4gICAgICAgIGlmICh0YWdUeXBlID09ICc9Jykge1xuICAgICAgICAgIGkgPSBjaGFuZ2VEZWxpbWl0ZXJzKHRleHQsIGkpO1xuICAgICAgICAgIHN0YXRlID0gSU5fVEVYVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlID0gSU5fVEFHO1xuICAgICAgICB9XG4gICAgICAgIHNlZW5UYWcgPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhZ0NoYW5nZShjdGFnLCB0ZXh0LCBpKSkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHt0YWc6IHRhZ1R5cGUsIG46IHRyaW0oYnVmKSwgb3RhZzogb3RhZywgY3RhZzogY3RhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgaTogKHRhZ1R5cGUgPT0gJy8nKSA/IHNlZW5UYWcgLSBvdGFnLmxlbmd0aCA6IGkgKyBjdGFnLmxlbmd0aH0pO1xuICAgICAgICAgIGJ1ZiA9ICcnO1xuICAgICAgICAgIGkgKz0gY3RhZy5sZW5ndGggLSAxO1xuICAgICAgICAgIHN0YXRlID0gSU5fVEVYVDtcbiAgICAgICAgICBpZiAodGFnVHlwZSA9PSAneycpIHtcbiAgICAgICAgICAgIGlmIChjdGFnID09ICd9fScpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xlYW5UcmlwbGVTdGFjaGUodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZiArPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlckxpbmUoc2VlblRhZywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5UcmlwbGVTdGFjaGUodG9rZW4pIHtcbiAgICBpZiAodG9rZW4ubi5zdWJzdHIodG9rZW4ubi5sZW5ndGggLSAxKSA9PT0gJ30nKSB7XG4gICAgICB0b2tlbi5uID0gdG9rZW4ubi5zdWJzdHJpbmcoMCwgdG9rZW4ubi5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltKHMpIHtcbiAgICBpZiAocy50cmltKSB7XG4gICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnQ2hhbmdlKHRhZywgdGV4dCwgaW5kZXgpIHtcbiAgICBpZiAodGV4dC5jaGFyQXQoaW5kZXgpICE9IHRhZy5jaGFyQXQoMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IHRhZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCArIGkpICE9IHRhZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlIHRhZ3MgYWxsb3dlZCBpbnNpZGUgc3VwZXIgdGVtcGxhdGVzXG4gIHZhciBhbGxvd2VkSW5TdXBlciA9IHsnX3QnOiB0cnVlLCAnXFxuJzogdHJ1ZSwgJyQnOiB0cnVlLCAnLyc6IHRydWV9O1xuXG4gIGZ1bmN0aW9uIGJ1aWxkVHJlZSh0b2tlbnMsIGtpbmQsIHN0YWNrLCBjdXN0b21UYWdzKSB7XG4gICAgdmFyIGluc3RydWN0aW9ucyA9IFtdLFxuICAgICAgICBvcGVuZXIgPSBudWxsLFxuICAgICAgICB0YWlsID0gbnVsbCxcbiAgICAgICAgdG9rZW4gPSBudWxsO1xuXG4gICAgdGFpbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXG4gICAgICBpZiAodGFpbCAmJiB0YWlsLnRhZyA9PSAnPCcgJiYgISh0b2tlbi50YWcgaW4gYWxsb3dlZEluU3VwZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjb250ZW50IGluIDwgc3VwZXIgdGFnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoSG9nYW4udGFnc1t0b2tlbi50YWddIDw9IEhvZ2FuLnRhZ3NbJyQnXSB8fCBpc09wZW5lcih0b2tlbiwgY3VzdG9tVGFncykpIHtcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuLm5vZGVzID0gYnVpbGRUcmVlKHRva2VucywgdG9rZW4udGFnLCBzdGFjaywgY3VzdG9tVGFncyk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnRhZyA9PSAnLycpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xvc2luZyB0YWcgd2l0aG91dCBvcGVuZXI6IC8nICsgdG9rZW4ubik7XG4gICAgICAgIH1cbiAgICAgICAgb3BlbmVyID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbi5uICE9IG9wZW5lci5uICYmICFpc0Nsb3Nlcih0b2tlbi5uLCBvcGVuZXIubiwgY3VzdG9tVGFncykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RpbmcgZXJyb3I6ICcgKyBvcGVuZXIubiArICcgdnMuICcgKyB0b2tlbi5uKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuZXIuZW5kID0gdG9rZW4uaTtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4udGFnID09ICdcXG4nKSB7XG4gICAgICAgIHRva2VuLmxhc3QgPSAodG9rZW5zLmxlbmd0aCA9PSAwKSB8fCAodG9rZW5zWzBdLnRhZyA9PSAnXFxuJyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNsb3NpbmcgdGFnOiAnICsgc3RhY2sucG9wKCkubik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3BlbmVyKHRva2VuLCB0YWdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRhZ3NbaV0ubyA9PSB0b2tlbi5uKSB7XG4gICAgICAgIHRva2VuLnRhZyA9ICcjJztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNDbG9zZXIoY2xvc2UsIG9wZW4sIHRhZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGFnc1tpXS5jID09IGNsb3NlICYmIHRhZ3NbaV0ubyA9PSBvcGVuKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVN1YnN0aXR1dGlvbnMob2JqKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaXRlbXMucHVzaCgnXCInICsgZXNjKGtleSkgKyAnXCI6IGZ1bmN0aW9uKGMscCx0LGkpIHsnICsgb2JqW2tleV0gKyAnfScpO1xuICAgIH1cbiAgICByZXR1cm4gXCJ7IFwiICsgaXRlbXMuam9pbihcIixcIikgKyBcIiB9XCI7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlQYXJ0aWFscyhjb2RlT2JqKSB7XG4gICAgdmFyIHBhcnRpYWxzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGNvZGVPYmoucGFydGlhbHMpIHtcbiAgICAgIHBhcnRpYWxzLnB1c2goJ1wiJyArIGVzYyhrZXkpICsgJ1wiOntuYW1lOlwiJyArIGVzYyhjb2RlT2JqLnBhcnRpYWxzW2tleV0ubmFtZSkgKyAnXCIsICcgKyBzdHJpbmdpZnlQYXJ0aWFscyhjb2RlT2JqLnBhcnRpYWxzW2tleV0pICsgXCJ9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJwYXJ0aWFsczoge1wiICsgcGFydGlhbHMuam9pbihcIixcIikgKyBcIn0sIHN1YnM6IFwiICsgc3RyaW5naWZ5U3Vic3RpdHV0aW9ucyhjb2RlT2JqLnN1YnMpO1xuICB9XG5cbiAgSG9nYW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24oY29kZU9iaiwgdGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBcIntjb2RlOiBmdW5jdGlvbiAoYyxwLGkpIHsgXCIgKyBIb2dhbi53cmFwTWFpbihjb2RlT2JqLmNvZGUpICsgXCIgfSxcIiArIHN0cmluZ2lmeVBhcnRpYWxzKGNvZGVPYmopICsgIFwifVwiO1xuICB9XG5cbiAgdmFyIHNlcmlhbE5vID0gMDtcbiAgSG9nYW4uZ2VuZXJhdGUgPSBmdW5jdGlvbih0cmVlLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgc2VyaWFsTm8gPSAwO1xuICAgIHZhciBjb250ZXh0ID0geyBjb2RlOiAnJywgc3Viczoge30sIHBhcnRpYWxzOiB7fSB9O1xuICAgIEhvZ2FuLndhbGsodHJlZSwgY29udGV4dCk7XG5cbiAgICBpZiAob3B0aW9ucy5hc1N0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KGNvbnRleHQsIHRleHQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1ha2VUZW1wbGF0ZShjb250ZXh0LCB0ZXh0LCBvcHRpb25zKTtcbiAgfVxuXG4gIEhvZ2FuLndyYXBNYWluID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHJldHVybiAndmFyIHQ9dGhpczt0LmIoaT1pfHxcIlwiKTsnICsgY29kZSArICdyZXR1cm4gdC5mbCgpOyc7XG4gIH1cblxuICBIb2dhbi50ZW1wbGF0ZSA9IEhvZ2FuLlRlbXBsYXRlO1xuXG4gIEhvZ2FuLm1ha2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKGNvZGVPYmosIHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm1ha2VQYXJ0aWFscyhjb2RlT2JqKTtcbiAgICB0ZW1wbGF0ZS5jb2RlID0gbmV3IEZ1bmN0aW9uKCdjJywgJ3AnLCAnaScsIHRoaXMud3JhcE1haW4oY29kZU9iai5jb2RlKSk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLnRlbXBsYXRlKHRlbXBsYXRlLCB0ZXh0LCB0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIEhvZ2FuLm1ha2VQYXJ0aWFscyA9IGZ1bmN0aW9uKGNvZGVPYmopIHtcbiAgICB2YXIga2V5LCB0ZW1wbGF0ZSA9IHtzdWJzOiB7fSwgcGFydGlhbHM6IGNvZGVPYmoucGFydGlhbHMsIG5hbWU6IGNvZGVPYmoubmFtZX07XG4gICAgZm9yIChrZXkgaW4gdGVtcGxhdGUucGFydGlhbHMpIHtcbiAgICAgIHRlbXBsYXRlLnBhcnRpYWxzW2tleV0gPSB0aGlzLm1ha2VQYXJ0aWFscyh0ZW1wbGF0ZS5wYXJ0aWFsc1trZXldKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gY29kZU9iai5zdWJzKSB7XG4gICAgICB0ZW1wbGF0ZS5zdWJzW2tleV0gPSBuZXcgRnVuY3Rpb24oJ2MnLCAncCcsICd0JywgJ2knLCBjb2RlT2JqLnN1YnNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzYyhzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShyU2xhc2gsICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAucmVwbGFjZShyUXVvdCwgJ1xcXFxcXFwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UockNyLCAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UockxpbmVTZXAsICdcXFxcdTIwMjgnKVxuICAgICAgICAgICAgLnJlcGxhY2UoclBhcmFncmFwaFNlcCwgJ1xcXFx1MjAyOScpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hvb3NlTWV0aG9kKHMpIHtcbiAgICByZXR1cm4gKH5zLmluZGV4T2YoJy4nKSkgPyAnZCcgOiAnZic7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKG5vZGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcHJlZml4ID0gXCI8XCIgKyAoY29udGV4dC5wcmVmaXggfHwgXCJcIik7XG4gICAgdmFyIHN5bSA9IHByZWZpeCArIG5vZGUubiArIHNlcmlhbE5vKys7XG4gICAgY29udGV4dC5wYXJ0aWFsc1tzeW1dID0ge25hbWU6IG5vZGUubiwgcGFydGlhbHM6IHt9fTtcbiAgICBjb250ZXh0LmNvZGUgKz0gJ3QuYih0LnJwKFwiJyArICBlc2Moc3ltKSArICdcIixjLHAsXCInICsgKG5vZGUuaW5kZW50IHx8ICcnKSArICdcIikpOyc7XG4gICAgcmV0dXJuIHN5bTtcbiAgfVxuXG4gIEhvZ2FuLmNvZGVnZW4gPSB7XG4gICAgJyMnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gJ2lmKHQucyh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDEpLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICdjLHAsMCwnICsgbm9kZS5pICsgJywnICsgbm9kZS5lbmQgKyAnLFwiJyArIG5vZGUub3RhZyArIFwiIFwiICsgbm9kZS5jdGFnICsgJ1wiKSl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ3QucnMoYyxwLCcgKyAnZnVuY3Rpb24oYyxwLHQpeyc7XG4gICAgICBIb2dhbi53YWxrKG5vZGUubm9kZXMsIGNvbnRleHQpO1xuICAgICAgY29udGV4dC5jb2RlICs9ICd9KTtjLnBvcCgpO30nO1xuICAgIH0sXG5cbiAgICAnXic6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuY29kZSArPSAnaWYoIXQucyh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDEpLGMscCwxLDAsMCxcIlwiKSl7JztcbiAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY29udGV4dCk7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gJ307JztcbiAgICB9LFxuXG4gICAgJz4nOiBjcmVhdGVQYXJ0aWFsLFxuICAgICc8JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgdmFyIGN0eCA9IHtwYXJ0aWFsczoge30sIGNvZGU6ICcnLCBzdWJzOiB7fSwgaW5QYXJ0aWFsOiB0cnVlfTtcbiAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY3R4KTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IGNvbnRleHQucGFydGlhbHNbY3JlYXRlUGFydGlhbChub2RlLCBjb250ZXh0KV07XG4gICAgICB0ZW1wbGF0ZS5zdWJzID0gY3R4LnN1YnM7XG4gICAgICB0ZW1wbGF0ZS5wYXJ0aWFscyA9IGN0eC5wYXJ0aWFscztcbiAgICB9LFxuXG4gICAgJyQnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY3R4ID0ge3N1YnM6IHt9LCBjb2RlOiAnJywgcGFydGlhbHM6IGNvbnRleHQucGFydGlhbHMsIHByZWZpeDogbm9kZS5ufTtcbiAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY3R4KTtcbiAgICAgIGNvbnRleHQuc3Vic1tub2RlLm5dID0gY3R4LmNvZGU7XG4gICAgICBpZiAoIWNvbnRleHQuaW5QYXJ0aWFsKSB7XG4gICAgICAgIGNvbnRleHQuY29kZSArPSAndC5zdWIoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLGkpOyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdcXG4nOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gd3JpdGUoJ1wiXFxcXG5cIicgKyAobm9kZS5sYXN0ID8gJycgOiAnICsgaScpKTtcbiAgICB9LFxuXG4gICAgJ192JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dC5jb2RlICs9ICd0LmIodC52KHQuJyArIGNob29zZU1ldGhvZChub2RlLm4pICsgJyhcIicgKyBlc2Mobm9kZS5uKSArICdcIixjLHAsMCkpKTsnO1xuICAgIH0sXG5cbiAgICAnX3QnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gd3JpdGUoJ1wiJyArIGVzYyhub2RlLnRleHQpICsgJ1wiJyk7XG4gICAgfSxcblxuICAgICd7JzogdHJpcGxlU3RhY2hlLFxuXG4gICAgJyYnOiB0cmlwbGVTdGFjaGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaXBsZVN0YWNoZShub2RlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5jb2RlICs9ICd0LmIodC50KHQuJyArIGNob29zZU1ldGhvZChub2RlLm4pICsgJyhcIicgKyBlc2Mobm9kZS5uKSArICdcIixjLHAsMCkpKTsnO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUocykge1xuICAgIHJldHVybiAndC5iKCcgKyBzICsgJyk7JztcbiAgfVxuXG4gIEhvZ2FuLndhbGsgPSBmdW5jdGlvbihub2RlbGlzdCwgY29udGV4dCkge1xuICAgIHZhciBmdW5jO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZWxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmdW5jID0gSG9nYW4uY29kZWdlbltub2RlbGlzdFtpXS50YWddO1xuICAgICAgZnVuYyAmJiBmdW5jKG5vZGVsaXN0W2ldLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBIb2dhbi5wYXJzZSA9IGZ1bmN0aW9uKHRva2VucywgdGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBidWlsZFRyZWUodG9rZW5zLCAnJywgW10sIG9wdGlvbnMuc2VjdGlvblRhZ3MgfHwgW10pO1xuICB9XG5cbiAgSG9nYW4uY2FjaGUgPSB7fTtcblxuICBIb2dhbi5jYWNoZUtleSA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gW3RleHQsICEhb3B0aW9ucy5hc1N0cmluZywgISFvcHRpb25zLmRpc2FibGVMYW1iZGEsIG9wdGlvbnMuZGVsaW1pdGVycywgISFvcHRpb25zLm1vZGVsR2V0XS5qb2luKCd8fCcpO1xuICB9XG5cbiAgSG9nYW4uY29tcGlsZSA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIga2V5ID0gSG9nYW4uY2FjaGVLZXkodGV4dCwgb3B0aW9ucyk7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5jYWNoZVtrZXldO1xuXG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgcGFydGlhbHMgPSB0ZW1wbGF0ZS5wYXJ0aWFscztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGFydGlhbHMpIHtcbiAgICAgICAgZGVsZXRlIHBhcnRpYWxzW25hbWVdLmluc3RhbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cblxuICAgIHRlbXBsYXRlID0gdGhpcy5nZW5lcmF0ZSh0aGlzLnBhcnNlKHRoaXMuc2Nhbih0ZXh0LCBvcHRpb25zLmRlbGltaXRlcnMpLCB0ZXh0LCBvcHRpb25zKSwgdGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XSA9IHRlbXBsYXRlO1xuICB9XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogSG9nYW4pO1xuIiwiLypcbiAqICBDb3B5cmlnaHQgMjAxMSBUd2l0dGVyLCBJbmMuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBUaGlzIGZpbGUgaXMgZm9yIHVzZSB3aXRoIE5vZGUuanMuIFNlZSBkaXN0LyBmb3IgYnJvd3NlciBmaWxlcy5cblxudmFyIEhvZ2FuID0gcmVxdWlyZSgnLi9jb21waWxlcicpO1xuSG9nYW4uVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJykuVGVtcGxhdGU7XG5Ib2dhbi50ZW1wbGF0ZSA9IEhvZ2FuLlRlbXBsYXRlO1xubW9kdWxlLmV4cG9ydHMgPSBIb2dhbjtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IDIwMTEgVHdpdHRlciwgSW5jLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIEhvZ2FuID0ge307XG5cbihmdW5jdGlvbiAoSG9nYW4pIHtcbiAgSG9nYW4uVGVtcGxhdGUgPSBmdW5jdGlvbiAoY29kZU9iaiwgdGV4dCwgY29tcGlsZXIsIG9wdGlvbnMpIHtcbiAgICBjb2RlT2JqID0gY29kZU9iaiB8fCB7fTtcbiAgICB0aGlzLnIgPSBjb2RlT2JqLmNvZGUgfHwgdGhpcy5yO1xuICAgIHRoaXMuYyA9IGNvbXBpbGVyO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy50ZXh0ID0gdGV4dCB8fCAnJztcbiAgICB0aGlzLnBhcnRpYWxzID0gY29kZU9iai5wYXJ0aWFscyB8fCB7fTtcbiAgICB0aGlzLnN1YnMgPSBjb2RlT2JqLnN1YnMgfHwge307XG4gICAgdGhpcy5idWYgPSAnJztcbiAgfVxuXG4gIEhvZ2FuLlRlbXBsYXRlLnByb3RvdHlwZSA9IHtcbiAgICAvLyByZW5kZXI6IHJlcGxhY2VkIGJ5IGdlbmVyYXRlZCBjb2RlLlxuICAgIHI6IGZ1bmN0aW9uIChjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7IHJldHVybiAnJzsgfSxcblxuICAgIC8vIHZhcmlhYmxlIGVzY2FwaW5nXG4gICAgdjogaG9nYW5Fc2NhcGUsXG5cbiAgICAvLyB0cmlwbGUgc3RhY2hlXG4gICAgdDogY29lcmNlVG9TdHJpbmcsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5yaShbY29udGV4dF0sIHBhcnRpYWxzIHx8IHt9LCBpbmRlbnQpO1xuICAgIH0sXG5cbiAgICAvLyByZW5kZXIgaW50ZXJuYWwgLS0gYSBob29rIGZvciBvdmVycmlkZXMgdGhhdCBjYXRjaGVzIHBhcnRpYWxzIHRvb1xuICAgIHJpOiBmdW5jdGlvbiAoY29udGV4dCwgcGFydGlhbHMsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHRoaXMucihjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KTtcbiAgICB9LFxuXG4gICAgLy8gZW5zdXJlUGFydGlhbFxuICAgIGVwOiBmdW5jdGlvbihzeW1ib2wsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHRoaXMucGFydGlhbHNbc3ltYm9sXTtcblxuICAgICAgLy8gY2hlY2sgdG8gc2VlIHRoYXQgaWYgd2UndmUgaW5zdGFudGlhdGVkIHRoaXMgcGFydGlhbCBiZWZvcmVcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IHBhcnRpYWxzW3BhcnRpYWwubmFtZV07XG4gICAgICBpZiAocGFydGlhbC5pbnN0YW5jZSAmJiBwYXJ0aWFsLmJhc2UgPT0gdGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWwuaW5zdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF0aGlzLmMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb21waWxlciBhdmFpbGFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlID0gdGhpcy5jLmNvbXBpbGUodGVtcGxhdGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHVzZSB0aGlzIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHBhcnRpYWxzIGRpY3Rpb25hcnkgaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMucGFydGlhbHNbc3ltYm9sXS5iYXNlID0gdGVtcGxhdGU7XG5cbiAgICAgIGlmIChwYXJ0aWFsLnN1YnMpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNvbnNpZGVyIHBhcmVudCB0ZW1wbGF0ZSBub3dcbiAgICAgICAgaWYgKCFwYXJ0aWFscy5zdGFja1RleHQpIHBhcnRpYWxzLnN0YWNrVGV4dCA9IHt9O1xuICAgICAgICBmb3IgKGtleSBpbiBwYXJ0aWFsLnN1YnMpIHtcbiAgICAgICAgICBpZiAoIXBhcnRpYWxzLnN0YWNrVGV4dFtrZXldKSB7XG4gICAgICAgICAgICBwYXJ0aWFscy5zdGFja1RleHRba2V5XSA9ICh0aGlzLmFjdGl2ZVN1YiAhPT0gdW5kZWZpbmVkICYmIHBhcnRpYWxzLnN0YWNrVGV4dFt0aGlzLmFjdGl2ZVN1Yl0pID8gcGFydGlhbHMuc3RhY2tUZXh0W3RoaXMuYWN0aXZlU3ViXSA6IHRoaXMudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUgPSBjcmVhdGVTcGVjaWFsaXplZFBhcnRpYWwodGVtcGxhdGUsIHBhcnRpYWwuc3VicywgcGFydGlhbC5wYXJ0aWFscyxcbiAgICAgICAgICB0aGlzLnN0YWNrU3VicywgdGhpcy5zdGFja1BhcnRpYWxzLCBwYXJ0aWFscy5zdGFja1RleHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWFsc1tzeW1ib2xdLmluc3RhbmNlID0gdGVtcGxhdGU7XG5cbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgLy8gdHJpZXMgdG8gZmluZCBhIHBhcnRpYWwgaW4gdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHJlbmRlciBpdFxuICAgIHJwOiBmdW5jdGlvbihzeW1ib2wsIGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gdGhpcy5lcChzeW1ib2wsIHBhcnRpYWxzKTtcbiAgICAgIGlmICghcGFydGlhbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJ0aWFsLnJpKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpO1xuICAgIH0sXG5cbiAgICAvLyByZW5kZXIgYSBzZWN0aW9uXG4gICAgcnM6IGZ1bmN0aW9uKGNvbnRleHQsIHBhcnRpYWxzLCBzZWN0aW9uKSB7XG4gICAgICB2YXIgdGFpbCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCFpc0FycmF5KHRhaWwpKSB7XG4gICAgICAgIHNlY3Rpb24oY29udGV4dCwgcGFydGlhbHMsIHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb250ZXh0LnB1c2godGFpbFtpXSk7XG4gICAgICAgIHNlY3Rpb24oY29udGV4dCwgcGFydGlhbHMsIHRoaXMpO1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBtYXliZSBzdGFydCBhIHNlY3Rpb25cbiAgICBzOiBmdW5jdGlvbih2YWwsIGN0eCwgcGFydGlhbHMsIGludmVydGVkLCBzdGFydCwgZW5kLCB0YWdzKSB7XG4gICAgICB2YXIgcGFzcztcblxuICAgICAgaWYgKGlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSB0aGlzLm1zKHZhbCwgY3R4LCBwYXJ0aWFscywgaW52ZXJ0ZWQsIHN0YXJ0LCBlbmQsIHRhZ3MpO1xuICAgICAgfVxuXG4gICAgICBwYXNzID0gISF2YWw7XG5cbiAgICAgIGlmICghaW52ZXJ0ZWQgJiYgcGFzcyAmJiBjdHgpIHtcbiAgICAgICAgY3R4LnB1c2goKHR5cGVvZiB2YWwgPT0gJ29iamVjdCcpID8gdmFsIDogY3R4W2N0eC5sZW5ndGggLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXNzO1xuICAgIH0sXG5cbiAgICAvLyBmaW5kIHZhbHVlcyB3aXRoIGRvdHRlZCBuYW1lc1xuICAgIGQ6IGZ1bmN0aW9uKGtleSwgY3R4LCBwYXJ0aWFscywgcmV0dXJuRm91bmQpIHtcbiAgICAgIHZhciBmb3VuZCxcbiAgICAgICAgICBuYW1lcyA9IGtleS5zcGxpdCgnLicpLFxuICAgICAgICAgIHZhbCA9IHRoaXMuZihuYW1lc1swXSwgY3R4LCBwYXJ0aWFscywgcmV0dXJuRm91bmQpLFxuICAgICAgICAgIGRvTW9kZWxHZXQgPSB0aGlzLm9wdGlvbnMubW9kZWxHZXQsXG4gICAgICAgICAgY3ggPSBudWxsO1xuXG4gICAgICBpZiAoa2V5ID09PSAnLicgJiYgaXNBcnJheShjdHhbY3R4Lmxlbmd0aCAtIDJdKSkge1xuICAgICAgICB2YWwgPSBjdHhbY3R4Lmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvdW5kID0gZmluZEluU2NvcGUobmFtZXNbaV0sIHZhbCwgZG9Nb2RlbEdldCk7XG4gICAgICAgICAgaWYgKGZvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN4ID0gdmFsO1xuICAgICAgICAgICAgdmFsID0gZm91bmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRm91bmQgJiYgIXZhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmV0dXJuRm91bmQgJiYgdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN0eC5wdXNoKGN4KTtcbiAgICAgICAgdmFsID0gdGhpcy5tdih2YWwsIGN0eCwgcGFydGlhbHMpO1xuICAgICAgICBjdHgucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIGZpbmQgdmFsdWVzIHdpdGggbm9ybWFsIG5hbWVzXG4gICAgZjogZnVuY3Rpb24oa2V5LCBjdHgsIHBhcnRpYWxzLCByZXR1cm5Gb3VuZCkge1xuICAgICAgdmFyIHZhbCA9IGZhbHNlLFxuICAgICAgICAgIHYgPSBudWxsLFxuICAgICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgICAgZG9Nb2RlbEdldCA9IHRoaXMub3B0aW9ucy5tb2RlbEdldDtcblxuICAgICAgZm9yICh2YXIgaSA9IGN0eC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2ID0gY3R4W2ldO1xuICAgICAgICB2YWwgPSBmaW5kSW5TY29wZShrZXksIHYsIGRvTW9kZWxHZXQpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICByZXR1cm4gKHJldHVybkZvdW5kKSA/IGZhbHNlIDogXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXR1cm5Gb3VuZCAmJiB0eXBlb2YgdmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gdGhpcy5tdih2YWwsIGN0eCwgcGFydGlhbHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICAvLyBoaWdoZXIgb3JkZXIgdGVtcGxhdGVzXG4gICAgbHM6IGZ1bmN0aW9uKGZ1bmMsIGN4LCBwYXJ0aWFscywgdGV4dCwgdGFncykge1xuICAgICAgdmFyIG9sZFRhZ3MgPSB0aGlzLm9wdGlvbnMuZGVsaW1pdGVycztcblxuICAgICAgdGhpcy5vcHRpb25zLmRlbGltaXRlcnMgPSB0YWdzO1xuICAgICAgdGhpcy5iKHRoaXMuY3QoY29lcmNlVG9TdHJpbmcoZnVuYy5jYWxsKGN4LCB0ZXh0KSksIGN4LCBwYXJ0aWFscykpO1xuICAgICAgdGhpcy5vcHRpb25zLmRlbGltaXRlcnMgPSBvbGRUYWdzO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIGNvbXBpbGUgdGV4dFxuICAgIGN0OiBmdW5jdGlvbih0ZXh0LCBjeCwgcGFydGlhbHMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUxhbWJkYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhbWJkYSBmZWF0dXJlcyBkaXNhYmxlZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmMuY29tcGlsZSh0ZXh0LCB0aGlzLm9wdGlvbnMpLnJlbmRlcihjeCwgcGFydGlhbHMpO1xuICAgIH0sXG5cbiAgICAvLyB0ZW1wbGF0ZSByZXN1bHQgYnVmZmVyaW5nXG4gICAgYjogZnVuY3Rpb24ocykgeyB0aGlzLmJ1ZiArPSBzOyB9LFxuXG4gICAgZmw6IGZ1bmN0aW9uKCkgeyB2YXIgciA9IHRoaXMuYnVmOyB0aGlzLmJ1ZiA9ICcnOyByZXR1cm4gcjsgfSxcblxuICAgIC8vIG1ldGhvZCByZXBsYWNlIHNlY3Rpb25cbiAgICBtczogZnVuY3Rpb24oZnVuYywgY3R4LCBwYXJ0aWFscywgaW52ZXJ0ZWQsIHN0YXJ0LCBlbmQsIHRhZ3MpIHtcbiAgICAgIHZhciB0ZXh0U291cmNlLFxuICAgICAgICAgIGN4ID0gY3R4W2N0eC5sZW5ndGggLSAxXSxcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmNhbGwoY3gpO1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChpbnZlcnRlZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRTb3VyY2UgPSAodGhpcy5hY3RpdmVTdWIgJiYgdGhpcy5zdWJzVGV4dCAmJiB0aGlzLnN1YnNUZXh0W3RoaXMuYWN0aXZlU3ViXSkgPyB0aGlzLnN1YnNUZXh0W3RoaXMuYWN0aXZlU3ViXSA6IHRoaXMudGV4dDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5scyhyZXN1bHQsIGN4LCBwYXJ0aWFscywgdGV4dFNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCksIHRhZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8vIG1ldGhvZCByZXBsYWNlIHZhcmlhYmxlXG4gICAgbXY6IGZ1bmN0aW9uKGZ1bmMsIGN0eCwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBjeCA9IGN0eFtjdHgubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5jYWxsKGN4KTtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdChjb2VyY2VUb1N0cmluZyhyZXN1bHQuY2FsbChjeCkpLCBjeCwgcGFydGlhbHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzdWI6IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBmID0gdGhpcy5zdWJzW25hbWVdO1xuICAgICAgaWYgKGYpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVTdWIgPSBuYW1lO1xuICAgICAgICBmKGNvbnRleHQsIHBhcnRpYWxzLCB0aGlzLCBpbmRlbnQpO1xuICAgICAgICB0aGlzLmFjdGl2ZVN1YiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8vRmluZCBhIGtleSBpbiBhbiBvYmplY3RcbiAgZnVuY3Rpb24gZmluZEluU2NvcGUoa2V5LCBzY29wZSwgZG9Nb2RlbEdldCkge1xuICAgIHZhciB2YWw7XG5cbiAgICBpZiAoc2NvcGUgJiYgdHlwZW9mIHNjb3BlID09ICdvYmplY3QnKSB7XG5cbiAgICAgIGlmIChzY29wZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsID0gc2NvcGVba2V5XTtcblxuICAgICAgLy8gdHJ5IGxvb2t1cCB3aXRoIGdldCBmb3IgYmFja2JvbmUgb3Igc2ltaWxhciBtb2RlbCBkYXRhXG4gICAgICB9IGVsc2UgaWYgKGRvTW9kZWxHZXQgJiYgc2NvcGUuZ2V0ICYmIHR5cGVvZiBzY29wZS5nZXQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSBzY29wZS5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3BlY2lhbGl6ZWRQYXJ0aWFsKGluc3RhbmNlLCBzdWJzLCBwYXJ0aWFscywgc3RhY2tTdWJzLCBzdGFja1BhcnRpYWxzLCBzdGFja1RleHQpIHtcbiAgICBmdW5jdGlvbiBQYXJ0aWFsVGVtcGxhdGUoKSB7fTtcbiAgICBQYXJ0aWFsVGVtcGxhdGUucHJvdG90eXBlID0gaW5zdGFuY2U7XG4gICAgZnVuY3Rpb24gU3Vic3RpdHV0aW9ucygpIHt9O1xuICAgIFN1YnN0aXR1dGlvbnMucHJvdG90eXBlID0gaW5zdGFuY2Uuc3VicztcbiAgICB2YXIga2V5O1xuICAgIHZhciBwYXJ0aWFsID0gbmV3IFBhcnRpYWxUZW1wbGF0ZSgpO1xuICAgIHBhcnRpYWwuc3VicyA9IG5ldyBTdWJzdGl0dXRpb25zKCk7XG4gICAgcGFydGlhbC5zdWJzVGV4dCA9IHt9OyAgLy9oZWhlLiBzdWJzdGV4dC5cbiAgICBwYXJ0aWFsLmJ1ZiA9ICcnO1xuXG4gICAgc3RhY2tTdWJzID0gc3RhY2tTdWJzIHx8IHt9O1xuICAgIHBhcnRpYWwuc3RhY2tTdWJzID0gc3RhY2tTdWJzO1xuICAgIHBhcnRpYWwuc3Vic1RleHQgPSBzdGFja1RleHQ7XG4gICAgZm9yIChrZXkgaW4gc3Vicykge1xuICAgICAgaWYgKCFzdGFja1N1YnNba2V5XSkgc3RhY2tTdWJzW2tleV0gPSBzdWJzW2tleV07XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHN0YWNrU3Vicykge1xuICAgICAgcGFydGlhbC5zdWJzW2tleV0gPSBzdGFja1N1YnNba2V5XTtcbiAgICB9XG5cbiAgICBzdGFja1BhcnRpYWxzID0gc3RhY2tQYXJ0aWFscyB8fCB7fTtcbiAgICBwYXJ0aWFsLnN0YWNrUGFydGlhbHMgPSBzdGFja1BhcnRpYWxzO1xuICAgIGZvciAoa2V5IGluIHBhcnRpYWxzKSB7XG4gICAgICBpZiAoIXN0YWNrUGFydGlhbHNba2V5XSkgc3RhY2tQYXJ0aWFsc1trZXldID0gcGFydGlhbHNba2V5XTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gc3RhY2tQYXJ0aWFscykge1xuICAgICAgcGFydGlhbC5wYXJ0aWFsc1trZXldID0gc3RhY2tQYXJ0aWFsc1trZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJ0aWFsO1xuICB9XG5cbiAgdmFyIHJBbXAgPSAvJi9nLFxuICAgICAgckx0ID0gLzwvZyxcbiAgICAgIHJHdCA9IC8+L2csXG4gICAgICByQXBvcyA9IC9cXCcvZyxcbiAgICAgIHJRdW90ID0gL1xcXCIvZyxcbiAgICAgIGhDaGFycyA9IC9bJjw+XFxcIlxcJ10vO1xuXG4gIGZ1bmN0aW9uIGNvZXJjZVRvU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiBTdHJpbmcoKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgPyAnJyA6IHZhbCk7XG4gIH1cblxuICBmdW5jdGlvbiBob2dhbkVzY2FwZShzdHIpIHtcbiAgICBzdHIgPSBjb2VyY2VUb1N0cmluZyhzdHIpO1xuICAgIHJldHVybiBoQ2hhcnMudGVzdChzdHIpID9cbiAgICAgIHN0clxuICAgICAgICAucmVwbGFjZShyQW1wLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZShyTHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2Uockd0LCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKHJBcG9zLCAnJiMzOTsnKVxuICAgICAgICAucmVwbGFjZShyUXVvdCwgJyZxdW90OycpIDpcbiAgICAgIHN0cjtcbiAgfVxuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IEhvZ2FuKTtcbiIsImZ1bmN0aW9uIERpZmYoKSB7fVxuRGlmZi5wcm90b3R5cGUgPSB7XG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcblxuXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XG4gICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGVkaXRMZW5ndGggPSAxO1xuICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgIHZhciBiZXN0UGF0aCA9IFt7XG4gICAgICBuZXdQb3M6IC0xLFxuICAgICAgY29tcG9uZW50czogW11cbiAgICB9XTsgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcblxuICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcblxuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe1xuICAgICAgICB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksXG4gICAgICAgIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoXG4gICAgICB9XSk7XG4gICAgfSAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgdmFyIGJhc2VQYXRoID0gdm9pZCAwO1xuXG4gICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICBfb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuXG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBfb2xkUG9zICYmIF9vbGRQb3MgPCBvbGRMZW47XG5cbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXG4gICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG5cblxuICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcblxuICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX29sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7IC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIF9vbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH0gLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQuXG5cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB3ZSB3YW50IHRvIGJlIHNhZmUuXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHB1c2hDb21wb25lbnQ6IGZ1bmN0aW9uIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgY291bnQ6IGxhc3QuY291bnQgKyAxLFxuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcbiAgICAgICAgY29tbW9uQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgIG5ld1BvcysrO1xuICAgICAgb2xkUG9zKys7XG4gICAgICBjb21tb25Db3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgY291bnQ6IGNvbW1vbkNvdW50XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XG4gICAgcmV0dXJuIG9sZFBvcztcbiAgfSxcbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICByZW1vdmVFbXB0eTogZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGNhc3RJbnB1dDogZnVuY3Rpb24gY2FzdElucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0b2tlbml6ZTogZnVuY3Rpb24gdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gIHZhciBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICBuZXdQb3MgPSAwLFxuICAgICAgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG5cbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIH1cblxuICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gQ29tbW9uIGNhc2VcblxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cblxuICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XG4gICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cblxuXG4gIHZhciBsYXN0Q29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcblxuICBpZiAoY29tcG9uZW50TGVuID4gMSAmJiB0eXBlb2YgbGFzdENvbXBvbmVudC52YWx1ZSA9PT0gJ3N0cmluZycgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKSAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICByZXR1cm4ge1xuICAgIG5ld1BvczogcGF0aC5uZXdQb3MsXG4gICAgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApXG4gIH07XG59XG5cbnZhciBjaGFyYWN0ZXJEaWZmID0gbmV3IERpZmYoKTtcbmZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0cztcbn1cblxuLy9cbi8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcbi8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MOKAkzAwRkZcbi8vICAtIFUrMDBENyAgw5cgTXVsdGlwbGljYXRpb24gc2lnblxuLy8gIC0gVSswMEY3ICDDtyBEaXZpc2lvbiBzaWduXG4vLyBMYXRpbiBFeHRlbmRlZC1BLCAwMTAw4oCTMDE3RlxuLy8gTGF0aW4gRXh0ZW5kZWQtQiwgMDE4MOKAkzAyNEZcbi8vIElQQSBFeHRlbnNpb25zLCAwMjUw4oCTMDJBRlxuLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzLCAwMkIw4oCTMDJGRlxuLy8gIC0gVSswMkM3ICDLhyAmIzcxMTsgIENhcm9uXG4vLyAgLSBVKzAyRDggIMuYICYjNzI4OyAgQnJldmVcbi8vICAtIFUrMDJEOSAgy5kgJiM3Mjk7ICBEb3QgQWJvdmVcbi8vICAtIFUrMDJEQSAgy5ogJiM3MzA7ICBSaW5nIEFib3ZlXG4vLyAgLSBVKzAyREIgIMubICYjNzMxOyAgT2dvbmVrXG4vLyAgLSBVKzAyREMgIMucICYjNzMyOyAgU21hbGwgVGlsZGVcbi8vICAtIFUrMDJERCAgy50gJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XG4vLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAw4oCTMUVGRlxuXG52YXIgZXh0ZW5kZWRXb3JkQ2hhcnMgPSAvXltBLVphLXpcXHhDMC1cXHUwMkM2XFx1MDJDOC1cXHUwMkQ3XFx1MDJERS1cXHUwMkZGXFx1MUUwMC1cXHUxRUZGXSskLztcbnZhciByZVdoaXRlc3BhY2UgPSAvXFxTLztcbnZhciB3b3JkRGlmZiA9IG5ldyBEaWZmKCk7XG5cbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcbiAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xuICAgIHJpZ2h0ID0gcmlnaHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KTtcbn07XG5cbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8vIEFsbCB3aGl0ZXNwYWNlIHN5bWJvbHMgZXhjZXB0IG5ld2xpbmUgZ3JvdXAgaW50byBvbmUgdG9rZW4sIGVhY2ggbmV3bGluZSAtIGluIHNlcGFyYXRlIHRva2VuXG4gIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFteXFxTXFxyXFxuXSt8WygpW1xcXXt9J1wiXFxyXFxuXXxcXGIpLyk7IC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcbiAgICBpZiAoIXRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAyXSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpXSkgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywge1xuICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5cbnZhciBsaW5lRGlmZiA9IG5ldyBEaWZmKCk7XG5cbmxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciByZXRMaW5lcyA9IFtdLFxuICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxufFxcclxcbikvKTsgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXG5cbiAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xuICB9IC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzQW5kTmV3bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XG5cbiAgICBpZiAoaSAlIDIgJiYgIXRoaXMub3B0aW9ucy5uZXdsaW5lSXNUb2tlbikge1xuICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0TGluZXM7XG59O1xuXG5mdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICB2YXIgb3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucyhjYWxsYmFjaywge1xuICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxudmFyIHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5cbnNlbnRlbmNlRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFMuKz9bLiE/XSkoPz1cXHMrfCQpLyk7XG59O1xuXG5mdW5jdGlvbiBkaWZmU2VudGVuY2VzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gc2VudGVuY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbn1cblxudmFyIGNzc0RpZmYgPSBuZXcgRGlmZigpO1xuXG5jc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbn07XG5cbmZ1bmN0aW9uIGRpZmZDc3Mob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGpzb25EaWZmID0gbmV3IERpZmYoKTsgLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcbi8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuXG5qc29uRGlmZi51c2VMb25nZXN0VG9rZW4gPSB0cnVlO1xuanNvbkRpZmYudG9rZW5pemUgPSBsaW5lRGlmZi50b2tlbml6ZTtcblxuanNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBfdGhpcyRvcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LFxuICAgICAgX3RoaXMkb3B0aW9ucyRzdHJpbmdpID0gX3RoaXMkb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcbiAgICAgIHN0cmluZ2lmeVJlcGxhY2VyID0gX3RoaXMkb3B0aW9ucyRzdHJpbmdpID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoaywgdikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHY7XG4gIH0gOiBfdGhpcyRvcHRpb25zJHN0cmluZ2k7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeShjYW5vbmljYWxpemUodmFsdWUsIG51bGwsIG51bGwsIHN0cmluZ2lmeVJlcGxhY2VyKSwgc3RyaW5naWZ5UmVwbGFjZXIsICcgICcpO1xufTtcblxuanNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBEaWZmLnByb3RvdHlwZS5lcXVhbHMuY2FsbChqc29uRGlmZiwgbGVmdC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSwgcmlnaHQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJykpO1xufTtcblxuZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cbi8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcblxuZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgaWYgKHJlcGxhY2VyKSB7XG4gICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xuICB9XG5cbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5vbmljYWxpemVkT2JqO1xuXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xuICAgIH1cblxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG4gIH1cblxuICBpZiAob2JqICYmIG9iai50b0pTT04pIHtcbiAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gIH1cblxuICBpZiAoX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXG4gICAgICAgIF9rZXk7XG5cbiAgICBmb3IgKF9rZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBzb3J0ZWRLZXlzLnB1c2goX2tleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ydGVkS2V5cy5zb3J0KCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICBjYW5vbmljYWxpemVkT2JqW19rZXldID0gY2Fub25pY2FsaXplKG9ialtfa2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBfa2V5KTtcbiAgICB9XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn1cblxudmFyIGFycmF5RGlmZiA9IG5ldyBEaWZmKCk7XG5cbmFycmF5RGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbn07XG5cbmFycmF5RGlmZi5qb2luID0gYXJyYXlEaWZmLnJlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGRpZmZBcnJheXMob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gdW5pRGlmZi5tYXRjaCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vZykgfHwgW10sXG4gICAgICBsaXN0ID0gW10sXG4gICAgICBpID0gMDtcblxuICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xuICAgIHZhciBpbmRleCA9IHt9O1xuICAgIGxpc3QucHVzaChpbmRleCk7IC8vIFBhcnNlIGRpZmYgbWV0YWRhdGFcblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIHZhciBsaW5lID0gZGlmZnN0cltpXTsgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcblxuICAgICAgaWYgKC9eKFxcLVxcLVxcLXxcXCtcXCtcXCt8QEApXFxzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBEaWZmIGluZGV4XG5cblxuICAgICAgdmFyIGhlYWRlciA9IC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFx3KykrKVxccysoLis/KVxccyokLy5leGVjKGxpbmUpO1xuXG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxuXG5cbiAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7IC8vIFBhcnNlIGh1bmtzXG5cbiAgICBpbmRleC5odW5rcyA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIF9saW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgaWYgKC9eKEluZGV4OnxkaWZmfFxcLVxcLVxcLXxcXCtcXCtcXCspXFxzLy50ZXN0KF9saW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChfbGluZSkpIHtcbiAgICAgICAgaW5kZXguaHVua3MucHVzaChwYXJzZUh1bmsoKSk7XG4gICAgICB9IGVsc2UgaWYgKF9saW5lICYmIG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsaW5lICcgKyAoaSArIDEpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoX2xpbmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUGFyc2VzIHRoZSAtLS0gYW5kICsrKyBoZWFkZXJzLCBpZiBub25lIGFyZSBmb3VuZCwgbm8gbGluZXNcbiAgLy8gYXJlIGNvbnN1bWVkLlxuXG5cbiAgZnVuY3Rpb24gcGFyc2VGaWxlSGVhZGVyKGluZGV4KSB7XG4gICAgdmFyIGZpbGVIZWFkZXIgPSAvXigtLS18XFwrXFwrXFwrKVxccysoLiopJC8uZXhlYyhkaWZmc3RyW2ldKTtcblxuICAgIGlmIChmaWxlSGVhZGVyKSB7XG4gICAgICB2YXIga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xuICAgICAgdmFyIGRhdGEgPSBmaWxlSGVhZGVyWzJdLnNwbGl0KCdcXHQnLCAyKTtcbiAgICAgIHZhciBmaWxlTmFtZSA9IGRhdGFbMF0ucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcblxuICAgICAgaWYgKC9eXCIuKlwiJC8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICB9XG5cbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSAvLyBQYXJzZXMgYSBodW5rXG4gIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBodW5rLlxuXG5cbiAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xuICAgIHZhciBjaHVua0hlYWRlckluZGV4ID0gaSxcbiAgICAgICAgY2h1bmtIZWFkZXJMaW5lID0gZGlmZnN0cltpKytdLFxuICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXGQrKSg/OiwoXFxkKykpPyBcXCsoXFxkKykoPzosKFxcZCspKT8gQEAvKTtcbiAgICB2YXIgaHVuayA9IHtcbiAgICAgIG9sZFN0YXJ0OiArY2h1bmtIZWFkZXJbMV0sXG4gICAgICBvbGRMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzJdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbMl0sXG4gICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxuICAgICAgbmV3TGluZXM6IHR5cGVvZiBjaHVua0hlYWRlcls0XSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogK2NodW5rSGVhZGVyWzRdLFxuICAgICAgbGluZXM6IFtdLFxuICAgICAgbGluZWRlbGltaXRlcnM6IFtdXG4gICAgfTsgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG5cbiAgICBpZiAoaHVuay5vbGRMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5vbGRTdGFydCArPSAxO1xuICAgIH1cblxuICAgIGlmIChodW5rLm5ld0xpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm5ld1N0YXJ0ICs9IDE7XG4gICAgfVxuXG4gICAgdmFyIGFkZENvdW50ID0gMCxcbiAgICAgICAgcmVtb3ZlQ291bnQgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXCJyZW1vdmUgbGluZVwiIG9wZXJhdGlvblxuICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxuICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwICYmIGkgKyAyIDwgZGlmZnN0ci5sZW5ndGggJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwICYmIGRpZmZzdHJbaSArIDJdLmluZGV4T2YoJ0BAJykgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcGVyYXRpb24gPSBkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gZGlmZnN0ci5sZW5ndGggLSAxID8gJyAnIDogZGlmZnN0cltpXVswXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGh1bmsubGluZXMucHVzaChkaWZmc3RyW2ldKTtcbiAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcbicpO1xuXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxuXG5cbiAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xuICAgIH1cblxuICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5vbGRMaW5lcyA9IDA7XG4gICAgfSAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xuXG5cbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIGlmIChhZGRDb3VudCAhPT0gaHVuay5uZXdMaW5lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZUNvdW50ICE9PSBodW5rLm9sZExpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1bms7XG4gIH1cblxuICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgcGFyc2VJbmRleCgpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIEl0ZXJhdG9yIHRoYXQgdHJhdmVyc2VzIGluIHRoZSByYW5nZSBvZiBbbWluLCBtYXhdLCBzdGVwcGluZ1xuLy8gYnkgZGlzdGFuY2UgZnJvbSBhIGdpdmVuIHN0YXJ0IHBvc2l0aW9uLiBJLmUuIGZvciBbMCwgNF0sIHdpdGhcbi8vIHN0YXJ0IG9mIDIsIHRoaXMgd2lsbCBpdGVyYXRlIDIsIDMsIDEsIDQsIDAuXG5mdW5jdGlvbiBkaXN0YW5jZUl0ZXJhdG9yIChzdGFydCwgbWluTGluZSwgbWF4TGluZSkge1xuICB2YXIgd2FudEZvcndhcmQgPSB0cnVlLFxuICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcbiAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcbiAgICAgIGxvY2FsT2Zmc2V0ID0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgIGlmICh3YW50Rm9yd2FyZCAmJiAhZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKGJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIGxvY2FsT2Zmc2V0Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YW50Rm9yd2FyZCA9IGZhbHNlO1xuICAgICAgfSAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJleW9uZCB0ZXh0IGxlbmd0aCwgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgLy8gYWZ0ZXIgb2Zmc2V0IGxvY2F0aW9uIChvciBkZXNpcmVkIGxvY2F0aW9uIG9uIGZpcnN0IGl0ZXJhdGlvbilcblxuXG4gICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cblxuXG4gICAgICBpZiAobWluTGluZSA8PSBzdGFydCAtIGxvY2FsT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAtbG9jYWxPZmZzZXQrKztcbiAgICAgIH1cblxuICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKCk7XG4gICAgfSAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHVuaURpZmYpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XG4gICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcbiAgICB9XG5cbiAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcbiAgfSAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcblxuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxuICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8IGZ1bmN0aW9uIChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudCkge1xuICAgIHJldHVybiBsaW5lID09PSBwYXRjaENvbnRlbnQ7XG4gIH0sXG4gICAgICBlcnJvckNvdW50ID0gMCxcbiAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcbiAgICAgIG1pbkxpbmUgPSAwLFxuICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgIHJlbW92ZUVPRk5MLFxuICAgICAgYWRkRU9GTkw7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGh1bmsgZXhhY3RseSBmaXRzIG9uIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbGluZSA9IGh1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcbiAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xuICAgICAgICAgIGVycm9yQ291bnQrKztcblxuICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIG1heExpbmUgPSBsaW5lcy5sZW5ndGggLSBodW5rLm9sZExpbmVzLFxuICAgICAgICBsb2NhbE9mZnNldCA9IDAsXG4gICAgICAgIHRvUG9zID0gb2Zmc2V0ICsgaHVuay5vbGRTdGFydCAtIDE7XG4gICAgdmFyIGl0ZXJhdG9yID0gZGlzdGFuY2VJdGVyYXRvcih0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG5cbiAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XG4gICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcbiAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxuICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XG5cblxuICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xuICB9IC8vIEFwcGx5IHBhdGNoIGh1bmtzXG5cblxuICB2YXIgZGlmZk9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGh1bmtzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfaHVuayA9IGh1bmtzW19pXSxcbiAgICAgICAgX3RvUG9zID0gX2h1bmsub2xkU3RhcnQgKyBfaHVuay5vZmZzZXQgKyBkaWZmT2Zmc2V0IC0gMTtcblxuICAgIGRpZmZPZmZzZXQgKz0gX2h1bmsubmV3TGluZXMgLSBfaHVuay5vbGRMaW5lcztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2h1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsaW5lID0gX2h1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lLFxuICAgICAgICAgIGRlbGltaXRlciA9IF9odW5rLmxpbmVkZWxpbWl0ZXJzW2pdO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgX3RvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAwLCBjb250ZW50KTtcbiAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAwLCBkZWxpbWl0ZXIpO1xuICAgICAgICBfdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzT3BlcmF0aW9uID0gX2h1bmsubGluZXNbaiAtIDFdID8gX2h1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcblxuICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuXG5cbiAgaWYgKHJlbW92ZUVPRk5MKSB7XG4gICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgbGluZXMucG9wKCk7XG4gICAgICBkZWxpbWl0ZXJzLnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgIGxpbmVzLnB1c2goJycpO1xuICAgIGRlbGltaXRlcnMucHVzaCgnXFxuJyk7XG4gIH1cblxuICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xuICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJycpO1xufSAvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXG5cbmZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50SW5kZXggPSAwO1xuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbmRleCgpIHtcbiAgICB2YXIgaW5kZXggPSB1bmlEaWZmW2N1cnJlbnRJbmRleCsrXTtcblxuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZENvbnRlbnQgPSBhcHBseVBhdGNoKGRhdGEsIGluZGV4LCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMucGF0Y2hlZChpbmRleCwgdXBkYXRlZENvbnRlbnQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvY2Vzc0luZGV4KCk7XG59XG5cbmZ1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xuICB9XG5cbiAgdmFyIGRpZmYgPSBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICBkaWZmLnB1c2goe1xuICAgIHZhbHVlOiAnJyxcbiAgICBsaW5lczogW11cbiAgfSk7IC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXG5cbiAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiAnICcgKyBlbnRyeTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBodW5rcyA9IFtdO1xuICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsXG4gICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcbiAgICAgIGN1clJhbmdlID0gW10sXG4gICAgICBvbGRMaW5lID0gMSxcbiAgICAgIG5ld0xpbmUgPSAxO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXG4gICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcblxuICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgdmFyIF9jdXJSYW5nZTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcbiAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICB2YXIgcHJldiA9IGRpZmZbaSAtIDFdO1xuICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcblxuXG4gICAgICAoX2N1clJhbmdlID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlLCBfdG9Db25zdW1hYmxlQXJyYXkobGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICB9KSkpOyAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXG5cblxuICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xuICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICB2YXIgX2N1clJhbmdlMjtcblxuICAgICAgICAgIC8vIE92ZXJsYXBwaW5nXG4gICAgICAgICAgKF9jdXJSYW5nZTIgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UyLCBfdG9Db25zdW1hYmxlQXJyYXkoY29udGV4dExpbmVzKGxpbmVzKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY3VyUmFuZ2UzO1xuXG4gICAgICAgICAgLy8gZW5kIHRoZSByYW5nZSBhbmQgb3V0cHV0XG4gICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBvcHRpb25zLmNvbnRleHQpO1xuXG4gICAgICAgICAgKF9jdXJSYW5nZTMgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UzLCBfdG9Db25zdW1hYmxlQXJyYXkoY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpKTtcblxuICAgICAgICAgIHZhciBodW5rID0ge1xuICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXG4gICAgICAgICAgICBvbGRMaW5lczogb2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICBsaW5lczogY3VyUmFuZ2VcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXG4gICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG9sZFN0cik7XG4gICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG5ld1N0cik7XG4gICAgICAgICAgICB2YXIgbm9ObEJlZm9yZUFkZHMgPSBsaW5lcy5sZW5ndGggPT0gMCAmJiBjdXJSYW5nZS5sZW5ndGggPiBodW5rLm9sZExpbmVzO1xuXG4gICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgbm9ObEJlZm9yZUFkZHMgJiYgb2xkU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbGQgaGFzIG5vIGVvbCBhbmQgbm8gdHJhaWxpbmcgY29udGV4dDsgbm8tbmwgY2FuIGVuZCB1cCBiZWZvcmUgYWRkc1xuICAgICAgICAgICAgICAvLyBob3dldmVyLCBpZiB0aGUgb2xkIGZpbGUgaXMgZW1wdHksIGRvIG5vdCBvdXRwdXQgdGhlIG5vLW5sIGxpbmVcbiAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvbGRFT0ZOZXdsaW5lICYmICFub05sQmVmb3JlQWRkcyB8fCAhbmV3RU9GTmV3bGluZSkge1xuICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIGN1clJhbmdlID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSxcbiAgICBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsXG4gICAgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXG4gICAgaHVua3M6IGh1bmtzXG4gIH07XG59XG5mdW5jdGlvbiBmb3JtYXRQYXRjaChkaWZmKSB7XG4gIHZhciByZXQgPSBbXTtcblxuICBpZiAoZGlmZi5vbGRGaWxlTmFtZSA9PSBkaWZmLm5ld0ZpbGVOYW1lKSB7XG4gICAgcmV0LnB1c2goJ0luZGV4OiAnICsgZGlmZi5vbGRGaWxlTmFtZSk7XG4gIH1cblxuICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGh1bmsgPSBkaWZmLmh1bmtzW2ldOyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgIC8vIHRoZSBmaXJzdCBudW1iZXIgaXMgb25lIGxvd2VyIHRoYW4gb25lIHdvdWxkIGV4cGVjdC5cbiAgICAvLyBodHRwczovL3d3dy5hcnRpbWEuY29tL3dlYmxvZ3Mvdmlld3Bvc3QuanNwP3RocmVhZD0xNjQyOTNcblxuICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm9sZFN0YXJ0IC09IDE7XG4gICAgfVxuXG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgLT0gMTtcbiAgICB9XG5cbiAgICByZXQucHVzaCgnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lcyArICcgKycgKyBodW5rLm5ld1N0YXJ0ICsgJywnICsgaHVuay5uZXdMaW5lcyArICcgQEAnKTtcbiAgICByZXQucHVzaC5hcHBseShyZXQsIGh1bmsubGluZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UGF0Y2goc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYXJyYXlTdGFydHNXaXRoKGEsIGIpO1xufVxuZnVuY3Rpb24gYXJyYXlTdGFydHNXaXRoKGFycmF5LCBzdGFydCkge1xuICBpZiAoc3RhcnQubGVuZ3RoID4gYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGFydFtpXSAhPT0gYXJyYXlbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FsY0xpbmVDb3VudChodW5rKSB7XG4gIHZhciBfY2FsY09sZE5ld0xpbmVDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQoaHVuay5saW5lcyksXG4gICAgICBvbGRMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm9sZExpbmVzLFxuICAgICAgbmV3TGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5uZXdMaW5lcztcblxuICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsub2xkTGluZXMgPSBvbGRMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5vbGRMaW5lcztcbiAgfVxuXG4gIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaHVuay5uZXdMaW5lcyA9IG5ld0xpbmVzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBodW5rLm5ld0xpbmVzO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZShtaW5lLCB0aGVpcnMsIGJhc2UpIHtcbiAgbWluZSA9IGxvYWRQYXRjaChtaW5lLCBiYXNlKTtcbiAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XG4gIHZhciByZXQgPSB7fTsgLy8gRm9yIGluZGV4IHdlIGp1c3QgbGV0IGl0IHBhc3MgdGhyb3VnaCBhcyBpdCBkb2Vzbid0IGhhdmUgYW55IG5lY2Vzc2FyeSBtZWFuaW5nLlxuICAvLyBMZWF2aW5nIHNhbml0eSBjaGVja3Mgb24gdGhpcyB0byB0aGUgQVBJIGNvbnN1bWVyIHRoYXQgbWF5IGtub3cgbW9yZSBhYm91dCB0aGVcbiAgLy8gbWVhbmluZyBpbiB0aGVpciBvd24gY29udGV4dC5cblxuICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcbiAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcbiAgfVxuXG4gIGlmIChtaW5lLm5ld0ZpbGVOYW1lIHx8IHRoZWlycy5uZXdGaWxlTmFtZSkge1xuICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHRoZWlycy5vbGRGaWxlTmFtZSB8fCBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSB0aGVpcnMubmV3SGVhZGVyIHx8IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEZpbGVOYW1lLCB0aGVpcnMub2xkRmlsZU5hbWUpO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdIZWFkZXIsIHRoZWlycy5uZXdIZWFkZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldC5odW5rcyA9IFtdO1xuICB2YXIgbWluZUluZGV4ID0gMCxcbiAgICAgIHRoZWlyc0luZGV4ID0gMCxcbiAgICAgIG1pbmVPZmZzZXQgPSAwLFxuICAgICAgdGhlaXJzT2Zmc2V0ID0gMDtcblxuICB3aGlsZSAobWluZUluZGV4IDwgbWluZS5odW5rcy5sZW5ndGggfHwgdGhlaXJzSW5kZXggPCB0aGVpcnMuaHVua3MubGVuZ3RoKSB7XG4gICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5odW5rc1ttaW5lSW5kZXhdIHx8IHtcbiAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgIH0sXG4gICAgICAgIHRoZWlyc0N1cnJlbnQgPSB0aGVpcnMuaHVua3NbdGhlaXJzSW5kZXhdIHx8IHtcbiAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgIH07XG5cbiAgICBpZiAoaHVua0JlZm9yZShtaW5lQ3VycmVudCwgdGhlaXJzQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcbiAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgdGhlaXJzT2Zmc2V0ICs9IG1pbmVDdXJyZW50Lm5ld0xpbmVzIC0gbWluZUN1cnJlbnQub2xkTGluZXM7XG4gICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xuICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cbiAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayh0aGVpcnNDdXJyZW50LCB0aGVpcnNPZmZzZXQpKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lT2Zmc2V0ICs9IHRoZWlyc0N1cnJlbnQubmV3TGluZXMgLSB0aGVpcnNDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxuICAgICAgdmFyIG1lcmdlZEh1bmsgPSB7XG4gICAgICAgIG9sZFN0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCksXG4gICAgICAgIG9sZExpbmVzOiAwLFxuICAgICAgICBuZXdTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQubmV3U3RhcnQgKyBtaW5lT2Zmc2V0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0ICsgdGhlaXJzT2Zmc2V0KSxcbiAgICAgICAgbmV3TGluZXM6IDAsXG4gICAgICAgIGxpbmVzOiBbXVxuICAgICAgfTtcbiAgICAgIG1lcmdlTGluZXMobWVyZ2VkSHVuaywgbWluZUN1cnJlbnQub2xkU3RhcnQsIG1pbmVDdXJyZW50LmxpbmVzLCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50LmxpbmVzKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRQYXRjaChwYXJhbSwgYmFzZSkge1xuICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIGlmICgvXkBAL20udGVzdChwYXJhbSkgfHwgL15JbmRleDovbS50ZXN0KHBhcmFtKSkge1xuICAgICAgcmV0dXJuIHBhcnNlUGF0Y2gocGFyYW0pWzBdO1xuICAgIH1cblxuICAgIGlmICghYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBiYXNlIHJlZmVyZW5jZSBvciBwYXNzIGluIGEgcGF0Y2gnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RydWN0dXJlZFBhdGNoKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW07XG59XG5cbmZ1bmN0aW9uIGZpbGVOYW1lQ2hhbmdlZChwYXRjaCkge1xuICByZXR1cm4gcGF0Y2gubmV3RmlsZU5hbWUgJiYgcGF0Y2gubmV3RmlsZU5hbWUgIT09IHBhdGNoLm9sZEZpbGVOYW1lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RGaWVsZChpbmRleCwgbWluZSwgdGhlaXJzKSB7XG4gIGlmIChtaW5lID09PSB0aGVpcnMpIHtcbiAgICByZXR1cm4gbWluZTtcbiAgfSBlbHNlIHtcbiAgICBpbmRleC5jb25mbGljdCA9IHRydWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbmU6IG1pbmUsXG4gICAgICB0aGVpcnM6IHRoZWlyc1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xuICByZXR1cm4gdGVzdC5vbGRTdGFydCA8IGNoZWNrLm9sZFN0YXJ0ICYmIHRlc3Qub2xkU3RhcnQgKyB0ZXN0Lm9sZExpbmVzIDwgY2hlY2sub2xkU3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcbiAgICBuZXdTdGFydDogaHVuay5uZXdTdGFydCArIG9mZnNldCxcbiAgICBuZXdMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICBsaW5lczogaHVuay5saW5lc1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcbiAgLy8gVGhpcyB3aWxsIGdlbmVyYWxseSByZXN1bHQgaW4gYSBjb25mbGljdGVkIGh1bmssIGJ1dCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIGNvbnRleHRcbiAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXG4gIHZhciBtaW5lID0ge1xuICAgIG9mZnNldDogbWluZU9mZnNldCxcbiAgICBsaW5lczogbWluZUxpbmVzLFxuICAgIGluZGV4OiAwXG4gIH0sXG4gICAgICB0aGVpciA9IHtcbiAgICBvZmZzZXQ6IHRoZWlyT2Zmc2V0LFxuICAgIGxpbmVzOiB0aGVpckxpbmVzLFxuICAgIGluZGV4OiAwXG4gIH07IC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG5cbiAgaW5zZXJ0TGVhZGluZyhodW5rLCBtaW5lLCB0aGVpcik7XG4gIGluc2VydExlYWRpbmcoaHVuaywgdGhlaXIsIG1pbmUpOyAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXG5cbiAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUubGluZXNbbWluZS5pbmRleF0sXG4gICAgICAgIHRoZWlyQ3VycmVudCA9IHRoZWlyLmxpbmVzW3RoZWlyLmluZGV4XTtcblxuICAgIGlmICgobWluZUN1cnJlbnRbMF0gPT09ICctJyB8fCBtaW5lQ3VycmVudFswXSA9PT0gJysnKSAmJiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgfHwgdGhlaXJDdXJyZW50WzBdID09PSAnKycpKSB7XG4gICAgICAvLyBCb3RoIG1vZGlmaWVkIC4uLlxuICAgICAgbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnKycgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lcztcblxuICAgICAgLy8gTWluZSBpbnNlcnRlZFxuICAgICAgKF9odW5rJGxpbmVzID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lcywgX3RvQ29uc3VtYWJsZUFycmF5KGNvbGxlY3RDaGFuZ2UobWluZSkpKTtcbiAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lczI7XG5cbiAgICAgIC8vIFRoZWlycyBpbnNlcnRlZFxuICAgICAgKF9odW5rJGxpbmVzMiA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMyLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sbGVjdENoYW5nZSh0aGVpcikpKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgdGhlaXIsIG1pbmUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xuICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgaHVuay5saW5lcy5wdXNoKG1pbmVDdXJyZW50KTtcbiAgICAgIG1pbmUuaW5kZXgrKztcbiAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcbiAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9XG4gIH0gLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXG5cblxuICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcbiAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgdGhlaXIpO1xuICBjYWxjTGluZUNvdW50KGh1bmspO1xufVxuXG5mdW5jdGlvbiBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXG4gICAgaWYgKGFycmF5U3RhcnRzV2l0aChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzMztcblxuICAgICAgKF9odW5rJGxpbmVzMyA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMzLCBfdG9Db25zdW1hYmxlQXJyYXkobXlDaGFuZ2VzKSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFycmF5U3RhcnRzV2l0aCh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICB2YXIgX2h1bmskbGluZXM0O1xuXG4gICAgICAoX2h1bmskbGluZXM0ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczQsIF90b0NvbnN1bWFibGVBcnJheSh0aGVpckNoYW5nZXMpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcnJheUVxdWFsKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xuICAgIHZhciBfaHVuayRsaW5lczU7XG5cbiAgICAoX2h1bmskbGluZXM1ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczUsIF90b0NvbnN1bWFibGVBcnJheShteUNoYW5nZXMpKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbmZsaWN0KGh1bmssIG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpciwgc3dhcCkge1xuICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcbiAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDb250ZXh0KHRoZWlyLCBteUNoYW5nZXMpO1xuXG4gIGlmICh0aGVpckNoYW5nZXMubWVyZ2VkKSB7XG4gICAgdmFyIF9odW5rJGxpbmVzNjtcblxuICAgIChfaHVuayRsaW5lczYgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzNiwgX3RvQ29uc3VtYWJsZUFycmF5KHRoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25mbGljdChodW5rLCBzd2FwID8gdGhlaXJDaGFuZ2VzIDogbXlDaGFuZ2VzLCBzd2FwID8gbXlDaGFuZ2VzIDogdGhlaXJDaGFuZ2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xuICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgaHVuay5saW5lcy5wdXNoKHtcbiAgICBjb25mbGljdDogdHJ1ZSxcbiAgICBtaW5lOiBtaW5lLFxuICAgIHRoZWlyczogdGhlaXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xuICB3aGlsZSAoaW5zZXJ0Lm9mZnNldCA8IHRoZWlyLm9mZnNldCAmJiBpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgICBpbnNlcnQub2Zmc2V0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VHJhaWxpbmcoaHVuaywgaW5zZXJ0KSB7XG4gIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0Q2hhbmdlKHN0YXRlKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIG9wZXJhdGlvbiA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XVswXTtcblxuICB3aGlsZSAoc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTsgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gJy0nICYmIGxpbmVbMF0gPT09ICcrJykge1xuICAgICAgb3BlcmF0aW9uID0gJysnO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb24gPT09IGxpbmVbMF0pIHtcbiAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdENvbnRleHQoc3RhdGUsIG1hdGNoQ2hhbmdlcykge1xuICB2YXIgY2hhbmdlcyA9IFtdLFxuICAgICAgbWVyZ2VkID0gW10sXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGNvbnRleHRDaGFuZ2VzID0gZmFsc2UsXG4gICAgICBjb25mbGljdGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGNoYW5nZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XSxcbiAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07IC8vIE9uY2Ugd2UndmUgaGl0IG91ciBhZGQsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgIGlmIChtYXRjaFswXSA9PT0gJysnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb250ZXh0Q2hhbmdlcyA9IGNvbnRleHRDaGFuZ2VzIHx8IGNoYW5nZVswXSAhPT0gJyAnO1xuICAgIG1lcmdlZC5wdXNoKG1hdGNoKTtcbiAgICBtYXRjaEluZGV4Kys7IC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XG4gICAgLy8gdG8gcHVsbCBpbiB0aGUgcmVtYWluaW5nIGNvbnRleHQgYWZ0ZXIgdGhpc1xuXG4gICAgaWYgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnICYmIGNvbnRleHRDaGFuZ2VzKSB7XG4gICAgY29uZmxpY3RlZCA9IHRydWU7XG4gIH1cblxuICBpZiAoY29uZmxpY3RlZCkge1xuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG5cbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoKSB7XG4gICAgbWVyZ2VkLnB1c2gobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXgrK10pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXJnZWQ6IG1lcmdlZCxcbiAgICBjaGFuZ2VzOiBjaGFuZ2VzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xuICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGNoYW5nZSkge1xuICAgIHJldHVybiBwcmV2ICYmIGNoYW5nZVswXSA9PT0gJy0nO1xuICB9LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2tpcFJlbW92ZVN1cGVyc2V0KHN0YXRlLCByZW1vdmVDaGFuZ2VzLCBkZWx0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICB2YXIgY2hhbmdlQ29udGVudCA9IHJlbW92ZUNoYW5nZXNbcmVtb3ZlQ2hhbmdlcy5sZW5ndGggLSBkZWx0YSArIGldLnN1YnN0cigxKTtcblxuICAgIGlmIChzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleCArIGldICE9PSAnICcgKyBjaGFuZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gIHZhciBvbGRMaW5lcyA9IDA7XG4gIHZhciBuZXdMaW5lcyA9IDA7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbXlDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS5taW5lKTtcbiAgICAgIHZhciB0aGVpckNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLnRoZWlycyk7XG5cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChteUNvdW50Lm9sZExpbmVzID09PSB0aGVpckNvdW50Lm9sZExpbmVzKSB7XG4gICAgICAgICAgb2xkTGluZXMgKz0gbXlDb3VudC5vbGRMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRMaW5lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xuICAgICAgICAgIG5ld0xpbmVzICs9IG15Q291bnQubmV3TGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICcrJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG5ld0xpbmVzKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnLScgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBvbGRMaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb2xkTGluZXM6IG9sZExpbmVzLFxuICAgIG5ld0xpbmVzOiBuZXdMaW5lc1xuICB9O1xufVxuXG4vLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIGNoYW5nZSxcbiAgICAgIG9wZXJhdGlvbjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgb3BlcmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICB9XG5cbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgdmFyIG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICByZXR1cm4gbjtcbn1cblxuZXhwb3J0IHsgRGlmZiwgYXBwbHlQYXRjaCwgYXBwbHlQYXRjaGVzLCBjYW5vbmljYWxpemUsIGNvbnZlcnRDaGFuZ2VzVG9ETVAsIGNvbnZlcnRDaGFuZ2VzVG9YTUwsIGNyZWF0ZVBhdGNoLCBjcmVhdGVUd29GaWxlc1BhdGNoLCBkaWZmQXJyYXlzLCBkaWZmQ2hhcnMsIGRpZmZDc3MsIGRpZmZKc29uLCBkaWZmTGluZXMsIGRpZmZTZW50ZW5jZXMsIGRpZmZUcmltbWVkTGluZXMsIGRpZmZXb3JkcywgZGlmZldvcmRzV2l0aFNwYWNlLCBtZXJnZSwgcGFyc2VQYXRjaCwgc3RydWN0dXJlZFBhdGNoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=