(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_datatables_net-datetime_dist_dataTables_dateTime_js-node_modules_datatab-a22e1b"],{

/***/ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js":
/*!*********************************************************************!*\
  !*** ./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables Bootstrap 5 integration
 * 2020 SpryMedia Ltd - datatables.net/license
 */

/**
 * DataTables integration for Bootstrap 4. This requires Bootstrap 5 and
 * DataTables 1.10 or newer.
 *
 * This file sets the defaults and adds options to DataTables to style its
 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
 * for further information.
 */
(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/* Set the defaults for DataTables initialisation */
$.extend( true, DataTable.defaults, {
	dom:
		"<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>" +
		"<'row'<'col-sm-12'tr>>" +
		"<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>",
	renderer: 'bootstrap'
} );


/* Default class modification */
$.extend( DataTable.ext.classes, {
	sWrapper:      "dataTables_wrapper dt-bootstrap5",
	sFilterInput:  "form-control form-control-sm",
	sLengthSelect: "form-select form-select-sm",
	sProcessing:   "dataTables_processing card",
	sPageButton:   "paginate_button page-item"
} );


/* Bootstrap paging button renderer */
DataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {
	var api     = new DataTable.Api( settings );
	var classes = settings.oClasses;
	var lang    = settings.oLanguage.oPaginate;
	var aria = settings.oLanguage.oAria.paginate || {};
	var btnDisplay, btnClass, counter=0;

	var attach = function( container, buttons ) {
		var i, ien, node, button;
		var clickHandler = function ( e ) {
			e.preventDefault();
			if ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {
				api.page( e.data.action ).draw( 'page' );
			}
		};

		for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
			button = buttons[i];

			if ( Array.isArray( button ) ) {
				attach( container, button );
			}
			else {
				btnDisplay = '';
				btnClass = '';

				switch ( button ) {
					case 'ellipsis':
						btnDisplay = '&#x2026;';
						btnClass = 'disabled';
						break;

					case 'first':
						btnDisplay = lang.sFirst;
						btnClass = button + (page > 0 ?
							'' : ' disabled');
						break;

					case 'previous':
						btnDisplay = lang.sPrevious;
						btnClass = button + (page > 0 ?
							'' : ' disabled');
						break;

					case 'next':
						btnDisplay = lang.sNext;
						btnClass = button + (page < pages-1 ?
							'' : ' disabled');
						break;

					case 'last':
						btnDisplay = lang.sLast;
						btnClass = button + (page < pages-1 ?
							'' : ' disabled');
						break;

					default:
						btnDisplay = button + 1;
						btnClass = page === button ?
							'active' : '';
						break;
				}

				if ( btnDisplay ) {
					node = $('<li>', {
							'class': classes.sPageButton+' '+btnClass,
							'id': idx === 0 && typeof button === 'string' ?
								settings.sTableId +'_'+ button :
								null
						} )
						.append( $('<a>', {
								'href': '#',
								'aria-controls': settings.sTableId,
								'aria-label': aria[ button ],
								'data-dt-idx': counter,
								'tabindex': settings.iTabIndex,
								'class': 'page-link'
							} )
							.html( btnDisplay )
						)
						.appendTo( container );

					settings.oApi._fnBindAction(
						node, {action: button}, clickHandler
					);

					counter++;
				}
			}
		}
	};

	// IE9 throws an 'unknown error' if document.activeElement is used
	// inside an iframe or frame. 
	var activeEl;

	try {
		// Because this approach is destroying and recreating the paging
		// elements, focus is lost on the select button which is bad for
		// accessibility. So we want to restore focus once the draw has
		// completed
		activeEl = $(host).find(document.activeElement).data('dt-idx');
	}
	catch (e) {}

	attach(
		$(host).empty().html('<ul class="pagination"/>').children('ul'),
		buttons
	);

	if ( activeEl !== undefined ) {
		$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
	}
};


return DataTable;
}));


/***/ }),

/***/ "./node_modules/datatables.net-datetime/dist/dataTables.dateTime.js":
/*!**************************************************************************!*\
  !*** ./node_modules/datatables.net-datetime/dist/dataTables.dateTime.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DateTime picker for DataTables.net v1.1.1
 *
 * Â© SpryMedia Ltd, all rights reserved.
 * License: MIT datatables.net/license/mit
 */

/**
 * @summary     DateTime picker for DataTables.net
 * @version     1.1.1
 * @file        dataTables.dateTime.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net/contact
 */
(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}(function( $, window, document, undefined ) {
'use strict';

// Supported formatting and parsing libraries:
// * Moment
// * Luxon
// * DayJS
var dateLib;

/*
 * This file provides a DateTime GUI picker (calendar and time input). Only the
 * format YYYY-MM-DD is supported without additional software, but the end user
 * experience can be greatly enhanced by including the momentjs, dayjs or luxon library
 * which provide date / time parsing and formatting options.
 *
 * This functionality is required because the HTML5 date and datetime input
 * types are not widely supported in desktop browsers.
 *
 * Constructed by using:
 *
 *     new DateTime( input, opts )
 *
 * where `input` is the HTML input element to use and `opts` is an object of
 * options based on the `DateTime.defaults` object.
 */
var DateTime = function ( input, opts ) {
	// Attempt to auto detect the formatting library (if there is one). Having it in
	// the constructor allows load order independence.
	if (typeof dateLib === 'undefined') {
		dateLib = window.moment
			? window.moment
			: window.dayjs
				? window.dayjs
				: window.luxon
					? window.luxon
					: null;
	}

	this.c = $.extend( true, {}, DateTime.defaults, opts );
	var classPrefix = this.c.classPrefix;
	var i18n = this.c.i18n;

	// Only IS8601 dates are supported without moment, dayjs or luxon
	if ( ! dateLib && this.c.format !== 'YYYY-MM-DD' ) {
		throw "DateTime: Without momentjs, dayjs or luxon only the format 'YYYY-MM-DD' can be used";
	}

	// Min and max need to be `Date` objects in the config
	if (typeof this.c.minDate === 'string') {
		this.c.minDate = new Date(this.c.minDate);
	}
	if (typeof this.c.maxDate === 'string') {
		this.c.maxDate = new Date(this.c.maxDate);
	}

	var timeBlock = function ( type ) {
		return '<div class="'+classPrefix+'-timeblock">'+
			'</div>';
	};

	var gap = function () {
		return '<span>:</span>';
	};

	// DOM structure
	var structure = $(
		'<div class="'+classPrefix+'">'+
			'<div class="'+classPrefix+'-date">'+
				'<div class="'+classPrefix+'-title">'+
					'<div class="'+classPrefix+'-iconLeft">'+
						'<button title="'+i18n.previous+'">'+i18n.previous+'</button>'+
					'</div>'+
					'<div class="'+classPrefix+'-iconRight">'+
						'<button title="'+i18n.next+'">'+i18n.next+'</button>'+
					'</div>'+
					'<div class="'+classPrefix+'-label">'+
						'<span></span>'+
						'<select class="'+classPrefix+'-month"></select>'+
					'</div>'+
					'<div class="'+classPrefix+'-label">'+
						'<span></span>'+
						'<select class="'+classPrefix+'-year"></select>'+
					'</div>'+
				'</div>'+
				'<div class="'+classPrefix+'-buttons">'+
					'<a class="'+classPrefix+'-clear">'+i18n.clear+'</a>'+
					'<a class="'+classPrefix+'-today">'+i18n.today+'</a>'+
				'</div>'+
				'<div class="'+classPrefix+'-calendar"></div>'+
			'</div>'+
			'<div class="'+classPrefix+'-time">'+
				'<div class="'+classPrefix+'-hours"></div>'+
				'<div class="'+classPrefix+'-minutes"></div>'+
				'<div class="'+classPrefix+'-seconds"></div>'+
			'</div>'+
			'<div class="'+classPrefix+'-error"></div>'+
		'</div>'
	);

	this.dom = {
		container: structure,
		date:      structure.find( '.'+classPrefix+'-date' ),
		title:     structure.find( '.'+classPrefix+'-title' ),
		calendar:  structure.find( '.'+classPrefix+'-calendar' ),
		time:      structure.find( '.'+classPrefix+'-time' ),
		error:     structure.find( '.'+classPrefix+'-error' ),
		buttons:     structure.find( '.'+classPrefix+'-buttons' ),
		clear:     structure.find( '.'+classPrefix+'-clear' ),
		today:     structure.find( '.'+classPrefix+'-today' ),
		input:     $(input)
	};

	this.s = {
		/** @type {Date} Date value that the picker has currently selected */
		d: null,

		/** @type {Date} Date of the calendar - might not match the value */
		display: null,

		/** @type {number} Used to select minutes in a range where the range base is itself unavailable */
		minutesRange: null,

		/** @type {number} Used to select minutes in a range where the range base is itself unavailable */
		secondsRange: null,

		/** @type {String} Unique namespace string for this instance */
		namespace: 'dateime-'+(DateTime._instance++),

		/** @type {Object} Parts of the picker that should be shown */
		parts: {
			date:    this.c.format.match( /[YMD]|L(?!T)|l/ ) !== null,
			time:    this.c.format.match( /[Hhm]|LT|LTS/ ) !== null,
			seconds: this.c.format.indexOf( 's' )   !== -1,
			hours12: this.c.format.match( /[haA]/ ) !== null
		}
	};

	this.dom.container
		.append( this.dom.date )
		.append( this.dom.time )
		.append( this.dom.error );

	this.dom.date
		.append( this.dom.title )
		.append( this.dom.buttons )
		.append( this.dom.calendar );

	this._constructor();
};

$.extend( DateTime.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public
	 */
	
	/**
	 * Destroy the control
	 */
	destroy: function () {
		this._hide(true);
		this.dom.container.off().empty();
		this.dom.input
			.removeAttr('autocomplete')
			.off('.datetime');
	},

	errorMsg: function ( msg ) {
		var error = this.dom.error;

		if ( msg ) {
			error.html( msg );
		}
		else {
			error.empty();
		}

		return this;
	},

	hide: function () {
		this._hide();

		return this;
	},

	max: function ( date ) {
		this.c.maxDate = typeof date === 'string'
			? new Date(date)
			: date;

		this._optionsTitle();
		this._setCalander();

		return this;
	},

	min: function ( date ) {
		this.c.minDate = typeof date === 'string'
			? new Date(date)
			: date;

		this._optionsTitle();
		this._setCalander();

		return this;
	},

	/**
	 * Check if an element belongs to this control
	 *
	 * @param  {node} node Element to check
	 * @return {boolean}   true if owned by this control, false otherwise
	 */
	owns: function ( node ) {
		return $(node).parents().filter( this.dom.container ).length > 0;
	},

	/**
	 * Get / set the value
	 *
	 * @param  {string|Date} set   Value to set
	 * @param  {boolean} [write=true] Flag to indicate if the formatted value
	 *   should be written into the input element
	 */
	val: function ( set, write ) {
		if ( set === undefined ) {
			return this.s.d;
		}

		if ( set instanceof Date ) {
			this.s.d = this._dateToUtc( set );
		}
		else if ( set === null || set === '' ) {
			this.s.d = null;
		}
		else if ( set === '--now' ) {
			this.s.d = new Date();
		}
		else if ( typeof set === 'string' ) {
			// luxon uses different method names so need to be able to call them
			if(dateLib && dateLib == window.luxon) {
				var luxDT = dateLib.DateTime.fromFormat(set, this.c.format)
				this.s.d = luxDT.isValid ? luxDT.toJSDate() : null;
			}
			else if ( dateLib ) {
				// Use moment, dayjs or luxon if possible (even for ISO8601 strings, since it
				// will correctly handle 0000-00-00 and the like)
				var m = dateLib.utc( set, this.c.format, this.c.locale, this.c.strict );
				this.s.d = m.isValid() ? m.toDate() : null;
			}
			else {
				// Else must be using ISO8601 without a date library (constructor would
				// have thrown an error otherwise)
				var match = set.match(/(\d{4})\-(\d{2})\-(\d{2})/ );
				this.s.d = match ?
					new Date( Date.UTC(match[1], match[2]-1, match[3]) ) :
					null;
			}
		}

		if ( write || write === undefined ) {
			if ( this.s.d ) {
				this._writeOutput();
			}
			else {
				// The input value was not valid...
				this.dom.input.val( set );
			}
		}

		// Need something to display
		this.s.display = this.s.d
			? new Date( this.s.d.toString() )
			: new Date();

		// Set the day of the month to be 1 so changing between months doesn't
        // run into issues when going from day 31 to 28 (for example)
		this.s.display.setUTCDate( 1 );

		// Update the display elements for the new value
		this._setTitle();
		this._setCalander();
		this._setTime();

		return this;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */
	
	/**
	 * Build the control and assign initial event handlers
	 *
	 * @private
	 */
	_constructor: function () {
		var that = this;
		var classPrefix = this.c.classPrefix;
		var last = this.dom.input.val();

		var onChange = function () {
			var curr = that.dom.input.val();

			if (curr !== last) {
				that.c.onChange.call( that, curr, that.s.d, that.dom.input );
				last = curr;
			}
		};

		if ( ! this.s.parts.date ) {
			this.dom.date.css( 'display', 'none' );
		}

		if ( ! this.s.parts.time ) {
			this.dom.time.css( 'display', 'none' );
		}

		if ( ! this.s.parts.seconds ) {
			this.dom.time.children('div.'+classPrefix+'-seconds').remove();
			this.dom.time.children('span').eq(1).remove();
		}

		if ( ! this.c.buttons.clear ) {
			this.dom.clear.css( 'display', 'none' );
		}

		if ( ! this.c.buttons.today ) {
			this.dom.today.css( 'display', 'none' );
		}

		// Render the options
		this._optionsTitle();

		$(document).on('i18n.dt', function (e, settings) {
			if (settings.oLanguage.datetime) {
				$.extend(true, that.c.i18n, settings.oLanguage.datetime);
				that._optionsTitle();
			}
		});

		// When attached to a hidden input, we always show the input picker, and
		// do so inline
		if (this.dom.input.attr('type') === 'hidden') {
			this.dom.container.addClass('inline');
			this.c.attachTo = 'input';

			this.val( this.dom.input.val(), false );
			this._show();
		}

		// Set the initial value
		if (last) {
			this.val( last, false );
		}

		// Trigger the display of the widget when clicking or focusing on the
		// input element
		this.dom.input
			.attr('autocomplete', 'off')
			.on('focus.datetime click.datetime', function () {
				// If already visible - don't do anything
				if ( that.dom.container.is(':visible') || that.dom.input.is(':disabled') ) {
					return;
				}

				// In case the value has changed by text
				that.val( that.dom.input.val(), false );

				that._show();
			} )
			.on('keyup.datetime', function () {
				// Update the calendar's displayed value as the user types
				if ( that.dom.container.is(':visible') ) {
					that.val( that.dom.input.val(), false );
				}
			} );

		// Main event handlers for input in the widget
		this.dom.container
			.on( 'change', 'select', function () {
				var select = $(this);
				var val = select.val();

				if ( select.hasClass(classPrefix+'-month') ) {
					// Month select
					that._correctMonth( that.s.display, val );
					that._setTitle();
					that._setCalander();
				}
				else if ( select.hasClass(classPrefix+'-year') ) {
					// Year select
					that.s.display.setUTCFullYear( val );
					that._setTitle();
					that._setCalander();
				}
				else if ( select.hasClass(classPrefix+'-hours') || select.hasClass(classPrefix+'-ampm') ) {
					// Hours - need to take account of AM/PM input if present
					if ( that.s.parts.hours12 ) {
						var hours = $(that.dom.container).find('.'+classPrefix+'-hours').val() * 1;
						var pm = $(that.dom.container).find('.'+classPrefix+'-ampm').val() === 'pm';

						that.s.d.setUTCHours( hours === 12 && !pm ?
							0 :
							pm && hours !== 12 ?
								hours + 12 :
								hours
						);
					}
					else {
						that.s.d.setUTCHours( val );
					}

					that._setTime();
					that._writeOutput( true );

					onChange();
				}
				else if ( select.hasClass(classPrefix+'-minutes') ) {
					// Minutes select
					that.s.d.setUTCMinutes( val );
					that._setTime();
					that._writeOutput( true );

					onChange();
				}
				else if ( select.hasClass(classPrefix+'-seconds') ) {
					// Seconds select
					that.s.d.setSeconds( val );
					that._setTime();
					that._writeOutput( true );

					onChange();
				}

				that.dom.input.focus();
				that._position();
			} )
			.on( 'click', function (e) {
				var d = that.s.d;
				var nodeName = e.target.nodeName.toLowerCase();
				var target = nodeName === 'span' ?
					e.target.parentNode :
					e.target;

				nodeName = target.nodeName.toLowerCase();

				if ( nodeName === 'select' ) {
					return;
				}

				e.stopPropagation();

				if ( nodeName === 'a' ) {
					e.preventDefault();

					if ($(target).hasClass(classPrefix+'-clear')) {
						// Clear the value and don't change the display
						that.s.d = null;
						that.dom.input.val('');
						that._writeOutput();
						that._setCalander();
						that._setTime();

						onChange();
					}
					else if ($(target).hasClass(classPrefix+'-today')) {
						// Don't change the value, but jump to the month
						// containing today
						that.s.display = new Date();

						that._setTitle();
						that._setCalander();
					}
				}
				if ( nodeName === 'button' ) {
					var button = $(target);
					var parent = button.parent();

					if ( parent.hasClass('disabled') && ! parent.hasClass('range') ) {
						button.blur();
						return;
					}

					if ( parent.hasClass(classPrefix+'-iconLeft') ) {
						// Previous month
						that.s.display.setUTCMonth( that.s.display.getUTCMonth()-1 );
						that._setTitle();
						that._setCalander();

						that.dom.input.focus();
					}
					else if ( parent.hasClass(classPrefix+'-iconRight') ) {
						// Next month
						that._correctMonth( that.s.display, that.s.display.getUTCMonth()+1 );
						that._setTitle();
						that._setCalander();

						that.dom.input.focus();
					}
					else if ( button.parents('.'+classPrefix+'-time').length ) {
						var val = button.data('value');
						var unit = button.data('unit');

						d = that._needValue();

						if ( unit === 'minutes' ) {
							if ( parent.hasClass('disabled') && parent.hasClass('range') ) {
								that.s.minutesRange = val;
								that._setTime();
								return;
							}
							else {
								that.s.minutesRange = null;
							}
						}

						if ( unit === 'seconds' ) {
							if ( parent.hasClass('disabled') && parent.hasClass('range') ) {
								that.s.secondsRange = val;
								that._setTime();
								return;
							}
							else {
								that.s.secondsRange = null;
							}
						}

						// Specific to hours for 12h clock
						if ( val === 'am' ) {
							if ( d.getUTCHours() >= 12 ) {
								val = d.getUTCHours() - 12;
							}
							else {
								return;
							}
						}
						else if ( val === 'pm' ) {
							if ( d.getUTCHours() < 12 ) {
								val = d.getUTCHours() + 12;
							}
							else {
								return;
							}
						}

						var set = unit === 'hours' ?
							'setUTCHours' :
							unit === 'minutes' ?
								'setUTCMinutes' :
								'setSeconds';

						d[set]( val );
						that._setTime();
						that._writeOutput( true );
						onChange();
					}
					else {
						// Calendar click
						d = that._needValue();

						// Can't be certain that the current day will exist in
						// the new month, and likewise don't know that the
						// new day will exist in the old month, But 1 always
						// does, so we can change the month without worry of a
						// recalculation being done automatically by `Date`
						d.setUTCDate( 1 );
						d.setUTCFullYear( button.data('year') );
						d.setUTCMonth( button.data('month') );
						d.setUTCDate( button.data('day') );

						that._writeOutput( true );

						// Don't hide if there is a time picker, since we want to
						// be able to select a time as well.
						if ( ! that.s.parts.time ) {
							// This is annoying but IE has some kind of async
							// behaviour with focus and the focus from the above
							// write would occur after this hide - resulting in the
							// calendar opening immediately
							setTimeout( function () {
								that._hide();
							}, 10 );
						}
						else {
							that._setCalander();
						}

						onChange();
					}
				}
				else {
					// Click anywhere else in the widget - return focus to the
					// input element
					that.dom.input.focus();
				}
			} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private
	 */

	/**
	 * Compare the date part only of two dates - this is made super easy by the
	 * toDateString method!
	 *
	 * @param  {Date} a Date 1
	 * @param  {Date} b Date 2
	 * @private
	 */
	_compareDates: function( a, b ) {
		// Can't use toDateString as that converts to local time
		// luxon uses different method names so need to be able to call them
		return dateLib && dateLib == window.luxon
			? dateLib.DateTime.fromJSDate(a).toISODate() === dateLib.DateTime.fromJSDate(b).toISODate()
			: this._dateToUtcString(a) === this._dateToUtcString(b);
	},

	/**
	 * When changing month, take account of the fact that some months don't have
	 * the same number of days. For example going from January to February you
	 * can have the 31st of Jan selected and just add a month since the date
	 * would still be 31, and thus drop you into March.
	 *
	 * @param  {Date} date  Date - will be modified
	 * @param  {integer} month Month to set
	 * @private
	 */
	_correctMonth: function ( date, month ) {
		var days = this._daysInMonth( date.getUTCFullYear(), month );
		var correctDays = date.getUTCDate() > days;

		date.setUTCMonth( month );

		if ( correctDays ) {
			date.setUTCDate( days );
			date.setUTCMonth( month );
		}
	},

	/**
	 * Get the number of days in a method. Based on
	 * http://stackoverflow.com/a/4881951 by Matti Virkkunen
	 *
	 * @param  {integer} year  Year
	 * @param  {integer} month Month (starting at 0)
	 * @private
	 */
	_daysInMonth: function ( year, month ) {
		// 
		var isLeap = ((year % 4) === 0 && ((year % 100) !== 0 || (year % 400) === 0));
		var months = [31, (isLeap ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

		return months[month];
	},

	/**
	 * Create a new date object which has the UTC values set to the local time.
	 * This allows the local time to be used directly for the library which
	 * always bases its calculations and display on UTC.
	 *
	 * @param  {Date} s Date to "convert"
	 * @return {Date}   Shifted date
	 */
	_dateToUtc: function ( s ) {
		return new Date( Date.UTC(
			s.getFullYear(), s.getMonth(), s.getDate(),
			s.getHours(), s.getMinutes(), s.getSeconds()
		) );
	},

	/**
	 * Create a UTC ISO8601 date part from a date object
	 *
	 * @param  {Date} d Date to "convert"
	 * @return {string} ISO formatted date
	 */
	_dateToUtcString: function ( d ) {
		// luxon uses different method names so need to be able to call them
		return dateLib && dateLib == window.luxon
			? dateLib.DateTime.fromJSDate(d).toISODate()
			: d.getUTCFullYear()+'-'+
				this._pad(d.getUTCMonth()+1)+'-'+
				this._pad(d.getUTCDate());
	},

	/**
	 * Hide the control and remove events related to its display
	 *
	 * @private
	 */
	_hide: function (destroy) {
		if (! destroy && this.dom.input.attr('type') === 'hidden') {
			return;
		}

		var namespace = this.s.namespace;

		this.dom.container.detach();

		$(window).off( '.'+namespace );
		$(document).off( 'keydown.'+namespace );
		$('div.dataTables_scrollBody').off( 'scroll.'+namespace );
		$('div.DTE_Body_Content').off( 'scroll.'+namespace );
		$('body').off( 'click.'+namespace );
	},

	/**
	 * Convert a 24 hour value to a 12 hour value
	 *
	 * @param  {integer} val 24 hour value
	 * @return {integer}     12 hour value
	 * @private
	 */
	_hours24To12: function ( val ) {
		return val === 0 ?
			12 :
			val > 12 ?
				val - 12 :
				val;
	},

	/**
	 * Generate the HTML for a single day in the calendar - this is basically
	 * and HTML cell with a button that has data attributes so we know what was
	 * clicked on (if it is clicked on) and a bunch of classes for styling.
	 *
	 * @param  {object} day Day object from the `_htmlMonth` method
	 * @return {string}     HTML cell
	 */
	_htmlDay: function( day )
	{
		if ( day.empty ) {
			return '<td class="empty"></td>';
		}

		var classes = [ 'selectable' ];
		var classPrefix = this.c.classPrefix;

		if ( day.disabled ) {
			classes.push( 'disabled' );
		}

		if ( day.today ) {
			classes.push( 'now' );
		}

		if ( day.selected ) {
			classes.push( 'selected' );
		}

		return '<td data-day="' + day.day + '" class="' + classes.join(' ') + '">' +
				'<button class="'+classPrefix+'-button '+classPrefix+'-day" type="button" ' +'data-year="' + day.year + '" data-month="' + day.month + '" data-day="' + day.day + '">' +
					'<span>'+day.day+'</span>'+
				'</button>' +
			'</td>';
	},


	/**
	 * Create the HTML for a month to be displayed in the calendar table.
	 * 
	 * Based upon the logic used in Pikaday - MIT licensed
	 * Copyright (c) 2014 David Bushell
	 * https://github.com/dbushell/Pikaday
	 *
	 * @param  {integer} year  Year
	 * @param  {integer} month Month (starting at 0)
	 * @return {string} Calendar month HTML
	 * @private
	 */
	_htmlMonth: function ( year, month ) {
		var now    = this._dateToUtc( new Date() ),
			days   = this._daysInMonth( year, month ),
			before = new Date( Date.UTC(year, month, 1) ).getUTCDay(),
			data   = [],
			row    = [];

		if ( this.c.firstDay > 0 ) {
			before -= this.c.firstDay;

			if (before < 0) {
				before += 7;
			}
		}

		var cells = days + before,
			after = cells;

		while ( after > 7 ) {
			after -= 7;
		}

		cells += 7 - after;

		var minDate = this.c.minDate;
		var maxDate = this.c.maxDate;

		if ( minDate ) {
			minDate.setUTCHours(0);
			minDate.setUTCMinutes(0);
			minDate.setSeconds(0);
		}

		if ( maxDate ) {
			maxDate.setUTCHours(23);
			maxDate.setUTCMinutes(59);
			maxDate.setSeconds(59);
		}

		for ( var i=0, r=0 ; i<cells ; i++ ) {
			var day      = new Date( Date.UTC(year, month, 1 + (i - before)) ),
				selected = this.s.d ? this._compareDates(day, this.s.d) : false,
				today    = this._compareDates(day, now),
				empty    = i < before || i >= (days + before),
				disabled = (minDate && day < minDate) ||
				           (maxDate && day > maxDate);

			var disableDays = this.c.disableDays;
			if ( Array.isArray( disableDays ) && $.inArray( day.getUTCDay(), disableDays ) !== -1 ) {
				disabled = true;
			}
			else if ( typeof disableDays === 'function' && disableDays( day ) === true ) {
				disabled = true;
			}

			var dayConfig = {
				day:      1 + (i - before),
				month:    month,
				year:     year,
				selected: selected,
				today:    today,
				disabled: disabled,
				empty:    empty
			};

			row.push( this._htmlDay(dayConfig) );

			if ( ++r === 7 ) {
				if ( this.c.showWeekNumber ) {
					row.unshift( this._htmlWeekOfYear(i - before, month, year) );
				}

				data.push( '<tr>'+row.join('')+'</tr>' );
				row = [];
				r = 0;
			}
		}

		var classPrefix = this.c.classPrefix;
		var className = classPrefix+'-table';
		if ( this.c.showWeekNumber ) {
			className += ' weekNumber';
		}

		// Show / hide month icons based on min/max
		if ( minDate ) {
			var underMin = minDate >= new Date( Date.UTC(year, month, 1, 0, 0, 0 ) );

			this.dom.title.find('div.'+classPrefix+'-iconLeft')
				.css( 'display', underMin ? 'none' : 'block' );
		}

		if ( maxDate ) {
			var overMax = maxDate < new Date( Date.UTC(year, month+1, 1, 0, 0, 0 ) );

			this.dom.title.find('div.'+classPrefix+'-iconRight')
				.css( 'display', overMax ? 'none' : 'block' );
		}

		return '<table class="'+className+'">' +
				'<thead>'+
					this._htmlMonthHead() +
				'</thead>'+
				'<tbody>'+
					data.join('') +
				'</tbody>'+
			'</table>';
	},

	/**
	 * Create the calendar table's header (week days)
	 *
	 * @return {string} HTML cells for the row
	 * @private
	 */
	_htmlMonthHead: function () {
		var a = [];
		var firstDay = this.c.firstDay;
		var i18n = this.c.i18n;

		// Take account of the first day shift
		var dayName = function ( day ) {
			day += firstDay;

			while (day >= 7) {
				day -= 7;
			}

			return i18n.weekdays[day];
		};
		
		// Empty cell in the header
		if ( this.c.showWeekNumber ) {
			a.push( '<th></th>' );
		}

		for ( var i=0 ; i<7 ; i++ ) {
			a.push( '<th>'+dayName( i )+'</th>' );
		}

		return a.join('');
	},

	/**
	 * Create a cell that contains week of the year - ISO8601
	 *
	 * Based on https://stackoverflow.com/questions/6117814/ and
	 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/
	 *
	 * @param  {integer} d Day of month
	 * @param  {integer} m Month of year (zero index)
	 * @param  {integer} y Year
	 * @return {string}   
	 * @private
	 */
	_htmlWeekOfYear: function ( d, m, y ) {
		var date = new Date( y, m, d, 0, 0, 0, 0 );

		// First week of the year always has 4th January in it
		date.setDate( date.getDate() + 4 - (date.getDay() || 7) );

		var oneJan = new Date( y, 0, 1 );
		var weekNum = Math.ceil( ( ( (date - oneJan) / 86400000) + 1)/7 );

		return '<td class="'+this.c.classPrefix+'-week">' + weekNum + '</td>';
	},

	/**
	 * Check if the instance has a date object value - it might be null.
	 * If is doesn't set one to now.
	 * @returns A Date object
	 * @private
	 */
	_needValue: function () {
		if ( ! this.s.d ) {
			this.s.d = this._dateToUtc( new Date() );
		}

		return this.s.d;
	},

	/**
	 * Create option elements from a range in an array
	 *
	 * @param  {string} selector Class name unique to the select element to use
	 * @param  {array} values   Array of values
	 * @param  {array} [labels] Array of labels. If given must be the same
	 *   length as the values parameter.
	 * @private
	 */
	_options: function ( selector, values, labels ) {
		if ( ! labels ) {
			labels = values;
		}

		var select = this.dom.container.find('select.'+this.c.classPrefix+'-'+selector);
		select.empty();

		for ( var i=0, ien=values.length ; i<ien ; i++ ) {
			select.append( '<option value="'+values[i]+'">'+labels[i]+'</option>' );
		}
	},

	/**
	 * Set an option and update the option's span pair (since the select element
	 * has opacity 0 for styling)
	 *
	 * @param  {string} selector Class name unique to the select element to use
	 * @param  {*}      val      Value to set
	 * @private
	 */
	_optionSet: function ( selector, val ) {
		var select = this.dom.container.find('select.'+this.c.classPrefix+'-'+selector);
		var span = select.parent().children('span');

		select.val( val );

		var selected = select.find('option:selected');
		span.html( selected.length !== 0 ?
			selected.text() :
			this.c.i18n.unknown
		);
	},

	/**
	 * Create time options list.
	 *
	 * @param  {string} unit Time unit - hours, minutes or seconds
	 * @param  {integer} count Count range - 12, 24 or 60
	 * @param  {integer} val Existing value for this unit
	 * @param  {integer[]} allowed Values allow for selection
	 * @param  {integer} range Override range
	 * @private
	 */
	_optionsTime: function ( unit, count, val, allowed, range ) {
		var classPrefix = this.c.classPrefix;
		var container = this.dom.container.find('div.'+classPrefix+'-'+unit);
		var i, j;
		var render = count === 12 ?
			function (i) { return i; } :
			this._pad;
		var classPrefix = this.c.classPrefix;
		var className = classPrefix+'-table';
		var i18n = this.c.i18n;

		if ( ! container.length ) {
			return;
		}

		var a = '';
		var span = 10;
		var button = function (value, label, className) {
			// Shift the value for PM
			if ( count === 12 && typeof value === 'number' ) {
				if (val >= 12 ) {
					value += 12;
				}

				if (value == 12) {
					value = 0;
				}
				else if (value == 24) {
					value = 12;
				}
			}

			var selected = val === value || (value === 'am' && val < 12) || (value === 'pm' && val >= 12) ?
				'selected' :
				'';
			
			if (allowed && $.inArray(value, allowed) === -1) {
				selected += ' disabled';
			}

			if ( className ) {
				selected += ' '+className;
			}

			return '<td class="selectable '+selected+'">' +
				'<button class="'+classPrefix+'-button '+classPrefix+'-day" type="button" data-unit="'+unit+'" data-value="'+value+ '">' +
					'<span>'+label+'</span>'+
				'</button>' +
			'</td>';
		}

		if ( count === 12 ) {
			// Hours with AM/PM
			a += '<tr>';
			
			for ( i=1 ; i<=6 ; i++ ) {
				a += button(i, render(i));
			}
			a += button('am', i18n.amPm[0]);

			a += '</tr>';
			a += '<tr>';

			for ( i=7 ; i<=12 ; i++ ) {
				a += button(i, render(i));
			}
			a += button('pm', i18n.amPm[1]);
			a += '</tr>';

			span = 7;
		}
		else if ( count === 24 ) {
			// Hours - 24
			var c = 0;
			for (j=0 ; j<4 ; j++ ) {
				a += '<tr>';
				for ( i=0 ; i<6 ; i++ ) {
					a += button(c, render(c));
					c++;
				}
				a += '</tr>';
			}

			span = 6;
		}
		else {
			// Minutes and seconds
			a += '<tr>';
			for (j=0 ; j<60 ; j+=10 ) {
				a += button(j, render(j), 'range');
			}
			a += '</tr>';
			
			// Slight hack to allow for the different number of columns
			a += '</tbody></thead><table class="'+className+' '+className+'-nospace"><tbody>';

			var start = range !== null ?
				range :
				Math.floor( val / 10 )*10;

			a += '<tr>';
			for (j=start+1 ; j<start+10 ; j++ ) {
				a += button(j, render(j));
			}
			a += '</tr>';

			span = 6;
		}

		container
			.empty()
			.append(
				'<table class="'+className+'">'+
					'<thead><tr><th colspan="'+span+'">'+
						i18n[unit] +
					'</th></tr></thead>'+
					'<tbody>'+
						a+
					'</tbody>'+
				'</table>'
			);
	},

	/**
	 * Create the options for the month and year
	 *
	 * @param  {integer} year  Year
	 * @param  {integer} month Month (starting at 0)
	 * @private
	 */
	_optionsTitle: function () {
		var i18n = this.c.i18n;
		var min = this.c.minDate;
		var max = this.c.maxDate;
		var minYear = min ? min.getFullYear() : null;
		var maxYear = max ? max.getFullYear() : null;

		var i = minYear !== null ? minYear : new Date().getFullYear() - this.c.yearRange;
		var j = maxYear !== null ? maxYear : new Date().getFullYear() + this.c.yearRange;

		this._options( 'month', this._range( 0, 11 ), i18n.months );
		this._options( 'year', this._range( i, j ) );
	},

	/**
	 * Simple two digit pad
	 *
	 * @param  {integer} i      Value that might need padding
	 * @return {string|integer} Padded value
	 * @private
	 */
	_pad: function ( i ) {
		return i<10 ? '0'+i : i;
	},

	/**
	 * Position the calendar to look attached to the input element
	 * @private
	 */
	_position: function () {
		var offset = this.c.attachTo === 'input' ? this.dom.input.position() : this.dom.input.offset();
		var container = this.dom.container;
		var inputHeight = this.dom.input.outerHeight();

		if (container.hasClass('inline')) {
			container.insertAfter( this.dom.input );
			return;
		}

		if ( this.s.parts.date && this.s.parts.time && $(window).width() > 550 ) {
			container.addClass('horizontal');
		}
		else {
			container.removeClass('horizontal');
		}

		if(this.c.attachTo === 'input') {
			container
				.css( {
					top: offset.top + inputHeight,
					left: offset.left
				} )
				.insertAfter( this.dom.input );
		}
		else {
			container
				.css( {
					top: offset.top + inputHeight,
					left: offset.left
				} )
				.appendTo( 'body' );
		}

		var calHeight = container.outerHeight();
		var calWidth = container.outerWidth();
		var scrollTop = $(window).scrollTop();

		// Correct to the bottom
		if ( offset.top + inputHeight + calHeight - scrollTop > $(window).height() ) {
			var newTop = offset.top - calHeight;

			container.css( 'top', newTop < 0 ? 0 : newTop );
		}

		// Correct to the right
		if ( calWidth + offset.left > $(window).width() ) {
			var newLeft = $(window).width() - calWidth;

			// Account for elements which are inside a position absolute element
			if (this.c.attachTo === 'input') {
				newLeft -= $(container).offsetParent().offset().left;
			}

			container.css( 'left', newLeft < 0 ? 0 : newLeft );
		}
	},

	/**
	 * Create a simple array with a range of values
	 *
	 * @param  {integer} start   Start value (inclusive)
	 * @param  {integer} end     End value (inclusive)
	 * @param  {integer} [inc=1] Increment value
	 * @return {array}           Created array
	 * @private
	 */
	_range: function ( start, end, inc ) {
		var a = [];

		if ( ! inc ) {
			inc = 1;
		}

		for ( var i=start ; i<=end ; i+=inc ) {
			a.push( i );
		}

		return a;
	},

	/**
	 * Redraw the calendar based on the display date - this is a destructive
	 * operation
	 *
	 * @private
	 */
	_setCalander: function () {
		if ( this.s.display ) {
			this.dom.calendar
				.empty()
				.append( this._htmlMonth(
					this.s.display.getUTCFullYear(),
					this.s.display.getUTCMonth()
				) );
		}
	},

	/**
	 * Set the month and year for the calendar based on the current display date
	 *
	 * @private
	 */
	_setTitle: function () {
		this._optionSet( 'month', this.s.display.getUTCMonth() );
		this._optionSet( 'year', this.s.display.getUTCFullYear() );
	},

	/**
	 * Set the time based on the current value of the widget
	 *
	 * @private
	 */
	_setTime: function () {
		var that = this;
		var d = this.s.d;
		
		// luxon uses different method names so need to be able to call them. This happens a few time later in this method too
		var luxDT = null
		if (dateLib && dateLib == window.luxon) {
			luxDT = dateLib.DateTime.fromJSDate(d);
		}

		var hours = luxDT != null
			? luxDT.hour
			: d
				? d.getUTCHours()
				: 0;

		var allowed = function ( prop ) { // Backwards compt with `Increment` option
			return that.c[prop+'Available'] ?
				that.c[prop+'Available'] :
				that._range( 0, 59, that.c[prop+'Increment'] );
		}

		this._optionsTime( 'hours', this.s.parts.hours12 ? 12 : 24, hours, this.c.hoursAvailable )
		this._optionsTime(
			'minutes',
			60,
			luxDT != null
				? luxDT.minute
				: d
					? d.getUTCMinutes()
					: 0, allowed('minutes'),
			this.s.minutesRange
		);
		this._optionsTime(
			'seconds',
			60,
			luxDT != null
				? luxDT.second
				: d
					? d.getSeconds()
					: 0,
			allowed('seconds'),
			this.s.secondsRange
		);
	},

	/**
	 * Show the widget and add events to the document required only while it
	 * is displayed
	 * 
	 * @private
	 */
	_show: function () {
		var that = this;
		var namespace = this.s.namespace;

		this._position();

		// Need to reposition on scroll
		$(window).on( 'scroll.'+namespace+' resize.'+namespace, function () {
			that._position();
		} );

		$('div.DTE_Body_Content').on( 'scroll.'+namespace, function () {
			that._position();
		} );

		$('div.dataTables_scrollBody').on( 'scroll.'+namespace, function () {
			that._position();
		} );

		var offsetParent = this.dom.input[0].offsetParent;

		if ( offsetParent !== document.body ) {
			$(offsetParent).on( 'scroll.'+namespace, function () {
				that._position();
			} );
		}

		// On tab focus will move to a different field (no keyboard navigation
		// in the date picker - this might need to be changed).
		$(document).on( 'keydown.'+namespace, function (e) {
			if (
				e.keyCode === 9  || // tab
				e.keyCode === 27 || // esc
				e.keyCode === 13    // return
			) {
				that._hide();
			}
		} );

		// Hide if clicking outside of the widget - but in a different click
		// event from the one that was used to trigger the show (bubble and
		// inline)
		setTimeout( function () {
			$('body').on( 'click.'+namespace, function (e) {
				var parents = $(e.target).parents();

				if ( ! parents.filter( that.dom.container ).length && e.target !== that.dom.input[0] ) {
					that._hide();
				}
			} );
		}, 10 );
	},

	/**
	 * Write the formatted string to the input element this control is attached
	 * to
	 *
	 * @private
	 */
	_writeOutput: function ( focus ) {
		var date = this.s.d;
		var out = '';

		// Use moment, dayjs or luxon if possible - otherwise it must be ISO8601 (or the
		// constructor would have thrown an error)
		// luxon uses different method names so need to be able to call them.
		if (date) {
			out = dateLib && dateLib == window.luxon
			? dateLib.DateTime.fromJSDate(this.s.d).toFormat(this.c.format)
			: dateLib ?
				dateLib.utc( date, undefined, this.c.locale, this.c.strict ).format( this.c.format ) :
				date.getUTCFullYear() +'-'+
					this._pad(date.getUTCMonth() + 1) +'-'+
					this._pad(date.getUTCDate());
		}

		this.dom.input
			.val( out )
			.trigger('change', {write: date});
		
		if ( this.dom.input.attr('type') === 'hidden' ) {
			this.val(out, false);
		}

		if ( focus ) {
			this.dom.input.focus();
		}
	}
} );

/**
 * Use a specificmoment compatible date library
 */
DateTime.use = function (lib) {
	dateLib = lib;
};

/**
 * For generating unique namespaces
 *
 * @type {Number}
 * @private
 */
DateTime._instance = 0;

/**
 * Defaults for the date time picker
 *
 * @type {Object}
 */
DateTime.defaults = {
	attachTo: 'body',

	buttons: {
		clear: false,
		today: false
	},

	// Not documented - could be an internal property
	classPrefix: 'dt-datetime',

	// function or array of ints
	disableDays: null,

	// first day of the week (0: Sunday, 1: Monday, etc)
	firstDay: 1,

	format: 'YYYY-MM-DD',

	hoursAvailable: null,

	i18n: {
		clear:    'Clear',
		previous: 'Previous',
		next:     'Next',
		months:   [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],
		weekdays: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],
		amPm:     [ 'am', 'pm' ],
		hours:    'Hour',
		minutes:  'Minute',
		seconds:  'Second',
		unknown:  '-',
		today:    'Today'
	},

	maxDate: null,

	minDate: null,

	minutesAvailable: null,

	minutesIncrement: 1, // deprecated

	strict: true,

	locale: 'en',

	onChange: function () {},

	secondsAvailable: null,

	secondsIncrement: 1, // deprecated

	// show the ISO week number at the head of the row
	showWeekNumber: false,

	// overruled by max / min date
	yearRange: 25
};

DateTime.version = '1.1.1';

// Global export - if no conflicts
if (! window.DateTime) {
	window.DateTime = DateTime;
}

// Make available via jQuery
$.fn.dtDateTime = function (options) {
	return this.each(function() {
		new DateTime(this, options);
	});
}

// Attach to DataTables if present
if ($.fn.dataTable) {
	$.fn.dataTable.DateTime = DateTime;
	$.fn.DataTable.DateTime = DateTime;

	if ($.fn.dataTable.Editor) {
		$.fn.dataTable.Editor.DateTime = DateTime;
	}
}

return DateTime;

}));


/***/ }),

/***/ "./node_modules/datatables.net-scroller-bs5/js/scroller.bootstrap5.js":
/*!****************************************************************************!*\
  !*** ./node_modules/datatables.net-scroller-bs5/js/scroller.bootstrap5.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap 5 styling wrapper for Scroller
 * Â©2018 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net-bs5 */ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js"), __webpack_require__(/*! datatables.net-scroller */ "./node_modules/datatables.net-scroller/js/dataTables.scroller.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}(function( $, window, document, undefined ) {

return $.fn.dataTable;

}));

/***/ }),

/***/ "./node_modules/datatables.net-scroller/js/dataTables.scroller.js":
/*!************************************************************************!*\
  !*** ./node_modules/datatables.net-scroller/js/dataTables.scroller.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Scroller 2.0.5
 * Â©2011-2021 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     Scroller
 * @description Virtual rendering for DataTables
 * @version     2.0.5
 * @file        dataTables.scroller.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2011-2021 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/**
 * Scroller is a virtual rendering plug-in for DataTables which allows large
 * datasets to be drawn on screen every quickly. What the virtual rendering means
 * is that only the visible portion of the table (and a bit to either side to make
 * the scrolling smooth) is drawn, while the scrolling container gives the
 * visual impression that the whole table is visible. This is done by making use
 * of the pagination abilities of DataTables and moving the table around in the
 * scrolling container DataTables adds to the page. The scrolling container is
 * forced to the height it would be for the full table display using an extra
 * element.
 *
 * Note that rows in the table MUST all be the same height. Information in a cell
 * which expands on to multiple lines will cause some odd behaviour in the scrolling.
 *
 * Scroller is initialised by simply including the letter 'S' in the sDom for the
 * table you want to have this feature enabled on. Note that the 'S' must come
 * AFTER the 't' parameter in `dom`.
 *
 * Key features include:
 *   <ul class="limit_length">
 *     <li>Speed! The aim of Scroller for DataTables is to make rendering large data sets fast</li>
 *     <li>Full compatibility with deferred rendering in DataTables for maximum speed</li>
 *     <li>Display millions of rows</li>
 *     <li>Integration with state saving in DataTables (scrolling position is saved)</li>
 *     <li>Easy to use</li>
 *   </ul>
 *
 *  @class
 *  @constructor
 *  @global
 *  @param {object} dt DataTables settings object or API instance
 *  @param {object} [opts={}] Configuration object for Scroller. Options 
 *    are defined by {@link Scroller.defaults}
 *
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.10.0+
 *
 *  @example
 *    $(document).ready(function() {
 *        $('#example').DataTable( {
 *            "scrollY": "200px",
 *            "ajax": "media/dataset/large.txt",
 *            "scroller": true,
 *            "deferRender": true
 *        } );
 *    } );
 */
var Scroller = function ( dt, opts ) {
	/* Sanity check - you just know it will happen */
	if ( ! (this instanceof Scroller) ) {
		alert( "Scroller warning: Scroller must be initialised with the 'new' keyword." );
		return;
	}

	if ( opts === undefined ) {
		opts = {};
	}

	var dtApi = $.fn.dataTable.Api( dt );

	/**
	 * Settings object which contains customisable information for the Scroller instance
	 * @namespace
	 * @private
	 * @extends Scroller.defaults
	 */
	this.s = {
		/**
		 * DataTables settings object
		 *  @type     object
		 *  @default  Passed in as first parameter to constructor
		 */
		dt: dtApi.settings()[0],

		/**
		 * DataTables API instance
		 *  @type     DataTable.Api
		 */
		dtApi: dtApi,

		/**
		 * Pixel location of the top of the drawn table in the viewport
		 *  @type     int
		 *  @default  0
		 */
		tableTop: 0,

		/**
		 * Pixel location of the bottom of the drawn table in the viewport
		 *  @type     int
		 *  @default  0
		 */
		tableBottom: 0,

		/**
		 * Pixel location of the boundary for when the next data set should be loaded and drawn
		 * when scrolling up the way.
		 *  @type     int
		 *  @default  0
		 *  @private
		 */
		redrawTop: 0,

		/**
		 * Pixel location of the boundary for when the next data set should be loaded and drawn
		 * when scrolling down the way. Note that this is actually calculated as the offset from
		 * the top.
		 *  @type     int
		 *  @default  0
		 *  @private
		 */
		redrawBottom: 0,

		/**
		 * Auto row height or not indicator
		 *  @type     bool
		 *  @default  0
		 */
		autoHeight: true,

		/**
		 * Number of rows calculated as visible in the visible viewport
		 *  @type     int
		 *  @default  0
		 */
		viewportRows: 0,

		/**
		 * setTimeout reference for state saving, used when state saving is enabled in the DataTable
		 * and when the user scrolls the viewport in order to stop the cookie set taking too much
		 * CPU!
		 *  @type     int
		 *  @default  0
		 */
		stateTO: null,

		stateSaveThrottle: function () {},

		/**
		 * setTimeout reference for the redraw, used when server-side processing is enabled in the
		 * DataTables in order to prevent DoSing the server
		 *  @type     int
		 *  @default  null
		 */
		drawTO: null,

		heights: {
			jump: null,
			page: null,
			virtual: null,
			scroll: null,

			/**
			 * Height of rows in the table
			 *  @type     int
			 *  @default  0
			 */
			row: null,

			/**
			 * Pixel height of the viewport
			 *  @type     int
			 *  @default  0
			 */
			viewport: null,
			labelHeight: 0,
			xbar: 0
		},

		topRowFloat: 0,
		scrollDrawDiff: null,
		loaderVisible: false,
		forceReposition: false,
		baseRowTop: 0,
		baseScrollTop: 0,
		mousedown: false,
		lastScrollTop: 0
	};

	// @todo The defaults should extend a `c` property and the internal settings
	// only held in the `s` property. At the moment they are mixed
	this.s = $.extend( this.s, Scroller.oDefaults, opts );

	// Workaround for row height being read from height object (see above comment)
	this.s.heights.row = this.s.rowHeight;

	/**
	 * DOM elements used by the class instance
	 * @private
	 * @namespace
	 *
	 */
	this.dom = {
		"force":    document.createElement('div'),
		"label":    $('<div class="dts_label">0</div>'),
		"scroller": null,
		"table":    null,
		"loader":   null
	};

	// Attach the instance to the DataTables instance so it can be accessed in
	// future. Don't initialise Scroller twice on the same table
	if ( this.s.dt.oScroller ) {
		return;
	}

	this.s.dt.oScroller = this;

	/* Let's do it */
	this.construct();
};



$.extend( Scroller.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods - to be exposed via the DataTables API
	 */

	/**
	 * Calculate and store information about how many rows are to be displayed
	 * in the scrolling viewport, based on current dimensions in the browser's
	 * rendering. This can be particularly useful if the table is initially
	 * drawn in a hidden element - for example in a tab.
	 *  @param {bool} [redraw=true] Redraw the table automatically after the recalculation, with
	 *    the new dimensions forming the basis for the draw.
	 *  @returns {void}
	 */
	measure: function ( redraw )
	{
		if ( this.s.autoHeight )
		{
			this._calcRowHeight();
		}

		var heights = this.s.heights;

		if ( heights.row ) {
			heights.viewport = this._parseHeight($(this.dom.scroller).css('max-height'));

			this.s.viewportRows = parseInt( heights.viewport / heights.row, 10 )+1;
			this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;
		}

		var label = this.dom.label.outerHeight();
		
		heights.xbar = this.dom.scroller.offsetHeight - this.dom.scroller.clientHeight;
		heights.labelHeight = label;

		if ( redraw === undefined || redraw )
		{
			this.s.dt.oInstance.fnDraw( false );
		}
	},

	/**
	 * Get information about current displayed record range. This corresponds to
	 * the information usually displayed in the "Info" block of the table.
	 *
	 * @returns {object} info as an object:
	 *  {
	 *      start: {int}, // the 0-indexed record at the top of the viewport
	 *      end:   {int}, // the 0-indexed record at the bottom of the viewport
	 *  }
	*/
	pageInfo: function()
	{
		var 
			dt = this.s.dt,
			iScrollTop = this.dom.scroller.scrollTop,
			iTotal = dt.fnRecordsDisplay(),
			iPossibleEnd = Math.ceil(this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani));

		return {
			start: Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani)),
			end: iTotal < iPossibleEnd ? iTotal-1 : iPossibleEnd-1
		};
	},

	/**
	 * Calculate the row number that will be found at the given pixel position
	 * (y-scroll).
	 *
	 * Please note that when the height of the full table exceeds 1 million
	 * pixels, Scroller switches into a non-linear mode for the scrollbar to fit
	 * all of the records into a finite area, but this function returns a linear
	 * value (relative to the last non-linear positioning).
	 *  @param {int} pixels Offset from top to calculate the row number of
	 *  @param {int} [intParse=true] If an integer value should be returned
	 *  @param {int} [virtual=false] Perform the calculations in the virtual domain
	 *  @returns {int} Row index
	 */
	pixelsToRow: function ( pixels, intParse, virtual )
	{
		var diff = pixels - this.s.baseScrollTop;
		var row = virtual ?
			(this._domain( 'physicalToVirtual', this.s.baseScrollTop ) + diff) / this.s.heights.row :
			( diff / this.s.heights.row ) + this.s.baseRowTop;

		return intParse || intParse === undefined ?
			parseInt( row, 10 ) :
			row;
	},

	/**
	 * Calculate the pixel position from the top of the scrolling container for
	 * a given row
	 *  @param {int} iRow Row number to calculate the position of
	 *  @returns {int} Pixels
	 */
	rowToPixels: function ( rowIdx, intParse, virtual )
	{
		var pixels;
		var diff = rowIdx - this.s.baseRowTop;

		if ( virtual ) {
			pixels = this._domain( 'virtualToPhysical', this.s.baseScrollTop );
			pixels += diff * this.s.heights.row;
		}
		else {
			pixels = this.s.baseScrollTop;
			pixels += diff * this.s.heights.row;
		}

		return intParse || intParse === undefined ?
			parseInt( pixels, 10 ) :
			pixels;
	},


	/**
	 * Calculate the row number that will be found at the given pixel position (y-scroll)
	 *  @param {int} row Row index to scroll to
	 *  @param {bool} [animate=true] Animate the transition or not
	 *  @returns {void}
	 */
	scrollToRow: function ( row, animate )
	{
		var that = this;
		var ani = false;
		var px = this.rowToPixels( row );

		// We need to know if the table will redraw or not before doing the
		// scroll. If it will not redraw, then we need to use the currently
		// displayed table, and scroll with the physical pixels. Otherwise, we
		// need to calculate the table's new position from the virtual
		// transform.
		var preRows = ((this.s.displayBuffer-1)/2) * this.s.viewportRows;
		var drawRow = row - preRows;
		if ( drawRow < 0 ) {
			drawRow = 0;
		}

		if ( (px > this.s.redrawBottom || px < this.s.redrawTop) && this.s.dt._iDisplayStart !== drawRow ) {
			ani = true;
			px = this._domain( 'virtualToPhysical', row * this.s.heights.row );

			// If we need records outside the current draw region, but the new
			// scrolling position is inside that (due to the non-linear nature
			// for larger numbers of records), we need to force position update.
			if ( this.s.redrawTop < px && px < this.s.redrawBottom ) {
				this.s.forceReposition = true;
				animate = false;
			}
		}

		if ( animate === undefined || animate )
		{
			this.s.ani = ani;
			$(this.dom.scroller).animate( {
				"scrollTop": px
			}, function () {
				// This needs to happen after the animation has completed and
				// the final scroll event fired
				setTimeout( function () {
					that.s.ani = false;
				}, 250 );
			} );
		}
		else
		{
			$(this.dom.scroller).scrollTop( px );
		}
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialisation for Scroller
	 *  @returns {void}
	 *  @private
	 */
	construct: function ()
	{
		var that = this;
		var dt = this.s.dtApi;

		/* Sanity check */
		if ( !this.s.dt.oFeatures.bPaginate ) {
			this.s.dt.oApi._fnLog( this.s.dt, 0, 'Pagination must be enabled for Scroller' );
			return;
		}

		/* Insert a div element that we can use to force the DT scrolling container to
		 * the height that would be required if the whole table was being displayed
		 */
		this.dom.force.style.position = "relative";
		this.dom.force.style.top = "0px";
		this.dom.force.style.left = "0px";
		this.dom.force.style.width = "1px";

		this.dom.scroller = $('div.'+this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];
		this.dom.scroller.appendChild( this.dom.force );
		this.dom.scroller.style.position = "relative";

		this.dom.table = $('>table', this.dom.scroller)[0];
		this.dom.table.style.position = "absolute";
		this.dom.table.style.top = "0px";
		this.dom.table.style.left = "0px";

		// Add class to 'announce' that we are a Scroller table
		$(dt.table().container()).addClass('dts DTS');

		// Add a 'loading' indicator
		if ( this.s.loadingIndicator )
		{
			this.dom.loader = $('<div class="dataTables_processing dts_loading">'+this.s.dt.oLanguage.sLoadingRecords+'</div>')
				.css('display', 'none');

			$(this.dom.scroller.parentNode)
				.css('position', 'relative')
				.append( this.dom.loader );
		}

		this.dom.label.appendTo(this.dom.scroller);

		/* Initial size calculations */
		if ( this.s.heights.row && this.s.heights.row != 'auto' )
		{
			this.s.autoHeight = false;
		}

		// Scrolling callback to see if a page change is needed
		this.s.ingnoreScroll = true;
		$(this.dom.scroller).on( 'scroll.dt-scroller', function (e) {
			that._scroll.call( that );
		} );

		// In iOS we catch the touchstart event in case the user tries to scroll
		// while the display is already scrolling
		$(this.dom.scroller).on('touchstart.dt-scroller', function () {
			that._scroll.call( that );
		} );

		$(this.dom.scroller)
			.on('mousedown.dt-scroller', function () {
				that.s.mousedown = true;
			})
			.on('mouseup.dt-scroller', function () {
				that.s.labelVisible = false;
				that.s.mousedown = false;
				that.dom.label.css('display', 'none');
			});

		// On resize, update the information element, since the number of rows shown might change
		$(window).on( 'resize.dt-scroller', function () {
			that.measure( false );
			that._info();
		} );

		// Add a state saving parameter to the DT state saving so we can restore the exact
		// position of the scrolling.
		var initialStateSave = true;
		var loadedState = dt.state.loaded();

		dt.on( 'stateSaveParams.scroller', function ( e, settings, data ) {
			if ( initialStateSave && loadedState ) {
				data.scroller = loadedState.scroller;
				initialStateSave = false;
			}
			else {
				// Need to used the saved position on init
				data.scroller = {
					topRow: that.s.topRowFloat,
					baseScrollTop: that.s.baseScrollTop,
					baseRowTop: that.s.baseRowTop,
					scrollTop: that.s.lastScrollTop
				};
			}
		} );

		if ( loadedState && loadedState.scroller ) {
			this.s.topRowFloat = loadedState.scroller.topRow;
			this.s.baseScrollTop = loadedState.scroller.baseScrollTop;
			this.s.baseRowTop = loadedState.scroller.baseRowTop;
		}

		this.measure( false );
	
		that.s.stateSaveThrottle = that.s.dt.oApi._fnThrottle( function () {
			that.s.dtApi.state.save();
		}, 500 );

		dt.on( 'init.scroller', function () {
			that.measure( false );

			// Setting to `jump` will instruct _draw to calculate the scroll top
			// position
			that.s.scrollType = 'jump';
			that._draw();

			// Update the scroller when the DataTable is redrawn
			dt.on( 'draw.scroller', function () {
				that._draw();
			});
		} );

		// Set height before the draw happens, allowing everything else to update
		// on draw complete without worry for roder.
		dt.on( 'preDraw.dt.scroller', function () {
			that._scrollForce();
		} );

		// Destructor
		dt.on( 'destroy.scroller', function () {
			$(window).off( 'resize.dt-scroller' );
			$(that.dom.scroller).off('.dt-scroller');
			$(that.s.dt.nTable).off( '.scroller' );

			$(that.s.dt.nTableWrapper).removeClass('DTS');
			$('div.DTS_Loading', that.dom.scroller.parentNode).remove();

			that.dom.table.style.position = "";
			that.dom.table.style.top = "";
			that.dom.table.style.left = "";
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Automatic calculation of table row height. This is just a little tricky here as using
	 * initialisation DataTables has tale the table out of the document, so we need to create
	 * a new table and insert it into the document, calculate the row height and then whip the
	 * table out.
	 *  @returns {void}
	 *  @private
	 */
	_calcRowHeight: function ()
	{
		var dt = this.s.dt;
		var origTable = dt.nTable;
		var nTable = origTable.cloneNode( false );
		var tbody = $('<tbody/>').appendTo( nTable );
		var container = $(
			'<div class="'+dt.oClasses.sWrapper+' DTS">'+
				'<div class="'+dt.oClasses.sScrollWrapper+'">'+
					'<div class="'+dt.oClasses.sScrollBody+'"></div>'+
				'</div>'+
			'</div>'
		);

		// Want 3 rows in the sizing table so :first-child and :last-child
		// CSS styles don't come into play - take the size of the middle row
		$('tbody tr:lt(4)', origTable).clone().appendTo( tbody );
        var rowsCount = $('tr', tbody).length;

        if ( rowsCount === 1 ) {
            tbody.prepend('<tr><td>&#160;</td></tr>');
            tbody.append('<tr><td>&#160;</td></tr>');
		}
		else {
            for (; rowsCount < 3; rowsCount++) {
                tbody.append('<tr><td>&#160;</td></tr>');
            }
		}
	
		$('div.'+dt.oClasses.sScrollBody, container).append( nTable );

		// If initialised using `dom`, use the holding element as the insert point
		var insertEl = this.s.dt.nHolding || origTable.parentNode;

		if ( ! $(insertEl).is(':visible') ) {
			insertEl = 'body';
		}

		// Remove form element links as they might select over others (particularly radio and checkboxes)
		container.find("input").removeAttr("name");

		container.appendTo( insertEl );
		this.s.heights.row = $('tr', tbody).eq(1).outerHeight();

		container.remove();
	},

	/**
	 * Draw callback function which is fired when the DataTable is redrawn. The main function of
	 * this method is to position the drawn table correctly the scrolling container for the rows
	 * that is displays as a result of the scrolling position.
	 *  @returns {void}
	 *  @private
	 */
	_draw: function ()
	{
		var
			that = this,
			heights = this.s.heights,
			iScrollTop = this.dom.scroller.scrollTop,
			iTableHeight = $(this.s.dt.nTable).height(),
			displayStart = this.s.dt._iDisplayStart,
			displayLen = this.s.dt._iDisplayLength,
			displayEnd = this.s.dt.fnRecordsDisplay();

		// Disable the scroll event listener while we are updating the DOM
		this.s.skip = true;

		// If paging is reset
		if ( (this.s.dt.bSorted || this.s.dt.bFiltered) && displayStart === 0 && !this.s.dt._drawHold ) {
			this.s.topRowFloat = 0;
		}

		iScrollTop = this.s.scrollType === 'jump' ?
			this._domain( 'virtualToPhysical', this.s.topRowFloat * heights.row ) :
			iScrollTop;

		// Store positional information so positional calculations can be based
		// upon the current table draw position
		this.s.baseScrollTop = iScrollTop;
		this.s.baseRowTop = this.s.topRowFloat;

		// Position the table in the virtual scroller
		var tableTop = iScrollTop - ((this.s.topRowFloat - displayStart) * heights.row);
		if ( displayStart === 0 ) {
			tableTop = 0;
		}
		else if ( displayStart + displayLen >= displayEnd ) {
			tableTop = heights.scroll - iTableHeight;
		}

		this.dom.table.style.top = tableTop+'px';

		/* Cache some information for the scroller */
		this.s.tableTop = tableTop;
		this.s.tableBottom = iTableHeight + this.s.tableTop;

		// Calculate the boundaries for where a redraw will be triggered by the
		// scroll event listener
		var boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;
		this.s.redrawTop = iScrollTop - boundaryPx;
		this.s.redrawBottom = iScrollTop + boundaryPx > heights.scroll - heights.viewport - heights.row ?
			heights.scroll - heights.viewport - heights.row :
			iScrollTop + boundaryPx;

		this.s.skip = false;

		// Restore the scrolling position that was saved by DataTable's state
		// saving Note that this is done on the second draw when data is Ajax
		// sourced, and the first draw when DOM soured
		if ( this.s.dt.oFeatures.bStateSave && this.s.dt.oLoadedState !== null &&
			 typeof this.s.dt.oLoadedState.scroller != 'undefined' )
		{
			// A quirk of DataTables is that the draw callback will occur on an
			// empty set if Ajax sourced, but not if server-side processing.
			var ajaxSourced = (this.s.dt.sAjaxSource || that.s.dt.ajax) && ! this.s.dt.oFeatures.bServerSide ?
				true :
				false;

			if ( ( ajaxSourced && this.s.dt.iDraw == 2) ||
			     (!ajaxSourced && this.s.dt.iDraw == 1) )
			{
				setTimeout( function () {
					$(that.dom.scroller).scrollTop( that.s.dt.oLoadedState.scroller.scrollTop );

					// In order to prevent layout thrashing we need another
					// small delay
					setTimeout( function () {
						that.s.ingnoreScroll = false;
					}, 0 );
				}, 0 );
			}
		}
		else {
			that.s.ingnoreScroll = false;
		}

		// Because of the order of the DT callbacks, the info update will
		// take precedence over the one we want here. So a 'thread' break is
		// needed.  Only add the thread break if bInfo is set
		if ( this.s.dt.oFeatures.bInfo ) {
			setTimeout( function () {
				that._info.call( that );
			}, 0 );
		}

		$(this.s.dt.nTable).triggerHandler('position.dts.dt', tableTop);

		// Hide the loading indicator
		if ( this.dom.loader && this.s.loaderVisible ) {
			this.dom.loader.css( 'display', 'none' );
			this.s.loaderVisible = false;
		}
	},

	/**
	 * Convert from one domain to another. The physical domain is the actual
	 * pixel count on the screen, while the virtual is if we had browsers which
	 * had scrolling containers of infinite height (i.e. the absolute value)
	 *
	 *  @param {string} dir Domain transform direction, `virtualToPhysical` or
	 *    `physicalToVirtual` 
	 *  @returns {number} Calculated transform
	 *  @private
	 */
	_domain: function ( dir, val )
	{
		var heights = this.s.heights;
		var diff;
		var magic = 10000; // the point at which the non-linear calculations start to happen

		// If the virtual and physical height match, then we use a linear
		// transform between the two, allowing the scrollbar to be linear
		if ( heights.virtual === heights.scroll ) {
			return val;
		}

		// In the first 10k pixels and the last 10k pixels, we want the scrolling
		// to be linear. After that it can be non-linear. It would be unusual for
		// anyone to mouse wheel through that much.
		if ( val < magic ) {
			return val;
		}
		else if ( dir === 'virtualToPhysical' && val >= heights.virtual - magic ) {
			diff = heights.virtual - val;
			return heights.scroll - diff;
		}
		else if ( dir === 'physicalToVirtual' && val >= heights.scroll - magic ) {
			diff = heights.scroll - val;
			return heights.virtual - diff;
		}

		// Otherwise, we want a non-linear scrollbar to take account of the
		// redrawing regions at the start and end of the table, otherwise these
		// can stutter badly - on large tables 30px (for example) scroll might
		// be hundreds of rows, so the table would be redrawing every few px at
		// the start and end. Use a simple linear eq. to stop this, effectively
		// causing a kink in the scrolling ratio. It does mean the scrollbar is
		// non-linear, but with such massive data sets, the scrollbar is going
		// to be a best guess anyway
		var m = (heights.virtual - magic - magic) / (heights.scroll - magic - magic);
		var c = magic - (m*magic);

		return dir === 'virtualToPhysical' ?
			(val-c) / m :
			(m*val) + c;
	},

	/**
	 * Update any information elements that are controlled by the DataTable based on the scrolling
	 * viewport and what rows are visible in it. This function basically acts in the same way as
	 * _fnUpdateInfo in DataTables, and effectively replaces that function.
	 *  @returns {void}
	 *  @private
	 */
	_info: function ()
	{
		if ( !this.s.dt.oFeatures.bInfo )
		{
			return;
		}

		var
			dt = this.s.dt,
			language = dt.oLanguage,
			iScrollTop = this.dom.scroller.scrollTop,
			iStart = Math.floor( this.pixelsToRow(iScrollTop, false, this.s.ani)+1 ),
			iMax = dt.fnRecordsTotal(),
			iTotal = dt.fnRecordsDisplay(),
			iPossibleEnd = Math.ceil( this.pixelsToRow(iScrollTop+this.s.heights.viewport, false, this.s.ani) ),
			iEnd = iTotal < iPossibleEnd ? iTotal : iPossibleEnd,
			sStart = dt.fnFormatNumber( iStart ),
			sEnd = dt.fnFormatNumber( iEnd ),
			sMax = dt.fnFormatNumber( iMax ),
			sTotal = dt.fnFormatNumber( iTotal ),
			sOut;

		if ( dt.fnRecordsDisplay() === 0 &&
			   dt.fnRecordsDisplay() == dt.fnRecordsTotal() )
		{
			/* Empty record set */
			sOut = language.sInfoEmpty+ language.sInfoPostFix;
		}
		else if ( dt.fnRecordsDisplay() === 0 )
		{
			/* Empty record set after filtering */
			sOut = language.sInfoEmpty +' '+
				language.sInfoFiltered.replace('_MAX_', sMax)+
					language.sInfoPostFix;
		}
		else if ( dt.fnRecordsDisplay() == dt.fnRecordsTotal() )
		{
			/* Normal record set */
			sOut = language.sInfo.
					replace('_START_', sStart).
					replace('_END_',   sEnd).
					replace('_MAX_',   sMax).
					replace('_TOTAL_', sTotal)+
				language.sInfoPostFix;
		}
		else
		{
			/* Record set after filtering */
			sOut = language.sInfo.
					replace('_START_', sStart).
					replace('_END_',   sEnd).
					replace('_MAX_',   sMax).
					replace('_TOTAL_', sTotal) +' '+
				language.sInfoFiltered.replace(
					'_MAX_',
					dt.fnFormatNumber(dt.fnRecordsTotal())
				)+
				language.sInfoPostFix;
		}

		var callback = language.fnInfoCallback;
		if ( callback ) {
			sOut = callback.call( dt.oInstance,
				dt, iStart, iEnd, iMax, iTotal, sOut
			);
		}

		var n = dt.aanFeatures.i;
		if ( typeof n != 'undefined' )
		{
			for ( var i=0, iLen=n.length ; i<iLen ; i++ )
			{
				$(n[i]).html( sOut );
			}
		}

		// DT doesn't actually (yet) trigger this event, but it will in future
		$(dt.nTable).triggerHandler( 'info.dt' );
	},

	/**
	 * Parse CSS height property string as number
	 *
	 * An attempt is made to parse the string as a number. Currently supported units are 'px',
	 * 'vh', and 'rem'. 'em' is partially supported; it works as long as the parent element's
	 * font size matches the body element. Zero is returned for unrecognized strings.
	 *  @param {string} cssHeight CSS height property string
	 *  @returns {number} height
	 *  @private
	 */
	_parseHeight: function(cssHeight) {
		var height;
		var matches = /^([+-]?(?:\d+(?:\.\d+)?|\.\d+))(px|em|rem|vh)$/.exec(cssHeight);

		if (matches === null) {
			return 0;
		}

		var value = parseFloat(matches[1]);
		var unit = matches[2];

		if ( unit === 'px' ) {
			height = value;
		}
		else if ( unit === 'vh' ) {
			height = ( value / 100 ) * $(window).height();
		}
		else if ( unit === 'rem' ) {
			height = value * parseFloat($(':root').css('font-size'));
		}
		else if ( unit === 'em' ) {
			height = value * parseFloat($('body').css('font-size'));
		}

		return height ?
			height :
			0;
	},

	/**
	 * Scrolling function - fired whenever the scrolling position is changed.
	 * This method needs to use the stored values to see if the table should be
	 * redrawn as we are moving towards the end of the information that is
	 * currently drawn or not. If needed, then it will redraw the table based on
	 * the new position.
	 *  @returns {void}
	 *  @private
	 */
	_scroll: function ()
	{
		var
			that = this,
			heights = this.s.heights,
			iScrollTop = this.dom.scroller.scrollTop,
			iTopRow;

		if ( this.s.skip ) {
			return;
		}

		if ( this.s.ingnoreScroll ) {
			return;
		}

		if ( iScrollTop === this.s.lastScrollTop ) {
			return;
		}

		/* If the table has been sorted or filtered, then we use the redraw that
		 * DataTables as done, rather than performing our own
		 */
		if ( this.s.dt.bFiltered || this.s.dt.bSorted ) {
			this.s.lastScrollTop = 0;
			return;
		}

		/* Update the table's information display for what is now in the viewport */
		this._info();

		/* We don't want to state save on every scroll event - that's heavy
		 * handed, so use a timeout to update the state saving only when the
		 * scrolling has finished
		 */
		clearTimeout( this.s.stateTO );
		this.s.stateTO = setTimeout( function () {
			that.s.dtApi.state.save();
		}, 250 );

		this.s.scrollType = Math.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport ?
			'jump' :
			'cont';

		this.s.topRowFloat = this.s.scrollType === 'cont' ?
			this.pixelsToRow( iScrollTop, false, false ) :
			this._domain( 'physicalToVirtual', iScrollTop ) / heights.row;

		if ( this.s.topRowFloat < 0 ) {
			this.s.topRowFloat = 0;
		}

		/* Check if the scroll point is outside the trigger boundary which would required
		 * a DataTables redraw
		 */
		if ( this.s.forceReposition || iScrollTop < this.s.redrawTop || iScrollTop > this.s.redrawBottom ) {
			var preRows = Math.ceil( ((this.s.displayBuffer-1)/2) * this.s.viewportRows );

			iTopRow = parseInt(this.s.topRowFloat, 10) - preRows;
			this.s.forceReposition = false;

			if ( iTopRow <= 0 ) {
				/* At the start of the table */
				iTopRow = 0;
			}
			else if ( iTopRow + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay() ) {
				/* At the end of the table */
				iTopRow = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;
				if ( iTopRow < 0 ) {
					iTopRow = 0;
				}
			}
			else if ( iTopRow % 2 !== 0 ) {
				// For the row-striping classes (odd/even) we want only to start
				// on evens otherwise the stripes will change between draws and
				// look rubbish
				iTopRow++;
			}

			// Store calcuated value, in case the following condition is not met, but so
			// that the draw function will still use it.
			this.s.targetTop = iTopRow;

			if ( iTopRow != this.s.dt._iDisplayStart ) {
				/* Cache the new table position for quick lookups */
				this.s.tableTop = $(this.s.dt.nTable).offset().top;
				this.s.tableBottom = $(this.s.dt.nTable).height() + this.s.tableTop;

				var draw = function () {
					that.s.dt._iDisplayStart = that.s.targetTop;
					that.s.dt.oApi._fnDraw( that.s.dt );
				};

				/* Do the DataTables redraw based on the calculated start point - note that when
				 * using server-side processing we introduce a small delay to not DoS the server...
				 */
				if ( this.s.dt.oFeatures.bServerSide ) {
					this.s.forceReposition = true;

					clearTimeout( this.s.drawTO );
					this.s.drawTO = setTimeout( draw, this.s.serverWait );
				}
				else {
					draw();
				}

				if ( this.dom.loader && ! this.s.loaderVisible ) {
					this.dom.loader.css( 'display', 'block' );
					this.s.loaderVisible = true;
				}
			}
		}
		else {
			this.s.topRowFloat = this.pixelsToRow( iScrollTop, false, true );
		}

		this.s.lastScrollTop = iScrollTop;
		this.s.stateSaveThrottle();

		if ( this.s.scrollType === 'jump' && this.s.mousedown ) {
			this.s.labelVisible = true;
		}
		if (this.s.labelVisible) {
			var labelFactor = (heights.viewport-heights.labelHeight - heights.xbar) / heights.scroll;

			this.dom.label
				.html( this.s.dt.fnFormatNumber( parseInt( this.s.topRowFloat, 10 )+1 ) )
				.css( 'top', iScrollTop + (iScrollTop * labelFactor) )
				.css( 'display', 'block' );
		}
	},

	/**
	 * Force the scrolling container to have height beyond that of just the
	 * table that has been drawn so the user can scroll the whole data set.
	 *
	 * Note that if the calculated required scrolling height exceeds a maximum
	 * value (1 million pixels - hard-coded) the forcing element will be set
	 * only to that maximum value and virtual / physical domain transforms will
	 * be used to allow Scroller to display tables of any number of records.
	 *  @returns {void}
	 *  @private
	 */
	_scrollForce: function ()
	{
		var heights = this.s.heights;
		var max = 1000000;

		heights.virtual = heights.row * this.s.dt.fnRecordsDisplay();
		heights.scroll = heights.virtual;

		if ( heights.scroll > max ) {
			heights.scroll = max;
		}

		// Minimum height so there is always a row visible (the 'no rows found'
		// if reduced to zero filtering)
		this.dom.force.style.height = heights.scroll > this.s.heights.row ?
			heights.scroll+'px' :
			this.s.heights.row+'px';
	}
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/**
 * Scroller default settings for initialisation
 *  @namespace
 *  @name Scroller.defaults
 *  @static
 */
Scroller.defaults = {
	/**
	 * Scroller uses the boundary scaling factor to decide when to redraw the table - which it
	 * typically does before you reach the end of the currently loaded data set (in order to
	 * allow the data to look continuous to a user scrolling through the data). If given as 0
	 * then the table will be redrawn whenever the viewport is scrolled, while 1 would not
	 * redraw the table until the currently loaded data has all been shown. You will want
	 * something in the middle - the default factor of 0.5 is usually suitable.
	 *  @type     float
	 *  @default  0.5
	 *  @static
	 */
	boundaryScale: 0.5,

	/**
	 * The display buffer is what Scroller uses to calculate how many rows it should pre-fetch
	 * for scrolling. Scroller automatically adjusts DataTables' display length to pre-fetch
	 * rows that will be shown in "near scrolling" (i.e. just beyond the current display area).
	 * The value is based upon the number of rows that can be displayed in the viewport (i.e.
	 * a value of 1), and will apply the display range to records before before and after the
	 * current viewport - i.e. a factor of 3 will allow Scroller to pre-fetch 1 viewport's worth
	 * of rows before the current viewport, the current viewport's rows and 1 viewport's worth
	 * of rows after the current viewport. Adjusting this value can be useful for ensuring
	 * smooth scrolling based on your data set.
	 *  @type     int
	 *  @default  7
	 *  @static
	 */
	displayBuffer: 9,

	/**
	 * Show (or not) the loading element in the background of the table. Note that you should
	 * include the dataTables.scroller.css file for this to be displayed correctly.
	 *  @type     boolean
	 *  @default  false
	 *  @static
	 */
	loadingIndicator: false,

	/**
	 * Scroller will attempt to automatically calculate the height of rows for it's internal
	 * calculations. However the height that is used can be overridden using this parameter.
	 *  @type     int|string
	 *  @default  auto
	 *  @static
	 */
	rowHeight: "auto",

	/**
	 * When using server-side processing, Scroller will wait a small amount of time to allow
	 * the scrolling to finish before requesting more data from the server. This prevents
	 * you from DoSing your own server! The wait time can be configured by this parameter.
	 *  @type     int
	 *  @default  200
	 *  @static
	 */
	serverWait: 200
};

Scroller.oDefaults = Scroller.defaults;



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Constants
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * Scroller version
 *  @type      String
 *  @default   See code
 *  @name      Scroller.version
 *  @static
 */
Scroller.version = "2.0.5";



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Initialisation
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.dtscroller', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.scroller;
	var defaults = DataTable.defaults.scroller;

	if ( init || defaults ) {
		var opts = $.extend( {}, init, defaults );

		if ( init !== false ) {
			new Scroller( settings, opts  );
		}
	}
} );


// Attach Scroller to DataTables so it can be accessed as an 'extra'
$.fn.dataTable.Scroller = Scroller;
$.fn.DataTable.Scroller = Scroller;


// DataTables 1.10 API method aliases
var Api = $.fn.dataTable.Api;

Api.register( 'scroller()', function () {
	return this;
} );

// Undocumented and deprecated - is it actually useful at all?
Api.register( 'scroller().rowToPixels()', function ( rowIdx, intParse, virtual ) {
	var ctx = this.context;

	if ( ctx.length && ctx[0].oScroller ) {
		return ctx[0].oScroller.rowToPixels( rowIdx, intParse, virtual );
	}
	// undefined
} );

// Undocumented and deprecated - is it actually useful at all?
Api.register( 'scroller().pixelsToRow()', function ( pixels, intParse, virtual ) {
	var ctx = this.context;

	if ( ctx.length && ctx[0].oScroller ) {
		return ctx[0].oScroller.pixelsToRow( pixels, intParse, virtual );
	}
	// undefined
} );

// `scroller().scrollToRow()` is undocumented and deprecated. Use `scroller.toPosition()
Api.register( ['scroller().scrollToRow()', 'scroller.toPosition()'], function ( idx, ani ) {
	this.iterator( 'table', function ( ctx ) {
		if ( ctx.oScroller ) {
			ctx.oScroller.scrollToRow( idx, ani );
		}
	} );

	return this;
} );

Api.register( 'row().scrollTo()', function ( ani ) {
	var that = this;

	this.iterator( 'row', function ( ctx, rowIdx ) {
		if ( ctx.oScroller ) {
			var displayIdx = that
				.rows( { order: 'applied', search: 'applied' } )
				.indexes()
				.indexOf( rowIdx );

			ctx.oScroller.scrollToRow( displayIdx, ani );
		}
	} );

	return this;
} );

Api.register( 'scroller.measure()', function ( redraw ) {
	this.iterator( 'table', function ( ctx ) {
		if ( ctx.oScroller ) {
			ctx.oScroller.measure( redraw );
		}
	} );

	return this;
} );

Api.register( 'scroller.page()', function() {
	var ctx = this.context;

	if ( ctx.length && ctx[0].oScroller ) {
		return ctx[0].oScroller.pageInfo();
	}
	// undefined
} );

return Scroller;
}));


/***/ }),

/***/ "./node_modules/datatables.net-searchbuilder-bs5/js/searchBuilder.bootstrap5.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/datatables.net-searchbuilder-bs5/js/searchBuilder.bootstrap5.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap 5 ui integration for DataTables' SearchBuilder
 * Â©2016 SpryMedia Ltd - datatables.net/license
 */
(function (factory) {
    if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net-bs5 */ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js"), __webpack_require__(/*! datatables.net-searchbuilder */ "./node_modules/datatables.net-searchbuilder/js/dataTables.searchBuilder.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
            return factory($);
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
}(function ($) {
    'use strict';
    var dataTable = $.fn.dataTable;
    $.extend(true, dataTable.SearchBuilder.classes, {
        clearAll: 'btn btn-light dtsb-clearAll'
    });
    $.extend(true, dataTable.Group.classes, {
        add: 'btn btn-light dtsb-add',
        clearGroup: 'btn btn-light dtsb-clearGroup',
        logic: 'btn btn-light dtsb-logic'
    });
    $.extend(true, dataTable.Criteria.classes, {
        condition: 'form-select dtsb-condition',
        data: 'dtsb-data form-select',
        "delete": 'btn btn-light dtsb-delete',
        input: 'form-control dtsb-input',
        left: 'btn btn-light dtsb-left',
        right: 'btn btn-light dtsb-right',
        select: 'form-select',
        value: 'dtsb-value'
    });
    return dataTable.searchPanes;
}));


/***/ }),

/***/ "./node_modules/datatables.net-searchbuilder/js/dataTables.searchBuilder.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/datatables.net-searchbuilder/js/dataTables.searchBuilder.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! SearchBuilder 1.2.1
 * Â©SpryMedia Ltd - datatables.net/license/mit
 */
(function () {
    'use strict';

    var $$2;
    var dataTable$2;
    // eslint-disable-next-line no-extra-parens
    var moment = window.moment;
    // eslint-disable-next-line no-extra-parens
    var luxon = window.luxon;
    /**
     * Sets the value of jQuery for use in the file
     *
     * @param jq the instance of jQuery to be set
     */
    function setJQuery$2(jq) {
        $$2 = jq;
        dataTable$2 = jq.fn.dataTable;
    }
    /**
     * The Criteria class is used within SearchBuilder to represent a search criteria
     */
    var Criteria = /** @class */ (function () {
        function Criteria(table, opts, topGroup, index, depth) {
            var _this = this;
            if (index === void 0) { index = 0; }
            if (depth === void 0) { depth = 1; }
            // Check that the required version of DataTables is included
            if (!dataTable$2 || !dataTable$2.versionCheck || !dataTable$2.versionCheck('1.10.0')) {
                throw new Error('SearchPane requires DataTables 1.10 or newer');
            }
            this.classes = $$2.extend(true, {}, Criteria.classes);
            // Get options from user and any extra conditions/column types defined by plug-ins
            this.c = $$2.extend(true, {}, Criteria.defaults, $$2.fn.dataTable.ext.searchBuilder, opts);
            var i18n = this.c.i18n;
            this.s = {
                condition: undefined,
                conditions: {},
                data: undefined,
                dataIdx: -1,
                dataPoints: [],
                dateFormat: false,
                depth: depth,
                dt: table,
                filled: false,
                index: index,
                origData: undefined,
                topGroup: topGroup,
                type: '',
                value: []
            };
            this.dom = {
                buttons: $$2('<div/>')
                    .addClass(this.classes.buttonContainer),
                condition: $$2('<select disabled/>')
                    .addClass(this.classes.condition)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.italic)
                    .attr('autocomplete', 'hacking'),
                conditionTitle: $$2('<option value="" disabled selected hidden/>')
                    .text(this.s.dt.i18n('searchBuilder.condition', i18n.condition)),
                container: $$2('<div/>')
                    .addClass(this.classes.container),
                data: $$2('<select/>')
                    .addClass(this.classes.data)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.italic),
                dataTitle: $$2('<option value="" disabled selected hidden/>')
                    .text(this.s.dt.i18n('searchBuilder.data', i18n.data)),
                defaultValue: $$2('<select disabled/>')
                    .addClass(this.classes.value)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.select),
                "delete": $$2('<button>&times</button>')
                    .addClass(this.classes["delete"])
                    .addClass(this.classes.button)
                    .attr('title', this.s.dt.i18n('searchBuilder.deleteTitle', i18n.deleteTitle))
                    .attr('type', 'button'),
                // eslint-disable-next-line no-useless-escape
                left: $$2('<button>\<</button>')
                    .addClass(this.classes.left)
                    .addClass(this.classes.button)
                    .attr('title', this.s.dt.i18n('searchBuilder.leftTitle', i18n.leftTitle))
                    .attr('type', 'button'),
                // eslint-disable-next-line no-useless-escape
                right: $$2('<button>\></button>')
                    .addClass(this.classes.right)
                    .addClass(this.classes.button)
                    .attr('title', this.s.dt.i18n('searchBuilder.rightTitle', i18n.rightTitle))
                    .attr('type', 'button'),
                value: [
                    $$2('<select disabled/>')
                        .addClass(this.classes.value)
                        .addClass(this.classes.dropDown)
                        .addClass(this.classes.italic)
                        .addClass(this.classes.select)
                ],
                valueTitle: $$2('<option value="--valueTitle--" selected/>')
                    .text(this.s.dt.i18n('searchBuilder.value', i18n.value))
            };
            // If the greyscale option is selected then add the class to add the grey colour to SearchBuilder
            if (this.c.greyscale) {
                this.dom.data.addClass(this.classes.greyscale);
                this.dom.condition.addClass(this.classes.greyscale);
                this.dom.defaultValue.addClass(this.classes.greyscale);
                for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                    var val = _a[_i];
                    val.addClass(this.classes.greyscale);
                }
            }
            // For responsive design, adjust the criterias properties on the following events
            this.s.dt.on('draw.dtsp', function () {
                _this._adjustCriteria();
            });
            this.s.dt.on('buttons-action', function () {
                _this._adjustCriteria();
            });
            $$2(window).on('resize.dtsp', dataTable$2.util.throttle(function () {
                _this._adjustCriteria();
            }));
            this._buildCriteria();
            return this;
        }
        /**
         * Adds the left button to the criteria
         */
        Criteria.prototype.updateArrows = function (hasSiblings, redraw) {
            if (hasSiblings === void 0) { hasSiblings = false; }
            if (redraw === void 0) { redraw = true; }
            // Empty the container and append all of the elements in the correct order
            this.dom.container.children().detach();
            this.dom.container
                .append(this.dom.data)
                .append(this.dom.condition)
                .append(this.dom.value[0]);
            this.setListeners();
            // Trigger the inserted events for the value elements as they are inserted
            if (this.dom.value[0] !== undefined) {
                this.dom.value[0].trigger('dtsb-inserted');
            }
            for (var i = 1; i < this.dom.value.length; i++) {
                this.dom.container.append(this.dom.value[i]);
                this.dom.value[i].trigger('dtsb-inserted');
            }
            // If this is a top level criteria then don't let it move left
            if (this.s.depth > 1) {
                this.dom.buttons.append(this.dom.left);
            }
            // If the depthLimit of the query has been hit then don't add the right button
            if ((this.c.depthLimit === false || this.s.depth < this.c.depthLimit) && hasSiblings) {
                this.dom.buttons.append(this.dom.right);
            }
            else {
                this.dom.right.remove();
            }
            this.dom.buttons.append(this.dom["delete"]);
            this.dom.container.append(this.dom.buttons);
            if (redraw) {
                // A different combination of arrows and selectors may lead to a need for responsive to be triggered
                this._adjustCriteria();
            }
        };
        /**
         * Destroys the criteria, removing listeners and container from the dom
         */
        Criteria.prototype.destroy = function () {
            // Turn off listeners
            this.dom.data.off('.dtsb');
            this.dom.condition.off('.dtsb');
            this.dom["delete"].off('.dtsb');
            for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                var val = _a[_i];
                val.off('.dtsb');
            }
            // Remove container from the dom
            this.dom.container.remove();
        };
        /**
         * Passes in the data for the row and compares it against this single criteria
         *
         * @param rowData The data for the row to be compared
         * @returns boolean Whether the criteria has passed
         */
        Criteria.prototype.search = function (rowData, rowIdx) {
            var condition = this.s.conditions[this.s.condition];
            if (this.s.condition !== undefined && condition !== undefined) {
                var filter = rowData[this.s.dataIdx];
                // This check is in place for if a custom decimal character is in place
                if (this.s.type.includes('num') &&
                    (this.s.dt.settings()[0].oLanguage.sDecimal !== '' ||
                        this.s.dt.settings()[0].oLanguage.sThousands !== '')) {
                    var splitRD = [rowData[this.s.dataIdx]];
                    if (this.s.dt.settings()[0].oLanguage.sDecimal !== '') {
                        splitRD = rowData[this.s.dataIdx].split(this.s.dt.settings()[0].oLanguage.sDecimal);
                    }
                    if (this.s.dt.settings()[0].oLanguage.sThousands !== '') {
                        for (var i = 0; i < splitRD.length; i++) {
                            splitRD[i] = splitRD[i].replace(this.s.dt.settings()[0].oLanguage.sThousands, ',');
                        }
                    }
                    filter = splitRD.join('.');
                }
                // If orthogonal data is in place we need to get it's values for searching
                if (this.c.orthogonal.search !== 'filter') {
                    var settings = this.s.dt.settings()[0];
                    filter = settings.oApi._fnGetCellData(settings, rowIdx, this.s.dataIdx, typeof this.c.orthogonal === 'string' ?
                        this.c.orthogonal :
                        this.c.orthogonal.search);
                }
                if (this.s.type === 'array') {
                    // Make sure we are working with an array
                    if (!Array.isArray(filter)) {
                        filter = [filter];
                    }
                    filter.sort();
                    for (var _i = 0, filter_1 = filter; _i < filter_1.length; _i++) {
                        var filt = filter_1[_i];
                        if (filt) {
                            filt = filt.replace(/[\r\n\u2028]/g, ' ');
                        }
                    }
                }
                else if (filter !== null) {
                    filter = filter.replace(/[\r\n\u2028]/g, ' ');
                }
                if (this.s.type.includes('html')) {
                    filter = filter.replace(/(<([^>]+)>)/ig, '');
                }
                // Not ideal, but jqueries .val() returns an empty string even
                // when the value set is null, so we shall assume the two are equal
                if (filter === null) {
                    filter = '';
                }
                return condition.search(filter, this.s.value, this);
            }
        };
        /**
         * Gets the details required to rebuild the criteria
         */
        Criteria.prototype.getDetails = function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            // This check is in place for if a custom decimal character is in place
            if (this.s.type !== null &&
                this.s.type.includes('num') &&
                (this.s.dt.settings()[0].oLanguage.sDecimal !== '' || this.s.dt.settings()[0].oLanguage.sThousands !== '')) {
                for (var i = 0; i < this.s.value.length; i++) {
                    var splitRD = [this.s.value[i].toString()];
                    if (this.s.dt.settings()[0].oLanguage.sDecimal !== '') {
                        splitRD = this.s.value[i].split(this.s.dt.settings()[0].oLanguage.sDecimal);
                    }
                    if (this.s.dt.settings()[0].oLanguage.sThousands !== '') {
                        for (var j = 0; j < splitRD.length; j++) {
                            splitRD[j] = splitRD[j].replace(this.s.dt.settings()[0].oLanguage.sThousands, ',');
                        }
                    }
                    this.s.value[i] = splitRD.join('.');
                }
            }
            else if (this.s.type !== null && deFormatDates) {
                if (this.s.type.includes('date') ||
                    this.s.type.includes('time')) {
                    for (var i = 0; i < this.s.value.length; i++) {
                        if (this.s.value[i].match(/^\d{4}-([0]\d|1[0-2])-([0-2]\d|3[01])$/g) === null) {
                            this.s.value[i] = '';
                        }
                    }
                }
                else if (this.s.type.includes('moment')) {
                    for (var i = 0; i < this.s.value.length; i++) {
                        this.s.value[i] = moment(this.s.value[i], this.s.dateFormat).toISOString();
                    }
                }
                else if (this.s.type.includes('luxon')) {
                    for (var i = 0; i < this.s.value.length; i++) {
                        this.s.value[i] = luxon.DateTime.fromFormat(this.s.value[i], this.s.dateFormat).toISO();
                    }
                }
            }
            if (this.s.type.includes('num') && this.s.dt.page.info().serverSide) {
                for (var i = 0; i < this.s.value.length; i++) {
                    this.s.value[i] = this.s.value[i].replace(/[^0-9.]/g, '');
                }
            }
            return {
                condition: this.s.condition,
                data: this.s.data,
                origData: this.s.origData,
                type: this.s.type,
                value: this.s.value.map(function (a) { return a.toString(); })
            };
        };
        /**
         * Getter for the node for the container of the criteria
         *
         * @returns JQuery<HTMLElement> the node for the container
         */
        Criteria.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * Populates the criteria data, condition and value(s) as far as has been selected
         */
        Criteria.prototype.populate = function () {
            this._populateData();
            // If the column index has been found attempt to select a condition
            if (this.s.dataIdx !== -1) {
                this._populateCondition();
                // If the condittion has been found attempt to select the values
                if (this.s.condition !== undefined) {
                    this._populateValue();
                }
            }
        };
        /**
         * Rebuilds the criteria based upon the details passed in
         *
         * @param loadedCriteria the details required to rebuild the criteria
         */
        Criteria.prototype.rebuild = function (loadedCriteria) {
            // Check to see if the previously selected data exists, if so select it
            var foundData = false;
            var dataIdx;
            this._populateData();
            // If a data selection has previously been made attempt to find and select it
            if (loadedCriteria.data !== undefined) {
                var italic_1 = this.classes.italic;
                var data_1 = this.dom.data;
                this.dom.data.children('option').each(function () {
                    if ($$2(this).text() === loadedCriteria.data) {
                        $$2(this).prop('selected', true);
                        data_1.removeClass(italic_1);
                        foundData = true;
                        dataIdx = $$2(this).val();
                    }
                    else {
                        $$2(this).removeProp('selected');
                    }
                });
            }
            // If the data has been found and selected then the condition can be populated and searched
            if (foundData) {
                this.s.data = loadedCriteria.data;
                this.s.origData = loadedCriteria.origData;
                this.s.dataIdx = dataIdx;
                this.c.orthogonal = this._getOptions().orthogonal;
                this.dom.dataTitle.remove();
                this._populateCondition();
                this.dom.conditionTitle.remove();
                var condition = void 0;
                // Check to see if the previously selected condition exists, if so select it
                var options = this.dom.condition.children('option');
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < options.length; i++) {
                    var option = $$2(options[i]);
                    if (loadedCriteria.condition !== undefined &&
                        option.val() === loadedCriteria.condition &&
                        typeof loadedCriteria.condition === 'string') {
                        option.prop('selected', true);
                        condition = option.val();
                    }
                    else {
                        option.removeProp('selected');
                    }
                }
                this.s.condition = condition;
                // If the condition has been found and selected then the value can be populated and searched
                if (this.s.condition !== undefined) {
                    this.dom.conditionTitle.removeProp('selected');
                    this.dom.conditionTitle.remove();
                    this.dom.condition.removeClass(this.classes.italic);
                    // eslint-disable-next-line @typescript-eslint/prefer-for-of
                    for (var i = 0; i < options.length; i++) {
                        var option = $$2(options[i]);
                        if (option.val() !== this.s.condition) {
                            option.removeProp('selected');
                        }
                    }
                    this._populateValue(loadedCriteria);
                }
                else {
                    this.dom.conditionTitle.prependTo(this.dom.condition).prop('selected', true);
                }
            }
        };
        /**
         * Sets the listeners for the criteria
         */
        Criteria.prototype.setListeners = function () {
            var _this = this;
            this.dom.data
                .unbind('change')
                .on('change', function () {
                _this.dom.dataTitle.removeProp('selected');
                // Need to go over every option to identify the correct selection
                var options = _this.dom.data.children('option.' + _this.classes.option);
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < options.length; i++) {
                    var option = $$2(options[i]);
                    if (option.val() === _this.dom.data.val()) {
                        _this.dom.data.removeClass(_this.classes.italic);
                        option.prop('selected', true);
                        _this.s.dataIdx = +option.val();
                        _this.s.data = option.text();
                        _this.s.origData = option.prop('origData');
                        _this.c.orthogonal = _this._getOptions().orthogonal;
                        // When the data is changed, the values in condition and
                        // value may also change so need to renew them
                        _this._clearCondition();
                        _this._clearValue();
                        _this._populateCondition();
                        // If this criteria was previously active in the search then
                        // remove it from the search and trigger a new search
                        if (_this.s.filled) {
                            _this.s.filled = false;
                            _this.s.dt.draw();
                            _this.setListeners();
                        }
                        _this.s.dt.state.save();
                    }
                    else {
                        option.removeProp('selected');
                    }
                }
            });
            this.dom.condition
                .unbind('change')
                .on('change', function () {
                _this.dom.conditionTitle.removeProp('selected');
                // Need to go over every option to identify the correct selection
                var options = _this.dom.condition.children('option.' + _this.classes.option);
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < options.length; i++) {
                    var option = $$2(options[i]);
                    if (option.val() === _this.dom.condition.val()) {
                        _this.dom.condition.removeClass(_this.classes.italic);
                        option.prop('selected', true);
                        var condDisp = option.val();
                        // Find the condition that has been selected and store it internally
                        for (var _i = 0, _a = Object.keys(_this.s.conditions); _i < _a.length; _i++) {
                            var cond = _a[_i];
                            if (cond === condDisp) {
                                _this.s.condition = condDisp;
                                break;
                            }
                        }
                        // When the condition is changed, the value selector may switch between
                        // a select element and an input element
                        _this._clearValue();
                        _this._populateValue();
                        for (var _b = 0, _c = _this.dom.value; _b < _c.length; _b++) {
                            var val = _c[_b];
                            // If this criteria was previously active in the search then remove
                            // it from the search and trigger a new search
                            if (_this.s.filled && val !== undefined && _this.dom.container.has(val[0]).length !== 0) {
                                _this.s.filled = false;
                                _this.s.dt.draw();
                                _this.setListeners();
                            }
                        }
                        if (_this.dom.value.length === 0 ||
                            _this.dom.value.length === 1 && _this.dom.value[0] === undefined) {
                            _this.s.dt.draw();
                        }
                    }
                    else {
                        option.removeProp('selected');
                    }
                }
            });
        };
        /**
         * Adjusts the criteria to make SearchBuilder responsive
         */
        Criteria.prototype._adjustCriteria = function () {
            // If this criteria is not present then don't bother adjusting it
            if ($$2(document).has(this.dom.container).length === 0) {
                return;
            }
            var valRight;
            var valWidth;
            var outmostval = this.dom.value[this.dom.value.length - 1];
            // Calculate the width and right value of the outmost value element
            if (outmostval !== undefined && this.dom.container.has(outmostval[0]).length !== 0) {
                valWidth = outmostval.outerWidth(true);
                valRight = outmostval.offset().left + valWidth;
            }
            else {
                return;
            }
            var leftOffset = this.dom.left.offset();
            var rightOffset = this.dom.right.offset();
            var clearOffset = this.dom["delete"].offset();
            var hasLeft = this.dom.container.has(this.dom.left[0]).length !== 0;
            var hasRight = this.dom.container.has(this.dom.right[0]).length !== 0;
            var buttonsLeft = hasLeft ?
                leftOffset.left :
                hasRight ?
                    rightOffset.left :
                    clearOffset.left;
            // Perform the responsive calculations and redraw where necessary
            if ((buttonsLeft - valRight < 15 ||
                hasLeft && leftOffset.top !== clearOffset.top ||
                hasRight && rightOffset.top !== clearOffset.top) &&
                !this.dom.container.parent().hasClass(this.classes.vertical)) {
                this.dom.container.parent().addClass(this.classes.vertical);
                this.s.topGroup.trigger('dtsb-redrawContents');
            }
            else if (buttonsLeft -
                (this.dom.data.offset().left +
                    this.dom.data.outerWidth(true) +
                    this.dom.condition.outerWidth(true) +
                    valWidth) > 15
                && this.dom.container.parent().hasClass(this.classes.vertical)) {
                this.dom.container.parent().removeClass(this.classes.vertical);
                this.s.topGroup.trigger('dtsb-redrawContents');
            }
        };
        /**
         * Builds the elements of the dom together
         */
        Criteria.prototype._buildCriteria = function () {
            // Append Titles for select elements
            this.dom.data.append(this.dom.dataTitle);
            this.dom.condition.append(this.dom.conditionTitle);
            // Add elements to container
            this.dom.container
                .append(this.dom.data)
                .append(this.dom.condition);
            for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                var val = _a[_i];
                val.append(this.dom.valueTitle);
                this.dom.container.append(val);
            }
            // Add buttons to container
            this.dom.container
                .append(this.dom["delete"])
                .append(this.dom.right);
            this.setListeners();
        };
        /**
         * Clears the condition select element
         */
        Criteria.prototype._clearCondition = function () {
            this.dom.condition.empty();
            this.dom.conditionTitle.prop('selected', true).attr('disabled', 'true');
            this.dom.condition.prepend(this.dom.conditionTitle).prop('selectedIndex', 0);
            this.s.conditions = {};
            this.s.condition = undefined;
        };
        /**
         * Clears the value elements
         */
        Criteria.prototype._clearValue = function () {
            if (this.s.condition !== undefined) {
                if (this.dom.value.length > 0 && this.dom.value[0] !== undefined) {
                    var _loop_1 = function (val) {
                        if (val !== undefined) {
                            // Timeout is annoying but because of IOS
                            setTimeout(function () {
                                val.remove();
                            }, 50);
                        }
                    };
                    // Remove all of the value elements
                    for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                        var val = _a[_i];
                        _loop_1(val);
                    }
                }
                // Call the init function to get the value elements for this condition
                this.dom.value = [].concat(this.s.conditions[this.s.condition].init(this, Criteria.updateListener));
                if (this.dom.value.length > 0 && this.dom.value[0] !== undefined) {
                    this.dom.value[0].insertAfter(this.dom.condition).trigger('dtsb-inserted');
                    // Insert all of the value elements
                    for (var i = 1; i < this.dom.value.length; i++) {
                        this.dom.value[i].insertAfter(this.dom.value[i - 1]).trigger('dtsb-inserted');
                    }
                }
            }
            else {
                var _loop_2 = function (val) {
                    if (val !== undefined) {
                        // Timeout is annoying but because of IOS
                        setTimeout(function () {
                            val.remove();
                        }, 50);
                    }
                };
                // Remove all of the value elements
                for (var _b = 0, _c = this.dom.value; _b < _c.length; _b++) {
                    var val = _c[_b];
                    _loop_2(val);
                }
                // Append the default valueTitle to the default select element
                this.dom.valueTitle
                    .prop('selected', true);
                this.dom.defaultValue
                    .append(this.dom.valueTitle)
                    .insertAfter(this.dom.condition);
            }
            this.s.value = [];
            this.dom.value = [
                $$2('<select disabled/>')
                    .addClass(this.classes.value)
                    .addClass(this.classes.dropDown)
                    .addClass(this.classes.italic)
                    .addClass(this.classes.select)
                    .append(this.dom.valueTitle.clone())
            ];
        };
        /**
         * Gets the options for the column
         *
         * @returns {object} The options for the column
         */
        Criteria.prototype._getOptions = function () {
            var table = this.s.dt;
            return $$2.extend(true, {}, Criteria.defaults, table.settings()[0].aoColumns[this.s.dataIdx].searchBuilder);
        };
        /**
         * Populates the condition dropdown
         */
        Criteria.prototype._populateCondition = function () {
            var conditionOpts = [];
            var conditionsLength = Object.keys(this.s.conditions).length;
            // If there are no conditions stored then we need to get them from the appropriate type
            if (conditionsLength === 0) {
                var column = +this.dom.data.children('option:selected').val();
                this.s.type = this.s.dt.columns().type().toArray()[column];
                var colInits = this.s.dt.settings()[0].aoColumns;
                if (colInits !== undefined) {
                    var colInit = colInits[column];
                    if (colInit.searchBuilderType !== undefined && colInit.searchBuilderType !== null) {
                        this.s.type = colInit.searchBuilderType;
                    }
                    else if (this.s.type === undefined || this.s.type === null) {
                        this.s.type = colInit.sType;
                    }
                }
                // If the column type is still unknown, call a draw to try reading it again
                if (this.s.type === null || this.s.type === undefined) {
                    $$2.fn.dataTable.ext.oApi._fnColumnTypes(this.s.dt.settings()[0]);
                    this.s.type = this.s.dt.columns().type().toArray()[column];
                }
                // Enable the condition element
                this.dom.condition
                    .removeAttr('disabled')
                    .empty()
                    .append(this.dom.conditionTitle)
                    .addClass(this.classes.italic);
                this.dom.conditionTitle
                    .prop('selected', true);
                var decimal = this.s.dt.settings()[0].oLanguage.sDecimal;
                // This check is in place for if a custom decimal character is in place
                if (decimal !== '' && this.s.type.indexOf(decimal) === this.s.type.length - decimal.length) {
                    if (this.s.type.includes('num-fmt')) {
                        this.s.type = this.s.type.replace(decimal, '');
                    }
                    else if (this.s.type.includes('num')) {
                        this.s.type = this.s.type.replace(decimal, '');
                    }
                }
                // Select which conditions are going to be used based on the column type
                var conditionObj = this.c.conditions[this.s.type] !== undefined ?
                    this.c.conditions[this.s.type] :
                    this.s.type.includes('moment') ?
                        this.c.conditions.moment :
                        this.s.type.includes('luxon') ?
                            this.c.conditions.luxon :
                            this.c.conditions.string;
                // If it is a moment format then extract the date format
                if (this.s.type.includes('moment')) {
                    this.s.dateFormat = this.s.type.replace(/moment-/g, '');
                }
                else if (this.s.type.includes('luxon')) {
                    this.s.dateFormat = this.s.type.replace(/luxon-/g, '');
                }
                // Add all of the conditions to the select element
                for (var _i = 0, _a = Object.keys(conditionObj); _i < _a.length; _i++) {
                    var condition = _a[_i];
                    if (conditionObj[condition] !== null) {
                        // Serverside processing does not supply the options for the select elements
                        // Instead input elements need to be used for these instead
                        if (this.s.dt.page.info().serverSide && conditionObj[condition].init === Criteria.initSelect) {
                            conditionObj[condition].init = Criteria.initInput;
                            conditionObj[condition].inputValue = Criteria.inputValueInput;
                            conditionObj[condition].isInputValid = Criteria.isInputValidInput;
                        }
                        this.s.conditions[condition] = conditionObj[condition];
                        var condName = conditionObj[condition].conditionName;
                        if (typeof condName === 'function') {
                            condName = condName(this.s.dt, this.c.i18n);
                        }
                        conditionOpts.push($$2('<option>', {
                            text: condName,
                            value: condition
                        })
                            .addClass(this.classes.option)
                            .addClass(this.classes.notItalic));
                    }
                }
            }
            // Otherwise we can just load them in
            else if (conditionsLength > 0) {
                this.dom.condition.empty().removeAttr('disabled').addClass(this.classes.italic);
                for (var _b = 0, _c = Object.keys(this.s.conditions); _b < _c.length; _b++) {
                    var condition = _c[_b];
                    var condName = this.s.conditions[condition].conditionName;
                    if (typeof condName === 'function') {
                        condName = condName(this.s.dt, this.c.i18n);
                    }
                    var newOpt = $$2('<option>', {
                        text: condName,
                        value: condition
                    })
                        .addClass(this.classes.option)
                        .addClass(this.classes.notItalic);
                    if (this.s.condition !== undefined && this.s.condition === condName) {
                        newOpt.prop('selected', true);
                        this.dom.condition.removeClass(this.classes.italic);
                    }
                    conditionOpts.push(newOpt);
                }
            }
            else {
                this.dom.condition
                    .attr('disabled', 'true')
                    .addClass(this.classes.italic);
                return;
            }
            for (var _d = 0, conditionOpts_1 = conditionOpts; _d < conditionOpts_1.length; _d++) {
                var opt = conditionOpts_1[_d];
                this.dom.condition.append(opt);
            }
            this.dom.condition.prop('selectedIndex', 0);
        };
        /**
         * Populates the data select element
         */
        Criteria.prototype._populateData = function () {
            var _this = this;
            this.dom.data.empty().append(this.dom.dataTitle);
            // If there are no datas stored then we need to get them from the table
            if (this.s.dataPoints.length === 0) {
                this.s.dt.columns().every(function (index) {
                    // Need to check that the column can be filtered on before adding it
                    if (_this.c.columns === true ||
                        _this.s.dt.columns(_this.c.columns).indexes().toArray().includes(index)) {
                        var found = false;
                        for (var _i = 0, _a = _this.s.dataPoints; _i < _a.length; _i++) {
                            var val = _a[_i];
                            if (val.index === index) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            var col = _this.s.dt.settings()[0].aoColumns[index];
                            var opt = {
                                index: index,
                                origData: col.data,
                                text: (col.searchBuilderTitle === undefined ?
                                    col.sTitle :
                                    col.searchBuilderTitle).replace(/(<([^>]+)>)/ig, '')
                            };
                            _this.s.dataPoints.push(opt);
                            _this.dom.data.append($$2('<option>', {
                                text: opt.text,
                                value: opt.index
                            })
                                .addClass(_this.classes.option)
                                .addClass(_this.classes.notItalic)
                                .prop('origData', col.data)
                                .prop('selected', _this.s.dataIdx === opt.index ? true : false));
                            if (_this.s.dataIdx === opt.index) {
                                _this.dom.dataTitle.removeProp('selected');
                            }
                        }
                    }
                });
            }
            // Otherwise we can just load them in
            else {
                var _loop_3 = function (data) {
                    this_1.s.dt.columns().every(function (index) {
                        var col = _this.s.dt.settings()[0].aoColumns[index];
                        if ((col.searchBuilderTitle === undefined ?
                            col.sTitle :
                            col.searchBuilderTitle).replace(/(<([^>]+)>)/ig, '') === data.text) {
                            data.index = index;
                            data.origData = col.data;
                        }
                    });
                    var newOpt = $$2('<option>', {
                        text: data.text.replace(/(<([^>]+)>)/ig, ''),
                        value: data.index
                    })
                        .addClass(this_1.classes.option)
                        .addClass(this_1.classes.notItalic)
                        .prop('origData', data.origData);
                    if (this_1.s.data === data.text) {
                        this_1.s.dataIdx = data.index;
                        this_1.dom.dataTitle.removeProp('selected');
                        newOpt.prop('selected', true);
                        this_1.dom.data.removeClass(this_1.classes.italic);
                    }
                    this_1.dom.data.append(newOpt);
                };
                var this_1 = this;
                for (var _i = 0, _a = this.s.dataPoints; _i < _a.length; _i++) {
                    var data = _a[_i];
                    _loop_3(data);
                }
            }
        };
        /**
         * Populates the Value select element
         *
         * @param loadedCriteria optional, used to reload criteria from predefined filters
         */
        Criteria.prototype._populateValue = function (loadedCriteria) {
            var _this = this;
            var prevFilled = this.s.filled;
            this.s.filled = false;
            // Remove any previous value elements
            // Timeout is annoying but because of IOS
            setTimeout(function () {
                _this.dom.defaultValue.remove();
            }, 50);
            var _loop_4 = function (val) {
                // Timeout is annoying but because of IOS
                setTimeout(function () {
                    if (val !== undefined) {
                        val.remove();
                    }
                }, 50);
            };
            for (var _i = 0, _a = this.dom.value; _i < _a.length; _i++) {
                var val = _a[_i];
                _loop_4(val);
            }
            var children = this.dom.container.children();
            if (children.length > 3) {
                for (var i = 2; i < children.length - 1; i++) {
                    $$2(children[i]).remove();
                }
            }
            // Find the column with the title matching the data for the criteria and take note of the index
            if (loadedCriteria !== undefined) {
                this.s.dt.columns().every(function (index) {
                    if (_this.s.dt.settings()[0].aoColumns[index].sTitle === loadedCriteria.data) {
                        _this.s.dataIdx = index;
                    }
                });
            }
            // Initialise the value elements based on the condition
            this.dom.value = [].concat(this.s.conditions[this.s.condition].init(this, Criteria.updateListener, loadedCriteria !== undefined ? loadedCriteria.value : undefined));
            if (loadedCriteria !== undefined && loadedCriteria.value !== undefined) {
                this.s.value = loadedCriteria.value;
            }
            // Insert value elements and trigger the inserted event
            if (this.dom.value[0] !== undefined) {
                this.dom.value[0]
                    .insertAfter(this.dom.condition)
                    .trigger('dtsb-inserted');
            }
            for (var i = 1; i < this.dom.value.length; i++) {
                this.dom.value[i]
                    .insertAfter(this.dom.value[i - 1])
                    .trigger('dtsb-inserted');
            }
            // Check if the criteria can be used in a search
            this.s.filled = this.s.conditions[this.s.condition].isInputValid(this.dom.value, this);
            this.setListeners();
            // If it can and this is different to before then trigger a draw
            if (prevFilled !== this.s.filled) {
                this.s.dt.draw();
                this.setListeners();
            }
        };
        /**
         * Provides throttling capabilities to SearchBuilder without having to use dt's _fnThrottle function
         * This is because that function is not quite suitable for our needs as it runs initially rather than waiting
         *
         * @param args arguments supplied to the throttle function
         * @returns Function that is to be run that implements the throttling
         */
        Criteria.prototype._throttle = function (fn, frequency) {
            if (frequency === void 0) { frequency = 200; }
            var last = null;
            var timer = null;
            var that = this;
            if (frequency === null) {
                frequency = 200;
            }
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var now = +new Date();
                if (last !== null && now < last + frequency) {
                    clearTimeout(timer);
                }
                else {
                    last = now;
                }
                timer = setTimeout(function () {
                    last = null;
                    fn.apply(that, args);
                }, frequency);
            };
        };
        Criteria.version = '1.1.0';
        Criteria.classes = {
            button: 'dtsb-button',
            buttonContainer: 'dtsb-buttonContainer',
            condition: 'dtsb-condition',
            container: 'dtsb-criteria',
            data: 'dtsb-data',
            "delete": 'dtsb-delete',
            dropDown: 'dtsb-dropDown',
            greyscale: 'dtsb-greyscale',
            input: 'dtsb-input',
            italic: 'dtsb-italic',
            joiner: 'dtsp-joiner',
            left: 'dtsb-left',
            notItalic: 'dtsb-notItalic',
            option: 'dtsb-option',
            right: 'dtsb-right',
            select: 'dtsb-select',
            value: 'dtsb-value',
            vertical: 'dtsb-vertical'
        };
        /**
         * Default initialisation function for select conditions
         */
        Criteria.initSelect = function (that, fn, preDefined, array) {
            if (preDefined === void 0) { preDefined = null; }
            if (array === void 0) { array = false; }
            var column = that.dom.data.children('option:selected').val();
            var indexArray = that.s.dt.rows().indexes().toArray();
            var settings = that.s.dt.settings()[0];
            // Declare select element to be used with all of the default classes and listeners.
            var el = $$2('<select/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.dropDown)
                .addClass(Criteria.classes.italic)
                .addClass(Criteria.classes.select)
                .append(that.dom.valueTitle)
                .on('change', function () {
                $$2(this).removeClass(Criteria.classes.italic);
                fn(that, this);
            });
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            var added = [];
            var options = [];
            // Add all of the options from the table to the select element.
            // Only add one option for each possible value
            for (var _i = 0, indexArray_1 = indexArray; _i < indexArray_1.length; _i++) {
                var index = indexArray_1[_i];
                var filter = settings.oApi._fnGetCellData(settings, index, column, typeof that.c.orthogonal === 'string' ?
                    that.c.orthogonal :
                    that.c.orthogonal.search);
                var value = {
                    filter: typeof filter === 'string' ?
                        filter.replace(/[\r\n\u2028]/g, ' ') : // Need to replace certain characters to match search values
                        filter,
                    index: index,
                    text: settings.oApi._fnGetCellData(settings, index, column, typeof that.c.orthogonal === 'string' ?
                        that.c.orthogonal :
                        that.c.orthogonal.display)
                };
                // If we are dealing with an array type, either make sure we are working with arrays, or sort them
                if (that.s.type === 'array') {
                    value.filter = !Array.isArray(value.filter) ?
                        [value.filter] :
                        value.filter = value.filter.sort();
                    value.text = !Array.isArray(value.text) ?
                        [value.text] :
                        value.text = value.text.sort();
                }
                // Function to add an option to the select element
                var addOption = function (filt, text) {
                    // Add text and value, stripping out any html if that is the column type
                    var opt = $$2('<option>', {
                        type: Array.isArray(filt) ? 'Array' : 'String',
                        value: that.s.type.includes('html') && filt !== null && typeof filt === 'string' ?
                            filt.replace(/(<([^>]+)>)/ig, '') :
                            filt
                    })
                        .addClass(that.classes.option)
                        .addClass(that.classes.notItalic)
                        // Have to add the text this way so that special html characters are not escaped - &amp; etc.
                        .html(typeof text === 'string' ?
                        text.replace(/(<([^>]+)>)/ig, '') :
                        text);
                    var val = opt.val();
                    // Check that this value has not already been added
                    if (added.indexOf(val) === -1) {
                        added.push(val);
                        options.push(opt);
                        if (preDefined !== null && Array.isArray(preDefined[0])) {
                            preDefined[0] = preDefined[0].sort().join(',');
                        }
                        // If this value was previously selected as indicated by preDefined, then select it again
                        if (preDefined !== null && opt.val() === preDefined[0]) {
                            opt.prop('selected', true);
                            el.removeClass(Criteria.classes.italic);
                        }
                    }
                };
                // If this is to add the individual values within the array we need to loop over the array
                if (array) {
                    for (var i = 0; i < value.filter.length; i++) {
                        addOption(value.filter[i], value.text[i]);
                    }
                }
                // Otherwise the value that is in the cell is to be added
                else {
                    addOption(value.filter, value.text);
                }
            }
            options.sort(function (a, b) {
                if (that.s.type === 'array' ||
                    that.s.type === 'string' ||
                    that.s.type === 'html') {
                    if (a.val() < b.val()) {
                        return -1;
                    }
                    else if (a.val() > b.val()) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
                else if (that.s.type === 'num' ||
                    that.s.type === 'html-num') {
                    if (+a.val().replace(/(<([^>]+)>)/ig, '') < +b.val().replace(/(<([^>]+)>)/ig, '')) {
                        return -1;
                    }
                    else if (+a.val().replace(/(<([^>]+)>)/ig, '') > +b.val().replace(/(<([^>]+)>)/ig, '')) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
                else if (that.s.type === 'num-fmt' || that.s.type === 'html-num-fmt') {
                    if (+a.val().replace(/[^0-9.]/g, '') < +b.val().replace(/[^0-9.]/g, '')) {
                        return -1;
                    }
                    else if (+a.val().replace(/[^0-9.]/g, '') > +b.val().replace(/[^0-9.]/g, '')) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            });
            for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
                var opt = options_1[_a];
                el.append(opt);
            }
            return el;
        };
        /**
         * Default initialisation function for select array conditions
         *
         * This exists because there needs to be different select functionality for contains/without and equals/not
         */
        Criteria.initSelectArray = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            return Criteria.initSelect(that, fn, preDefined, true);
        };
        /**
         * Default initialisation function for input conditions
         */
        Criteria.initInput = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            // Declare the input element
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            var el = $$2('<input/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.input)
                .on('input keypress', that._throttle(function (e) {
                var code = e.keyCode || e.which;
                if (!that.c.enterSearch &&
                    !(that.s.dt.settings()[0].oInit.search !== undefined &&
                        that.s.dt.settings()[0].oInit.search["return"]) ||
                    code === 13) {
                    return fn(that, this);
                }
            }, searchDelay === null ? 100 : searchDelay));
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            // If there is a preDefined value then add it
            if (preDefined !== null) {
                el.val(preDefined[0]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return el;
        };
        /**
         * Default initialisation function for conditions requiring 2 inputs
         */
        Criteria.init2Input = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            // Declare all of the necessary jQuery elements
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            var els = [
                $$2('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .on('input keypress', that._throttle(function (e) {
                    var code = e.keyCode || e.which;
                    if (!that.c.enterSearch &&
                        !(that.s.dt.settings()[0].oInit.search !== undefined &&
                            that.s.dt.settings()[0].oInit.search["return"]) ||
                        code === 13) {
                        return fn(that, this);
                    }
                }, searchDelay === null ? 100 : searchDelay)),
                $$2('<span>')
                    .addClass(that.classes.joiner)
                    .text(that.s.dt.i18n('searchBuilder.valueJoiner', that.c.i18n.valueJoiner)),
                $$2('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .on('input keypress', that._throttle(function (e) {
                    var code = e.keyCode || e.which;
                    if (!that.c.enterSearch &&
                        !(that.s.dt.settings()[0].oInit.search !== undefined &&
                            that.s.dt.settings()[0].oInit.search["return"]) ||
                        code === 13) {
                        return fn(that, this);
                    }
                }, searchDelay === null ? 100 : searchDelay))
            ];
            if (that.c.greyscale) {
                els[0].addClass(Criteria.classes.greyscale);
                els[2].addClass(Criteria.classes.greyscale);
            }
            // If there is a preDefined value then add it
            if (preDefined !== null) {
                els[0].val(preDefined[0]);
                els[2].val(preDefined[1]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return els;
        };
        /**
         * Default initialisation function for date conditions
         */
        Criteria.initDate = function (that, fn, preDefined) {
            if (preDefined === void 0) { preDefined = null; }
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            // Declare date element using DataTables dateTime plugin
            var el = $$2('<input/>')
                .addClass(Criteria.classes.value)
                .addClass(Criteria.classes.input)
                .dtDateTime({
                attachTo: 'input',
                format: that.s.dateFormat ? that.s.dateFormat : undefined
            })
                .on('change', that._throttle(function () {
                return fn(that, this);
            }, searchDelay === null ? 100 : searchDelay))
                .on('input keypress', that.c.enterSearch ||
                that.s.dt.settings()[0].oInit.search !== undefined &&
                    that.s.dt.settings()[0].oInit.search["return"] ?
                function (e) {
                    that._throttle(function () {
                        var code = e.keyCode || e.which;
                        if (code === 13) {
                            return fn(that, this);
                        }
                    }, searchDelay === null ? 100 : searchDelay);
                } :
                that._throttle(function () {
                    return fn(that, this);
                }, searchDelay === null ? 100 : searchDelay));
            if (that.c.greyscale) {
                el.addClass(Criteria.classes.greyscale);
            }
            // If there is a preDefined value then add it
            if (preDefined !== null) {
                el.val(preDefined[0]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return el;
        };
        Criteria.initNoValue = function (that) {
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
        };
        Criteria.init2Date = function (that, fn, preDefined) {
            var _this = this;
            if (preDefined === void 0) { preDefined = null; }
            var searchDelay = that.s.dt.settings()[0].searchDelay;
            // Declare all of the date elements that are required using DataTables dateTime plugin
            var els = [
                $$2('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .dtDateTime({
                    attachTo: 'input',
                    format: that.s.dateFormat ? that.s.dateFormat : undefined
                })
                    .on('change', searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    function () {
                        fn(that, _this);
                    })
                    .on('input keypress', !that.c.enterSearch &&
                    !(that.s.dt.settings()[0].oInit.search !== undefined &&
                        that.s.dt.settings()[0].oInit.search["return"]) &&
                    searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    that.c.enterSearch ||
                        that.s.dt.settings()[0].oInit.search !== undefined &&
                            that.s.dt.settings()[0].oInit.search["return"] ?
                        function (e) {
                            var code = e.keyCode || e.which;
                            if (code === 13) {
                                fn(that, _this);
                            }
                        } :
                        function () {
                            fn(that, _this);
                        }),
                $$2('<span>')
                    .addClass(that.classes.joiner)
                    .text(that.s.dt.i18n('searchBuilder.valueJoiner', that.c.i18n.valueJoiner)),
                $$2('<input/>')
                    .addClass(Criteria.classes.value)
                    .addClass(Criteria.classes.input)
                    .dtDateTime({
                    attachTo: 'input',
                    format: that.s.dateFormat ? that.s.dateFormat : undefined
                })
                    .on('change', searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    function () {
                        fn(that, _this);
                    })
                    .on('input keypress', !that.c.enterSearch &&
                    !(that.s.dt.settings()[0].oInit.search !== undefined &&
                        that.s.dt.settings()[0].oInit.search["return"]) &&
                    searchDelay !== null ?
                    that.s.dt.settings()[0].oApi._fnThrottle(function () {
                        return fn(that, this);
                    }, searchDelay) :
                    that.c.enterSearch ||
                        that.s.dt.settings()[0].oInit.search !== undefined &&
                            that.s.dt.settings()[0].oInit.search["return"] ?
                        function (e) {
                            var code = e.keyCode || e.which;
                            if (code === 13) {
                                fn(that, _this);
                            }
                        } :
                        function () {
                            fn(that, _this);
                        })
            ];
            if (that.c.greyscale) {
                els[0].addClass(Criteria.classes.greyscale);
                els[2].addClass(Criteria.classes.greyscale);
            }
            // If there are and preDefined values then add them
            if (preDefined !== null && preDefined.length > 0) {
                els[0].val(preDefined[0]);
                els[2].val(preDefined[1]);
            }
            // This is add responsive functionality to the logic button without redrawing everything else
            that.s.dt.one('draw', function () {
                that.s.topGroup.trigger('dtsb-redrawLogic');
            });
            return els;
        };
        /**
         * Default function for select elements to validate condition
         */
        Criteria.isInputValidSelect = function (el) {
            var allFilled = true;
            // Check each element to make sure that the selections are valid
            for (var _i = 0, el_1 = el; _i < el_1.length; _i++) {
                var element = el_1[_i];
                if (element.children('option:selected').length ===
                    element.children('option').length -
                        element.children('option.' + Criteria.classes.notItalic).length &&
                    element.children('option:selected').length === 1 &&
                    element.children('option:selected')[0] === element.children('option:hidden')[0]) {
                    allFilled = false;
                }
            }
            return allFilled;
        };
        /**
         * Default function for input and date elements to validate condition
         */
        Criteria.isInputValidInput = function (el) {
            var allFilled = true;
            // Check each element to make sure that the inputs are valid
            for (var _i = 0, el_2 = el; _i < el_2.length; _i++) {
                var element = el_2[_i];
                if (element.is('input') && element.val().length === 0) {
                    allFilled = false;
                }
            }
            return allFilled;
        };
        /**
         * Default function for getting select conditions
         */
        Criteria.inputValueSelect = function (el) {
            var values = [];
            // Go through the select elements and push each selected option to the return array
            for (var _i = 0, el_3 = el; _i < el_3.length; _i++) {
                var element = el_3[_i];
                if (element.is('select')) {
                    var val = element.children('option:selected').val();
                    // If the type of the option is an array we need to split it up and sort it
                    values.push(element.children('option:selected').attr('type') === 'Array' ?
                        val.split(',').sort() :
                        val);
                }
            }
            return values;
        };
        /**
         * Default function for getting input conditions
         */
        Criteria.inputValueInput = function (el) {
            var values = [];
            // Go through the input elements and push each value to the return array
            for (var _i = 0, el_4 = el; _i < el_4.length; _i++) {
                var element = el_4[_i];
                if (element.is('input')) {
                    values.push(element.val());
                }
            }
            return values;
        };
        /**
         * Function that is run on each element as a call back when a search should be triggered
         */
        Criteria.updateListener = function (that, el) {
            // When the value is changed the criteria is now complete so can be included in searches
            // Get the condition from the map based on the key that has been selected for the condition
            var condition = that.s.conditions[that.s.condition];
            that.s.filled = condition.isInputValid(that.dom.value, that);
            that.s.value = condition.inputValue(that.dom.value, that);
            if (!that.s.filled) {
                that.s.dt.draw();
                return;
            }
            if (!Array.isArray(that.s.value)) {
                that.s.value = [that.s.value];
            }
            for (var i = 0; i < that.s.value.length; i++) {
                // If the value is an array we need to sort it
                if (Array.isArray(that.s.value[i])) {
                    that.s.value[i].sort();
                }
                // Otherwise replace the decimal place character for i18n
                else if (that.s.type.includes('num') &&
                    (that.s.dt.settings()[0].oLanguage.sDecimal !== '' ||
                        that.s.dt.settings()[0].oLanguage.sThousands !== '')) {
                    var splitRD = [that.s.value[i].toString()];
                    if (that.s.dt.settings()[0].oLanguage.sDecimal !== '') {
                        splitRD = that.s.value[i].split(that.s.dt.settings()[0].oLanguage.sDecimal);
                    }
                    if (that.s.dt.settings()[0].oLanguage.sThousands !== '') {
                        for (var j = 0; j < splitRD.length; j++) {
                            splitRD[j] = splitRD[j].replace(that.s.dt.settings()[0].oLanguage.sThousands, ',');
                        }
                    }
                    that.s.value[i] = splitRD.join('.');
                }
            }
            // Take note of the cursor position so that we can refocus there later
            var idx = null;
            var cursorPos = null;
            for (var i = 0; i < that.dom.value.length; i++) {
                if (el === that.dom.value[i][0]) {
                    idx = i;
                    if (el.selectionStart !== undefined) {
                        cursorPos = el.selectionStart;
                    }
                }
            }
            // Trigger a search
            that.s.dt.draw();
            // Refocus the element and set the correct cursor position
            if (idx !== null) {
                that.dom.value[idx].removeClass(that.classes.italic);
                that.dom.value[idx].focus();
                if (cursorPos !== null) {
                    that.dom.value[idx][0].setSelectionRange(cursorPos, cursorPos);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.dateConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.equals', i18n.conditions.date.equals);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value === comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.not', i18n.conditions.date.not);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value !== comparison[0];
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.before', i18n.conditions.date.before);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value < comparison[0];
                }
            },
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.after', i18n.conditions.date.after);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    return value > comparison[0];
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.between', i18n.conditions.date.between);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    if (comparison[0] < comparison[1]) {
                        return comparison[0] <= value && value <= comparison[1];
                    }
                    else {
                        return comparison[1] <= value && value <= comparison[0];
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notBetween', i18n.conditions.date.notBetween);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    value = value.replace(/(\/|-|,)/g, '-');
                    if (comparison[0] < comparison[1]) {
                        return !(comparison[0] <= value && value <= comparison[1]);
                    }
                    else {
                        return !(comparison[1] <= value && value <= comparison[0]);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.empty', i18n.conditions.date.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notEmpty', i18n.conditions.date.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.momentDateConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.equals', i18n.conditions.date.equals);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment(value, that.s.dateFormat).valueOf() ===
                        moment(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.not', i18n.conditions.date.not);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment(value, that.s.dateFormat).valueOf() !==
                        moment(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.before', i18n.conditions.date.before);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment(value, that.s.dateFormat).valueOf() < moment(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.after', i18n.conditions.date.after);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return moment(value, that.s.dateFormat).valueOf() > moment(comparison[0], that.s.dateFormat).valueOf();
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.between', i18n.conditions.date.between);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = moment(value, that.s.dateFormat).valueOf();
                    var comp0 = moment(comparison[0], that.s.dateFormat).valueOf();
                    var comp1 = moment(comparison[1], that.s.dateFormat).valueOf();
                    if (comp0 < comp1) {
                        return comp0 <= val && val <= comp1;
                    }
                    else {
                        return comp1 <= val && val <= comp0;
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notBetween', i18n.conditions.date.notBetween);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = moment(value, that.s.dateFormat).valueOf();
                    var comp0 = moment(comparison[0], that.s.dateFormat).valueOf();
                    var comp1 = moment(comparison[1], that.s.dateFormat).valueOf();
                    if (comp0 < comp1) {
                        return !(+comp0 <= +val && +val <= +comp1);
                    }
                    else {
                        return !(+comp1 <= +val && +val <= +comp0);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.empty', i18n.conditions.date.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notEmpty', i18n.conditions.date.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.luxonDateConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.equals', i18n.conditions.date.equals);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon.DateTime.fromFormat(value, that.s.dateFormat).ts
                        === luxon.DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.not', i18n.conditions.date.not);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon.DateTime.fromFormat(value, that.s.dateFormat).ts
                        !== luxon.DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.before', i18n.conditions.date.before);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon.DateTime.fromFormat(value, that.s.dateFormat).ts
                        < luxon.DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.after', i18n.conditions.date.after);
                },
                init: Criteria.initDate,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    return luxon.DateTime.fromFormat(value, that.s.dateFormat).ts
                        > luxon.DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.between', i18n.conditions.date.between);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = luxon.DateTime.fromFormat(value, that.s.dateFormat).ts;
                    var comp0 = luxon.DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                    var comp1 = luxon.DateTime.fromFormat(comparison[1], that.s.dateFormat).ts;
                    if (comp0 < comp1) {
                        return comp0 <= val && val <= comp1;
                    }
                    else {
                        return comp1 <= val && val <= comp0;
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notBetween', i18n.conditions.date.notBetween);
                },
                init: Criteria.init2Date,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison, that) {
                    var val = luxon.DateTime.fromFormat(value, that.s.dateFormat).ts;
                    var comp0 = luxon.DateTime.fromFormat(comparison[0], that.s.dateFormat).ts;
                    var comp1 = luxon.DateTime.fromFormat(comparison[1], that.s.dateFormat).ts;
                    if (comp0 < comp1) {
                        return !(+comp0 <= +val && +val <= +comp1);
                    }
                    else {
                        return !(+comp1 <= +val && +val <= +comp0);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.empty', i18n.conditions.date.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.date.notEmpty', i18n.conditions.date.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.numConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.equals', i18n.conditions.number.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return +value === +comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.not', i18n.conditions.number.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return +value !== +comparison[0];
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lt', i18n.conditions.number.lt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value < +comparison[0];
                }
            },
            '<=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lte', i18n.conditions.number.lte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value <= +comparison[0];
                }
            },
            '>=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gte', i18n.conditions.number.gte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value >= +comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gt', i18n.conditions.number.gt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return +value > +comparison[0];
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.between', i18n.conditions.number.between);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    if (+comparison[0] < +comparison[1]) {
                        return +comparison[0] <= +value && +value <= +comparison[1];
                    }
                    else {
                        return +comparison[1] <= +value && +value <= +comparison[0];
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notBetween', i18n.conditions.number.notBetween);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    if (+comparison[0] < +comparison[1]) {
                        return !(+comparison[0] <= +value && +value <= +comparison[1]);
                    }
                    else {
                        return !(+comparison[1] <= +value && +value <= +comparison[0]);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.empty', i18n.conditions.number.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notEmpty', i18n.conditions.number.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.numFmtConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.equals', i18n.conditions.number.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    return +val === +comp;
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.not', i18n.conditions.number.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    return +val !== +comp;
                }
            },
            '<': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lt', i18n.conditions.number.lt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    return +val < +comp;
                }
            },
            '<=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.lte', i18n.conditions.number.lte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    return +val <= +comp;
                }
            },
            '>=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gte', i18n.conditions.number.gte);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    return +val >= +comp;
                }
            },
            // eslint-disable-next-line sort-keys
            '>': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.gt', i18n.conditions.number.gt);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    return +val > +comp;
                }
            },
            'between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.between', i18n.conditions.number.between);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp0 = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    var comp1 = comparison[1].indexOf('-') === 0 ?
                        '-' + comparison[1].replace(/[^0-9.]/g, '') :
                        comparison[1].replace(/[^0-9.]/g, '');
                    if (+comp0 < +comp1) {
                        return +comp0 <= +val && +val <= +comp1;
                    }
                    else {
                        return +comp1 <= +val && +val <= +comp0;
                    }
                }
            },
            // eslint-disable-next-line sort-keys
            '!between': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notBetween', i18n.conditions.number.notBetween);
                },
                init: Criteria.init2Input,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    var val = value.indexOf('-') === 0 ?
                        '-' + value.replace(/[^0-9.]/g, '') :
                        value.replace(/[^0-9.]/g, '');
                    var comp0 = comparison[0].indexOf('-') === 0 ?
                        '-' + comparison[0].replace(/[^0-9.]/g, '') :
                        comparison[0].replace(/[^0-9.]/g, '');
                    var comp1 = comparison[1].indexOf('-') === 0 ?
                        '-' + comparison[1].replace(/[^0-9.]/g, '') :
                        comparison[1].replace(/[^0-9.]/g, '');
                    if (+comp0 < +comp1) {
                        return !(+comp0 <= +val && +val <= +comp1);
                    }
                    else {
                        return !(+comp1 <= +val && +val <= +comp0);
                    }
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.empty', i18n.conditions.number.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.number.notEmpty', i18n.conditions.number.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Has to be in this order so that they are displayed correctly in select elements
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.stringConditions = {
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.equals', i18n.conditions.string.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return value === comparison[0];
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.not', i18n.conditions.string.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value !== comparison[0];
                }
            },
            'starts': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.startsWith', i18n.conditions.string.startsWith);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().indexOf(comparison[0].toLowerCase()) === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            'contains': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.contains', i18n.conditions.string.contains);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().includes(comparison[0].toLowerCase());
                }
            },
            'ends': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.endsWith', i18n.conditions.string.endsWith);
                },
                init: Criteria.initInput,
                inputValue: Criteria.inputValueInput,
                isInputValid: Criteria.isInputValidInput,
                search: function (value, comparison) {
                    return value.toLowerCase().endsWith(comparison[0].toLowerCase());
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.empty', i18n.conditions.string.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.string.notEmpty', i18n.conditions.string.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return !(value === null || value === undefined || value.length === 0);
                }
            }
        };
        // The order of the conditions will make eslint sad :(
        // Also have to disable member ordering for this as the private methods used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.arrayConditions = {
            'contains': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.contains', i18n.conditions.array.contains);
                },
                init: Criteria.initSelectArray,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return value.includes(comparison[0]);
                }
            },
            'without': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.without', i18n.conditions.array.without);
                },
                init: Criteria.initSelectArray,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    return value.indexOf(comparison[0]) === -1;
                }
            },
            // eslint-disable-next-line sort-keys
            '=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.equals', i18n.conditions.array.equals);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    if (value.length === comparison[0].length) {
                        for (var i = 0; i < value.length; i++) {
                            if (value[i] !== comparison[0][i]) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                }
            },
            // eslint-disable-next-line sort-keys
            '!=': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.not', i18n.conditions.array.not);
                },
                init: Criteria.initSelect,
                inputValue: Criteria.inputValueSelect,
                isInputValid: Criteria.isInputValidSelect,
                search: function (value, comparison) {
                    if (value.length === comparison[0].length) {
                        for (var i = 0; i < value.length; i++) {
                            if (value[i] !== comparison[0][i]) {
                                return true;
                            }
                        }
                        return false;
                    }
                    return true;
                }
            },
            'null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.empty', i18n.conditions.array.empty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value === null || value === undefined || value.length === 0;
                }
            },
            // eslint-disable-next-line sort-keys
            '!null': {
                conditionName: function (dt, i18n) {
                    return dt.i18n('searchBuilder.conditions.array.notEmpty', i18n.conditions.array.notEmpty);
                },
                init: Criteria.initNoValue,
                inputValue: function () {
                    return;
                },
                isInputValid: function () {
                    return true;
                },
                search: function (value) {
                    return value !== null && value !== undefined && value.length !== 0;
                }
            }
        };
        // eslint will be sad because we have to disable member ordering for this as the
        // private static properties used are not yet declared otherwise
        // eslint-disable-next-line @typescript-eslint/member-ordering
        Criteria.defaults = {
            columns: true,
            conditions: {
                'array': Criteria.arrayConditions,
                'date': Criteria.dateConditions,
                'html': Criteria.stringConditions,
                'html-num': Criteria.numConditions,
                'html-num-fmt': Criteria.numFmtConditions,
                'luxon': Criteria.luxonDateConditions,
                'moment': Criteria.momentDateConditions,
                'num': Criteria.numConditions,
                'num-fmt': Criteria.numFmtConditions,
                'string': Criteria.stringConditions
            },
            depthLimit: false,
            enterSearch: false,
            filterChanged: undefined,
            greyscale: false,
            i18n: {
                add: 'Add Condition',
                button: {
                    0: 'Search Builder',
                    _: 'Search Builder (%d)'
                },
                clearAll: 'Clear All',
                condition: 'Condition',
                data: 'Data',
                deleteTitle: 'Delete filtering rule',
                leftTitle: 'Outdent criteria',
                logicAnd: 'And',
                logicOr: 'Or',
                rightTitle: 'Indent criteria',
                title: {
                    0: 'Custom Search Builder',
                    _: 'Custom Search Builder (%d)'
                },
                value: 'Value',
                valueJoiner: 'and'
            },
            logic: 'AND',
            orthogonal: {
                display: 'display',
                search: 'filter'
            },
            preDefined: false
        };
        return Criteria;
    }());

    var $$1;
    var dataTable$1;
    /**
     * Sets the value of jQuery for use in the file
     *
     * @param jq the instance of jQuery to be set
     */
    function setJQuery$1(jq) {
        $$1 = jq;
        dataTable$1 = jq.fn.dataTable;
    }
    /**
     * The Group class is used within SearchBuilder to represent a group of criteria
     */
    var Group = /** @class */ (function () {
        function Group(table, opts, topGroup, index, isChild, depth) {
            if (index === void 0) { index = 0; }
            if (isChild === void 0) { isChild = false; }
            if (depth === void 0) { depth = 1; }
            // Check that the required version of DataTables is included
            if (!dataTable$1 || !dataTable$1.versionCheck || !dataTable$1.versionCheck('1.10.0')) {
                throw new Error('SearchBuilder requires DataTables 1.10 or newer');
            }
            this.classes = $$1.extend(true, {}, Group.classes);
            // Get options from user
            this.c = $$1.extend(true, {}, Group.defaults, opts);
            this.s = {
                criteria: [],
                depth: depth,
                dt: table,
                index: index,
                isChild: isChild,
                logic: undefined,
                opts: opts,
                preventRedraw: false,
                toDrop: undefined,
                topGroup: topGroup
            };
            this.dom = {
                add: $$1('<button/>')
                    .addClass(this.classes.add)
                    .addClass(this.classes.button)
                    .attr('type', 'button'),
                clear: $$1('<button>&times</button>')
                    .addClass(this.classes.button)
                    .addClass(this.classes.clearGroup)
                    .attr('type', 'button'),
                container: $$1('<div/>')
                    .addClass(this.classes.group),
                logic: $$1('<button><div/></button>')
                    .addClass(this.classes.logic)
                    .addClass(this.classes.button)
                    .attr('type', 'button'),
                logicContainer: $$1('<div/>')
                    .addClass(this.classes.logicContainer)
            };
            // A reference to the top level group is maintained throughout any subgroups and criteria that may be created
            if (this.s.topGroup === undefined) {
                this.s.topGroup = this.dom.container;
            }
            this._setup();
            return this;
        }
        /**
         * Destroys the groups buttons, clears the internal criteria and removes it from the dom
         */
        Group.prototype.destroy = function () {
            // Turn off listeners
            this.dom.add.off('.dtsb');
            this.dom.logic.off('.dtsb');
            // Trigger event for groups at a higher level to pick up on
            this.dom.container
                .trigger('dtsb-destroy')
                .remove();
            this.s.criteria = [];
        };
        /**
         * Gets the details required to rebuild the group
         */
        // Eslint upset at empty object but needs to be done
        // eslint-disable-next-line @typescript-eslint/ban-types
        Group.prototype.getDetails = function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            if (this.s.criteria.length === 0) {
                return {};
            }
            var details = {
                criteria: [],
                logic: this.s.logic
            };
            // NOTE here crit could be either a subgroup or a criteria
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                details.criteria.push(crit.criteria.getDetails(deFormatDates));
            }
            return details;
        };
        /**
         * Getter for the node for the container of the group
         *
         * @returns Node for the container of the group
         */
        Group.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * Rebuilds the group based upon the details passed in
         *
         * @param loadedDetails the details required to rebuild the group
         */
        Group.prototype.rebuild = function (loadedDetails) {
            // If no criteria are stored then just return
            if (loadedDetails.criteria === undefined ||
                loadedDetails.criteria === null ||
                Array.isArray(loadedDetails.criteria) && loadedDetails.criteria.length === 0) {
                return;
            }
            this.s.logic = loadedDetails.logic;
            this.dom.logic.children().first().text(this.s.logic === 'OR'
                ? this.s.dt.i18n('searchBuilder.logicOr', this.c.i18n.logicOr)
                : this.s.dt.i18n('searchBuilder.logicAnd', this.c.i18n.logicAnd));
            // Add all of the criteria, be it a sub group or a criteria
            if (Array.isArray(loadedDetails.criteria)) {
                for (var _i = 0, _a = loadedDetails.criteria; _i < _a.length; _i++) {
                    var crit = _a[_i];
                    if (crit.logic !== undefined) {
                        this._addPrevGroup(crit);
                    }
                    else if (crit.logic === undefined) {
                        this._addPrevCriteria(crit);
                    }
                }
            }
            // For all of the criteria children, update the arrows incase they require changing and set the listeners
            for (var _b = 0, _c = this.s.criteria; _b < _c.length; _b++) {
                var crit = _c[_b];
                if (crit.criteria instanceof Criteria) {
                    crit.criteria.updateArrows(this.s.criteria.length > 1, false);
                    this._setCriteriaListeners(crit.criteria);
                }
            }
        };
        /**
         * Redraws the Contents of the searchBuilder Groups and Criteria
         */
        Group.prototype.redrawContents = function () {
            if (this.s.preventRedraw) {
                return;
            }
            // Clear the container out and add the basic elements
            this.dom.container.children().detach();
            this.dom.container
                .append(this.dom.logicContainer)
                .append(this.dom.add);
            // Sort the criteria by index so that they appear in the correct order
            this.s.criteria.sort(function (a, b) {
                if (a.criteria.s.index < b.criteria.s.index) {
                    return -1;
                }
                else if (a.criteria.s.index > b.criteria.s.index) {
                    return 1;
                }
                return 0;
            });
            this.setListeners();
            for (var i = 0; i < this.s.criteria.length; i++) {
                var crit = this.s.criteria[i].criteria;
                if (crit instanceof Criteria) {
                    // Reset the index to the new value
                    this.s.criteria[i].index = i;
                    this.s.criteria[i].criteria.s.index = i;
                    // Add to the group
                    this.s.criteria[i].criteria.dom.container.insertBefore(this.dom.add);
                    // Set listeners for various points
                    this._setCriteriaListeners(crit);
                    this.s.criteria[i].criteria.rebuild(this.s.criteria[i].criteria.getDetails());
                }
                else if (crit instanceof Group && crit.s.criteria.length > 0) {
                    // Reset the index to the new value
                    this.s.criteria[i].index = i;
                    this.s.criteria[i].criteria.s.index = i;
                    // Add the sub group to the group
                    this.s.criteria[i].criteria.dom.container.insertBefore(this.dom.add);
                    // Redraw the contents of the group
                    crit.redrawContents();
                    this._setGroupListeners(crit);
                }
                else {
                    // The group is empty so remove it
                    this.s.criteria.splice(i, 1);
                    i--;
                }
            }
            this.setupLogic();
        };
        /**
         * Resizes the logic button only rather than the entire dom.
         */
        Group.prototype.redrawLogic = function () {
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit instanceof Group) {
                    crit.redrawLogic();
                }
            }
            this.setupLogic();
        };
        /**
         * Search method, checking the row data against the criteria in the group
         *
         * @param rowData The row data to be compared
         * @returns boolean The result of the search
         */
        Group.prototype.search = function (rowData, rowIdx) {
            if (this.s.logic === 'AND') {
                return this._andSearch(rowData, rowIdx);
            }
            else if (this.s.logic === 'OR') {
                return this._orSearch(rowData, rowIdx);
            }
            return true;
        };
        /**
         * Locates the groups logic button to the correct location on the page
         */
        Group.prototype.setupLogic = function () {
            // Remove logic button
            this.dom.logicContainer.remove();
            this.dom.clear.remove();
            // If there are no criteria in the group then keep the logic removed and return
            if (this.s.criteria.length < 1) {
                if (!this.s.isChild) {
                    this.dom.container.trigger('dtsb-destroy');
                    // Set criteria left margin
                    this.dom.container.css('margin-left', 0);
                }
                return;
            }
            // Set width, take 2 for the border
            var height = this.dom.container.height() - 1;
            this.dom.clear.height('0px');
            this.dom.logicContainer.append(this.dom.clear).width(height);
            // Prepend logic button
            this.dom.container.prepend(this.dom.logicContainer);
            this._setLogicListener();
            // Set criteria left margin
            this.dom.container.css('margin-left', this.dom.logicContainer.outerHeight(true));
            var logicOffset = this.dom.logicContainer.offset();
            // Set horizontal alignment
            var currentLeft = logicOffset.left;
            var groupLeft = this.dom.container.offset().left;
            var shuffleLeft = currentLeft - groupLeft;
            var newPos = currentLeft - shuffleLeft - this.dom.logicContainer.outerHeight(true);
            this.dom.logicContainer.offset({ left: newPos });
            // Set vertical alignment
            var firstCrit = this.dom.logicContainer.next();
            var currentTop = logicOffset.top;
            var firstTop = $$1(firstCrit).offset().top;
            var shuffleTop = currentTop - firstTop;
            var newTop = currentTop - shuffleTop;
            this.dom.logicContainer.offset({ top: newTop });
            this.dom.clear.outerHeight(this.dom.logicContainer.height());
            this._setClearListener();
        };
        /**
         * Sets listeners on the groups elements
         */
        Group.prototype.setListeners = function () {
            var _this = this;
            this.dom.add.unbind('click');
            this.dom.add.on('click', function () {
                // If this is the parent group then the logic button has not been added yet
                if (!_this.s.isChild) {
                    _this.dom.container.prepend(_this.dom.logicContainer);
                }
                _this.addCriteria();
                _this.dom.container.trigger('dtsb-add');
                _this.s.dt.state.save();
                return false;
            });
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                crit.criteria.setListeners();
            }
            this._setClearListener();
            this._setLogicListener();
        };
        /**
         * Adds a criteria to the group
         *
         * @param crit Instance of Criteria to be added to the group
         */
        Group.prototype.addCriteria = function (crit, redraw) {
            if (crit === void 0) { crit = null; }
            if (redraw === void 0) { redraw = true; }
            var index = crit === null ? this.s.criteria.length : crit.s.index;
            var criteria = new Criteria(this.s.dt, this.s.opts, this.s.topGroup, index, this.s.depth);
            // If a Criteria has been passed in then set the values to continue that
            if (crit !== null) {
                criteria.c = crit.c;
                criteria.s = crit.s;
                criteria.s.depth = this.s.depth;
                criteria.classes = crit.classes;
            }
            criteria.populate();
            var inserted = false;
            for (var i = 0; i < this.s.criteria.length; i++) {
                if (i === 0 && this.s.criteria[i].criteria.s.index > criteria.s.index) {
                    // Add the node for the criteria at the start of the group
                    criteria.getNode().insertBefore(this.s.criteria[i].criteria.dom.container);
                    inserted = true;
                }
                else if (i < this.s.criteria.length - 1 &&
                    this.s.criteria[i].criteria.s.index < criteria.s.index &&
                    this.s.criteria[i + 1].criteria.s.index > criteria.s.index) {
                    // Add the node for the criteria in the correct location
                    criteria.getNode().insertAfter(this.s.criteria[i].criteria.dom.container);
                    inserted = true;
                }
            }
            if (!inserted) {
                criteria.getNode().insertBefore(this.dom.add);
            }
            // Add the details for this criteria to the array
            this.s.criteria.push({
                criteria: criteria,
                index: index
            });
            this.s.criteria = this.s.criteria.sort(function (a, b) { return a.criteria.s.index - b.criteria.s.index; });
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var opt = _a[_i];
                if (opt.criteria instanceof Criteria) {
                    opt.criteria.updateArrows(this.s.criteria.length > 1, redraw);
                }
            }
            this._setCriteriaListeners(criteria);
            criteria.setListeners();
            this.setupLogic();
        };
        /**
         * Checks the group to see if it has any filled criteria
         */
        Group.prototype.checkFilled = function () {
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Criteria && crit.criteria.s.filled ||
                    crit.criteria instanceof Group && crit.criteria.checkFilled()) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Gets the count for the number of criteria in this group and any sub groups
         */
        Group.prototype.count = function () {
            var count = 0;
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Group) {
                    count += crit.criteria.count();
                }
                else {
                    count++;
                }
            }
            return count;
        };
        /**
         * Rebuilds a sub group that previously existed
         *
         * @param loadedGroup The details of a group within this group
         */
        Group.prototype._addPrevGroup = function (loadedGroup) {
            var idx = this.s.criteria.length;
            var group = new Group(this.s.dt, this.c, this.s.topGroup, idx, true, this.s.depth + 1);
            // Add the new group to the criteria array
            this.s.criteria.push({
                criteria: group,
                index: idx,
                logic: group.s.logic
            });
            // Rebuild it with the previous conditions for that group
            group.rebuild(loadedGroup);
            this.s.criteria[idx].criteria = group;
            this.s.topGroup.trigger('dtsb-redrawContents');
            this._setGroupListeners(group);
        };
        /**
         * Rebuilds a criteria of this group that previously existed
         *
         * @param loadedCriteria The details of a criteria within the group
         */
        Group.prototype._addPrevCriteria = function (loadedCriteria) {
            var idx = this.s.criteria.length;
            var criteria = new Criteria(this.s.dt, this.s.opts, this.s.topGroup, idx, this.s.depth);
            criteria.populate();
            // Add the new criteria to the criteria array
            this.s.criteria.push({
                criteria: criteria,
                index: idx
            });
            // Rebuild it with the previous conditions for that criteria
            criteria.rebuild(loadedCriteria);
            this.s.criteria[idx].criteria = criteria;
            this.s.topGroup.trigger('dtsb-redrawContents');
        };
        /**
         * Checks And the criteria using AND logic
         *
         * @param rowData The row data to be checked against the search criteria
         * @returns boolean The result of the AND search
         */
        Group.prototype._andSearch = function (rowData, rowIdx) {
            // If there are no criteria then return true for this group
            if (this.s.criteria.length === 0) {
                return true;
            }
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                // If the criteria is not complete then skip it
                if (crit.criteria instanceof Criteria && !crit.criteria.s.filled) {
                    continue;
                }
                // Otherwise if a single one fails return false
                else if (!crit.criteria.search(rowData, rowIdx)) {
                    return false;
                }
            }
            // If we get to here then everything has passed, so return true for the group
            return true;
        };
        /**
         * Checks And the criteria using OR logic
         *
         * @param rowData The row data to be checked against the search criteria
         * @returns boolean The result of the OR search
         */
        Group.prototype._orSearch = function (rowData, rowIdx) {
            // If there are no criteria in the group then return true
            if (this.s.criteria.length === 0) {
                return true;
            }
            // This will check to make sure that at least one criteria in the group is complete
            var filledfound = false;
            for (var _i = 0, _a = this.s.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                if (crit.criteria instanceof Criteria && crit.criteria.s.filled) {
                    // A completed criteria has been found so set the flag
                    filledfound = true;
                    // If the search passes then return true
                    if (crit.criteria.search(rowData, rowIdx)) {
                        return true;
                    }
                }
                else if (crit.criteria instanceof Group && crit.criteria.checkFilled()) {
                    filledfound = true;
                    if (crit.criteria.search(rowData, rowIdx)) {
                        return true;
                    }
                }
            }
            // If we get here we need to return the inverse of filledfound,
            //  as if any have been found and we are here then none have passed
            return !filledfound;
        };
        /**
         * Removes a criteria from the group
         *
         * @param criteria The criteria instance to be removed
         */
        Group.prototype._removeCriteria = function (criteria, group) {
            if (group === void 0) { group = false; }
            // If removing a criteria and there is only then then just destroy the group
            if (this.s.criteria.length <= 1 && this.s.isChild) {
                this.destroy();
            }
            else {
                // Otherwise splice the given criteria out and redo the indexes
                var last = void 0;
                for (var i = 0; i < this.s.criteria.length; i++) {
                    if (this.s.criteria[i].index === criteria.s.index &&
                        (!group || this.s.criteria[i].criteria instanceof Group)) {
                        last = i;
                    }
                }
                // We want to remove the last element with the desired index, as its replacement will be inserted before it
                if (last !== undefined) {
                    this.s.criteria.splice(last, 1);
                }
                for (var i = 0; i < this.s.criteria.length; i++) {
                    this.s.criteria[i].index = i;
                    this.s.criteria[i].criteria.s.index = i;
                }
            }
        };
        /**
         * Sets the listeners in group for a criteria
         *
         * @param criteria The criteria for the listeners to be set on
         */
        Group.prototype._setCriteriaListeners = function (criteria) {
            var _this = this;
            criteria.dom["delete"]
                .unbind('click')
                .on('click', function () {
                _this._removeCriteria(criteria);
                criteria.dom.container.remove();
                for (var _i = 0, _a = _this.s.criteria; _i < _a.length; _i++) {
                    var crit = _a[_i];
                    if (crit.criteria instanceof Criteria) {
                        crit.criteria.updateArrows(_this.s.criteria.length > 1);
                    }
                }
                criteria.destroy();
                _this.s.dt.draw();
                _this.s.topGroup.trigger('dtsb-redrawContents');
                _this.s.topGroup.trigger('dtsb-updateTitle');
                return false;
            });
            criteria.dom.right
                .unbind('click')
                .on('click', function () {
                var idx = criteria.s.index;
                var group = new Group(_this.s.dt, _this.s.opts, _this.s.topGroup, criteria.s.index, true, _this.s.depth + 1);
                // Add the criteria that is to be moved to the new group
                group.addCriteria(criteria);
                // Update the details in the current groups criteria array
                _this.s.criteria[idx].criteria = group;
                _this.s.criteria[idx].logic = 'AND';
                _this.s.topGroup.trigger('dtsb-redrawContents');
                _this._setGroupListeners(group);
                return false;
            });
            criteria.dom.left
                .unbind('click')
                .on('click', function () {
                _this.s.toDrop = new Criteria(_this.s.dt, _this.s.opts, _this.s.topGroup, criteria.s.index);
                _this.s.toDrop.s = criteria.s;
                _this.s.toDrop.c = criteria.c;
                _this.s.toDrop.classes = criteria.classes;
                _this.s.toDrop.populate();
                // The dropCriteria event mutates the reference to the index so need to store it
                var index = _this.s.toDrop.s.index;
                _this.dom.container.trigger('dtsb-dropCriteria');
                criteria.s.index = index;
                _this._removeCriteria(criteria);
                // By tracking the top level group we can directly trigger a redraw on it,
                //  bubbling is also possible, but that is slow with deep levelled groups
                _this.s.topGroup.trigger('dtsb-redrawContents');
                _this.s.dt.draw();
                return false;
            });
        };
        /**
         * Set's the listeners for the group clear button
         */
        Group.prototype._setClearListener = function () {
            var _this = this;
            this.dom.clear
                .unbind('click')
                .on('click', function () {
                if (!_this.s.isChild) {
                    _this.dom.container.trigger('dtsb-clearContents');
                    return false;
                }
                _this.destroy();
                _this.s.topGroup.trigger('dtsb-updateTitle');
                _this.s.topGroup.trigger('dtsb-redrawContents');
                return false;
            });
        };
        /**
         * Sets listeners for sub groups of this group
         *
         * @param group The sub group that the listeners are to be set on
         */
        Group.prototype._setGroupListeners = function (group) {
            var _this = this;
            // Set listeners for the new group
            group.dom.add
                .unbind('click')
                .on('click', function () {
                _this.setupLogic();
                _this.dom.container.trigger('dtsb-add');
                return false;
            });
            group.dom.container
                .unbind('dtsb-add')
                .on('dtsb-add', function () {
                _this.setupLogic();
                _this.dom.container.trigger('dtsb-add');
                return false;
            });
            group.dom.container
                .unbind('dtsb-destroy')
                .on('dtsb-destroy', function () {
                _this._removeCriteria(group, true);
                group.dom.container.remove();
                _this.setupLogic();
                return false;
            });
            group.dom.container
                .unbind('dtsb-dropCriteria')
                .on('dtsb-dropCriteria', function () {
                var toDrop = group.s.toDrop;
                toDrop.s.index = group.s.index;
                toDrop.updateArrows(_this.s.criteria.length > 1, false);
                _this.addCriteria(toDrop, false);
                return false;
            });
            group.setListeners();
        };
        /**
         * Sets up the Group instance, setting listeners and appending elements
         */
        Group.prototype._setup = function () {
            this.setListeners();
            this.dom.add.text(this.s.dt.i18n('searchBuilder.add', this.c.i18n.add));
            this.dom.logic.children().first().text(this.c.logic === 'OR'
                ? this.s.dt.i18n('searchBuilder.logicOr', this.c.i18n.logicOr)
                : this.s.dt.i18n('searchBuilder.logicAnd', this.c.i18n.logicAnd));
            this.s.logic = this.c.logic === 'OR' ? 'OR' : 'AND';
            if (this.c.greyscale) {
                this.dom.logic.addClass(this.classes.greyscale);
            }
            this.dom.logicContainer.append(this.dom.logic).append(this.dom.clear);
            // Only append the logic button immediately if this is a sub group,
            //  otherwise it will be prepended later when adding a criteria
            if (this.s.isChild) {
                this.dom.container.append(this.dom.logicContainer);
            }
            this.dom.container.append(this.dom.add);
        };
        /**
         * Sets the listener for the logic button
         */
        Group.prototype._setLogicListener = function () {
            var _this = this;
            this.dom.logic
                .unbind('click')
                .on('click', function () {
                _this._toggleLogic();
                _this.s.dt.draw();
                for (var _i = 0, _a = _this.s.criteria; _i < _a.length; _i++) {
                    var crit = _a[_i];
                    crit.criteria.setListeners();
                }
            });
        };
        /**
         * Toggles the logic for the group
         */
        Group.prototype._toggleLogic = function () {
            if (this.s.logic === 'OR') {
                this.s.logic = 'AND';
                this.dom.logic.children().first().text(this.s.dt.i18n('searchBuilder.logicAnd', this.c.i18n.logicAnd));
            }
            else if (this.s.logic === 'AND') {
                this.s.logic = 'OR';
                this.dom.logic.children().first().text(this.s.dt.i18n('searchBuilder.logicOr', this.c.i18n.logicOr));
            }
        };
        Group.version = '1.1.0';
        Group.classes = {
            add: 'dtsb-add',
            button: 'dtsb-button',
            clearGroup: 'dtsb-clearGroup',
            greyscale: 'dtsb-greyscale',
            group: 'dtsb-group',
            inputButton: 'dtsb-iptbtn',
            logic: 'dtsb-logic',
            logicContainer: 'dtsb-logicContainer'
        };
        Group.defaults = {
            columns: true,
            conditions: {
                'date': Criteria.dateConditions,
                'html': Criteria.stringConditions,
                'html-num': Criteria.numConditions,
                'html-num-fmt': Criteria.numFmtConditions,
                'luxon': Criteria.luxonDateConditions,
                'moment': Criteria.momentDateConditions,
                'num': Criteria.numConditions,
                'num-fmt': Criteria.numFmtConditions,
                'string': Criteria.stringConditions
            },
            depthLimit: false,
            enterSearch: false,
            filterChanged: undefined,
            greyscale: false,
            i18n: {
                add: 'Add Condition',
                button: {
                    0: 'Search Builder',
                    _: 'Search Builder (%d)'
                },
                clearAll: 'Clear All',
                condition: 'Condition',
                data: 'Data',
                deleteTitle: 'Delete filtering rule',
                leftTitle: 'Outdent criteria',
                logicAnd: 'And',
                logicOr: 'Or',
                rightTitle: 'Indent criteria',
                title: {
                    0: 'Custom Search Builder',
                    _: 'Custom Search Builder (%d)'
                },
                value: 'Value',
                valueJoiner: 'and'
            },
            logic: 'AND',
            orthogonal: {
                display: 'display',
                search: 'filter'
            },
            preDefined: false
        };
        return Group;
    }());

    var $;
    var dataTable;
    /**
     * Sets the value of jQuery for use in the file
     *
     * @param jq the instance of jQuery to be set
     */
    function setJQuery(jq) {
        $ = jq;
        dataTable = jq.fn.DataTable;
    }
    /**
     * SearchBuilder class for DataTables.
     * Allows for complex search queries to be constructed and implemented on a DataTable
     */
    var SearchBuilder = /** @class */ (function () {
        function SearchBuilder(builderSettings, opts) {
            var _this = this;
            // Check that the required version of DataTables is included
            if (!dataTable || !dataTable.versionCheck || !dataTable.versionCheck('1.10.0')) {
                throw new Error('SearchBuilder requires DataTables 1.10 or newer');
            }
            var table = new dataTable.Api(builderSettings);
            this.classes = $.extend(true, {}, SearchBuilder.classes);
            // Get options from user
            this.c = $.extend(true, {}, SearchBuilder.defaults, opts);
            this.dom = {
                clearAll: $('<button type="button">' + table.i18n('searchBuilder.clearAll', this.c.i18n.clearAll) + '</button>')
                    .addClass(this.classes.clearAll)
                    .addClass(this.classes.button)
                    .attr('type', 'button'),
                container: $('<div/>')
                    .addClass(this.classes.container),
                title: $('<div/>')
                    .addClass(this.classes.title),
                titleRow: $('<div/>')
                    .addClass(this.classes.titleRow),
                topGroup: undefined
            };
            this.s = {
                dt: table,
                opts: opts,
                search: undefined,
                topGroup: undefined
            };
            // If searchbuilder is already defined for this table then return
            if (table.settings()[0]._searchBuilder !== undefined) {
                return;
            }
            table.settings()[0]._searchBuilder = this;
            // Run the remaining setup when the table is initialised
            if (this.s.dt.settings()[0]._bInitComplete) {
                this._setUp();
            }
            else {
                table.one('init.dt', function () {
                    _this._setUp();
                });
            }
            return this;
        }
        /**
         * Gets the details required to rebuild the SearchBuilder as it currently is
         */
        // eslint upset at empty object but that is what it is
        // eslint-disable-next-line @typescript-eslint/ban-types
        SearchBuilder.prototype.getDetails = function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            return this.s.topGroup.getDetails(deFormatDates);
        };
        /**
         * Getter for the node of the container for the searchBuilder
         *
         * @returns JQuery<HTMLElement> the node of the container
         */
        SearchBuilder.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * Rebuilds the SearchBuilder to a state that is provided
         *
         * @param details The details required to perform a rebuild
         */
        SearchBuilder.prototype.rebuild = function (details) {
            this.dom.clearAll.click();
            // If there are no details to rebuild then return
            if (details === undefined || details === null) {
                return this;
            }
            this.s.topGroup.s.preventRedraw = true;
            this.s.topGroup.rebuild(details);
            this.s.topGroup.s.preventRedraw = false;
            this.s.topGroup.redrawContents();
            this.s.dt.draw(false);
            this.s.topGroup.setListeners();
            return this;
        };
        /**
         * Applies the defaults to preDefined criteria
         *
         * @param preDef the array of criteria to be processed.
         */
        SearchBuilder.prototype._applyPreDefDefaults = function (preDef) {
            var _this = this;
            if (preDef.criteria !== undefined && preDef.logic === undefined) {
                preDef.logic = 'AND';
            }
            var _loop_1 = function (crit) {
                // Apply the defaults to any further criteria
                if (crit.criteria !== undefined) {
                    crit = this_1._applyPreDefDefaults(crit);
                }
                else {
                    this_1.s.dt.columns().every(function (index) {
                        if (_this.s.dt.settings()[0].aoColumns[index].sTitle === crit.data) {
                            crit.dataIdx = index;
                        }
                    });
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = preDef.criteria; _i < _a.length; _i++) {
                var crit = _a[_i];
                _loop_1(crit);
            }
            return preDef;
        };
        /**
         * Set's up the SearchBuilder
         */
        SearchBuilder.prototype._setUp = function (loadState) {
            var _this = this;
            if (loadState === void 0) { loadState = true; }
            // Register an Api method for getting the column type
            $.fn.DataTable.Api.registerPlural('columns().type()', 'column().type()', function () {
                return this.iterator('column', function (settings, column) {
                    return settings.aoColumns[column].sType;
                }, 1);
            });
            // Check that DateTime is included, If not need to check if it could be used
            // eslint-disable-next-line no-extra-parens
            if (!dataTable.DateTime) {
                var types = this.s.dt.columns().type().toArray();
                if (types === undefined || types.includes(undefined) || types.includes(null)) {
                    types = [];
                    for (var _i = 0, _a = this.s.dt.settings()[0].aoColumns; _i < _a.length; _i++) {
                        var colInit = _a[_i];
                        types.push(colInit.searchBuilderType !== undefined ? colInit.searchBuilderType : colInit.sType);
                    }
                }
                var columnIdxs = this.s.dt.columns().toArray();
                // If the types are not yet set then draw to see if they can be retrieved then
                if (types === undefined || types.includes(undefined) || types.includes(null)) {
                    $.fn.dataTable.ext.oApi._fnColumnTypes(this.s.dt.settings()[0]);
                    types = this.s.dt.columns().type().toArray();
                }
                for (var i = 0; i < columnIdxs[0].length; i++) {
                    var column = columnIdxs[0][i];
                    var type = types[column];
                    if (
                    // Check if this column can be filtered
                    (this.c.columns === true ||
                        Array.isArray(this.c.columns) &&
                            this.c.columns.includes(i)) &&
                        // Check if the type is one of the restricted types
                        (type.includes('date') ||
                            type.includes('moment') ||
                            type.includes('luxon'))) {
                        alert('SearchBuilder Requires DateTime when used with dates.');
                        throw new Error('SearchBuilder requires DateTime');
                    }
                }
            }
            this.s.topGroup = new Group(this.s.dt, this.c, undefined);
            this._setClearListener();
            this.s.dt.on('stateSaveParams', function (e, settings, data) {
                data.searchBuilder = _this.getDetails();
                data.page = _this.s.dt.page();
            });
            this._build();
            this.s.dt.on('preXhr', function (e, settings, data) {
                if (_this.s.dt.page.info().serverSide) {
                    data.searchBuilder = _this._collapseArray(_this.getDetails(true));
                }
            });
            if (loadState) {
                var loadedState = this.s.dt.state.loaded();
                // If the loaded State is not null rebuild based on it for statesave
                if (loadedState !== null && loadedState.searchBuilder !== undefined) {
                    this.s.topGroup.rebuild(loadedState.searchBuilder);
                    this.s.topGroup.dom.container.trigger('dtsb-redrawContents');
                    this.s.dt.page(loadedState.page).draw('page');
                    this.s.topGroup.setListeners();
                }
                // Otherwise load any predefined options
                else if (this.c.preDefined !== false) {
                    this.c.preDefined = this._applyPreDefDefaults(this.c.preDefined);
                    this.rebuild(this.c.preDefined);
                }
            }
            this._setEmptyListener();
            this.s.dt.state.save();
        };
        SearchBuilder.prototype._collapseArray = function (criteria) {
            if (criteria.logic === undefined) {
                if (criteria.value !== undefined) {
                    criteria.value.sort(function (a, b) {
                        if (!isNaN(+a)) {
                            a = +a;
                            b = +b;
                        }
                        if (a < b) {
                            return -1;
                        }
                        else if (b < a) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    });
                    criteria.value1 = criteria.value[0];
                    criteria.value2 = criteria.value[1];
                }
            }
            else {
                for (var i = 0; i < criteria.criteria.length; i++) {
                    criteria.criteria[i] = this._collapseArray(criteria.criteria[i]);
                }
            }
            return criteria;
        };
        /**
         * Updates the title of the SearchBuilder
         *
         * @param count the number of filters in the SearchBuilder
         */
        SearchBuilder.prototype._updateTitle = function (count) {
            this.dom.title.html(this.s.dt.i18n('searchBuilder.title', this.c.i18n.title, count));
        };
        /**
         * Builds all of the dom elements together
         */
        SearchBuilder.prototype._build = function () {
            var _this = this;
            // Empty and setup the container
            this.dom.clearAll.remove();
            this.dom.container.empty();
            var count = this.s.topGroup.count();
            this._updateTitle(count);
            this.dom.titleRow.append(this.dom.title);
            this.dom.container.append(this.dom.titleRow);
            this.dom.topGroup = this.s.topGroup.getNode();
            this.dom.container.append(this.dom.topGroup);
            this._setRedrawListener();
            var tableNode = this.s.dt.table(0).node();
            if (!$.fn.dataTable.ext.search.includes(this.s.search)) {
                // Custom search function for SearchBuilder
                this.s.search = function (settings, searchData, dataIndex) {
                    if (settings.nTable !== tableNode) {
                        return true;
                    }
                    return _this.s.topGroup.search(searchData, dataIndex);
                };
                // Add SearchBuilder search function to the dataTables search array
                $.fn.dataTable.ext.search.push(this.s.search);
            }
            this.s.dt.on('destroy.dt', function () {
                _this.dom.container.remove();
                _this.dom.clearAll.remove();
                var searchIdx = $.fn.dataTable.ext.search.indexOf(_this.s.search);
                while (searchIdx !== -1) {
                    $.fn.dataTable.ext.search.splice(searchIdx, 1);
                    searchIdx = $.fn.dataTable.ext.search.indexOf(_this.s.search);
                }
            });
        };
        /**
         * Checks if the clearAll button should be added or not
         */
        SearchBuilder.prototype._checkClear = function () {
            if (this.s.topGroup.s.criteria.length > 0) {
                this.dom.clearAll.insertAfter(this.dom.title);
                this._setClearListener();
            }
            else {
                this.dom.clearAll.remove();
            }
        };
        /**
         * Update the count in the title/button
         *
         * @param count Number of filters applied
         */
        SearchBuilder.prototype._filterChanged = function (count) {
            var fn = this.c.filterChanged;
            if (typeof fn === 'function') {
                fn(count, this.s.dt.i18n('searchBuilder.button', this.c.i18n.button, count));
            }
        };
        /**
         * Set the listener for the clear button
         */
        SearchBuilder.prototype._setClearListener = function () {
            var _this = this;
            this.dom.clearAll.unbind('click');
            this.dom.clearAll.on('click', function () {
                _this.s.topGroup = new Group(_this.s.dt, _this.c, undefined);
                _this._build();
                _this.s.dt.draw();
                _this.s.topGroup.setListeners();
                _this.dom.clearAll.remove();
                _this._setEmptyListener();
                _this._filterChanged(0);
                return false;
            });
        };
        /**
         * Set the listener for the Redraw event
         */
        SearchBuilder.prototype._setRedrawListener = function () {
            var _this = this;
            this.s.topGroup.dom.container.unbind('dtsb-redrawContents');
            this.s.topGroup.dom.container.on('dtsb-redrawContents', function () {
                _this._checkClear();
                _this.s.topGroup.redrawContents();
                _this.s.topGroup.setupLogic();
                _this._setEmptyListener();
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
                _this.s.dt.draw();
                _this.s.dt.state.save();
            });
            this.s.topGroup.dom.container.unbind('dtsb-redrawLogic');
            this.s.topGroup.dom.container.on('dtsb-redrawLogic', function () {
                _this.s.topGroup.redrawLogic();
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
            });
            this.s.topGroup.dom.container.unbind('dtsb-add');
            this.s.topGroup.dom.container.on('dtsb-add', function () {
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
            });
            this.s.dt.on('postEdit postCreate postRemove', function () {
                _this.s.topGroup.redrawContents();
            });
            this.s.topGroup.dom.container.unbind('dtsb-clearContents');
            this.s.topGroup.dom.container.on('dtsb-clearContents', function () {
                _this._setUp(false);
                _this._filterChanged(0);
                _this.s.dt.draw();
            });
            this.s.topGroup.dom.container.on('dtsb-updateTitle', function () {
                var count = _this.s.topGroup.count();
                _this._updateTitle(count);
                _this._filterChanged(count);
            });
        };
        /**
         * Sets listeners to check whether clearAll should be added or removed
         */
        SearchBuilder.prototype._setEmptyListener = function () {
            var _this = this;
            this.s.topGroup.dom.add.on('click', function () {
                _this._checkClear();
            });
            this.s.topGroup.dom.container.on('dtsb-destroy', function () {
                _this.dom.clearAll.remove();
            });
        };
        SearchBuilder.version = '1.2.1';
        SearchBuilder.classes = {
            button: 'dtsb-button',
            clearAll: 'dtsb-clearAll',
            container: 'dtsb-searchBuilder',
            inputButton: 'dtsb-iptbtn',
            title: 'dtsb-title',
            titleRow: 'dtsb-titleRow'
        };
        SearchBuilder.defaults = {
            columns: true,
            conditions: {
                'date': Criteria.dateConditions,
                'html': Criteria.stringConditions,
                'html-num': Criteria.numConditions,
                'html-num-fmt': Criteria.numFmtConditions,
                'luxon': Criteria.luxonDateConditions,
                'moment': Criteria.momentDateConditions,
                'num': Criteria.numConditions,
                'num-fmt': Criteria.numFmtConditions,
                'string': Criteria.stringConditions
            },
            depthLimit: false,
            enterSearch: false,
            filterChanged: undefined,
            greyscale: false,
            i18n: {
                add: 'Add Condition',
                button: {
                    0: 'Search Builder',
                    _: 'Search Builder (%d)'
                },
                clearAll: 'Clear All',
                condition: 'Condition',
                conditions: {
                    array: {
                        contains: 'Contains',
                        empty: 'Empty',
                        equals: 'Equals',
                        not: 'Not',
                        notEmpty: 'Not Empty',
                        without: 'Without'
                    },
                    date: {
                        after: 'After',
                        before: 'Before',
                        between: 'Between',
                        empty: 'Empty',
                        equals: 'Equals',
                        not: 'Not',
                        notBetween: 'Not Between',
                        notEmpty: 'Not Empty'
                    },
                    // eslint-disable-next-line id-blacklist
                    number: {
                        between: 'Between',
                        empty: 'Empty',
                        equals: 'Equals',
                        gt: 'Greater Than',
                        gte: 'Greater Than Equal To',
                        lt: 'Less Than',
                        lte: 'Less Than Equal To',
                        not: 'Not',
                        notBetween: 'Not Between',
                        notEmpty: 'Not Empty'
                    },
                    // eslint-disable-next-line id-blacklist
                    string: {
                        contains: 'Contains',
                        empty: 'Empty',
                        endsWith: 'Ends With',
                        equals: 'Equals',
                        not: 'Not',
                        notEmpty: 'Not Empty',
                        startsWith: 'Starts With'
                    }
                },
                data: 'Data',
                deleteTitle: 'Delete filtering rule',
                leftTitle: 'Outdent criteria',
                logicAnd: 'And',
                logicOr: 'Or',
                rightTitle: 'Indent criteria',
                title: {
                    0: 'Custom Search Builder',
                    _: 'Custom Search Builder (%d)'
                },
                value: 'Value',
                valueJoiner: 'and'
            },
            logic: 'AND',
            orthogonal: {
                display: 'display',
                search: 'filter'
            },
            preDefined: false
        };
        return SearchBuilder;
    }());

    /*! SearchBuilder 1.2.1
     * Â©SpryMedia Ltd - datatables.net/license/mit
     */
    // DataTables extensions common UMD. Note that this allows for AMD, CommonJS
    // (with window and jQuery being allowed as parameters to the returned
    // function) or just default browser loading.
    (function (factory) {
        if (true) {
            // AMD
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
                return factory($, window, document);
            }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
        else {}
    }(function ($, window, document) {
        setJQuery($);
        setJQuery$1($);
        setJQuery$2($);
        var dataTable = $.fn.dataTable;
        // eslint-disable-next-line no-extra-parens
        $.fn.dataTable.SearchBuilder = SearchBuilder;
        // eslint-disable-next-line no-extra-parens
        $.fn.DataTable.SearchBuilder = SearchBuilder;
        // eslint-disable-next-line no-extra-parens
        $.fn.dataTable.Group = Group;
        // eslint-disable-next-line no-extra-parens
        $.fn.DataTable.Group = Group;
        // eslint-disable-next-line no-extra-parens
        $.fn.dataTable.Criteria = Criteria;
        // eslint-disable-next-line no-extra-parens
        $.fn.DataTable.Criteria = Criteria;
        // eslint-disable-next-line no-extra-parens
        var apiRegister = $.fn.dataTable.Api.register;
        // Set up object for plugins
        $.fn.dataTable.ext.searchBuilder = {
            conditions: {}
        };
        $.fn.dataTable.ext.buttons.searchBuilder = {
            action: function (e, dt, node, config) {
                this.popover(config._searchBuilder.getNode(), {
                    align: 'dt-container'
                });
                // Need to redraw the contents to calculate the correct positions for the elements
                if (config._searchBuilder.s.topGroup !== undefined) {
                    config._searchBuilder.s.topGroup.dom.container.trigger('dtsb-redrawContents');
                }
            },
            config: {},
            init: function (dt, node, config) {
                var sb = new $.fn.dataTable.SearchBuilder(dt, $.extend({
                    filterChanged: function (count, text) {
                        dt.button(node).text(text);
                    }
                }, config.config));
                dt.button(node).text(config.text || dt.i18n('searchBuilder.button', sb.c.i18n.button, 0));
                config._searchBuilder = sb;
            },
            text: null
        };
        apiRegister('searchBuilder.getDetails()', function (deFormatDates) {
            if (deFormatDates === void 0) { deFormatDates = false; }
            var ctx = this.context[0];
            // If SearchBuilder has not been initialised on this instance then return
            return ctx._searchBuilder ?
                ctx._searchBuilder.getDetails(deFormatDates) :
                null;
        });
        apiRegister('searchBuilder.rebuild()', function (details) {
            var ctx = this.context[0];
            // If SearchBuilder has not been initialised on this instance then return
            if (ctx._searchBuilder === undefined) {
                return null;
            }
            ctx._searchBuilder.rebuild(details);
            return this;
        });
        apiRegister('searchBuilder.container()', function () {
            var ctx = this.context[0];
            // If SearchBuilder has not been initialised on this instance then return
            return ctx._searchBuilder ?
                ctx._searchBuilder.getNode() :
                null;
        });
        /**
         * Init function for SearchBuilder
         *
         * @param settings the settings to be applied
         * @param options the options for SearchBuilder
         * @returns JQUERY<HTMLElement> Returns the node of the SearchBuilder
         */
        function _init(settings, options) {
            var api = new dataTable.Api(settings);
            var opts = options
                ? options
                : api.init().searchBuilder || dataTable.defaults.searchBuilder;
            var searchBuilder = new SearchBuilder(api, opts);
            var node = searchBuilder.getNode();
            return node;
        }
        // Attach a listener to the document which listens for DataTables initialisation
        // events so we can automatically initialise
        $(document).on('preInit.dt.dtsp', function (e, settings) {
            if (e.namespace !== 'dt') {
                return;
            }
            if (settings.oInit.searchBuilder ||
                dataTable.defaults.searchBuilder) {
                if (!settings._searchBuilder) {
                    _init(settings);
                }
            }
        });
        // DataTables `dom` feature option
        dataTable.ext.feature.push({
            cFeature: 'Q',
            fnInit: _init
        });
        // DataTables 2 layout feature
        if (dataTable.ext.features) {
            dataTable.ext.features.register('searchBuilder', _init);
        }
    }));

}());


/***/ }),

/***/ "./node_modules/datatables.net-searchpanes-bs5/js/searchPanes.bootstrap5.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/datatables.net-searchpanes-bs5/js/searchPanes.bootstrap5.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap 5 integration for DataTables' SearchPanes
 * Â©2016 SpryMedia Ltd - datatables.net/license
 */
(function (factory) {
    if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net-bs5 */ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js"), __webpack_require__(/*! datatables.net-searchpanes */ "./node_modules/datatables.net-searchpanes/js/dataTables.searchPanes.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
            return factory($, window, document);
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
}(function ($, window, document) {
    'use strict';
    var dataTable = $.fn.dataTable;
    $.extend(true, dataTable.SearchPane.classes, {
        buttonGroup: 'btn-group',
        disabledButton: 'disabled',
        narrow: 'col',
        pane: {
            container: 'table'
        },
        paneButton: 'btn btn-light',
        pill: 'badge rounded-pill bg-secondary',
        search: 'form-control search',
        table: 'table table-sm table-borderless',
        topRow: 'dtsp-topRow'
    });
    $.extend(true, dataTable.SearchPanes.classes, {
        clearAll: 'dtsp-clearAll btn btn-light',
        collapseAll: 'dtsp-collapseAll btn btn-light',
        container: 'dtsp-searchPanes',
        disabledButton: 'disabled',
        panes: 'dtsp-panes dtsp-panesContainer',
        showAll: 'dtsp-showAll btn btn-light',
        title: 'dtsp-title',
        titleRow: 'dtsp-titleRow'
    });
    return dataTable.searchPanes;
}));


/***/ }),

/***/ "./node_modules/datatables.net-searchpanes/js/dataTables.searchPanes.js":
/*!******************************************************************************!*\
  !*** ./node_modules/datatables.net-searchpanes/js/dataTables.searchPanes.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! SearchPanes 1.4.0
 * 2019-2020 SpryMedia Ltd - datatables.net/license
 */
(function () {
    'use strict';

    var $;
    var dataTable;
    function setJQuery(jq) {
        $ = jq;
        dataTable = jq.fn.dataTable;
    }
    var SearchPane = /** @class */ (function () {
        /**
         * Creates the panes, sets up the search function
         *
         * @param paneSettings The settings for the searchPanes
         * @param opts The options for the default features
         * @param idx the index of the column for this pane
         * @returns {object} the pane that has been created, including the table and the index of the pane
         */
        function SearchPane(paneSettings, opts, idx, layout, panesContainer, panes) {
            var _this = this;
            if (panes === void 0) { panes = null; }
            // Check that the required version of DataTables is included
            if (!dataTable || !dataTable.versionCheck || !dataTable.versionCheck('1.10.0')) {
                throw new Error('SearchPane requires DataTables 1.10 or newer');
            }
            // Check that Select is included
            // eslint-disable-next-line no-extra-parens
            if (!dataTable.select) {
                throw new Error('SearchPane requires Select');
            }
            var table = new dataTable.Api(paneSettings);
            this.classes = $.extend(true, {}, SearchPane.classes);
            // Get options from user
            this.c = $.extend(true, {}, SearchPane.defaults, opts);
            if (opts !== undefined && opts.hideCount !== undefined && opts.viewCount === undefined) {
                this.c.viewCount = !this.c.hideCount;
            }
            this.customPaneSettings = panes;
            this.s = {
                cascadeRegen: false,
                clearing: false,
                colOpts: [],
                deselect: false,
                displayed: false,
                dt: table,
                dtPane: undefined,
                filteringActive: false,
                firstSet: true,
                forceViewTotal: false,
                index: idx,
                indexes: [],
                lastCascade: false,
                lastSelect: false,
                listSet: false,
                name: undefined,
                redraw: false,
                rowData: {
                    arrayFilter: [],
                    arrayOriginal: [],
                    arrayTotals: [],
                    bins: {},
                    binsOriginal: {},
                    binsTotal: {},
                    filterMap: new Map(),
                    totalOptions: 0
                },
                scrollTop: 0,
                searchFunction: undefined,
                selectPresent: false,
                serverSelect: [],
                serverSelecting: false,
                showFiltered: false,
                tableLength: null,
                updating: false
            };
            var rowLength = table.columns().eq(0).toArray().length;
            this.colExists = this.s.index < rowLength;
            // Add extra elements to DOM object including clear and hide buttons
            this.c.layout = layout;
            var layVal = parseInt(layout.split('-')[1], 10);
            this.dom = {
                buttonGroup: $('<div/>').addClass(this.classes.buttonGroup),
                clear: $('<button type="button">&#215;</button>')
                    .addClass(this.classes.disabledButton)
                    .attr('disabled', 'true')
                    .addClass(this.classes.paneButton)
                    .addClass(this.classes.clearButton),
                collapseButton: $('<button type="button"><span class="dtsp-caret">&#x5e;</span></button>')
                    .addClass(this.classes.paneButton)
                    .addClass(this.classes.collapseButton),
                container: $('<div/>')
                    .addClass(this.classes.container)
                    .addClass(this.classes.layout +
                    (layVal < 10 ? layout : layout.split('-')[0] + '-9')),
                countButton: $('<button type="button"></button>')
                    .addClass(this.classes.paneButton)
                    .addClass(this.classes.countButton),
                dtP: $('<table><thead><tr><th>' +
                    (this.colExists
                        ? $(table.column(this.colExists ? this.s.index : 0).header()).text()
                        : this.customPaneSettings.header || 'Custom Pane') + '</th><th/></tr></thead></table>'),
                lower: $('<div/>').addClass(this.classes.subRow2).addClass(this.classes.narrowButton),
                nameButton: $('<button type="button"></button>')
                    .addClass(this.classes.paneButton)
                    .addClass(this.classes.nameButton),
                panesContainer: panesContainer,
                searchBox: $('<input/>').addClass(this.classes.paneInputButton).addClass(this.classes.search),
                searchButton: $('<button type = "button" class="' + this.classes.searchIcon + '"></button>')
                    .addClass(this.classes.paneButton),
                searchCont: $('<div/>').addClass(this.classes.searchCont),
                searchLabelCont: $('<div/>').addClass(this.classes.searchLabelCont),
                topRow: $('<div/>').addClass(this.classes.topRow),
                upper: $('<div/>').addClass(this.classes.subRow1).addClass(this.classes.narrowSearch)
            };
            this.s.displayed = false;
            table = this.s.dt;
            this.selections = [];
            this.s.colOpts = this.colExists ? this._getOptions() : this._getBonusOptions();
            var colOpts = this.s.colOpts;
            var clear = $('<button type="button">X</button>').addClass(this.classes.paneButton);
            clear.text(table.i18n('searchPanes.clearPane', this.c.i18n.clearPane));
            this.dom.container.addClass(colOpts.className);
            this.dom.container.addClass(this.customPaneSettings !== null && this.customPaneSettings.className !== undefined
                ? this.customPaneSettings.className
                : '');
            // Set the value of name incase ordering is desired
            if (this.s.colOpts.name !== undefined) {
                this.s.name = this.s.colOpts.name;
            }
            else if (this.customPaneSettings !== null && this.customPaneSettings.name !== undefined) {
                this.s.name = this.customPaneSettings.name;
            }
            else {
                this.s.name = this.colExists ?
                    $(table.column(this.s.index).header()).text() :
                    this.customPaneSettings.header || 'Custom Pane';
            }
            $(panesContainer).append(this.dom.container);
            var tableNode = table.table(0).node();
            // Custom search function for table
            this.s.searchFunction = function (settings, searchData, dataIndex, origData) {
                // If no data has been selected then show all
                if (_this.selections.length === 0) {
                    return true;
                }
                if (settings.nTable !== tableNode) {
                    return true;
                }
                var filter = null;
                if (_this.colExists) {
                    // Get the current filtered data
                    filter = searchData[_this.s.index];
                    if (colOpts.orthogonal.filter !== 'filter') {
                        // get the filter value from the map
                        filter = _this.s.rowData.filterMap.get(dataIndex);
                        if (filter instanceof $.fn.dataTable.Api) {
                            // eslint-disable-next-line no-extra-parens
                            filter = filter.toArray();
                        }
                    }
                }
                return _this._search(filter, dataIndex);
            };
            $.fn.dataTable.ext.search.push(this.s.searchFunction);
            // If the clear button for this pane is clicked clear the selections
            if (this.c.clear) {
                clear.on('click', function () {
                    var searches = _this.dom.container.find('.' + _this.classes.search.replace(/\s+/g, '.'));
                    searches.each(function () {
                        $(this).val('');
                        $(this).trigger('input');
                    });
                    _this.clearPane();
                });
            }
            // Sometimes the top row of the panes containing the search box and ordering buttons appears
            //  weird if the width of the panes is lower than expected, this fixes the design.
            // Equally this may occur when the table is resized.
            table.on('draw.dtsp', function () {
                _this.adjustTopRow();
            });
            table.on('buttons-action', function () {
                _this.adjustTopRow();
            });
            // When column-reorder is present and the columns are moved, it is necessary to
            //  reassign all of the panes indexes to the new index of the column.
            table.on('column-reorder.dtsp', function (e, settings, details) {
                _this.s.index = details.mapping[_this.s.index];
            });
            return this;
        }
        /**
         * Adds a row to the panes table
         *
         * @param display the value to be displayed to the user
         * @param filter the value to be filtered on when searchpanes is implemented
         * @param shown the number of rows in the table that are currently visible matching this criteria
         * @param total the total number of rows in the table that match this criteria
         * @param sort the value to be sorted in the pane table
         * @param type the value of which the type is to be derived from
         */
        SearchPane.prototype.addRow = function (display, filter, shown, total, sort, type, className) {
            var index;
            for (var _i = 0, _a = this.s.indexes; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry.filter === filter) {
                    index = entry.index;
                }
            }
            if (index === undefined) {
                index = this.s.indexes.length;
                this.s.indexes.push({ filter: filter, index: index });
            }
            return this.s.dtPane.row.add({
                className: className,
                display: display !== '' ?
                    display :
                    this.emptyMessage(),
                filter: filter,
                index: index,
                shown: shown,
                sort: sort,
                total: total,
                type: type
            });
        };
        /**
         * Adjusts the layout of the top row when the screen is resized
         */
        SearchPane.prototype.adjustTopRow = function () {
            var subContainers = this.dom.container.find('.' + this.classes.subRowsContainer.replace(/\s+/g, '.'));
            var subRow1 = this.dom.container.find('.' + this.classes.subRow1.replace(/\s+/g, '.'));
            var subRow2 = this.dom.container.find('.' + this.classes.subRow2.replace(/\s+/g, '.'));
            var topRow = this.dom.container.find('.' + this.classes.topRow.replace(/\s+/g, '.'));
            // If the width is 0 then it is safe to assume that the pane has not yet been displayed.
            //  Even if it has, if the width is 0 it won't make a difference if it has the narrow class or not
            if (($(subContainers[0]).width() < 252 || $(topRow[0]).width() < 252) && $(subContainers[0]).width() !== 0) {
                $(subContainers[0]).addClass(this.classes.narrow);
                $(subRow1[0]).addClass(this.classes.narrowSub).removeClass(this.classes.narrowSearch);
                $(subRow2[0]).addClass(this.classes.narrowSub).removeClass(this.classes.narrowButton);
            }
            else {
                $(subContainers[0]).removeClass(this.classes.narrow);
                $(subRow1[0]).removeClass(this.classes.narrowSub).addClass(this.classes.narrowSearch);
                $(subRow2[0]).removeClass(this.classes.narrowSub).addClass(this.classes.narrowButton);
            }
        };
        /**
         * In the case of a rebuild there is potential for new data to have been included or removed
         * so all of the rowData must be reset as a precaution.
         */
        SearchPane.prototype.clearData = function () {
            this.s.rowData = {
                arrayFilter: [],
                arrayOriginal: [],
                arrayTotals: [],
                bins: {},
                binsOriginal: {},
                binsTotal: {},
                filterMap: new Map(),
                totalOptions: 0
            };
        };
        /**
         * Clear the selections in the pane
         */
        SearchPane.prototype.clearPane = function () {
            // Deselect all rows which are selected and update the table and filter count.
            this.s.dtPane.rows({ selected: true }).deselect();
            this.updateTable();
            return this;
        };
        /**
         * Collapses the pane so that only the header is displayed
         */
        SearchPane.prototype.collapse = function () {
            var _this = this;
            if (!this.s.displayed ||
                (!this.c.collapse && this.s.colOpts.collapse !== true ||
                    this.s.colOpts.collapse === false)) {
                return;
            }
            this.dom.collapseButton.addClass(this.classes.rotated);
            $(this.s.dtPane.table().container()).addClass(this.classes.hidden);
            this.dom.topRow.addClass(this.classes.bordered);
            this.dom.countButton.addClass(this.classes.disabledButton);
            this.dom.nameButton.addClass(this.classes.disabledButton);
            this.dom.searchButton.addClass(this.classes.disabledButton);
            this.dom.topRow.one('click', function () {
                _this.show();
            });
        };
        /**
         * Strips all of the SearchPanes elements from the document and turns all of the listeners for the buttons off
         */
        SearchPane.prototype.destroy = function () {
            if (this.s.dtPane !== undefined) {
                this.s.dtPane.off('.dtsp');
            }
            this.dom.nameButton.off('.dtsp');
            this.dom.collapseButton.off('.dtsp');
            this.dom.countButton.off('.dtsp');
            this.dom.clear.off('.dtsp');
            this.dom.searchButton.off('.dtsp');
            this.dom.container.remove();
            var searchIdx = $.fn.dataTable.ext.search.indexOf(this.s.searchFunction);
            while (searchIdx !== -1) {
                $.fn.dataTable.ext.search.splice(searchIdx, 1);
                searchIdx = $.fn.dataTable.ext.search.indexOf(this.s.searchFunction);
            }
            // If the datatables have been defined for the panes then also destroy these
            if (this.s.dtPane !== undefined) {
                this.s.dtPane.destroy();
            }
            this.s.listSet = false;
        };
        /**
         * Getting the legacy message is a little complex due a legacy parameter
         */
        SearchPane.prototype.emptyMessage = function () {
            var def = this.c.i18n.emptyMessage;
            // Legacy parameter support
            if (this.c.emptyMessage) {
                def = this.c.emptyMessage;
            }
            // Override per column
            if (this.s.colOpts.emptyMessage !== false && this.s.colOpts.emptyMessage !== null) {
                def = this.s.colOpts.emptyMessage;
            }
            return this.s.dt.i18n('searchPanes.emptyMessage', def);
        };
        /**
         * Updates the number of filters that have been applied in the title
         */
        SearchPane.prototype.getPaneCount = function () {
            return this.s.dtPane !== undefined ?
                this.s.dtPane.rows({ selected: true }).data().toArray().length :
                0;
        };
        /**
         * Rebuilds the panes from the start having deleted the old ones
         *
         * @param? last boolean to indicate if this is the last pane a selection was made in
         * @param? dataIn data to be used in buildPane
         * @param? init Whether this is the initial draw or not
         * @param? maintainSelection Whether the current selections are to be maintained over rebuild
         */
        SearchPane.prototype.rebuildPane = function (last, dataIn, init, maintainSelection) {
            if (last === void 0) { last = false; }
            if (dataIn === void 0) { dataIn = null; }
            if (init === void 0) { init = null; }
            if (maintainSelection === void 0) { maintainSelection = false; }
            this.clearData();
            var selectedRows = [];
            this.s.serverSelect = [];
            var prevEl = null;
            // When rebuilding strip all of the HTML Elements out of the container and start from scratch
            if (this.s.dtPane !== undefined) {
                if (maintainSelection) {
                    if (!this.s.dt.page.info().serverSide) {
                        selectedRows = this.s.dtPane.rows({ selected: true }).data().toArray();
                    }
                    else {
                        this.s.serverSelect = this.s.dtPane.rows({ selected: true }).data().toArray();
                    }
                }
                this.s.dtPane.clear().destroy();
                prevEl = this.dom.container.prev();
                this.destroy();
                this.s.dtPane = undefined;
                $.fn.dataTable.ext.search.push(this.s.searchFunction);
            }
            this.dom.container.removeClass(this.classes.hidden);
            this.s.displayed = false;
            this._buildPane(!this.s.dt.page.info().serverSide ?
                selectedRows :
                this.s.serverSelect, last, dataIn, init, prevEl);
            return this;
        };
        /**
         * removes the pane from the page and sets the displayed property to false.
         */
        SearchPane.prototype.removePane = function () {
            this.s.displayed = false;
            this.dom.container.hide();
        };
        /**
         * Resizes the pane based on the layout that is passed in
         *
         * @param layout the layout to be applied to this pane
         */
        SearchPane.prototype.resize = function (layout) {
            this.c.layout = layout;
            var layVal = parseInt(layout.split('-')[1], 10);
            this.dom.container
                .removeClass()
                .addClass(this.classes.container)
                .addClass(this.classes.layout +
                (layVal < 10 ? layout : layout.split('-')[0] + '-9'))
                .addClass(this.s.colOpts.className)
                .addClass(this.customPaneSettings !== null && this.customPaneSettings.className !== undefined
                ? this.customPaneSettings.className
                : '')
                .addClass(this.classes.show);
            this.adjustTopRow();
        };
        /**
         * Sets the cascadeRegen property of the pane. Accessible from above because as SearchPanes.ts
         * deals with the rebuilds.
         *
         * @param val the boolean value that the cascadeRegen property is to be set to
         */
        SearchPane.prototype.setCascadeRegen = function (val) {
            this.s.cascadeRegen = val;
        };
        /**
         * This function allows the clearing property to be assigned. This is used when implementing cascadePane.
         * In setting this to true for the clearing of the panes selection on the deselects it forces the pane to
         * repopulate from the entire dataset not just the displayed values.
         *
         * @param val the boolean value which the clearing property is to be assigned
         */
        SearchPane.prototype.setClear = function (val) {
            this.s.clearing = val;
        };
        /**
         * Expands the pane from the collapsed state
         */
        SearchPane.prototype.show = function () {
            if (!this.s.displayed) {
                return;
            }
            this.dom.collapseButton.removeClass(this.classes.rotated);
            $(this.s.dtPane.table().container()).removeClass(this.classes.hidden);
            this.dom.topRow.removeClass(this.classes.bordered);
            this.dom.countButton.removeClass(this.classes.disabledButton);
            this.dom.nameButton.removeClass(this.classes.disabledButton);
            this.dom.searchButton.removeClass(this.classes.disabledButton);
        };
        /**
         * Updates the values of all of the panes
         *
         * @param draw whether this has been triggered by a draw event or not
         */
        SearchPane.prototype.updatePane = function (draw) {
            if (draw === void 0) { draw = false; }
            this.s.updating = true;
            this._updateCommon(draw);
            this.s.updating = false;
        };
        /**
         * Updates the panes if one of the options to do so has been set to true
         * rather than the filtered message when using viewTotal.
         */
        SearchPane.prototype.updateTable = function () {
            var selectedRows = this.s.dtPane.rows({ selected: true }).data().toArray();
            this.selections = selectedRows;
            this._searchExtras();
            // If either of the options that effect how the panes are displayed are selected then update the Panes
            if (this.c.cascadePanes || this.c.viewTotal) {
                this.updatePane();
            }
        };
        /**
         * Sets the listeners for the pane.
         *
         * Having it in it's own function makes it easier to only set them once
         */
        SearchPane.prototype._setListeners = function () {
            var _this = this;
            var rowData = this.s.rowData;
            var t0;
            // When an item is selected on the pane, add these to the array which holds selected items.
            // Custom search will perform.
            this.s.dtPane.off('select.dtsp');
            this.s.dtPane.on('select.dtsp', function () {
                clearTimeout(t0);
                if (_this.s.dt.page.info().serverSide && !_this.s.updating) {
                    if (!_this.s.serverSelecting) {
                        _this.s.serverSelect = _this.s.dtPane.rows({ selected: true }).data().toArray();
                        _this.s.scrollTop = $(_this.s.dtPane.table().node()).parent()[0].scrollTop;
                        _this.s.selectPresent = true;
                        _this.s.dt.draw(false);
                    }
                }
                else if (!_this.s.updating) {
                    _this.s.selectPresent = true;
                    _this._makeSelection();
                    _this.s.selectPresent = false;
                }
                _this.dom.clear.removeClass(_this.classes.disabledButton).removeAttr('disabled');
            });
            // When an item is deselected on the pane, re add the currently selected items to the array
            // which holds selected items. Custom search will be performed.
            this.s.dtPane.off('deselect.dtsp');
            this.s.dtPane.on('deselect.dtsp', function () {
                t0 = setTimeout(function () {
                    _this.s.scrollTop = $(_this.s.dtPane.table().node()).parent()[0].scrollTop;
                    if (_this.s.dt.page.info().serverSide && !_this.s.updating) {
                        if (!_this.s.serverSelecting) {
                            _this.s.serverSelect = _this.s.dtPane.rows({ selected: true }).data().toArray();
                            _this.s.deselect = true;
                            _this.s.dt.draw(false);
                        }
                    }
                    else {
                        _this.s.deselect = true;
                        _this._makeSelection();
                        _this.s.deselect = false;
                    }
                    if (_this.s.dtPane.rows({ selected: true }).data().toArray().length === 0) {
                        _this.dom.clear.addClass(_this.classes.disabledButton).attr('disabled', 'true');
                    }
                }, 50);
            });
            // If we attempty to turn off this event then it will ruin behaviour in other panes
            //  so need to make sure that it is only done once
            if (this.s.firstSet) {
                this.s.firstSet = false;
                // When saving the state store all of the selected rows for preselection next time around
                this.s.dt.on('stateSaveParams.dtsp', function (e, settings, data) {
                    // If the data being passed in is empty then state clear must have occured
                    // so clear the panes state as well
                    if ($.isEmptyObject(data)) {
                        _this.s.dtPane.state.clear();
                        return;
                    }
                    var selected = [];
                    var searchTerm;
                    var order;
                    var bins;
                    var arrayFilter;
                    var collapsed;
                    // Get all of the data needed for the state save from the pane
                    if (_this.s.dtPane !== undefined) {
                        selected = _this.s.dtPane
                            .rows({ selected: true })
                            .data()
                            .map(function (item) { return item.filter.toString(); })
                            .toArray();
                        searchTerm = _this.dom.searchBox.val();
                        order = _this.s.dtPane.order();
                        bins = rowData.binsOriginal;
                        arrayFilter = rowData.arrayOriginal;
                        collapsed = _this.dom.collapseButton.hasClass(_this.classes.rotated);
                    }
                    if (data.searchPanes === undefined) {
                        data.searchPanes = {};
                    }
                    if (data.searchPanes.panes === undefined) {
                        data.searchPanes.panes = [];
                    }
                    for (var i = 0; i < data.searchPanes.panes.length; i++) {
                        if (data.searchPanes.panes[i].id === _this.s.index) {
                            data.searchPanes.panes.splice(i, 1);
                            i--;
                        }
                    }
                    // Add the panes data to the state object
                    data.searchPanes.panes.push({
                        arrayFilter: arrayFilter,
                        bins: bins,
                        collapsed: collapsed,
                        id: _this.s.index,
                        order: order,
                        searchTerm: searchTerm,
                        selected: selected
                    });
                });
            }
            this.s.dtPane.off('user-select.dtsp');
            this.s.dtPane.on('user-select.dtsp', function (e, _dt, type, cell, originalEvent) {
                originalEvent.stopPropagation();
            });
            this.s.dtPane.off('draw.dtsp');
            this.s.dtPane.on('draw.dtsp', function () {
                _this.adjustTopRow();
            });
            // When the button to order by the name of the options is clicked then
            //  change the ordering to whatever it isn't currently
            this.dom.nameButton.off('click.dtsp');
            this.dom.nameButton.on('click.dtsp', function () {
                var currentOrder = _this.s.dtPane.order()[0][1];
                _this.s.dtPane.order([0, currentOrder === 'asc' ? 'desc' : 'asc']).draw();
                // This state save is required so that the ordering of the panes is maintained
                _this.s.dt.state.save();
            });
            // When the button to order by the number of entries in the column is clicked then
            //  change the ordering to whatever it isn't currently
            this.dom.countButton.off('click.dtsp');
            this.dom.countButton.on('click.dtsp', function () {
                var currentOrder = _this.s.dtPane.order()[0][1];
                _this.s.dtPane.order([1, currentOrder === 'asc' ? 'desc' : 'asc']).draw();
                // This state save is required so that the ordering of the panes is maintained
                _this.s.dt.state.save();
            });
            // When the button to order by the number of entries in the column is clicked then
            //  change the ordering to whatever it isn't currently
            this.dom.collapseButton.off('click.dtsp');
            this.dom.collapseButton.on('click.dtsp', function (e) {
                e.stopPropagation();
                var container = $(_this.s.dtPane.table().container());
                // Toggle the classes
                _this.dom.collapseButton.toggleClass(_this.classes.rotated);
                container.toggleClass(_this.classes.hidden);
                _this.dom.topRow.toggleClass(_this.classes.bordered);
                _this.dom.countButton.toggleClass(_this.classes.disabledButton);
                _this.dom.nameButton.toggleClass(_this.classes.disabledButton);
                _this.dom.searchButton.toggleClass(_this.classes.disabledButton);
                if (container.hasClass(_this.classes.hidden)) {
                    _this.dom.topRow.on('click', function () { return _this.dom.collapseButton.click(); });
                }
                else {
                    _this.dom.topRow.off('click');
                }
                _this.s.dt.state.save();
                return;
            });
            // When the clear button is clicked reset the pane
            this.dom.clear.off('click.dtsp');
            this.dom.clear.on('click.dtsp', function () {
                var searches = _this.dom.container.find('.' + _this.classes.search.replace(/ /g, '.'));
                searches.each(function () {
                    // set the value of the search box to be an empty string and then search on that, effectively reseting
                    $(this).val('');
                    $(this).trigger('input');
                });
                _this.clearPane();
            });
            // When the search button is clicked then draw focus to the search box
            this.dom.searchButton.off('click.dtsp');
            this.dom.searchButton.on('click.dtsp', function () {
                _this.dom.searchBox.focus();
            });
            // When a character is inputted into the searchbox search the pane for matching values.
            // Doing it this way means that no button has to be clicked to trigger a search, it is done asynchronously
            this.dom.searchBox.off('click.dtsp');
            this.dom.searchBox.on('input.dtsp', function () {
                var searchval = _this.dom.searchBox.val();
                _this.s.dtPane.search(searchval).draw();
                if (typeof searchval === 'string' &&
                    (searchval.length > 0 ||
                        searchval.length === 0 && _this.s.dtPane.rows({ selected: true }).data().toArray().length > 0)) {
                    _this.dom.clear.removeClass(_this.classes.disabledButton).removeAttr('disabled');
                }
                else {
                    _this.dom.clear.addClass(_this.classes.disabledButton).attr('disabled', 'true');
                }
                // This state save is required so that the searching on the panes is maintained
                _this.s.dt.state.save();
            });
            return true;
        };
        /**
         * Takes in potentially undetected rows and adds them to the array if they are not yet featured
         *
         * @param filter the filter value of the potential row
         * @param display the display value of the potential row
         * @param sort the sort value of the potential row
         * @param type the type value of the potential row
         * @param arrayFilter the array to be populated
         * @param bins the bins to be populated
         */
        SearchPane.prototype._addOption = function (filter, display, sort, type, arrayFilter, bins) {
            // If the filter is an array then take a note of this, and add the elements to the arrayFilter array
            if (Array.isArray(filter) || filter instanceof dataTable.Api) {
                // Convert to an array so that we can work with it
                if (filter instanceof dataTable.Api) {
                    filter = filter.toArray();
                    display = display.toArray();
                }
                if (filter.length === display.length) {
                    for (var i = 0; i < filter.length; i++) {
                        // If we haven't seen this row before add it
                        if (!bins[filter[i]]) {
                            bins[filter[i]] = 1;
                            arrayFilter.push({
                                display: display[i],
                                filter: filter[i],
                                sort: sort[i],
                                type: type[i]
                            });
                        }
                        // Otherwise just increment the count
                        else {
                            bins[filter[i]]++;
                        }
                        this.s.rowData.totalOptions++;
                    }
                    return;
                }
                else {
                    throw new Error('display and filter not the same length');
                }
            }
            // If the values were affected by othogonal data and are not an array then check if it is already present
            else if (typeof this.s.colOpts.orthogonal === 'string') {
                if (!bins[filter]) {
                    bins[filter] = 1;
                    arrayFilter.push({
                        display: display,
                        filter: filter,
                        sort: sort,
                        type: type
                    });
                    this.s.rowData.totalOptions++;
                }
                else {
                    bins[filter]++;
                    this.s.rowData.totalOptions++;
                    return;
                }
            }
            // Otherwise we must just be adding an option
            else {
                arrayFilter.push({
                    display: display,
                    filter: filter,
                    sort: sort,
                    type: type
                });
            }
        };
        /**
         * Method to construct the actual pane.
         *
         * @param selectedRows previously selected Rows to be reselected
         * @last boolean to indicate whether this pane was the last one to have a selection made
         */
        SearchPane.prototype._buildPane = function (selectedRows, last, dataIn, init, prevEl) {
            var _this = this;
            if (selectedRows === void 0) { selectedRows = []; }
            if (last === void 0) { last = false; }
            if (dataIn === void 0) { dataIn = null; }
            if (init === void 0) { init = null; }
            if (prevEl === void 0) { prevEl = null; }
            // Aliases
            this.selections = [];
            var table = this.s.dt;
            var column = table.column(this.colExists ? this.s.index : 0);
            var colOpts = this.s.colOpts;
            var rowData = this.s.rowData;
            // Other Variables
            var countMessage = table.i18n('searchPanes.count', this.c.i18n.count);
            var filteredMessage = table.i18n('searchPanes.countFiltered', this.c.i18n.countFiltered);
            var loadedFilter = table.state.loaded();
            // If the listeners have not been set yet then using the latest state may result in funny errors
            if (this.s.listSet) {
                loadedFilter = table.state();
            }
            // If it is not a custom pane in place
            if (this.colExists) {
                var idx = -1;
                if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.panes) {
                    for (var i = 0; i < loadedFilter.searchPanes.panes.length; i++) {
                        if (loadedFilter.searchPanes.panes[i].id === this.s.index) {
                            idx = i;
                            break;
                        }
                    }
                }
                // Perform checks that do not require populate pane to run
                if ((colOpts.show === false ||
                    colOpts.show !== undefined && colOpts.show !== true) &&
                    idx === -1) {
                    this.dom.container.addClass(this.classes.hidden);
                    this.s.displayed = false;
                    return false;
                }
                else if (colOpts.show === true || idx !== -1) {
                    this.s.displayed = true;
                }
                if (!this.s.dt.page.info().serverSide &&
                    (dataIn === null ||
                        dataIn.searchPanes === null ||
                        dataIn.searchPanes.options === null)) {
                    // Only run populatePane if the data has not been collected yet
                    if (rowData.arrayFilter.length === 0) {
                        this._populatePane(last);
                        this.s.rowData.totalOptions = 0;
                        this._detailsPane();
                        rowData.arrayOriginal = rowData.arrayTotals;
                        rowData.binsOriginal = rowData.binsTotal;
                    }
                    var binLength = Object.keys(rowData.binsOriginal).length;
                    var uniqueRatio = this._uniqueRatio(binLength, table.rows()[0].length);
                    // Don't show the pane if there isn't enough variance in the data, or there is only 1 entry
                    //  for that pane
                    if (this.s.displayed === false &&
                        ((colOpts.show === undefined && colOpts.threshold === null ?
                            uniqueRatio > this.c.threshold :
                            uniqueRatio > colOpts.threshold) ||
                            colOpts.show !== true && binLength <= 1)) {
                        this.dom.container.addClass(this.classes.hidden);
                        this.s.displayed = false;
                        return;
                    }
                    // If the option viewTotal is true then find
                    // the total count for the whole table to display alongside the displayed count
                    if (this.c.viewTotal && rowData.arrayTotals.length === 0) {
                        this.s.rowData.totalOptions = 0;
                        this._detailsPane();
                    }
                    else {
                        rowData.binsTotal = rowData.bins;
                    }
                    this.dom.container.addClass(this.classes.show);
                    this.s.displayed = true;
                }
                else if (dataIn !== null && dataIn.searchPanes !== null && dataIn.searchPanes.options !== null) {
                    if (dataIn.tableLength !== undefined) {
                        this.s.tableLength = dataIn.tableLength;
                        this.s.rowData.totalOptions = this.s.tableLength;
                    }
                    else if (this.s.tableLength === null || table.rows()[0].length > this.s.tableLength) {
                        this.s.tableLength = table.rows()[0].length;
                        this.s.rowData.totalOptions = this.s.tableLength;
                    }
                    var colTitle = table.column(this.s.index).dataSrc();
                    if (dataIn.searchPanes.options[colTitle] !== undefined) {
                        for (var _i = 0, _a = dataIn.searchPanes.options[colTitle]; _i < _a.length; _i++) {
                            var dataPoint = _a[_i];
                            this.s.rowData.arrayFilter.push({
                                display: dataPoint.label,
                                filter: dataPoint.value,
                                sort: dataPoint.label,
                                type: dataPoint.label
                            });
                            this.s.rowData.bins[dataPoint.value] = this.c.viewTotal || this.c.cascadePanes ?
                                dataPoint.count :
                                dataPoint.total;
                            this.s.rowData.binsTotal[dataPoint.value] = dataPoint.total;
                        }
                    }
                    var binLength = Object.keys(rowData.binsTotal).length;
                    var uniqueRatio = this._uniqueRatio(binLength, this.s.tableLength);
                    // Don't show the pane if there isnt enough variance in the data, or there is only 1 entry for that pane
                    if (this.s.displayed === false &&
                        ((colOpts.show === undefined && colOpts.threshold === null ?
                            uniqueRatio > this.c.threshold :
                            uniqueRatio > colOpts.threshold) ||
                            colOpts.show !== true && binLength <= 1)) {
                        this.dom.container.addClass(this.classes.hidden);
                        this.s.displayed = false;
                        return;
                    }
                    this.s.rowData.arrayOriginal = this.s.rowData.arrayFilter;
                    this.s.rowData.binsOriginal = this.s.rowData.bins;
                    this.s.displayed = true;
                }
            }
            else {
                this.s.displayed = true;
            }
            // If the variance is accceptable then display the search pane
            this._displayPane();
            if (!this.s.listSet) {
                // Here, when the state is loaded if the data object on the original table is empty,
                //  then a state.clear() must have occurred, so delete all of the panes tables state objects too.
                this.dom.dtP.on('stateLoadParams.dt', function (e, settings, data) {
                    if ($.isEmptyObject(table.state.loaded())) {
                        $.each(data, function (index, value) {
                            delete data[index];
                        });
                    }
                });
            }
            // Add the container to the document in its original location
            if (prevEl !== null && this.dom.panesContainer.has(prevEl).length > 0) {
                this.dom.container.insertAfter(prevEl);
            }
            else {
                this.dom.panesContainer.prepend(this.dom.container);
            }
            // Declare the datatable for the pane
            var errMode = $.fn.dataTable.ext.errMode;
            $.fn.dataTable.ext.errMode = 'none';
            // eslint-disable-next-line no-extra-parens
            var haveScroller = dataTable.Scroller;
            this.s.dtPane = this.dom.dtP.DataTable($.extend(true, {
                columnDefs: [
                    {
                        className: 'dtsp-nameColumn',
                        data: 'display',
                        render: function (data, type, row) {
                            if (type === 'sort') {
                                return row.sort;
                            }
                            else if (type === 'type') {
                                return row.type;
                            }
                            var message;
                            message =
                                (_this.s.filteringActive || _this.s.showFiltered) && _this.c.viewTotal ||
                                    _this.c.viewTotal && _this.s.forceViewTotal ?
                                    filteredMessage.replace(/{total}/, row.total) :
                                    countMessage.replace(/{total}/, row.total);
                            message = message.replace(/{shown}/, row.shown);
                            while (message.includes('{total}')) {
                                message = message.replace(/{total}/, row.total);
                            }
                            while (message.includes('{shown}')) {
                                message = message.replace(/{shown}/, row.shown);
                            }
                            // We are displaying the count in the same columne as the name of the search option.
                            // This is so that there is not need to call columns.adjust()
                            //  which in turn speeds up the code
                            var pill = '<span class="' + _this.classes.pill + '">' + message + '</span>';
                            if (!_this.c.viewCount || !colOpts.viewCount) {
                                pill = '';
                            }
                            if (type === 'filter') {
                                return typeof data === 'string' && data.match(/<[^>]*>/) !== null ?
                                    data.replace(/<[^>]*>/g, '') :
                                    data;
                            }
                            return '<div class="' + _this.classes.nameCont + '"><span title="' +
                                (typeof data === 'string' && data.match(/<[^>]*>/) !== null ?
                                    data.replace(/<[^>]*>/g, '') :
                                    data) +
                                '" class="' + _this.classes.name + '">' +
                                data + '</span>' +
                                pill + '</div>';
                        },
                        targets: 0,
                        // Accessing the private datatables property to set type based on the original table.
                        // This is null if not defined by the user, meaning that automatic type detection
                        //  would take place
                        type: table.settings()[0].aoColumns[this.s.index] !== undefined ?
                            table.settings()[0].aoColumns[this.s.index]._sManualType :
                            null
                    },
                    {
                        className: 'dtsp-countColumn ' + this.classes.badgePill,
                        data: 'shown',
                        orderData: [1, 2],
                        searchable: false,
                        targets: 1,
                        visible: false
                    },
                    {
                        data: 'total',
                        searchable: false,
                        targets: 2,
                        visible: false
                    }
                ],
                deferRender: true,
                dom: 't',
                info: false,
                language: this.s.dt.settings()[0].oLanguage,
                paging: haveScroller ? true : false,
                scrollX: false,
                scrollY: '200px',
                scroller: haveScroller ? true : false,
                select: true,
                stateSave: table.settings()[0].oFeatures.bStateSave ? true : false
            }, this.c.dtOpts, colOpts !== undefined ? colOpts.dtOpts : {}, this.s.colOpts.options !== undefined || !this.colExists ?
                {
                    createdRow: function (row, data, dataIndex) {
                        $(row).addClass(data.className);
                    }
                } :
                undefined, this.customPaneSettings !== null && this.customPaneSettings.dtOpts !== undefined ?
                this.customPaneSettings.dtOpts :
                {}, $.fn.dataTable.versionCheck('2')
                ? {
                    layout: {
                        bottomLeft: null,
                        bottomRight: null,
                        topLeft: null,
                        topRight: null
                    }
                }
                : {}));
            this.dom.dtP.addClass(this.classes.table);
            // Getting column titles is a little messy
            var headerText = 'Custom Pane';
            if (this.customPaneSettings && this.customPaneSettings.header) {
                headerText = this.customPaneSettings.header;
            }
            else if (colOpts.header) {
                headerText = colOpts.header;
            }
            else if (this.colExists) {
                headerText = $.fn.dataTable.versionCheck('2')
                    ? table.column(this.s.index).title()
                    : table.settings()[0].aoColumns[this.s.index].sTitle;
            }
            this.dom.searchBox.attr('placeholder', headerText);
            // As the pane table is not in the document yet we must initialise select ourselves
            // eslint-disable-next-line no-extra-parens
            $.fn.dataTable.select.init(this.s.dtPane);
            $.fn.dataTable.ext.errMode = errMode;
            // If it is not a custom pane
            if (this.colExists) {
                // On initialisation, do we need to set a filtering value from a
                // saved state or init option?
                var search = column.search();
                search = search ? search.substr(1, search.length - 2).split('|') : [];
                // Count the number of empty cells
                var count_1 = 0;
                rowData.arrayFilter.forEach(function (element) {
                    if (element.filter === '') {
                        count_1++;
                    }
                });
                // Add all of the search options to the pane
                for (var i = 0, ien = rowData.arrayFilter.length; i < ien; i++) {
                    var selected = false;
                    for (var _b = 0, _c = this.s.serverSelect; _b < _c.length; _b++) {
                        var option = _c[_b];
                        if (option.filter === rowData.arrayFilter[i].filter) {
                            selected = true;
                        }
                    }
                    if (this.s.dt.page.info().serverSide &&
                        (!this.c.cascadePanes ||
                            this.c.cascadePanes && rowData.bins[rowData.arrayFilter[i].filter] !== 0 ||
                            this.c.cascadePanes && init !== null ||
                            selected)) {
                        var row = this.addRow(rowData.arrayFilter[i].display, rowData.arrayFilter[i].filter, init ?
                            rowData.binsTotal[rowData.arrayFilter[i].filter] :
                            rowData.bins[rowData.arrayFilter[i].filter], this.c.viewTotal || init
                            ? String(rowData.binsTotal[rowData.arrayFilter[i].filter])
                            : rowData.bins[rowData.arrayFilter[i].filter], rowData.arrayFilter[i].sort, rowData.arrayFilter[i].type);
                        for (var _d = 0, _e = this.s.serverSelect; _d < _e.length; _d++) {
                            var option = _e[_d];
                            if (option.filter === rowData.arrayFilter[i].filter) {
                                this.s.serverSelecting = true;
                                row.select();
                                this.s.serverSelecting = false;
                            }
                        }
                    }
                    else if (!this.s.dt.page.info().serverSide &&
                        rowData.arrayFilter[i] &&
                        (rowData.bins[rowData.arrayFilter[i].filter] !== undefined || !this.c.cascadePanes)) {
                        this.addRow(rowData.arrayFilter[i].display, rowData.arrayFilter[i].filter, rowData.bins[rowData.arrayFilter[i].filter], rowData.binsTotal[rowData.arrayFilter[i].filter], rowData.arrayFilter[i].sort, rowData.arrayFilter[i].type);
                    }
                    else if (!this.s.dt.page.info().serverSide) {
                        // Just pass an empty string as the message will be calculated based on that in addRow()
                        this.addRow('', count_1, count_1, '', '', '');
                    }
                }
            }
            // eslint-disable-next-line no-extra-parens
            dataTable.select.init(this.s.dtPane);
            // If there are custom options set or it is a custom pane then get them
            if (colOpts.options !== undefined ||
                this.customPaneSettings !== null && this.customPaneSettings.options !== undefined) {
                this._getComparisonRows();
            }
            // Display the pane
            this.s.dtPane.draw();
            this.s.dtPane.table().node().parentNode.scrollTop = this.s.scrollTop;
            this.adjustTopRow();
            if (!this.s.listSet) {
                this._setListeners();
                this.s.listSet = true;
            }
            for (var _f = 0, selectedRows_1 = selectedRows; _f < selectedRows_1.length; _f++) {
                var selection = selectedRows_1[_f];
                if (selection !== undefined) {
                    for (var _g = 0, _h = this.s.dtPane.rows().indexes().toArray(); _g < _h.length; _g++) {
                        var row = _h[_g];
                        if (this.s.dtPane.row(row).data() !== undefined &&
                            selection.filter === this.s.dtPane.row(row).data().filter) {
                            // If this is happening when serverSide processing is happening then
                            //  different behaviour is needed
                            if (this.s.dt.page.info().serverSide) {
                                this.s.serverSelecting = true;
                                this.s.dtPane.row(row).select();
                                this.s.serverSelecting = false;
                            }
                            else {
                                this.s.dtPane.row(row).select();
                            }
                        }
                    }
                }
            }
            //  If SSP and the table is ready, apply the search for the pane
            if (this.s.dt.page.info().serverSide) {
                this.s.dtPane.search(this.dom.searchBox.val()).draw();
            }
            if ((this.c.initCollapsed && this.s.colOpts.initCollapsed !== false ||
                this.s.colOpts.initCollapsed) &&
                (this.c.collapse && this.s.colOpts.collapse !== false ||
                    this.s.colOpts.collapse)) {
                this.collapse();
            }
            // Reload the selection, searchbox entry and ordering from the previous state
            // Need to check here if SSP that this is the first draw, otherwise it will infinite loop
            if (loadedFilter &&
                loadedFilter.searchPanes &&
                loadedFilter.searchPanes.panes &&
                (dataIn === null ||
                    dataIn.draw === 1)) {
                if (!this.c.cascadePanes) {
                    this._reloadSelect(loadedFilter);
                }
                for (var _j = 0, _k = loadedFilter.searchPanes.panes; _j < _k.length; _j++) {
                    var pane = _k[_j];
                    if (pane.id === this.s.index) {
                        // Save some time by only triggering an input if there is a value
                        if (pane.searchTerm && pane.searchTerm.length > 0) {
                            this.dom.searchBox.val(pane.searchTerm);
                            this.dom.searchBox.trigger('input');
                        }
                        this.s.dtPane.order(pane.order).draw();
                        // Is the pane to be hidden or shown?
                        if (pane.collapsed) {
                            this.collapse();
                        }
                        else {
                            this.show();
                        }
                    }
                }
            }
            return true;
        };
        /**
         * Update the array which holds the display and filter values for the table
         */
        SearchPane.prototype._detailsPane = function () {
            var table = this.s.dt;
            this.s.rowData.arrayTotals = [];
            this.s.rowData.binsTotal = {};
            var settings = this.s.dt.settings()[0];
            var indexArray = table.rows().indexes();
            if (!this.s.dt.page.info().serverSide) {
                for (var _i = 0, indexArray_1 = indexArray; _i < indexArray_1.length; _i++) {
                    var rowIdx = indexArray_1[_i];
                    this._populatePaneArray(rowIdx, this.s.rowData.arrayTotals, settings, this.s.rowData.binsTotal);
                }
            }
        };
        /**
         * Appends all of the HTML elements to their relevant parent Elements
         */
        SearchPane.prototype._displayPane = function () {
            var container = this.dom.container;
            var colOpts = this.s.colOpts;
            var layVal = parseInt(this.c.layout.split('-')[1], 10);
            // Empty everything to start again
            this.dom.topRow.empty();
            this.dom.dtP.empty();
            this.dom.topRow.addClass(this.classes.topRow);
            // If there are more than 3 columns defined then make there be a smaller gap between the panes
            if (layVal > 3) {
                this.dom.container.addClass(this.classes.smallGap);
            }
            this.dom.topRow.addClass(this.classes.subRowsContainer);
            this.dom.upper.appendTo(this.dom.topRow);
            this.dom.lower.appendTo(this.dom.topRow);
            this.dom.searchCont.appendTo(this.dom.upper);
            this.dom.buttonGroup.appendTo(this.dom.lower);
            // If no selections have been made in the pane then disable the clear button
            if (this.c.dtOpts.searching === false ||
                colOpts.dtOpts !== undefined && colOpts.dtOpts.searching === false ||
                (!this.c.controls || !colOpts.controls) ||
                this.customPaneSettings !== null &&
                    this.customPaneSettings.dtOpts !== undefined &&
                    this.customPaneSettings.dtOpts.searching !== undefined &&
                    !this.customPaneSettings.dtOpts.searching) {
                this.dom.searchBox
                    .removeClass(this.classes.paneInputButton)
                    .addClass(this.classes.disabledButton)
                    .attr('disabled', 'true');
            }
            this.dom.searchBox.appendTo(this.dom.searchCont);
            // Create the contents of the searchCont div. Worth noting that this function will change when using semantic ui
            this._searchContSetup();
            // If the clear button is allowed to show then display it
            if (this.c.clear && this.c.controls && colOpts.controls) {
                this.dom.clear.appendTo(this.dom.buttonGroup);
            }
            if (this.c.orderable && colOpts.orderable && this.c.controls && colOpts.controls) {
                this.dom.nameButton.appendTo(this.dom.buttonGroup);
            }
            // If the count column is hidden then don't display the ordering button for it
            if (this.c.viewCount &&
                colOpts.viewCount &&
                this.c.orderable &&
                colOpts.orderable &&
                this.c.controls &&
                colOpts.controls) {
                this.dom.countButton.appendTo(this.dom.buttonGroup);
            }
            if ((this.c.collapse && this.s.colOpts.collapse !== false ||
                this.s.colOpts.collapse) &&
                this.c.controls && colOpts.controls) {
                this.dom.collapseButton.appendTo(this.dom.buttonGroup);
            }
            this.dom.topRow.prependTo(this.dom.container);
            container.append(this.dom.dtP);
            container.show();
        };
        /**
         * Gets the options for the row for the customPanes
         *
         * @returns {object} The options for the row extended to include the options from the user.
         */
        SearchPane.prototype._getBonusOptions = function () {
            // We need to reset the thresholds as if they have a value in colOpts then that value will be used
            var defaultMutator = {
                orthogonal: {
                    threshold: null
                },
                threshold: null
            };
            return $.extend(true, {}, SearchPane.defaults, defaultMutator, this.c !== undefined ? this.c : {});
        };
        /**
         * Adds the custom options to the pane
         *
         * @returns {Array} Returns the array of rows which have been added to the pane
         */
        SearchPane.prototype._getComparisonRows = function () {
            var colOpts = this.s.colOpts;
            // Find the appropriate options depending on whether this is a pane for a specific column or a custom pane
            var options = colOpts.options !== undefined
                ? colOpts.options
                : this.customPaneSettings !== null && this.customPaneSettings.options !== undefined
                    ? this.customPaneSettings.options
                    : undefined;
            if (options === undefined) {
                return;
            }
            var tableVals = this.s.dt.rows({ search: 'applied' }).data().toArray();
            var appRows = this.s.dt.rows({ search: 'applied' });
            var tableValsTotal = this.s.dt.rows().data().toArray();
            var allRows = this.s.dt.rows();
            var rows = [];
            // Clear all of the other rows from the pane, only custom options are to be displayed when they are defined
            this.s.dtPane.clear();
            for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
                var comp = options_1[_i];
                // Initialise the object which is to be placed in the row
                var insert = comp.label !== '' ?
                    comp.label :
                    this.emptyMessage();
                var comparisonObj = {
                    className: comp.className,
                    display: insert,
                    filter: typeof comp.value === 'function' ? comp.value : [],
                    shown: 0,
                    sort: insert,
                    total: 0,
                    type: insert
                };
                // If a custom function is in place
                if (typeof comp.value === 'function') {
                    // Count the number of times the function evaluates to true for the data currently being displayed
                    for (var tVal = 0; tVal < tableVals.length; tVal++) {
                        if (comp.value.call(this.s.dt, tableVals[tVal], appRows[0][tVal])) {
                            comparisonObj.shown++;
                        }
                    }
                    // Count the number of times the function evaluates to true for the original data in the Table
                    for (var i = 0; i < tableValsTotal.length; i++) {
                        if (comp.value.call(this.s.dt, tableValsTotal[i], allRows[0][i])) {
                            comparisonObj.total++;
                        }
                    }
                    // Update the comparisonObj
                    if (typeof comparisonObj.filter !== 'function') {
                        comparisonObj.filter.push(comp.filter);
                    }
                }
                // If cascadePanes is not active or if it is and the comparisonObj should be shown then add it to the pane
                if (!this.c.cascadePanes || this.c.cascadePanes && comparisonObj.shown !== 0) {
                    rows.push(this.addRow(comparisonObj.display, comparisonObj.filter, comparisonObj.shown, comparisonObj.total, comparisonObj.sort, comparisonObj.type, comparisonObj.className));
                }
            }
            return rows;
        };
        /**
         * Gets the options for the row for the customPanes
         *
         * @returns {object} The options for the row extended to include the options from the user.
         */
        SearchPane.prototype._getOptions = function () {
            var table = this.s.dt;
            // We need to reset the thresholds as if they have a value in colOpts then that value will be used
            var defaultMutator = {
                collapse: null,
                emptyMessage: false,
                initCollapsed: null,
                orthogonal: {
                    threshold: null
                },
                threshold: null
            };
            var columnOptions = table.settings()[0].aoColumns[this.s.index].searchPanes;
            var colOpts = $.extend(true, {}, SearchPane.defaults, defaultMutator, columnOptions);
            if (columnOptions !== undefined &&
                columnOptions.hideCount !== undefined &&
                columnOptions.viewCount === undefined) {
                colOpts.viewCount = !columnOptions.hideCount;
            }
            return colOpts;
        };
        /**
         * This method allows for changes to the panes and table to be made when a selection or a deselection occurs
         *
         * @param select Denotes whether a selection has been made or not
         */
        SearchPane.prototype._makeSelection = function () {
            this.updateTable();
            this.s.updating = true;
            this.s.dt.draw();
            this.s.updating = false;
        };
        /**
         * Fill the array with the values that are currently being displayed in the table
         *
         * @param last boolean to indicate whether this was the last pane a selection was made in
         */
        SearchPane.prototype._populatePane = function (last) {
            if (last === void 0) { last = false; }
            var table = this.s.dt;
            this.s.rowData.arrayFilter = [];
            this.s.rowData.bins = {};
            var settings = this.s.dt.settings()[0];
            // If cascadePanes or viewTotal are active it is necessary to get the data which is currently
            // being displayed for their functionality.
            // Also make sure that this was not the last pane to have a selection made
            if (!this.s.dt.page.info().serverSide) {
                var indexArray = (this.c.cascadePanes || this.c.viewTotal) && (!this.s.clearing && !last) ?
                    table.rows({ search: 'applied' }).indexes() :
                    table.rows().indexes();
                for (var _i = 0, _a = indexArray.toArray(); _i < _a.length; _i++) {
                    var index = _a[_i];
                    this._populatePaneArray(index, this.s.rowData.arrayFilter, settings);
                }
            }
        };
        /**
         * Populates an array with all of the data for the table
         *
         * @param rowIdx The current row index to be compared
         * @param arrayFilter The array that is to be populated with row Details
         * @param bins The bins object that is to be populated with the row counts
         */
        SearchPane.prototype._populatePaneArray = function (rowIdx, arrayFilter, settings, bins) {
            if (bins === void 0) { bins = this.s.rowData.bins; }
            var colOpts = this.s.colOpts;
            // Retrieve the rendered data from the cell using the fnGetCellData function
            // rather than the cell().render API method for optimisation
            if (typeof colOpts.orthogonal === 'string') {
                var rendered = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal);
                this.s.rowData.filterMap.set(rowIdx, rendered);
                this._addOption(rendered, rendered, rendered, rendered, arrayFilter, bins);
            }
            else {
                var filter = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.search);
                // Null and empty string are to be considered the same value
                if (filter === null) {
                    filter = '';
                }
                if (typeof filter === 'string') {
                    filter = filter.replace(/<[^>]*>/g, '');
                }
                this.s.rowData.filterMap.set(rowIdx, filter);
                if (!bins[filter]) {
                    bins[filter] = 1;
                    this._addOption(filter, settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.display), settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.sort), settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.type), arrayFilter, bins);
                    this.s.rowData.totalOptions++;
                }
                else {
                    bins[filter]++;
                    this.s.rowData.totalOptions++;
                    return;
                }
            }
        };
        /**
         * Reloads all of the previous selects into the panes
         *
         * @param loadedFilter The loaded filters from a previous state
         */
        SearchPane.prototype._reloadSelect = function (loadedFilter) {
            // If the state was not saved don't selected any
            if (loadedFilter === undefined) {
                return;
            }
            var idx;
            // For each pane, check that the loadedFilter list exists and is not null,
            // find the id of each search item and set it to be selected.
            for (var i = 0; i < loadedFilter.searchPanes.panes.length; i++) {
                if (loadedFilter.searchPanes.panes[i].id === this.s.index) {
                    idx = i;
                    break;
                }
            }
            if (idx !== undefined) {
                var table = this.s.dtPane;
                var rows = table.rows({ order: 'index' }).data().map(function (item) { return item.filter !== null ?
                    item.filter.toString() :
                    null; }).toArray();
                for (var _i = 0, _a = loadedFilter.searchPanes.panes[idx].selected; _i < _a.length; _i++) {
                    var filter = _a[_i];
                    var id = -1;
                    if (filter !== null) {
                        id = rows.indexOf(filter.toString());
                    }
                    if (id > -1) {
                        this.s.serverSelecting = true;
                        table.row(id).select();
                        this.s.serverSelecting = false;
                    }
                }
            }
        };
        /**
         * This method decides whether a row should contribute to the pane or not
         *
         * @param filter the value that the row is to be filtered on
         * @param dataIndex the row index
         */
        SearchPane.prototype._search = function (filter, dataIndex) {
            var colOpts = this.s.colOpts;
            var table = this.s.dt;
            // For each item selected in the pane, check if it is available in the cell
            for (var _i = 0, _a = this.selections; _i < _a.length; _i++) {
                var colSelect = _a[_i];
                if (typeof colSelect.filter === 'string' && typeof filter === 'string') {
                    // The filter value will not have the &amp; in place but a &,
                    // so we need to do a replace to make sure that they will match
                    colSelect.filter = colSelect.filter
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"');
                }
                // if the filter is an array then is the column present in it
                if (Array.isArray(filter)) {
                    if (filter.includes(colSelect.filter)) {
                        return true;
                    }
                }
                // if the filter is a function then does it meet the criteria of that function or not
                else if (typeof colSelect.filter === 'function') {
                    if (colSelect.filter.call(table, table.row(dataIndex).data(), dataIndex)) {
                        if (colOpts.combiner === 'or') {
                            return true;
                        }
                    }
                    // If the combiner is an "and" then we need to check against all possible selections
                    // so if it fails here then the and is not met and return false
                    else if (colOpts.combiner === 'and') {
                        return false;
                    }
                }
                // otherwise if the two filter values are equal then return true
                else if (filter === colSelect.filter ||
                    // Loose type checking incase number type in column comparing to a string
                    // eslint-disable-next-line eqeqeq
                    !(typeof filter === 'string' && filter.length === 0) && filter == colSelect.filter ||
                    colSelect.filter === null && typeof filter === 'string' && filter === '') {
                    return true;
                }
            }
            // If the combiner is an and then we need to check against all possible selections
            // so return true here if so because it would have returned false earlier if it had failed
            if (colOpts.combiner === 'and') {
                return true;
            }
            // Otherwise it hasn't matched with anything by this point so it must be false
            else {
                return false;
            }
        };
        /**
         * Creates the contents of the searchCont div
         *
         * NOTE This is overridden when semantic ui styling in order to integrate the search button into the text box.
         */
        SearchPane.prototype._searchContSetup = function () {
            if (this.c.controls && this.s.colOpts.controls) {
                this.dom.searchButton.appendTo(this.dom.searchLabelCont);
            }
            if (!(this.c.dtOpts.searching === false ||
                this.s.colOpts.dtOpts.searching === false ||
                this.customPaneSettings !== null &&
                    this.customPaneSettings.dtOpts !== undefined &&
                    this.customPaneSettings.dtOpts.searching !== undefined &&
                    !this.customPaneSettings.dtOpts.searching)) {
                this.dom.searchLabelCont.appendTo(this.dom.searchCont);
            }
        };
        /**
         * Adds outline to the pane when a selection has been made
         */
        SearchPane.prototype._searchExtras = function () {
            var updating = this.s.updating;
            this.s.updating = true;
            var filters = this.s.dtPane.rows({ selected: true }).data().pluck('filter').toArray();
            var nullIndex = filters.indexOf(this.emptyMessage());
            var container = $(this.s.dtPane.table().container());
            // If null index is found then search for empty cells as a filter.
            if (nullIndex > -1) {
                filters[nullIndex] = '';
            }
            // If a filter has been applied then outline the respective pane, remove it when it no longer is.
            if (filters.length > 0) {
                container.addClass(this.classes.selected);
            }
            else if (filters.length === 0) {
                container.removeClass(this.classes.selected);
            }
            this.s.updating = updating;
        };
        /**
         * Finds the ratio of the number of different options in the table to the number of rows
         *
         * @param bins the number of different options in the table
         * @param rowCount the total number of rows in the table
         * @returns {number} returns the ratio
         */
        SearchPane.prototype._uniqueRatio = function (bins, rowCount) {
            if (rowCount > 0 &&
                (this.s.rowData.totalOptions > 0 && !this.s.dt.page.info().serverSide ||
                    this.s.dt.page.info().serverSide && this.s.tableLength > 0)) {
                return bins / this.s.rowData.totalOptions;
            }
            else {
                return 1;
            }
        };
        /**
         * updates the options within the pane
         *
         * @param draw a flag to define whether this has been called due to a draw event or not
         */
        SearchPane.prototype._updateCommon = function (draw) {
            if (draw === void 0) { draw = false; }
            // Update the panes if doing a deselect. if doing a select then
            // update all of the panes except for the one causing the change
            if (!this.s.dt.page.info().serverSide &&
                this.s.dtPane !== undefined &&
                (!this.s.filteringActive || this.c.cascadePanes || draw === true) &&
                (this.c.cascadePanes !== true || this.s.selectPresent !== true) &&
                (!this.s.lastSelect || !this.s.lastCascade)) {
                var colOpts = this.s.colOpts;
                var selected = this.s.dtPane.rows({ selected: true }).data().toArray();
                var rowData = this.s.rowData;
                // Clear the pane in preparation for adding the updated search options
                this.s.dtPane.clear();
                // If it is not a custom pane
                if (this.colExists) {
                    // Only run populatePane if the data has not been collected yet
                    if (rowData.arrayFilter.length === 0) {
                        this._populatePane(!this.s.filteringActive);
                    }
                    // If cascadePanes is active and the table has returned to its default state then
                    // there is a need to update certain parts ofthe rowData.
                    else if (this.c.cascadePanes &&
                        this.s.dt.rows().data().toArray().length ===
                            this.s.dt.rows({ search: 'applied' }).data().toArray().length) {
                        rowData.arrayFilter = rowData.arrayOriginal;
                        rowData.bins = rowData.binsOriginal;
                    }
                    // Otherwise if viewTotal or cascadePanes is active then the data from the table must be read.
                    else if (this.c.viewTotal || this.c.cascadePanes) {
                        this._populatePane(!this.s.filteringActive);
                    }
                    // If the viewTotal option is selected then find the totals for the table
                    if (this.c.viewTotal) {
                        this._detailsPane();
                    }
                    else {
                        rowData.binsTotal = rowData.bins;
                    }
                    if (this.c.viewTotal && !this.c.cascadePanes) {
                        rowData.arrayFilter = rowData.arrayTotals;
                    }
                    var _loop_1 = function (dataP) {
                        // If both view Total and cascadePanes have been selected and the count of the row
                        // is not 0 then add it to pane
                        // Do this also if the viewTotal option has been selected and cascadePanes has not
                        if (dataP &&
                            (rowData.bins[dataP.filter] !== undefined &&
                                rowData.bins[dataP.filter] !== 0 &&
                                this_1.c.cascadePanes ||
                                !this_1.c.cascadePanes ||
                                this_1.s.clearing)) {
                            var row = this_1.addRow(dataP.display, dataP.filter, !this_1.c.viewTotal ?
                                rowData.bins[dataP.filter] :
                                rowData.bins[dataP.filter] !== undefined ?
                                    rowData.bins[dataP.filter] :
                                    0, this_1.c.viewTotal ?
                                String(rowData.binsTotal[dataP.filter]) :
                                rowData.bins[dataP.filter], dataP.sort, dataP.type);
                            // Find out if the filter was selected in the previous search,
                            // if so select it and remove from array.
                            var selectIndex = selected.findIndex(function (element) {
                                return element.filter === dataP.filter;
                            });
                            if (selectIndex !== -1) {
                                row.select();
                                selected.splice(selectIndex, 1);
                            }
                        }
                    };
                    var this_1 = this;
                    for (var _i = 0, _a = rowData.arrayFilter; _i < _a.length; _i++) {
                        var dataP = _a[_i];
                        _loop_1(dataP);
                    }
                }
                if (colOpts.searchPanes !== undefined && colOpts.searchPanes.options !== undefined ||
                    colOpts.options !== undefined ||
                    this.customPaneSettings !== null && this.customPaneSettings.options !== undefined) {
                    var rows = this._getComparisonRows();
                    var _loop_2 = function (row) {
                        var selectIndex = selected.findIndex(function (element) {
                            if (element.display === row.data().display) {
                                return true;
                            }
                        });
                        if (selectIndex !== -1) {
                            row.select();
                            selected.splice(selectIndex, 1);
                        }
                    };
                    for (var _b = 0, rows_1 = rows; _b < rows_1.length; _b++) {
                        var row = rows_1[_b];
                        _loop_2(row);
                    }
                }
                // Add search options which were previously selected but whos results are no
                // longer present in the resulting data set.
                for (var _c = 0, selected_1 = selected; _c < selected_1.length; _c++) {
                    var selectedEl = selected_1[_c];
                    var row = this.addRow(selectedEl.display, selectedEl.filter, 0, this.c.viewTotal
                        ? selectedEl.total
                        : 0, selectedEl.display, selectedEl.display);
                    this.s.updating = true;
                    row.select();
                    this.s.updating = false;
                }
                this.s.dtPane.draw();
                this.s.dtPane.table().node().parentNode.scrollTop = this.s.scrollTop;
            }
        };
        SearchPane.version = '1.3.0';
        SearchPane.classes = {
            bordered: 'dtsp-bordered',
            buttonGroup: 'dtsp-buttonGroup',
            buttonSub: 'dtsp-buttonSub',
            clear: 'dtsp-clear',
            clearAll: 'dtsp-clearAll',
            clearButton: 'clearButton',
            collapseAll: 'dtsp-collapseAll',
            collapseButton: 'dtsp-collapseButton',
            container: 'dtsp-searchPane',
            countButton: 'dtsp-countButton',
            disabledButton: 'dtsp-disabledButton',
            hidden: 'dtsp-hidden',
            hide: 'dtsp-hide',
            layout: 'dtsp-',
            name: 'dtsp-name',
            nameButton: 'dtsp-nameButton',
            nameCont: 'dtsp-nameCont',
            narrow: 'dtsp-narrow',
            paneButton: 'dtsp-paneButton',
            paneInputButton: 'dtsp-paneInputButton',
            pill: 'dtsp-pill',
            rotated: 'dtsp-rotated',
            search: 'dtsp-search',
            searchCont: 'dtsp-searchCont',
            searchIcon: 'dtsp-searchIcon',
            searchLabelCont: 'dtsp-searchButtonCont',
            selected: 'dtsp-selected',
            smallGap: 'dtsp-smallGap',
            subRow1: 'dtsp-subRow1',
            subRow2: 'dtsp-subRow2',
            subRowsContainer: 'dtsp-subRowsContainer',
            title: 'dtsp-title',
            topRow: 'dtsp-topRow'
        };
        // Define SearchPanes default options
        SearchPane.defaults = {
            cascadePanes: false,
            clear: true,
            collapse: true,
            combiner: 'or',
            container: function (dt) {
                return dt.table().container();
            },
            controls: true,
            dtOpts: {},
            emptyMessage: null,
            hideCount: false,
            i18n: {
                clearPane: '&times;',
                count: '{total}',
                countFiltered: '{shown} ({total})',
                emptyMessage: '<em>No data</em>'
            },
            initCollapsed: false,
            layout: 'auto',
            name: undefined,
            orderable: true,
            orthogonal: {
                display: 'display',
                filter: 'filter',
                hideCount: false,
                search: 'filter',
                show: undefined,
                sort: 'sort',
                threshold: 0.6,
                type: 'type',
                viewCount: true
            },
            preSelect: [],
            threshold: 0.6,
            viewCount: true,
            viewTotal: false
        };
        return SearchPane;
    }());

    var $$1;
    var dataTable$1;
    function setJQuery$1(jq) {
        $$1 = jq;
        dataTable$1 = jq.fn.dataTable;
    }
    var SearchPanes = /** @class */ (function () {
        function SearchPanes(paneSettings, opts, fromInit) {
            var _this = this;
            if (fromInit === void 0) { fromInit = false; }
            this.regenerating = false;
            // Check that the required version of DataTables is included
            if (!dataTable$1 || !dataTable$1.versionCheck || !dataTable$1.versionCheck('1.10.0')) {
                throw new Error('SearchPane requires DataTables 1.10 or newer');
            }
            // Check that Select is included
            // eslint-disable-next-line no-extra-parens
            if (!dataTable$1.select) {
                throw new Error('SearchPane requires Select');
            }
            var table = new dataTable$1.Api(paneSettings);
            this.classes = $$1.extend(true, {}, SearchPanes.classes);
            // Get options from user
            this.c = $$1.extend(true, {}, SearchPanes.defaults, opts);
            // Add extra elements to DOM object including clear
            this.dom = {
                clearAll: $$1('<button type="button">Clear All</button>').addClass(this.classes.clearAll),
                collapseAll: $$1('<button type="button">Collapse All</button>').addClass(this.classes.collapseAll),
                container: $$1('<div/>').addClass(this.classes.panes).text(table.i18n('searchPanes.loadMessage', this.c.i18n.loadMessage)),
                emptyMessage: $$1('<div/>').addClass(this.classes.emptyMessage),
                options: $$1('<div/>').addClass(this.classes.container),
                panes: $$1('<div/>').addClass(this.classes.container),
                showAll: $$1('<button type="button">Show All</button>')
                    .addClass(this.classes.showAll)
                    .addClass(this.classes.disabledButton)
                    .attr('disabled', 'true'),
                title: $$1('<div/>').addClass(this.classes.title),
                titleRow: $$1('<div/>').addClass(this.classes.titleRow),
                wrapper: $$1('<div/>')
            };
            this.s = {
                colOpts: [],
                dt: table,
                filterCount: 0,
                filterPane: -1,
                page: 0,
                paging: false,
                panes: [],
                selectionList: [],
                serverData: {},
                stateRead: false,
                updating: false
            };
            if (table.settings()[0]._searchPanes !== undefined) {
                return;
            }
            this._getState();
            if (this.s.dt.page.info().serverSide) {
                table.on('preXhr.dt', function (e, settings, data) {
                    if (data.searchPanes === undefined) {
                        data.searchPanes = {};
                    }
                    if (data.searchPanes_null === undefined) {
                        data.searchPanes_null = {};
                    }
                    for (var _i = 0, _a = _this.s.selectionList; _i < _a.length; _i++) {
                        var selection = _a[_i];
                        var src = _this.s.dt.column(selection.index).dataSrc();
                        if (data.searchPanes[src] === undefined) {
                            data.searchPanes[src] = {};
                        }
                        if (data.searchPanes_null[src] === undefined) {
                            data.searchPanes_null[src] = {};
                        }
                        for (var i = 0; i < selection.rows.length; i++) {
                            data.searchPanes[src][i] = selection.rows[i].filter;
                            if (data.searchPanes[src][i] === null) {
                                data.searchPanes_null[src][i] = true;
                            }
                        }
                    }
                });
            }
            // We are using the xhr event to rebuild the panes if required due to viewTotal being enabled
            // If viewTotal is not enabled then we simply update the data from the server
            table.on('xhr', function (e, settings, json, xhr) {
                if (json && json.searchPanes && json.searchPanes.options) {
                    _this.s.serverData = json;
                    _this.s.serverData.tableLength = json.recordsTotal;
                    _this._serverTotals();
                }
            });
            table.settings()[0]._searchPanes = this;
            this.dom.clearAll.text(table.i18n('searchPanes.clearMessage', this.c.i18n.clearMessage));
            this.dom.collapseAll.text(table.i18n('searchPanes.collapseMessage', this.c.i18n.collapseMessage));
            this.dom.showAll.text(table.i18n('searchPanes.showMessage', this.c.i18n.showMessage));
            if (this.s.dt.settings()[0]._bInitComplete || fromInit) {
                this._paneDeclare(table, paneSettings, opts);
            }
            else {
                table.one('preInit.dt', function (settings) {
                    _this._paneDeclare(table, paneSettings, opts);
                });
            }
            return this;
        }
        /**
         * Clear the selections of all of the panes
         */
        SearchPanes.prototype.clearSelections = function () {
            // Load in all of the searchBoxes in the documents
            var searches = this.dom.container.find('.' + this.classes.search.replace(/\s+/g, '.'));
            // For each searchBox set the input text to be empty and then trigger
            // an input on them so that they no longer filter the panes
            searches.each(function () {
                $$1(this).val('');
                $$1(this).trigger('input');
            });
            var returnArray = [];
            // Clear the selectionList to prevent cascadePanes from reselecting rows
            this.s.selectionList = [];
            // For every pane, clear the selections in the pane
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.dtPane !== undefined) {
                    returnArray.push(pane.clearPane());
                }
            }
            return returnArray;
        };
        /**
         * returns the container node for the searchPanes
         */
        SearchPanes.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * rebuilds all of the panes
         */
        SearchPanes.prototype.rebuild = function (targetIdx, maintainSelection) {
            if (targetIdx === void 0) { targetIdx = false; }
            if (maintainSelection === void 0) { maintainSelection = false; }
            this.dom.emptyMessage.remove();
            // As a rebuild from scratch is required, empty the searchpanes container.
            var returnArray = [];
            // Rebuild each pane individually, if a specific pane has been selected then only rebuild that one
            if (targetIdx === false) {
                this.dom.panes.empty();
            }
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (targetIdx !== false && pane.s.index !== targetIdx) {
                    continue;
                }
                pane.clearData();
                returnArray.push(
                // Pass a boolean to say whether this is the last choice made for maintaining selections when rebuilding
                pane.rebuildPane(this.s.selectionList[this.s.selectionList.length - 1] !== undefined ?
                    pane.s.index === this.s.selectionList[this.s.selectionList.length - 1].index :
                    false, this.s.dt.page.info().serverSide ?
                    this.s.serverData :
                    undefined, null, maintainSelection));
                this.dom.panes.append(pane.dom.container);
            }
            if (this.c.cascadePanes || this.c.viewTotal) {
                this.redrawPanes(true);
            }
            else {
                this._updateSelection();
            }
            // Attach panes, clear buttons, and title bar to the document
            this._updateFilterCount();
            this._attachPaneContainer();
            // If the selections are to be maintained, then it is safe to assume that paging is also to be maintained
            // Otherwise, the paging should be reset
            this.s.dt.draw(!maintainSelection);
            // Resize the panes incase there has been a change
            this.resizePanes();
            // If a single pane has been rebuilt then return only that pane
            if (returnArray.length === 1) {
                return returnArray[0];
            }
            // Otherwise return all of the panes that have been rebuilt
            else {
                return returnArray;
            }
        };
        /**
         * Redraws all of the panes
         */
        SearchPanes.prototype.redrawPanes = function (rebuild) {
            if (rebuild === void 0) { rebuild = false; }
            var table = this.s.dt;
            // Only do this if the redraw isn't being triggered by the panes updating themselves
            if (!this.s.updating && !this.s.dt.page.info().serverSide) {
                var filterActive = true;
                var filterPane = this.s.filterPane;
                var selectTotal = null;
                for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    if (pane.s.dtPane !== undefined) {
                        selectTotal += pane.s.dtPane.rows({ selected: true }).data().toArray().length;
                    }
                }
                // If the number of rows currently visible is equal to the number of rows in the table
                // then there can't be any filtering taking place
                if (selectTotal === 0 &&
                    table.rows({ search: 'applied' }).data().toArray().length === table.rows().data().toArray().length) {
                    filterActive = false;
                }
                // Otherwise if viewTotal is active then it is necessary to determine which panes a select is present in.
                // If there is only one pane with a selection present then it should not show the filtered message as
                // more selections may be made in that pane.
                else if (this.c.viewTotal) {
                    for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                        var pane = _c[_b];
                        if (pane.s.dtPane !== undefined) {
                            var selectLength = pane.s.dtPane.rows({ selected: true }).data().toArray().length;
                            if (selectLength === 0) {
                                for (var _d = 0, _e = this.s.selectionList; _d < _e.length; _d++) {
                                    var selection = _e[_d];
                                    if (selection.index === pane.s.index && selection.rows.length !== 0) {
                                        selectLength = selection.rows.length;
                                    }
                                }
                            }
                            // If filterPane === -1 then a pane with a selection has not been found yet,
                            // so set filterPane to that panes index
                            if (selectLength > 0 && filterPane === -1) {
                                filterPane = pane.s.index;
                            }
                            // Then if another pane is found with a selection then set filterPane to null to
                            // show that multiple panes have selections present
                            else if (selectLength > 0) {
                                filterPane = null;
                            }
                        }
                    }
                    // If the searchbox is in place and filtering is applied then need to cascade down anyway
                    if (selectTotal === 0) {
                        filterPane = null;
                    }
                }
                var deselectIdx = void 0;
                var newSelectionList = [];
                // Don't run this if it is due to the panes regenerating
                if (!this.regenerating) {
                    for (var _f = 0, _g = this.s.panes; _f < _g.length; _f++) {
                        var pane = _g[_f];
                        // Identify the pane where a selection or deselection has been made and add it to the list.
                        if (pane.s.selectPresent) {
                            this.s.selectionList.push({
                                index: pane.s.index,
                                protect: false,
                                rows: pane.s.dtPane.rows({ selected: true }).data().toArray()
                            });
                            break;
                        }
                        else if (pane.s.deselect) {
                            deselectIdx = pane.s.index;
                            var selectedData = pane.s.dtPane.rows({ selected: true }).data().toArray();
                            if (selectedData.length > 0) {
                                this.s.selectionList.push({
                                    index: pane.s.index,
                                    protect: true,
                                    rows: selectedData
                                });
                            }
                        }
                    }
                    if (this.s.selectionList.length > 0) {
                        var last = this.s.selectionList[this.s.selectionList.length - 1].index;
                        for (var _h = 0, _j = this.s.panes; _h < _j.length; _h++) {
                            var pane = _j[_h];
                            pane.s.lastSelect = pane.s.index === last;
                        }
                    }
                    // Remove selections from the list from the pane where a deselect has taken place
                    for (var i = 0; i < this.s.selectionList.length; i++) {
                        if (this.s.selectionList[i].index !== deselectIdx || this.s.selectionList[i].protect === true) {
                            var further = false;
                            // Find out if this selection is the last one in the list for that pane
                            for (var j = i + 1; j < this.s.selectionList.length; j++) {
                                if (this.s.selectionList[j].index === this.s.selectionList[i].index) {
                                    further = true;
                                }
                            }
                            // If there are no selections for this pane in the list then just push this one
                            if (!further) {
                                newSelectionList.push(this.s.selectionList[i]);
                                this.s.selectionList[i].protect = false;
                            }
                        }
                    }
                    var solePane = -1;
                    if (newSelectionList.length === 1 && selectTotal !== null && selectTotal !== 0) {
                        solePane = newSelectionList[0].index;
                    }
                    // Update all of the panes to reflect the current state of the filters
                    for (var _k = 0, _l = this.s.panes; _k < _l.length; _k++) {
                        var pane = _l[_k];
                        if (pane.s.dtPane !== undefined) {
                            var tempFilter = true;
                            pane.s.filteringActive = true;
                            if (filterPane !== -1 && filterPane !== null && filterPane === pane.s.index ||
                                filterActive === false ||
                                pane.s.index === solePane) {
                                tempFilter = false;
                                pane.s.filteringActive = false;
                            }
                            pane.updatePane(!tempFilter ? false : filterActive);
                        }
                    }
                    // If the length of the selections are different then some of them have been
                    // removed and a deselect has occured
                    if (newSelectionList.length > 0 && (newSelectionList.length < this.s.selectionList.length || rebuild)) {
                        this._cascadeRegen(newSelectionList, selectTotal);
                        var last = newSelectionList[newSelectionList.length - 1].index;
                        for (var _m = 0, _o = this.s.panes; _m < _o.length; _m++) {
                            var pane = _o[_m];
                            pane.s.lastSelect = pane.s.index === last;
                        }
                    }
                    else if (newSelectionList.length > 0) {
                        // Update all of the other panes as you would just making a normal selection
                        for (var _p = 0, _q = this.s.panes; _p < _q.length; _p++) {
                            var paneUpdate = _q[_p];
                            if (paneUpdate.s.dtPane !== undefined) {
                                var tempFilter = true;
                                paneUpdate.s.filteringActive = true;
                                if (filterPane !== -1 && filterPane !== null && filterPane === paneUpdate.s.index ||
                                    filterActive === false ||
                                    paneUpdate.s.index === solePane) {
                                    tempFilter = false;
                                    paneUpdate.s.filteringActive = false;
                                }
                                paneUpdate.updatePane(!tempFilter ? tempFilter : filterActive);
                            }
                        }
                    }
                    // Update the label that shows how many filters are in place
                    this._updateFilterCount();
                }
                else {
                    var solePane = -1;
                    if (newSelectionList.length === 1 && selectTotal !== null && selectTotal !== 0) {
                        solePane = newSelectionList[0].index;
                    }
                    for (var _r = 0, _s = this.s.panes; _r < _s.length; _r++) {
                        var pane = _s[_r];
                        if (pane.s.dtPane !== undefined) {
                            var tempFilter = true;
                            pane.s.filteringActive = true;
                            if (filterPane !== -1 && filterPane !== null && filterPane === pane.s.index ||
                                filterActive === false ||
                                pane.s.index === solePane) {
                                tempFilter = false;
                                pane.s.filteringActive = false;
                            }
                            pane.updatePane(!tempFilter ? tempFilter : filterActive);
                        }
                    }
                    // Update the label that shows how many filters are in place
                    this._updateFilterCount();
                }
                if (!filterActive || selectTotal === 0) {
                    this.s.selectionList = [];
                }
            }
        };
        /**
         * Resizes all of the panes
         */
        SearchPanes.prototype.resizePanes = function () {
            if (this.c.layout === 'auto') {
                var contWidth = $$1(this.s.dt.searchPanes.container()).width();
                var target = Math.floor(contWidth / 260.0); // The neatest number of panes per row
                var highest = 1;
                var highestmod = 0;
                var dispIndex = [];
                // Get the indexes of all of the displayed panes
                for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    if (pane.s.displayed) {
                        dispIndex.push(pane.s.index);
                    }
                }
                var displayCount = dispIndex.length;
                // If the neatest number is the number we have then use this.
                if (target === displayCount) {
                    highest = target;
                }
                else {
                    // Go from the target down and find the value with the most panes left over, this will be the best fit
                    for (var ppr = target; ppr > 1; ppr--) {
                        var rem = displayCount % ppr;
                        if (rem === 0) {
                            highest = ppr;
                            highestmod = 0;
                            break;
                        }
                        // If there are more left over at this amount of panes per row (ppr)
                        // then it fits better so new values
                        else if (rem > highestmod) {
                            highest = ppr;
                            highestmod = rem;
                        }
                    }
                }
                // If there is a perfect fit then none are to be wider
                var widerIndexes = highestmod !== 0 ? dispIndex.slice(dispIndex.length - highestmod, dispIndex.length) : [];
                for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                    var pane = _c[_b];
                    // Resize the pane with the new layout
                    if (pane.s.displayed) {
                        var layout = 'columns-' + (!widerIndexes.includes(pane.s.index) ? highest : highestmod);
                        pane.resize(layout);
                    }
                }
            }
            else {
                for (var _d = 0, _e = this.s.panes; _d < _e.length; _d++) {
                    var pane = _e[_d];
                    pane.adjustTopRow();
                }
            }
            return this;
        };
        /**
         * Attach the panes, buttons and title to the document
         */
        SearchPanes.prototype._attach = function () {
            var _this = this;
            this.dom.container.removeClass(this.classes.hide);
            this.dom.titleRow.removeClass(this.classes.hide);
            this.dom.titleRow.remove();
            this.dom.title.appendTo(this.dom.titleRow);
            // If the clear button is permitted attach it
            if (this.c.clear) {
                this.dom.clearAll.appendTo(this.dom.titleRow);
                this.dom.clearAll.on('click.dtsps', function () {
                    _this.clearSelections();
                });
            }
            if (this.c.collapse) {
                this._setCollapseListener();
            }
            this.dom.titleRow.appendTo(this.dom.container);
            // Attach the container for each individual pane to the overall container
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                pane.dom.container.appendTo(this.dom.panes);
            }
            // Attach everything to the document
            this.dom.panes.appendTo(this.dom.container);
            if ($$1('div.' + this.classes.container).length === 0) {
                this.dom.container.prependTo(this.s.dt);
            }
            return this.dom.container;
        };
        /**
         * Attach the top row containing the filter count and clear all button
         */
        SearchPanes.prototype._attachExtras = function () {
            this.dom.container.removeClass(this.classes.hide);
            this.dom.titleRow.removeClass(this.classes.hide);
            this.dom.titleRow.remove();
            this.dom.title.appendTo(this.dom.titleRow);
            // If the clear button is permitted attach it
            if (this.c.clear) {
                this.dom.clearAll.appendTo(this.dom.titleRow);
            }
            // If collapsing is permitted attach those buttons
            if (this.c.collapse) {
                this.dom.showAll.appendTo(this.dom.titleRow);
                this.dom.collapseAll.appendTo(this.dom.titleRow);
            }
            this.dom.titleRow.appendTo(this.dom.container);
            return this.dom.container;
        };
        /**
         * If there are no panes to display then this method is called to either
         * display a message in their place or hide them completely.
         */
        SearchPanes.prototype._attachMessage = function () {
            // Create a message to display on the screen
            var message;
            try {
                message = this.s.dt.i18n('searchPanes.emptyPanes', this.c.i18n.emptyPanes);
            }
            catch (error) {
                message = null;
            }
            // If the message is an empty string then searchPanes.emptyPanes is undefined,
            // therefore the pane container should be removed from the display
            if (message === null) {
                this.dom.container.addClass(this.classes.hide);
                this.dom.titleRow.removeClass(this.classes.hide);
                return;
            }
            else {
                this.dom.container.removeClass(this.classes.hide);
                this.dom.titleRow.addClass(this.classes.hide);
            }
            // Otherwise display the message
            this.dom.emptyMessage.text(message);
            this.dom.emptyMessage.appendTo(this.dom.container);
            return this.dom.container;
        };
        /**
         * Attaches the panes to the document and displays a message or hides if there are none
         */
        SearchPanes.prototype._attachPaneContainer = function () {
            // If a pane is to be displayed then attach the normal pane output
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.displayed === true) {
                    return this._attach();
                }
            }
            // Otherwise attach the custom message or remove the container from the display
            return this._attachMessage();
        };
        /**
         * Prepares the panes for selections to be made when cascade is active and a deselect has occured
         *
         * @param newSelectionList the list of selections which are to be made
         */
        SearchPanes.prototype._cascadeRegen = function (newSelectionList, selectTotal) {
            // Set this to true so that the actions taken do not cause this to run until it is finished
            this.regenerating = true;
            // If only one pane has been selected then take note of its index
            var solePane = -1;
            if (newSelectionList.length === 1 && selectTotal !== null && selectTotal !== 0) {
                solePane = newSelectionList[0].index;
            }
            // Let the pane know that a cascadeRegen is taking place to avoid unexpected behaviour
            // and clear all of the previous selections in the pane
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                pane.setCascadeRegen(true);
                pane.setClear(true);
                // If this is the same as the pane with the only selection then pass it as a parameter into clearPane
                if (pane.s.dtPane !== undefined && pane.s.index === solePane || pane.s.dtPane !== undefined) {
                    pane.clearPane();
                }
                pane.setClear(false);
            }
            // Rebin panes
            this.s.dt.draw();
            // While all of the selections have been removed, check the table lengths
            // If they are different, another filter is in place and we need to force viewTotal to be used
            var noSelectionsTableLength = this.s.dt.rows({ search: 'applied' }).data().toArray().length;
            var tableLength = this.s.dt.rows().data().toArray().length;
            if (tableLength !== noSelectionsTableLength) {
                for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                    var pane = _c[_b];
                    pane.s.forceViewTotal = true;
                }
            }
            for (var _d = 0, _e = this.s.panes; _d < _e.length; _d++) {
                var pane = _e[_d];
                pane.updatePane(true);
            }
            // Remake Selections
            this._makeCascadeSelections(newSelectionList);
            // Set the selection list property to be the list without the selections from the deselect pane
            this.s.selectionList = newSelectionList;
            // The regeneration of selections is over so set it back to false
            for (var _f = 0, _g = this.s.panes; _f < _g.length; _f++) {
                var pane = _g[_f];
                pane.setCascadeRegen(false);
            }
            this.regenerating = false;
            // ViewTotal has already been forced at this point so can cancel that for future
            if (tableLength !== noSelectionsTableLength) {
                for (var _h = 0, _j = this.s.panes; _h < _j.length; _h++) {
                    var pane = _j[_h];
                    pane.s.forceViewTotal = false;
                }
            }
        };
        /**
         * Attaches the message to the document but does not add any panes
         */
        SearchPanes.prototype._checkMessage = function () {
            // If a pane is to be displayed then attach the normal pane output
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.displayed === true) {
                    // Ensure that the empty message is removed if a pane is displayed
                    this.dom.emptyMessage.remove();
                    this.dom.titleRow.removeClass(this.classes.hide);
                    return;
                }
            }
            // Otherwise attach the custom message or remove the container from the display
            return this._attachMessage();
        };
        /**
         * Checks which panes are collapsed and then performs relevant actions to the collapse/show all buttons
         *
         * @param pane The pane to be checked
         */
        SearchPanes.prototype._checkCollapse = function () {
            var disableClose = true;
            var disableShow = true;
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.displayed) {
                    // It the pane is not collapsed
                    if (!pane.dom.collapseButton.hasClass(pane.classes.rotated)) {
                        // Enable the collapse all button
                        this.dom.collapseAll.removeClass(this.classes.disabledButton).removeAttr('disabled');
                        disableClose = false;
                    }
                    else {
                        // Otherwise enable the show all button
                        this.dom.showAll.removeClass(this.classes.disabledButton).removeAttr('disabled');
                        disableShow = false;
                    }
                }
            }
            // If this flag is still true, no panes are open so the close button should be disabled
            if (disableClose) {
                this.dom.collapseAll.addClass(this.classes.disabledButton).attr('disabled', 'true');
            }
            // If this flag is still true, no panes are closed so the show button should be disabled
            if (disableShow) {
                this.dom.showAll.addClass(this.classes.disabledButton).attr('disabled', 'true');
            }
        };
        /**
         * Collapses all of the panes
         */
        SearchPanes.prototype._collapseAll = function () {
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                pane.collapse();
            }
        };
        /**
         * Gets the selection list from the previous state and stores it in the selectionList Property
         */
        SearchPanes.prototype._getState = function () {
            var loadedFilter = this.s.dt.state.loaded();
            if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.selectionList !== undefined) {
                this.s.selectionList = loadedFilter.searchPanes.selectionList;
            }
        };
        /**
         * Makes all of the selections when cascade is active
         *
         * @param newSelectionList the list of selections to be made, in the order they were originally selected
         */
        SearchPanes.prototype._makeCascadeSelections = function (newSelectionList) {
            // make selections in the order they were made previously,
            // excluding those from the pane where a deselect was made
            for (var i = 0; i < newSelectionList.length; i++) {
                var _loop_1 = function (pane) {
                    if (pane.s.index === newSelectionList[i].index && pane.s.dtPane !== undefined) {
                        // When regenerating the cascade selections we need this flag so that
                        // the panes are only ignored if it
                        // is the last selection and the pane for that selection
                        if (i === newSelectionList.length - 1) {
                            pane.s.lastCascade = true;
                        }
                        // if there are any selections currently in the pane then
                        // deselect them as we are about to make our new selections
                        if (pane.s.dtPane.rows({ selected: true }).data().toArray().length > 0 && pane.s.dtPane !== undefined) {
                            pane.setClear(true);
                            pane.clearPane();
                            pane.setClear(false);
                        }
                        var _loop_2 = function (row) {
                            var found = false;
                            pane.s.dtPane.rows().every(function (rowIdx) {
                                if (pane.s.dtPane.row(rowIdx).data() !== undefined &&
                                    row !== undefined &&
                                    pane.s.dtPane.row(rowIdx).data().filter === row.filter) {
                                    found = true;
                                    pane.s.dtPane.row(rowIdx).select();
                                }
                            });
                            if (!found) {
                                var newRow = pane.addRow(row.display, row.filter, 0, row.total, row.sort, row.type, row.className);
                                newRow.select();
                            }
                        };
                        // select every row in the pane that was selected previously
                        for (var _i = 0, _a = newSelectionList[i].rows; _i < _a.length; _i++) {
                            var row = _a[_i];
                            _loop_2(row);
                        }
                        pane.s.scrollTop = $$1(pane.s.dtPane.table().node()).parent()[0].scrollTop;
                        pane.s.dtPane.draw();
                        pane.s.dtPane.table().node().parentNode.scrollTop = pane.s.scrollTop;
                        pane.s.lastCascade = false;
                    }
                };
                // As the selections may have been made across the panes
                // in a different order to the pane index we must identify
                // which pane has the index of the selection. This is also important for colreorder etc
                for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    _loop_1(pane);
                }
            }
        };
        /**
         * Declares the instances of individual searchpanes dependant on the number of columns.
         * It is necessary to run this once preInit has completed otherwise no panes will be
         * created as the column count will be 0.
         *
         * @param table the DataTable api for the parent table
         * @param paneSettings the settings passed into the constructor
         * @param opts the options passed into the constructor
         */
        SearchPanes.prototype._paneDeclare = function (table, paneSettings, opts) {
            var _this = this;
            // Create Panes
            table
                .columns(this.c.columns.length > 0 ? this.c.columns : undefined)
                .eq(0)
                .each(function (idx) {
                _this.s.panes.push(new SearchPane(paneSettings, opts, idx, _this.c.layout, _this.dom.panes));
            });
            // If there is any extra custom panes defined then create panes for them too
            var rowLength = table.columns().eq(0).toArray().length;
            var paneLength = this.c.panes.length;
            for (var i = 0; i < paneLength; i++) {
                var id = rowLength + i;
                this.s.panes.push(new SearchPane(paneSettings, opts, id, this.c.layout, this.dom.panes, this.c.panes[i]));
            }
            // If a custom ordering is being used
            if (this.c.order.length > 0) {
                // Make a new Array of panes based upon the order
                var newPanes = this.c.order.map(function (name, index, values) { return _this._findPane(name); });
                // Remove the old panes from the dom
                this.dom.panes.empty();
                this.s.panes = newPanes;
                // Append the panes in the correct order
                for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    this.dom.panes.append(pane.dom.container);
                }
            }
            // If this internal property is true then the DataTable has been initialised already
            if (this.s.dt.settings()[0]._bInitComplete) {
                this._startup(table);
            }
            else {
                // Otherwise add the paneStartup function to the list of functions
                // that are to be run when the table is initialised. This will garauntee that the
                // panes are initialised before the init event and init Complete callback is fired
                this.s.dt.settings()[0].aoInitComplete.push({ fn: function () {
                        _this._startup(table);
                    } });
            }
        };
        /**
         * Finds a pane based upon the name of that pane
         *
         * @param name string representing the name of the pane
         * @returns SearchPane The pane which has that name
         */
        SearchPanes.prototype._findPane = function (name) {
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (name === pane.s.name) {
                    return pane;
                }
            }
        };
        /**
         * Works out which panes to update when data is recieved from the server and viewTotal is active
         */
        SearchPanes.prototype._serverTotals = function () {
            var selectPresent = false;
            var deselectPresent = false;
            var table = this.s.dt;
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                // Identify the pane where a selection or deselection has been made and add it to the list.
                if (pane.s.selectPresent) {
                    this.s.selectionList.push({
                        index: pane.s.index,
                        protect: false,
                        rows: pane.s.dtPane.rows({ selected: true }).data().toArray()
                    });
                    pane.s.selectPresent = false;
                    selectPresent = true;
                    break;
                }
                else if (pane.s.deselect) {
                    var selectedData = pane.s.dtPane.rows({ selected: true }).data().toArray();
                    if (selectedData.length > 0) {
                        this.s.selectionList.push({
                            index: pane.s.index,
                            protect: true,
                            rows: selectedData
                        });
                    }
                    selectPresent = true;
                    deselectPresent = true;
                }
            }
            // Build an updated list based on any selections or deselections added
            if (!selectPresent) {
                this.s.selectionList = [];
            }
            else {
                var newSelectionList = [];
                for (var i = 0; i < this.s.selectionList.length; i++) {
                    var further = false;
                    // Find out if this selection is the last one in the list for that pane
                    for (var j = i + 1; j < this.s.selectionList.length; j++) {
                        if (this.s.selectionList[j].index === this.s.selectionList[i].index) {
                            further = true;
                        }
                    }
                    // If there are no selections for this pane in the list then just push this one
                    if (!further) {
                        var push = false;
                        for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                            var pane = _c[_b];
                            if (pane.s.index === this.s.selectionList[i].index &&
                                pane.s.dtPane.rows({ selected: true }).data().toArray().length > 0) {
                                push = true;
                            }
                        }
                        if (push) {
                            newSelectionList.push(this.s.selectionList[i]);
                        }
                    }
                }
                this.s.selectionList = newSelectionList;
            }
            var initIdx = -1;
            // If there has been a deselect and only one pane has a selection then update everything
            if (deselectPresent && this.s.selectionList.length === 1) {
                for (var _d = 0, _e = this.s.panes; _d < _e.length; _d++) {
                    var pane = _e[_d];
                    pane.s.lastSelect = false;
                    pane.s.deselect = false;
                    if (pane.s.dtPane !== undefined && pane.s.dtPane.rows({ selected: true }).data().toArray().length > 0) {
                        initIdx = pane.s.index;
                    }
                }
            }
            // Otherwise if there are more 1 selections then find the last one and set it to not update that pane
            else if (this.s.selectionList.length > 0) {
                var last = this.s.selectionList[this.s.selectionList.length - 1].index;
                for (var _f = 0, _g = this.s.panes; _f < _g.length; _f++) {
                    var pane = _g[_f];
                    pane.s.lastSelect = pane.s.index === last;
                    pane.s.deselect = false;
                }
            }
            // Otherwise if there are no selections then find where that took place and do not update to maintain scrolling
            else if (this.s.selectionList.length === 0) {
                for (var _h = 0, _j = this.s.panes; _h < _j.length; _h++) {
                    var pane = _j[_h];
                    // pane.s.lastSelect = (pane.s.deselect === true);
                    pane.s.lastSelect = false;
                    pane.s.deselect = false;
                }
            }
            this.dom.panes.empty();
            // Rebuild the desired panes
            for (var _k = 0, _l = this.s.panes; _k < _l.length; _k++) {
                var pane = _l[_k];
                if (!pane.s.lastSelect) {
                    pane.rebuildPane(undefined, this.s.dt.page.info().serverSide ? this.s.serverData : undefined, pane.s.index === initIdx ? true : null, true);
                }
                else {
                    pane._setListeners();
                }
                // append all of the panes and enable select
                this.dom.panes.append(pane.dom.container);
                if (pane.s.dtPane !== undefined) {
                    $$1(pane.s.dtPane.table().node()).parent()[0].scrollTop = pane.s.scrollTop;
                    // eslint-disable-next-line no-extra-parens
                    $$1.fn.dataTable.select.init(pane.s.dtPane);
                }
            }
            this._updateSelection();
        };
        /**
         * Sets the listeners for the collapse and show all buttons
         * Also sets and performs checks on current panes to see if they are collapsed
         */
        SearchPanes.prototype._setCollapseListener = function () {
            var _this = this;
            this.dom.collapseAll.on('click.dtsps', function () {
                _this._collapseAll();
                _this.dom.collapseAll.addClass(_this.classes.disabledButton).attr('disabled', 'true');
                _this.dom.showAll.removeClass(_this.classes.disabledButton).removeAttr('disabled');
                _this.s.dt.state.save();
            });
            this.dom.showAll.on('click.dtsps', function () {
                _this._showAll();
                _this.dom.showAll.addClass(_this.classes.disabledButton).attr('disabled', 'true');
                _this.dom.collapseAll.removeClass(_this.classes.disabledButton).removeAttr('disabled');
                _this.s.dt.state.save();
            });
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                // We want to make the same check whenever there is a collapse/expand
                pane.dom.collapseButton.on('click', function () { return _this._checkCollapse(); });
            }
            this._checkCollapse();
        };
        /**
         * Shows all of the panes
         */
        SearchPanes.prototype._showAll = function () {
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                pane.show();
            }
        };
        /**
         * Initialises the tables previous/preset selections and initialises callbacks for events
         *
         * @param table the parent table for which the searchPanes are being created
         */
        SearchPanes.prototype._startup = function (table) {
            var _this = this;
            this.dom.container.text('');
            // Attach clear button and title bar to the document
            this._attachExtras();
            this.dom.container.append(this.dom.panes);
            this.dom.panes.empty();
            var loadedFilter = this.s.dt.state.loaded();
            if (this.c.viewTotal && !this.c.cascadePanes) {
                if (loadedFilter !== null &&
                    loadedFilter !== undefined &&
                    loadedFilter.searchPanes !== undefined &&
                    loadedFilter.searchPanes.panes !== undefined) {
                    var filterActive = false;
                    for (var _i = 0, _a = loadedFilter.searchPanes.panes; _i < _a.length; _i++) {
                        var pane = _a[_i];
                        if (pane.selected.length > 0) {
                            filterActive = true;
                            break;
                        }
                    }
                    if (filterActive) {
                        for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                            var pane = _c[_b];
                            pane.s.showFiltered = true;
                        }
                    }
                }
            }
            for (var _d = 0, _e = this.s.panes; _d < _e.length; _d++) {
                var pane = _e[_d];
                pane.rebuildPane(undefined, Object.keys(this.s.serverData).length > 0 ? this.s.serverData : undefined);
                this.dom.panes.append(pane.dom.container);
            }
            // If the layout is set to auto then the panes need to be resized to their best fit
            if (this.c.layout === 'auto') {
                this.resizePanes();
            }
            // Reset the paging if that has been saved in the state
            if (!this.s.stateRead && loadedFilter !== null && loadedFilter !== undefined) {
                this.s.dt.page(loadedFilter.start / this.s.dt.page.len());
                this.s.dt.draw('page');
            }
            this.s.stateRead = true;
            if (this.c.viewTotal && !this.c.cascadePanes) {
                for (var _f = 0, _g = this.s.panes; _f < _g.length; _f++) {
                    var pane = _g[_f];
                    pane.updatePane();
                }
            }
            this._checkMessage();
            // When a draw is called on the DataTable, update all of the panes incase the data in the DataTable has changed
            table.on('preDraw.dtsps', function () {
                // Check that the panes are not updating to avoid infinite loops
                // Also check that this draw is not due to paging
                if (!_this.s.updating && !_this.s.paging) {
                    if ((_this.c.cascadePanes || _this.c.viewTotal) && !_this.s.dt.page.info().serverSide) {
                        _this.redrawPanes(_this.c.viewTotal);
                    }
                    else {
                        _this._updateFilterCount();
                        _this._updateSelection();
                    }
                    _this.s.filterPane = -1;
                }
                // Paging flag reset - we only need to dodge the draw once
                _this.s.paging = false;
            });
            $$1(window).on('resize.dtsp', dataTable$1.util.throttle(function () {
                _this.resizePanes();
            }));
            // Whenever a state save occurs store the selection list in the state object
            this.s.dt.on('stateSaveParams.dtsp', function (e, settings, data) {
                if (data.searchPanes === undefined) {
                    data.searchPanes = {};
                }
                data.searchPanes.selectionList = _this.s.selectionList;
            });
            // Listener for paging on main table
            table.off('page');
            table.on('page', function () {
                _this.s.paging = true;
                _this.s.page = _this.s.dt.page();
            });
            if (this.s.dt.page.info().serverSide) {
                table.off('preXhr.dt');
                table.on('preXhr.dt', function (e, settings, data) {
                    if (data.searchPanes === undefined) {
                        data.searchPanes = {};
                    }
                    if (data.searchPanes_null === undefined) {
                        data.searchPanes_null = {};
                    }
                    // Count how many filters are being applied
                    var filterCount = 0;
                    for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {
                        var pane = _a[_i];
                        var src = _this.s.dt.column(pane.s.index).dataSrc();
                        if (data.searchPanes[src] === undefined) {
                            data.searchPanes[src] = {};
                        }
                        if (data.searchPanes_null[src] === undefined) {
                            data.searchPanes_null[src] = {};
                        }
                        if (pane.s.dtPane !== undefined) {
                            var rowData = pane.s.dtPane.rows({ selected: true }).data().toArray();
                            for (var i = 0; i < rowData.length; i++) {
                                data.searchPanes[src][i] = rowData[i].filter;
                                if (data.searchPanes[src][i] === null) {
                                    data.searchPanes_null[src][i] = true;
                                }
                                filterCount++;
                            }
                        }
                    }
                    if (_this.c.viewTotal) {
                        _this._prepViewTotal(filterCount);
                    }
                    // If there is a filter to be applied, then we need to read from the start of the result set
                    // and set the paging to 0. This matches the behaviour of client side processing
                    if (filterCount > 0) {
                        // If the number of filters has changed we need to read from the start of the
                        // result set and reset the paging
                        if (filterCount !== _this.s.filterCount) {
                            data.start = 0;
                            _this.s.page = 0;
                        }
                        // Otherwise it is a paging request and we need to read from whatever the paging has been set to
                        else {
                            data.start = _this.s.page * _this.s.dt.page.len();
                        }
                        _this.s.dt.page(_this.s.page);
                        _this.s.filterCount = filterCount;
                    }
                });
            }
            else {
                table.on('preXhr.dt', function (e, settings, data) {
                    for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {
                        var pane = _a[_i];
                        pane.clearData();
                    }
                });
            }
            // If the data is reloaded from the server then it is possible that it has changed completely,
            // so we need to rebuild the panes
            this.s.dt.on('xhr', function (e, settings, json, xhr) {
                if (settings.nTable !== _this.s.dt.table().node()) {
                    return;
                }
                var processing = false;
                if (!_this.s.dt.page.info().serverSide) {
                    _this.s.dt.one('preDraw', function () {
                        if (processing) {
                            return;
                        }
                        var page = _this.s.dt.page();
                        processing = true;
                        _this.s.updating = true;
                        _this.dom.panes.empty();
                        for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {
                            var pane = _a[_i];
                            pane.clearData(); // Clears all of the bins and will mean that the data has to be re-read
                            // Pass a boolean to say whether this is the last choice made for maintaining selections
                            // when rebuilding
                            pane.rebuildPane(_this.s.selectionList[_this.s.selectionList.length - 1] !== undefined ?
                                pane.s.index === _this.s.selectionList[_this.s.selectionList.length - 1].index :
                                false, undefined, undefined, true);
                            _this.dom.panes.append(pane.dom.container);
                        }
                        if (!_this.s.dt.page.info().serverSide) {
                            _this.s.dt.draw();
                        }
                        _this.s.updating = false;
                        if (_this.c.cascadePanes || _this.c.viewTotal) {
                            _this.redrawPanes(_this.c.cascadePanes);
                        }
                        else {
                            _this._updateSelection();
                        }
                        _this._checkMessage();
                        _this.s.dt.one('draw', function () {
                            _this.s.updating = true;
                            _this.s.dt.page(page).draw(false);
                            _this.s.updating = false;
                        });
                    });
                }
            });
            // PreSelect any selections which have been defined using the preSelect option
            for (var _h = 0, _j = this.s.panes; _h < _j.length; _h++) {
                var pane = _j[_h];
                if (pane !== undefined &&
                    pane.s.dtPane !== undefined &&
                    (pane.s.colOpts.preSelect !== undefined && pane.s.colOpts.preSelect.length > 0 ||
                        pane.customPaneSettings !== null &&
                            pane.customPaneSettings.preSelect !== undefined &&
                            pane.customPaneSettings.preSelect.length > 0)) {
                    var tableLength = pane.s.dtPane.rows().data().toArray().length;
                    for (var i = 0; i < tableLength; i++) {
                        if (pane.s.colOpts.preSelect.includes(pane.s.dtPane.cell(i, 0).data()) ||
                            pane.customPaneSettings !== null &&
                                pane.customPaneSettings.preSelect !== undefined &&
                                pane.customPaneSettings.preSelect.includes(pane.s.dtPane.cell(i, 0).data())) {
                            pane.s.dtPane.row(i).select();
                        }
                    }
                    pane.updateTable();
                }
            }
            if (this.s.selectionList !== undefined && this.s.selectionList.length > 0) {
                var last = this.s.selectionList[this.s.selectionList.length - 1].index;
                for (var _k = 0, _l = this.s.panes; _k < _l.length; _k++) {
                    var pane = _l[_k];
                    pane.s.lastSelect = pane.s.index === last;
                }
            }
            // If cascadePanes is active then make the previous selections in the order they were previously
            if (this.s.selectionList.length > 0 && this.c.cascadePanes) {
                this._cascadeRegen(this.s.selectionList, this.s.selectionList.length);
            }
            // Update the title bar to show how many filters have been selected
            this._updateFilterCount();
            // If the table is destroyed and restarted then clear the selections so that they do not persist.
            table.on('destroy.dtsps', function () {
                for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    pane.destroy();
                }
                table.off('.dtsps');
                _this.dom.collapseAll.off('.dtsps');
                _this.dom.showAll.off('.dtsps');
                _this.dom.clearAll.off('.dtsps');
                _this.dom.container.remove();
                _this.clearSelections();
            });
            if (this.c.collapse) {
                this._setCollapseListener();
            }
            // When the clear All button has been pressed clear all of the selections in the panes
            if (this.c.clear) {
                this.dom.clearAll.on('click.dtsps', function () {
                    _this.clearSelections();
                });
            }
            table.settings()[0]._searchPanes = this;
            // This state save is required so that state is maintained over multiple refreshes if no actions are made
            this.s.dt.state.save();
        };
        SearchPanes.prototype._prepViewTotal = function (selectTotal) {
            var filterPane = this.s.filterPane;
            var filterActive = false;
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.dtPane !== undefined) {
                    var selectLength = pane.s.dtPane.rows({ selected: true }).data().toArray().length;
                    // If filterPane === -1 then a pane with a selection has not been found yet,
                    // so set filterPane to that panes index
                    if (selectLength > 0 && filterPane === -1) {
                        filterPane = pane.s.index;
                        filterActive = true;
                    }
                    // Then if another pane is found with a selection then set filterPane to null to
                    // show that multiple panes have selections present
                    else if (selectLength > 0) {
                        filterPane = null;
                    }
                }
            }
            if (selectTotal !== null && selectTotal !== 0) {
                filterPane = null;
            }
            // Update all of the panes to reflect the current state of the filters
            for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                var pane = _c[_b];
                if (pane.s.dtPane !== undefined) {
                    pane.s.filteringActive = true;
                    if (filterPane !== -1 && filterPane !== null && filterPane === pane.s.index ||
                        filterActive === false) {
                        pane.s.filteringActive = false;
                    }
                }
            }
        };
        /**
         * Updates the number of filters that have been applied in the title
         */
        SearchPanes.prototype._updateFilterCount = function () {
            var filterCount = 0;
            // Add the number of all of the filters throughout the panes
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.dtPane !== undefined) {
                    filterCount += pane.getPaneCount();
                }
            }
            // Run the message through the internationalisation method to improve readability
            var message = this.s.dt.i18n('searchPanes.title', this.c.i18n.title, filterCount);
            this.dom.title.text(message);
            if (this.c.filterChanged !== undefined && typeof this.c.filterChanged === 'function') {
                this.c.filterChanged.call(this.s.dt, filterCount);
            }
            if (filterCount === 0) {
                this.dom.clearAll.addClass(this.classes.disabledButton).attr('disabled', 'true');
            }
            else {
                this.dom.clearAll.removeClass(this.classes.disabledButton).removeAttr('disabled');
            }
        };
        /**
         * Updates the selectionList when cascade is not in place
         */
        SearchPanes.prototype._updateSelection = function () {
            this.s.selectionList = [];
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.dtPane !== undefined) {
                    this.s.selectionList.push({
                        index: pane.s.index,
                        protect: false,
                        rows: pane.s.dtPane.rows({ selected: true }).data().toArray()
                    });
                }
            }
        };
        SearchPanes.version = '1.4.0';
        SearchPanes.classes = {
            clear: 'dtsp-clear',
            clearAll: 'dtsp-clearAll',
            collapseAll: 'dtsp-collapseAll',
            container: 'dtsp-searchPanes',
            disabledButton: 'dtsp-disabledButton',
            emptyMessage: 'dtsp-emptyMessage',
            hide: 'dtsp-hidden',
            panes: 'dtsp-panesContainer',
            search: 'dtsp-search',
            showAll: 'dtsp-showAll',
            title: 'dtsp-title',
            titleRow: 'dtsp-titleRow'
        };
        // Define SearchPanes default options
        SearchPanes.defaults = {
            cascadePanes: false,
            clear: true,
            collapse: true,
            columns: [],
            container: function (dt) {
                return dt.table().container();
            },
            filterChanged: undefined,
            i18n: {
                clearMessage: 'Clear All',
                clearPane: '&times;',
                collapse: {
                    0: 'SearchPanes',
                    _: 'SearchPanes (%d)'
                },
                collapseMessage: 'Collapse All',
                count: '{total}',
                countFiltered: '{shown} ({total})',
                emptyMessage: '<em>No data</em>',
                emptyPanes: 'No SearchPanes',
                loadMessage: 'Loading Search Panes...',
                showMessage: 'Show All',
                title: 'Filters Active - %d'
            },
            layout: 'auto',
            order: [],
            panes: [],
            viewTotal: false
        };
        return SearchPanes;
    }());

    /*! SearchPanes 1.4.0
     * 2019-2020 SpryMedia Ltd - datatables.net/license
     */
    // DataTables extensions common UMD. Note that this allows for AMD, CommonJS
    // (with window and jQuery being allowed as parameters to the returned
    // function) or just default browser loading.
    (function (factory) {
        if (true) {
            // AMD
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
                return factory($, window, document);
            }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
        else {}
    }(function ($, window, document) {
        setJQuery($);
        setJQuery$1($);
        var dataTable = $.fn.dataTable;
        // eslint-disable-next-line no-extra-parens
        $.fn.dataTable.SearchPanes = SearchPanes;
        // eslint-disable-next-line no-extra-parens
        $.fn.DataTable.SearchPanes = SearchPanes;
        // eslint-disable-next-line no-extra-parens
        $.fn.dataTable.SearchPane = SearchPane;
        // eslint-disable-next-line no-extra-parens
        $.fn.DataTable.SearchPane = SearchPane;
        // eslint-disable-next-line no-extra-parens
        var apiRegister = $.fn.dataTable.Api.register;
        apiRegister('searchPanes()', function () {
            return this;
        });
        apiRegister('searchPanes.clearSelections()', function () {
            return this.iterator('table', function (ctx) {
                if (ctx._searchPanes) {
                    ctx._searchPanes.clearSelections();
                }
            });
        });
        apiRegister('searchPanes.rebuildPane()', function (targetIdx, maintainSelections) {
            return this.iterator('table', function (ctx) {
                if (ctx._searchPanes) {
                    ctx._searchPanes.rebuild(targetIdx, maintainSelections);
                }
            });
        });
        apiRegister('searchPanes.resizePanes()', function () {
            var ctx = this.context[0];
            return ctx._searchPanes ?
                ctx._searchPanes.resizePanes() :
                null;
        });
        apiRegister('searchPanes.container()', function () {
            var ctx = this.context[0];
            return ctx._searchPanes
                ? ctx._searchPanes.getNode()
                : null;
        });
        $.fn.dataTable.ext.buttons.searchPanesClear = {
            action: function (e, dt, node, config) {
                dt.searchPanes.clearSelections();
            },
            text: 'Clear Panes'
        };
        $.fn.dataTable.ext.buttons.searchPanes = {
            action: function (e, dt, node, config) {
                e.stopPropagation();
                this.popover(config._panes.getNode(), {
                    align: 'dt-container'
                });
                config._panes.rebuild(undefined, true);
            },
            config: {},
            init: function (dt, node, config) {
                var panes = new $.fn.dataTable.SearchPanes(dt, $.extend({
                    filterChanged: function (count) {
                        // console.log(dt.context[0])
                        dt.button(node).text(dt.i18n('searchPanes.collapse', dt.context[0].oLanguage.searchPanes !== undefined ?
                            dt.context[0].oLanguage.searchPanes.collapse :
                            dt.context[0]._searchPanes.c.i18n.collapse, count));
                    }
                }, config.config));
                var message = dt.i18n('searchPanes.collapse', panes.c.i18n.collapse, 0);
                dt.button(node).text(message);
                config._panes = panes;
            },
            text: 'Search Panes'
        };
        function _init(settings, options, fromPre) {
            if (options === void 0) { options = null; }
            if (fromPre === void 0) { fromPre = false; }
            var api = new dataTable.Api(settings);
            var opts = options
                ? options
                : api.init().searchPanes || dataTable.defaults.searchPanes;
            var searchPanes = new SearchPanes(api, opts, fromPre);
            var node = searchPanes.getNode();
            return node;
        }
        // Attach a listener to the document which listens for DataTables initialisation
        // events so we can automatically initialise
        $(document).on('preInit.dt.dtsp', function (e, settings, json) {
            if (e.namespace !== 'dt') {
                return;
            }
            if (settings.oInit.searchPanes ||
                dataTable.defaults.searchPanes) {
                if (!settings._searchPanes) {
                    _init(settings, null, true);
                }
            }
        });
        // DataTables `dom` feature option
        dataTable.ext.feature.push({
            cFeature: 'P',
            fnInit: _init
        });
        // DataTables 2 layout feature
        if (dataTable.ext.features) {
            dataTable.ext.features.register('searchPanes', _init);
        }
    }));

}());


/***/ }),

/***/ "./node_modules/datatables.net-select-bs5/js/select.bootstrap5.js":
/*!************************************************************************!*\
  !*** ./node_modules/datatables.net-select-bs5/js/select.bootstrap5.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap 5 styling wrapper for Select
 * Â©2021 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net-bs5 */ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js"), __webpack_require__(/*! datatables.net-select */ "./node_modules/datatables.net-select/js/dataTables.select.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}(function( $, window, document, undefined ) {

return $.fn.dataTable;

}));

/***/ }),

/***/ "./node_modules/datatables.net-select/js/dataTables.select.js":
/*!********************************************************************!*\
  !*** ./node_modules/datatables.net-select/js/dataTables.select.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Select for DataTables 1.3.3
 * 2015-2021 SpryMedia Ltd - datatables.net/license/mit
 */

/**
 * @summary     Select for DataTables
 * @description A collection of API methods, events and buttons for DataTables
 *   that provides selection options of the items in a DataTable
 * @version     1.3.3
 * @file        dataTables.select.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     datatables.net/forums
 * @copyright   Copyright 2015-2021 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net/extensions/select
 */
(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


// Version information for debugger
DataTable.select = {};

DataTable.select.version = '1.3.3';

DataTable.select.init = function ( dt ) {
	var ctx = dt.settings()[0];
	var init = ctx.oInit.select;
	var defaults = DataTable.defaults.select;
	var opts = init === undefined ?
		defaults :
		init;

	// Set defaults
	var items = 'row';
	var style = 'api';
	var blurable = false;
	var toggleable = true;
	var info = true;
	var selector = 'td, th';
	var className = 'selected';
	var setStyle = false;

	ctx._select = {};

	// Initialisation customisations
	if ( opts === true ) {
		style = 'os';
		setStyle = true;
	}
	else if ( typeof opts === 'string' ) {
		style = opts;
		setStyle = true;
	}
	else if ( $.isPlainObject( opts ) ) {
		if ( opts.blurable !== undefined ) {
			blurable = opts.blurable;
		}
		
		if ( opts.toggleable !== undefined ) {
			toggleable = opts.toggleable;
		}

		if ( opts.info !== undefined ) {
			info = opts.info;
		}

		if ( opts.items !== undefined ) {
			items = opts.items;
		}

		if ( opts.style !== undefined ) {
			style = opts.style;
			setStyle = true;
		}
		else {
			style = 'os';
			setStyle = true;
		}

		if ( opts.selector !== undefined ) {
			selector = opts.selector;
		}

		if ( opts.className !== undefined ) {
			className = opts.className;
		}
	}

	dt.select.selector( selector );
	dt.select.items( items );
	dt.select.style( style );
	dt.select.blurable( blurable );
	dt.select.toggleable( toggleable );
	dt.select.info( info );
	ctx._select.className = className;


	// Sort table based on selected rows. Requires Select Datatables extension
	$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {
		return this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {
			if ( settings._select.items === 'row' ) {
				return $( td ).parent().hasClass( settings._select.className );
			} else if ( settings._select.items === 'cell' ) {
				return $( td ).hasClass( settings._select.className );
			}
			return false;
		});
	};

	// If the init options haven't enabled select, but there is a selectable
	// class name, then enable
	if ( ! setStyle && $( dt.table().node() ).hasClass( 'selectable' ) ) {
		dt.select.style( 'os' );
	}
};

/*

Select is a collection of API methods, event handlers, event emitters and
buttons (for the `Buttons` extension) for DataTables. It provides the following
features, with an overview of how they are implemented:

## Selection of rows, columns and cells. Whether an item is selected or not is
   stored in:

* rows: a `_select_selected` property which contains a boolean value of the
  DataTables' `aoData` object for each row
* columns: a `_select_selected` property which contains a boolean value of the
  DataTables' `aoColumns` object for each column
* cells: a `_selected_cells` property which contains an array of boolean values
  of the `aoData` object for each row. The array is the same length as the
  columns array, with each element of it representing a cell.

This method of using boolean flags allows Select to operate when nodes have not
been created for rows / cells (DataTables' defer rendering feature).

## API methods

A range of API methods are available for triggering selection and de-selection
of rows. Methods are also available to configure the selection events that can
be triggered by an end user (such as which items are to be selected). To a large
extent, these of API methods *is* Select. It is basically a collection of helper
functions that can be used to select items in a DataTable.

Configuration of select is held in the object `_select` which is attached to the
DataTables settings object on initialisation. Select being available on a table
is not optional when Select is loaded, but its default is for selection only to
be available via the API - so the end user wouldn't be able to select rows
without additional configuration.

The `_select` object contains the following properties:

```
{
	items:string       - Can be `rows`, `columns` or `cells`. Defines what item 
	                     will be selected if the user is allowed to activate row
	                     selection using the mouse.
	style:string       - Can be `none`, `single`, `multi` or `os`. Defines the
	                     interaction style when selecting items
	blurable:boolean   - If row selection can be cleared by clicking outside of
	                     the table
	toggleable:boolean - If row selection can be cancelled by repeated clicking
	                     on the row
	info:boolean       - If the selection summary should be shown in the table
	                     information elements
}
```

In addition to the API methods, Select also extends the DataTables selector
options for rows, columns and cells adding a `selected` option to the selector
options object, allowing the developer to select only selected items or
unselected items.

## Mouse selection of items

Clicking on items can be used to select items. This is done by a simple event
handler that will select the items using the API methods.

 */


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Local functions
 */

/**
 * Add one or more cells to the selection when shift clicking in OS selection
 * style cell selection.
 *
 * Cell range is more complicated than row and column as we want to select
 * in the visible grid rather than by index in sequence. For example, if you
 * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1
 * should also be selected (and not 1-3, 1-4. etc)
 * 
 * @param  {DataTable.Api} dt   DataTable
 * @param  {object}        idx  Cell index to select to
 * @param  {object}        last Cell index to select from
 * @private
 */
function cellRange( dt, idx, last )
{
	var indexes;
	var columnIndexes;
	var rowIndexes;
	var selectColumns = function ( start, end ) {
		if ( start > end ) {
			var tmp = end;
			end = start;
			start = tmp;
		}
		
		var record = false;
		return dt.columns( ':visible' ).indexes().filter( function (i) {
			if ( i === start ) {
				record = true;
			}
			
			if ( i === end ) { // not else if, as start might === end
				record = false;
				return true;
			}

			return record;
		} );
	};

	var selectRows = function ( start, end ) {
		var indexes = dt.rows( { search: 'applied' } ).indexes();

		// Which comes first - might need to swap
		if ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {
			var tmp = end;
			end = start;
			start = tmp;
		}

		var record = false;
		return indexes.filter( function (i) {
			if ( i === start ) {
				record = true;
			}
			
			if ( i === end ) {
				record = false;
				return true;
			}

			return record;
		} );
	};

	if ( ! dt.cells( { selected: true } ).any() && ! last ) {
		// select from the top left cell to this one
		columnIndexes = selectColumns( 0, idx.column );
		rowIndexes = selectRows( 0 , idx.row );
	}
	else {
		// Get column indexes between old and new
		columnIndexes = selectColumns( last.column, idx.column );
		rowIndexes = selectRows( last.row , idx.row );
	}

	indexes = dt.cells( rowIndexes, columnIndexes ).flatten();

	if ( ! dt.cells( idx, { selected: true } ).any() ) {
		// Select range
		dt.cells( indexes ).select();
	}
	else {
		// Deselect range
		dt.cells( indexes ).deselect();
	}
}

/**
 * Disable mouse selection by removing the selectors
 *
 * @param {DataTable.Api} dt DataTable to remove events from
 * @private
 */
function disableMouseSelection( dt )
{
	var ctx = dt.settings()[0];
	var selector = ctx._select.selector;

	$( dt.table().container() )
		.off( 'mousedown.dtSelect', selector )
		.off( 'mouseup.dtSelect', selector )
		.off( 'click.dtSelect', selector );

	$('body').off( 'click.dtSelect' + _safeId(dt.table().node()) );
}

/**
 * Attach mouse listeners to the table to allow mouse selection of items
 *
 * @param {DataTable.Api} dt DataTable to remove events from
 * @private
 */
function enableMouseSelection ( dt )
{
	var container = $( dt.table().container() );
	var ctx = dt.settings()[0];
	var selector = ctx._select.selector;
	var matchSelection;

	container
		.on( 'mousedown.dtSelect', selector, function(e) {
			// Disallow text selection for shift clicking on the table so multi
			// element selection doesn't look terrible!
			if ( e.shiftKey || e.metaKey || e.ctrlKey ) {
				container
					.css( '-moz-user-select', 'none' )
					.one('selectstart.dtSelect', selector, function () {
						return false;
					} );
			}

			if ( window.getSelection ) {
				matchSelection = window.getSelection();
			}
		} )
		.on( 'mouseup.dtSelect', selector, function() {
			// Allow text selection to occur again, Mozilla style (tested in FF
			// 35.0.1 - still required)
			container.css( '-moz-user-select', '' );
		} )
		.on( 'click.dtSelect', selector, function ( e ) {
			var items = dt.select.items();
			var idx;

			// If text was selected (click and drag), then we shouldn't change
			// the row's selected state
			if ( matchSelection ) {
				var selection = window.getSelection();

				// If the element that contains the selection is not in the table, we can ignore it
				// This can happen if the developer selects text from the click event
				if ( ! selection.anchorNode || $(selection.anchorNode).closest('table')[0] === dt.table().node() ) {
					if ( selection !== matchSelection ) {
						return;
					}
				}
			}

			var ctx = dt.settings()[0];
			var wrapperClass = dt.settings()[0].oClasses.sWrapper.trim().replace(/ +/g, '.');

			// Ignore clicks inside a sub-table
			if ( $(e.target).closest('div.'+wrapperClass)[0] != dt.table().container() ) {
				return;
			}

			var cell = dt.cell( $(e.target).closest('td, th') );

			// Check the cell actually belongs to the host DataTable (so child
			// rows, etc, are ignored)
			if ( ! cell.any() ) {
				return;
			}

			var event = $.Event('user-select.dt');
			eventTrigger( dt, event, [ items, cell, e ] );

			if ( event.isDefaultPrevented() ) {
				return;
			}

			var cellIndex = cell.index();
			if ( items === 'row' ) {
				idx = cellIndex.row;
				typeSelect( e, dt, ctx, 'row', idx );
			}
			else if ( items === 'column' ) {
				idx = cell.index().column;
				typeSelect( e, dt, ctx, 'column', idx );
			}
			else if ( items === 'cell' ) {
				idx = cell.index();
				typeSelect( e, dt, ctx, 'cell', idx );
			}

			ctx._select_lastCell = cellIndex;
		} );

	// Blurable
	$('body').on( 'click.dtSelect' + _safeId(dt.table().node()), function ( e ) {
		if ( ctx._select.blurable ) {
			// If the click was inside the DataTables container, don't blur
			if ( $(e.target).parents().filter( dt.table().container() ).length ) {
				return;
			}

			// Ignore elements which have been removed from the DOM (i.e. paging
			// buttons)
			if ( $(e.target).parents('html').length === 0 ) {
			 	return;
			}

			// Don't blur in Editor form
			if ( $(e.target).parents('div.DTE').length ) {
				return;
			}

			clear( ctx, true );
		}
	} );
}

/**
 * Trigger an event on a DataTable
 *
 * @param {DataTable.Api} api      DataTable to trigger events on
 * @param  {boolean}      selected true if selected, false if deselected
 * @param  {string}       type     Item type acting on
 * @param  {boolean}      any      Require that there are values before
 *     triggering
 * @private
 */
function eventTrigger ( api, type, args, any )
{
	if ( any && ! api.flatten().length ) {
		return;
	}

	if ( typeof type === 'string' ) {
		type = type +'.dt';
	}

	args.unshift( api );

	$(api.table().node()).trigger( type, args );
}

/**
 * Update the information element of the DataTable showing information about the
 * items selected. This is done by adding tags to the existing text
 * 
 * @param {DataTable.Api} api DataTable to update
 * @private
 */
function info ( api )
{
	var ctx = api.settings()[0];

	if ( ! ctx._select.info || ! ctx.aanFeatures.i ) {
		return;
	}

	if ( api.select.style() === 'api' ) {
		return;
	}

	var rows    = api.rows( { selected: true } ).flatten().length;
	var columns = api.columns( { selected: true } ).flatten().length;
	var cells   = api.cells( { selected: true } ).flatten().length;

	var add = function ( el, name, num ) {
		el.append( $('<span class="select-item"/>').append( api.i18n(
			'select.'+name+'s',
			{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },
			num
		) ) );
	};

	// Internal knowledge of DataTables to loop over all information elements
	$.each( ctx.aanFeatures.i, function ( i, el ) {
		el = $(el);

		var output  = $('<span class="select-info"/>');
		add( output, 'row', rows );
		add( output, 'column', columns );
		add( output, 'cell', cells  );

		var exisiting = el.children('span.select-info');
		if ( exisiting.length ) {
			exisiting.remove();
		}

		if ( output.text() !== '' ) {
			el.append( output );
		}
	} );
}

/**
 * Initialisation of a new table. Attach event handlers and callbacks to allow
 * Select to operate correctly.
 *
 * This will occur _after_ the initial DataTables initialisation, although
 * before Ajax data is rendered, if there is ajax data
 *
 * @param  {DataTable.settings} ctx Settings object to operate on
 * @private
 */
function init ( ctx ) {
	var api = new DataTable.Api( ctx );

	// Row callback so that classes can be added to rows and cells if the item
	// was selected before the element was created. This will happen with the
	// `deferRender` option enabled.
	// 
	// This method of attaching to `aoRowCreatedCallback` is a hack until
	// DataTables has proper events for row manipulation If you are reviewing
	// this code to create your own plug-ins, please do not do this!
	ctx.aoRowCreatedCallback.push( {
		fn: function ( row, data, index ) {
			var i, ien;
			var d = ctx.aoData[ index ];

			// Row
			if ( d._select_selected ) {
				$( row ).addClass( ctx._select.className );
			}

			// Cells and columns - if separated out, we would need to do two
			// loops, so it makes sense to combine them into a single one
			for ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {
				if ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {
					$(d.anCells[i]).addClass( ctx._select.className );
				}
			}
		},
		sName: 'select-deferRender'
	} );

	// On Ajax reload we want to reselect all rows which are currently selected,
	// if there is an rowId (i.e. a unique value to identify each row with)
	api.on( 'preXhr.dt.dtSelect', function (e, settings) {
		if (settings !== api.settings()[0]) {
			// Not triggered by our DataTable!
			return;
		}

		// note that column selection doesn't need to be cached and then
		// reselected, as they are already selected
		var rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {
			return d !== undefined;
		} );

		var cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {
			var id = api.row( cellIdx.row ).id( true );
			return id ?
				{ row: id, column: cellIdx.column } :
				undefined;
		} ).filter( function ( d ) {
			return d !== undefined;
		} );

		// On the next draw, reselect the currently selected items
		api.one( 'draw.dt.dtSelect', function () {
			api.rows( rows ).select();

			// `cells` is not a cell index selector, so it needs a loop
			if ( cells.any() ) {
				cells.each( function ( id ) {
					api.cells( id.row, id.column ).select();
				} );
			}
		} );
	} );

	// Update the table information element with selected item summary
	api.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {
		info( api );
	} );

	// Clean up and release
	api.on( 'destroy.dtSelect', function () {
		api.rows({selected: true}).deselect();

		disableMouseSelection( api );
		api.off( '.dtSelect' );
	} );
}

/**
 * Add one or more items (rows or columns) to the selection when shift clicking
 * in OS selection style
 *
 * @param  {DataTable.Api} dt   DataTable
 * @param  {string}        type Row or column range selector
 * @param  {object}        idx  Item index to select to
 * @param  {object}        last Item index to select from
 * @private
 */
function rowColumnRange( dt, type, idx, last )
{
	// Add a range of rows from the last selected row to this one
	var indexes = dt[type+'s']( { search: 'applied' } ).indexes();
	var idx1 = $.inArray( last, indexes );
	var idx2 = $.inArray( idx, indexes );

	if ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {
		// select from top to here - slightly odd, but both Windows and Mac OS
		// do this
		indexes.splice( $.inArray( idx, indexes )+1, indexes.length );
	}
	else {
		// reverse so we can shift click 'up' as well as down
		if ( idx1 > idx2 ) {
			var tmp = idx2;
			idx2 = idx1;
			idx1 = tmp;
		}

		indexes.splice( idx2+1, indexes.length );
		indexes.splice( 0, idx1 );
	}

	if ( ! dt[type]( idx, { selected: true } ).any() ) {
		// Select range
		dt[type+'s']( indexes ).select();
	}
	else {
		// Deselect range - need to keep the clicked on row selected
		indexes.splice( $.inArray( idx, indexes ), 1 );
		dt[type+'s']( indexes ).deselect();
	}
}

/**
 * Clear all selected items
 *
 * @param  {DataTable.settings} ctx Settings object of the host DataTable
 * @param  {boolean} [force=false] Force the de-selection to happen, regardless
 *     of selection style
 * @private
 */
function clear( ctx, force )
{
	if ( force || ctx._select.style === 'single' ) {
		var api = new DataTable.Api( ctx );
		
		api.rows( { selected: true } ).deselect();
		api.columns( { selected: true } ).deselect();
		api.cells( { selected: true } ).deselect();
	}
}

/**
 * Select items based on the current configuration for style and items.
 *
 * @param  {object}             e    Mouse event object
 * @param  {DataTables.Api}     dt   DataTable
 * @param  {DataTable.settings} ctx  Settings object of the host DataTable
 * @param  {string}             type Items to select
 * @param  {int|object}         idx  Index of the item to select
 * @private
 */
function typeSelect ( e, dt, ctx, type, idx )
{
	var style = dt.select.style();
	var toggleable = dt.select.toggleable();
	var isSelected = dt[type]( idx, { selected: true } ).any();
	
	if ( isSelected && ! toggleable ) {
		return;
	}

	if ( style === 'os' ) {
		if ( e.ctrlKey || e.metaKey ) {
			// Add or remove from the selection
			dt[type]( idx ).select( ! isSelected );
		}
		else if ( e.shiftKey ) {
			if ( type === 'cell' ) {
				cellRange( dt, idx, ctx._select_lastCell || null );
			}
			else {
				rowColumnRange( dt, type, idx, ctx._select_lastCell ?
					ctx._select_lastCell[type] :
					null
				);
			}
		}
		else {
			// No cmd or shift click - deselect if selected, or select
			// this row only
			var selected = dt[type+'s']( { selected: true } );

			if ( isSelected && selected.flatten().length === 1 ) {
				dt[type]( idx ).deselect();
			}
			else {
				selected.deselect();
				dt[type]( idx ).select();
			}
		}
	} else if ( style == 'multi+shift' ) {
		if ( e.shiftKey ) {
			if ( type === 'cell' ) {
				cellRange( dt, idx, ctx._select_lastCell || null );
			}
			else {
				rowColumnRange( dt, type, idx, ctx._select_lastCell ?
					ctx._select_lastCell[type] :
					null
				);
			}
		}
		else {
			dt[ type ]( idx ).select( ! isSelected );
		}
	}
	else {
		dt[ type ]( idx ).select( ! isSelected );
	}
}

function _safeId( node ) {
	return node.id.replace(/[^a-zA-Z0-9\-\_]/g, '-');
}



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables selectors
 */

// row and column are basically identical just assigned to different properties
// and checking a different array, so we can dynamically create the functions to
// reduce the code size
$.each( [
	{ type: 'row', prop: 'aoData' },
	{ type: 'column', prop: 'aoColumns' }
], function ( i, o ) {
	DataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {
		var selected = opts.selected;
		var data;
		var out = [];

		if ( selected !== true && selected !== false ) {
			return indexes;
		}

		for ( var i=0, ien=indexes.length ; i<ien ; i++ ) {
			data = settings[ o.prop ][ indexes[i] ];

			if ( (selected === true && data._select_selected === true) ||
			     (selected === false && ! data._select_selected )
			) {
				out.push( indexes[i] );
			}
		}

		return out;
	} );
} );

DataTable.ext.selector.cell.push( function ( settings, opts, cells ) {
	var selected = opts.selected;
	var rowData;
	var out = [];

	if ( selected === undefined ) {
		return cells;
	}

	for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
		rowData = settings.aoData[ cells[i].row ];

		if ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||
		     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )
		) {
			out.push( cells[i] );
		}
	}

	return out;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API
 *
 * For complete documentation, please refer to the docs/api directory or the
 * DataTables site
 */

// Local variables to improve compression
var apiRegister = DataTable.Api.register;
var apiRegisterPlural = DataTable.Api.registerPlural;

apiRegister( 'select()', function () {
	return this.iterator( 'table', function ( ctx ) {
		DataTable.select.init( new DataTable.Api( ctx ) );
	} );
} );

apiRegister( 'select.blurable()', function ( flag ) {
	if ( flag === undefined ) {
		return this.context[0]._select.blurable;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.blurable = flag;
	} );
} );

apiRegister( 'select.toggleable()', function ( flag ) {
	if ( flag === undefined ) {
		return this.context[0]._select.toggleable;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.toggleable = flag;
	} );
} );

apiRegister( 'select.info()', function ( flag ) {
	if ( flag === undefined ) {
		return this.context[0]._select.info;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.info = flag;
	} );
} );

apiRegister( 'select.items()', function ( items ) {
	if ( items === undefined ) {
		return this.context[0]._select.items;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.items = items;

		eventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );
	} );
} );

// Takes effect from the _next_ selection. None disables future selection, but
// does not clear the current selection. Use the `deselect` methods for that
apiRegister( 'select.style()', function ( style ) {
	if ( style === undefined ) {
		return this.context[0]._select.style;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.style = style;

		if ( ! ctx._select_init ) {
			init( ctx );
		}

		// Add / remove mouse event handlers. They aren't required when only
		// API selection is available
		var dt = new DataTable.Api( ctx );
		disableMouseSelection( dt );
		
		if ( style !== 'api' ) {
			enableMouseSelection( dt );
		}

		eventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );
	} );
} );

apiRegister( 'select.selector()', function ( selector ) {
	if ( selector === undefined ) {
		return this.context[0]._select.selector;
	}

	return this.iterator( 'table', function ( ctx ) {
		disableMouseSelection( new DataTable.Api( ctx ) );

		ctx._select.selector = selector;

		if ( ctx._select.style !== 'api' ) {
			enableMouseSelection( new DataTable.Api( ctx ) );
		}
	} );
} );



apiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {
	var api = this;

	if ( select === false ) {
		return this.deselect();
	}

	this.iterator( 'row', function ( ctx, idx ) {
		clear( ctx );

		ctx.aoData[ idx ]._select_selected = true;
		$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'select', [ 'row', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {
	var api = this;

	if ( select === false ) {
		return this.deselect();
	}

	this.iterator( 'column', function ( ctx, idx ) {
		clear( ctx );

		ctx.aoColumns[ idx ]._select_selected = true;

		var column = new DataTable.Api( ctx ).column( idx );

		$( column.header() ).addClass( ctx._select.className );
		$( column.footer() ).addClass( ctx._select.className );

		column.nodes().to$().addClass( ctx._select.className );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'select', [ 'column', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {
	var api = this;

	if ( select === false ) {
		return this.deselect();
	}

	this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
		clear( ctx );

		var data = ctx.aoData[ rowIdx ];

		if ( data._selected_cells === undefined ) {
			data._selected_cells = [];
		}

		data._selected_cells[ colIdx ] = true;

		if ( data.anCells ) {
			$( data.anCells[ colIdx ] ).addClass( ctx._select.className );
		}
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'select', [ 'cell', api.cells(api[i]).indexes().toArray() ], true );
	} );

	return this;
} );


apiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {
	var api = this;

	this.iterator( 'row', function ( ctx, idx ) {
		ctx.aoData[ idx ]._select_selected = false;
		ctx._select_lastCell = null;
		$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'deselect', [ 'row', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {
	var api = this;

	this.iterator( 'column', function ( ctx, idx ) {
		ctx.aoColumns[ idx ]._select_selected = false;

		var api = new DataTable.Api( ctx );
		var column = api.column( idx );

		$( column.header() ).removeClass( ctx._select.className );
		$( column.footer() ).removeClass( ctx._select.className );

		// Need to loop over each cell, rather than just using
		// `column().nodes()` as cells which are individually selected should
		// not have the `selected` class removed from them
		api.cells( null, idx ).indexes().each( function (cellIdx) {
			var data = ctx.aoData[ cellIdx.row ];
			var cellSelected = data._selected_cells;

			if ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {
				$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );
			}
		} );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'deselect', [ 'column', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {
	var api = this;

	this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
		var data = ctx.aoData[ rowIdx ];

		data._selected_cells[ colIdx ] = false;

		// Remove class only if the cells exist, and the cell is not column
		// selected, in which case the class should remain (since it is selected
		// in the column)
		if ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {
			$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );
		}
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'deselect', [ 'cell', api[i] ], true );
	} );

	return this;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Buttons
 */
function i18n( label, def ) {
	return function (dt) {
		return dt.i18n( 'buttons.'+label, def );
	};
}

// Common events with suitable namespaces
function namespacedEvents ( config ) {
	var unique = config._eventNamespace;

	return 'draw.dt.DT'+unique+' select.dt.DT'+unique+' deselect.dt.DT'+unique;
}

function enabled ( dt, config ) {
	if ( $.inArray( 'rows', config.limitTo ) !== -1 && dt.rows( { selected: true } ).any() ) {
		return true;
	}

	if ( $.inArray( 'columns', config.limitTo ) !== -1 && dt.columns( { selected: true } ).any() ) {
		return true;
	}

	if ( $.inArray( 'cells', config.limitTo ) !== -1 && dt.cells( { selected: true } ).any() ) {
		return true;
	}

	return false;
}

var _buttonNamespace = 0;

$.extend( DataTable.ext.buttons, {
	selected: {
		text: i18n( 'selected', 'Selected' ),
		className: 'buttons-selected',
		limitTo: [ 'rows', 'columns', 'cells' ],
		init: function ( dt, node, config ) {
			var that = this;
			config._eventNamespace = '.select'+(_buttonNamespace++);

			// .DT namespace listeners are removed by DataTables automatically
			// on table destroy
			dt.on( namespacedEvents(config), function () {
				that.enable( enabled(dt, config) );
			} );

			this.disable();
		},
		destroy: function ( dt, node, config ) {
			dt.off( config._eventNamespace );
		}
	},
	selectedSingle: {
		text: i18n( 'selectedSingle', 'Selected single' ),
		className: 'buttons-selected-single',
		init: function ( dt, node, config ) {
			var that = this;
			config._eventNamespace = '.select'+(_buttonNamespace++);

			dt.on( namespacedEvents(config), function () {
				var count = dt.rows( { selected: true } ).flatten().length +
				            dt.columns( { selected: true } ).flatten().length +
				            dt.cells( { selected: true } ).flatten().length;

				that.enable( count === 1 );
			} );

			this.disable();
		},
		destroy: function ( dt, node, config ) {
			dt.off( config._eventNamespace );
		}
	},
	selectAll: {
		text: i18n( 'selectAll', 'Select all' ),
		className: 'buttons-select-all',
		action: function () {
			var items = this.select.items();
			this[ items+'s' ]().select();
		}
	},
	selectNone: {
		text: i18n( 'selectNone', 'Deselect all' ),
		className: 'buttons-select-none',
		action: function () {
			clear( this.settings()[0], true );
		},
		init: function ( dt, node, config ) {
			var that = this;
			config._eventNamespace = '.select'+(_buttonNamespace++);

			dt.on( namespacedEvents(config), function () {
				var count = dt.rows( { selected: true } ).flatten().length +
				            dt.columns( { selected: true } ).flatten().length +
				            dt.cells( { selected: true } ).flatten().length;

				that.enable( count > 0 );
			} );

			this.disable();
		},
		destroy: function ( dt, node, config ) {
			dt.off( config._eventNamespace );
		}
	}
} );

$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {
	var lc = item.toLowerCase();

	DataTable.ext.buttons[ 'select'+item+'s' ] = {
		text: i18n( 'select'+item+'s', 'Select '+lc+'s' ),
		className: 'buttons-select-'+lc+'s',
		action: function () {
			this.select.items( lc );
		},
		init: function ( dt ) {
			var that = this;

			dt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {
				that.active( items === lc );
			} );
		}
	};
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Initialisation
 */

// DataTables creation - check if select has been defined in the options. Note
// this required that the table be in the document! If it isn't then something
// needs to trigger this method unfortunately. The next major release of
// DataTables will rework the events and address this.
$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	DataTable.select.init( new DataTable.Api( ctx ) );
} );


return DataTable.select;
}));


/***/ }),

/***/ "./node_modules/datatables.net/js/jquery.dataTables.js":
/*!*************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.11.3
 * Â©2008-2021 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.11.3
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2021 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function( factory ) {
	"use strict";

	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {}
}
(function( $, window, document, undefined ) {
	"use strict";

	/**
	 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	 * flexible tool, based upon the foundations of progressive enhancement,
	 * which will add advanced interaction controls to any HTML table. For a
	 * full list of features please refer to
	 * [DataTables.net](href="http://datatables.net).
	 *
	 * Note that the `DataTable` object is not a global variable but is aliased
	 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
	 * be  accessed.
	 *
	 *  @class
	 *  @param {object} [init={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.7+
	 *
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
	 *
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "paginate": false,
	 *        "sort": false
	 *      } );
	 *    } );
	 */
	var DataTable = function ( selector, options )
	{
		// When creating with `new`, create a new DataTable, returning the API instance
		if (this instanceof DataTable) {
			return $(selector).DataTable(options);
		}
		else {
			// Argument switching
			options = selector;
		}

		/**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
		this.$ = function ( sSelector, oOpts )
		{
			return this.api(true).$( sSelector, oOpts );
		};
		
		
		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
		 *    entry in the array.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"search": "applied"});
		 *
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the search" );
		 *    } );
		 */
		this._ = function ( sSelector, oOpts )
		{
			return this.api(true).rows( sSelector, oOpts ).data();
		};
		
		
		/**
		 * Create a DataTables Api instance, with the currently selected tables for
		 * the Api's context.
		 * @param {boolean} [traditional=false] Set the API instance's context to be
		 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
		 *   or if all tables captured in the jQuery object should be used.
		 * @return {DataTables.Api}
		 */
		this.api = function ( traditional )
		{
			return traditional ?
				new _Api(
					_fnSettingsFromNode( this[ _ext.iApiIndex ] )
				) :
				new _Api( this );
		};
		
		
		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} data The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mData</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
		 *    </ul>
		 *  @param {bool} [redraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
		 *    the table.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function( data, redraw )
		{
			var api = this.api( true );
		
			/* Check if we want to add multiple rows or not */
			var rows = Array.isArray(data) && ( Array.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
				api.rows.add( data ) :
				api.row.add( data );
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return rows.flatten().toArray();
		};
		
		
		/**
		 * This function will make DataTables recalculate the column sizes, based on the data
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
		 * through the sWidth parameter). This can be useful when the width of the table's
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *
		 *      $(window).on('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			var api = this.api( true ).columns.adjust();
			var settings = api.settings()[0];
			var scroll = settings.oScroll;
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw( false );
			}
			else if ( scroll.sX !== "" || scroll.sY !== "" ) {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				_fnScrollDraw( settings );
			}
		};
		
		
		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function( bRedraw )
		{
			var api = this.api( true ).clear();
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
		};
		
		
		/**
		 * The exact opposite of 'opening' a row, this function will close any rows which
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnClose = function( nTr )
		{
			this.api( true ).row( nTr ).child.hide();
		};
		
		
		/**
		 * Remove a row for the table
		 *  @param {mixed} target The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [callBack] Callback function
		 *  @param {bool} [redraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function( target, callback, redraw )
		{
			var api = this.api( true );
			var rows = api.rows( target );
			var settings = rows.settings()[0];
			var data = settings.aoData[ rows[0][0] ];
		
			rows.remove();
		
			if ( callback ) {
				callback.call( this, settings, data );
			}
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return data;
		};
		
		
		/**
		 * Restore the table to it's original state in the DOM by removing all of DataTables
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [remove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function ( remove )
		{
			this.api( true ).destroy( remove );
		};
		
		
		/**
		 * Redraw the table
		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function( complete )
		{
			// Note that this isn't an exact match to the old call to _fnDraw - it takes
			// into account the new data, but can hold position.
			this.api( true ).draw( complete );
		};
		
		
		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
		{
			var api = this.api( true );
		
			if ( iColumn === null || iColumn === undefined ) {
				api.search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
			else {
				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
		
			api.draw();
		};
		
		
		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the
		 * provided parameters.
		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [col] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function( src, col )
		{
			var api = this.api( true );
		
			if ( src !== undefined ) {
				var type = src.nodeName ? src.nodeName.toLowerCase() : '';
		
				return col !== undefined || type == 'td' || type == 'th' ?
					api.cell( src, col ).data() :
					api.row( src ).data() || null;
			}
		
			return api.data().toArray();
		};
		
		
		/**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will
		 * typically want to use the '$' API method in preference to this as it is more
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function( iRow )
		{
			var api = this.api( true );
		
			return iRow !== undefined ?
				api.row( iRow ).node() :
				api.rows().nodes().flatten().toArray();
		};
		
		
		/**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} node this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible),
		 *    column index (all)] is given.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnGetPosition = function( node )
		{
			var api = this.api( true );
			var nodeName = node.nodeName.toUpperCase();
		
			if ( nodeName == 'TR' ) {
				return api.row( node ).index();
			}
			else if ( nodeName == 'TD' || nodeName == 'TH' ) {
				var cell = api.cell( node ).index();
		
				return [
					cell.row,
					cell.columnVisible,
					cell.column
				];
			}
			return null;
		};
		
		
		/**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnIsOpen = function( nTr )
		{
			return this.api( true ).row( nTr ).child.isShown();
		};
		
		
		/**
		 * This function will place a new row directly after a row which is currently
		 * on display on the page, with the HTML contents that is passed into the
		 * function. This can be used, for example, to ask for confirmation that a
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnOpen = function( nTr, mHtml, sClass )
		{
			return this.api( true )
				.row( nTr )
				.child( mHtml, sClass )
				.show()
				.child()[0];
		};
		
		
		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API
		 * function. With this function you can have a DataTables table go to the next,
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
		this.fnPageChange = function ( mAction, bRedraw )
		{
			var api = this.api( true ).page( mAction );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw(false);
			}
		};
		
		
		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var api = this.api( true ).column( iCol ).visible( bShow );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.columns.adjust().draw();
			}
		};
		
		
		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function()
		{
			return _fnSettingsFromNode( this[_ext.iApiIndex] );
		};
		
		
		/**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
		this.fnSort = function( aaSort )
		{
			this.api( true ).order( aaSort ).draw();
		};
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			this.api( true ).order.listener( nNode, iColumn, fnCallback );
		};
		
		
		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update, give as null or undefined to
		 *    update a whole row.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
		 *    } );
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var api = this.api( true );
		
			if ( iColumn === undefined || iColumn === null ) {
				api.row( mRow ).data( mData );
			}
			else {
				api.cell( mRow, iColumn ).data( mData );
			}
		
			if ( bAction === undefined || bAction ) {
				api.columns.adjust();
			}
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
			return 0;
		};
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		this.fnVersionCheck = _ext.fnVersionCheck;
		

		var _that = this;
		var emptyInit = options === undefined;
		var len = this.length;

		if ( emptyInit ) {
			options = {};
		}

		this.oApi = this.internal = _ext.internal;

		// Extend with old style plug-in API methods
		for ( var fn in DataTable.ext.internal ) {
			if ( fn ) {
				this[fn] = _fnExternApiFunc(fn);
			}
		}

		this.each(function() {
			// For each initialisation we want to give it a clean initialisation
			// object that can be bashed around
			var o = {};
			var oInit = len > 1 ? // optimisation for single table case
				_fnExtend( o, options, true ) :
				options;

			/*global oInit,_that,emptyInit*/
			var i=0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute( 'id' );
			var bInitHandedOff = false;
			var defaults = DataTable.defaults;
			var $this = $(this);
			
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != 'table' )
			{
				_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
				return;
			}
			
			/* Backwards compatibility for the defaults */
			_fnCompatOpts( defaults );
			_fnCompatCols( defaults.column );
			
			/* Convert the camel-case defaults to Hungarian */
			_fnCamelToHungarian( defaults, defaults, true );
			_fnCamelToHungarian( defaults.column, defaults.column, true );
			
			/* Setting up the initialisation object */
			_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );
			
			
			
			/* Check to see if we are re-initialising a table */
			var allSettings = DataTable.settings;
			for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
			{
				var s = allSettings[i];
			
				/* Base check on table node */
				if (
					s.nTable == this ||
					(s.nTHead && s.nTHead.parentNode == this) ||
					(s.nTFoot && s.nTFoot.parentNode == this)
				) {
					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
			
					if ( emptyInit || bRetrieve )
					{
						return s.oInstance;
					}
					else if ( bDestroy )
					{
						s.oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
						return;
					}
				}
			
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( s.sTableId == this.id )
				{
					allSettings.splice( i, 1 );
					break;
				}
			}
			
			/* Ensure the table has an ID - required for accessibility */
			if ( sId === null || sId === "" )
			{
				sId = "DataTables_Table_"+(DataTable.ext._unique++);
				this.id = sId;
			}
			
			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
				"sDestroyWidth": $this[0].style.width,
				"sInstance":     sId,
				"sTableId":      sId
			} );
			oSettings.nTable = this;
			oSettings.oApi   = _that.internal;
			oSettings.oInit  = oInit;
			
			allSettings.push( oSettings );
			
			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
			
			// Backwards compatibility, before we apply all the defaults
			_fnCompatOpts( oInit );
			_fnLanguageCompat( oInit.oLanguage );
			
			// If the length menu is given, but the init display length is not, use the length menu
			if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
			{
				oInit.iDisplayLength = Array.isArray( oInit.aLengthMenu[0] ) ?
					oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
			}
			
			// Apply the defaults and init options to make a single init object will all
			// options defined from defaults and instance options.
			oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
			
			
			// Map the initialisation options onto the settings object
			_fnMap( oSettings.oFeatures, oInit, [
				"bPaginate",
				"bLengthChange",
				"bFilter",
				"bSort",
				"bSortMulti",
				"bInfo",
				"bProcessing",
				"bAutoWidth",
				"bSortClasses",
				"bServerSide",
				"bDeferRender"
			] );
			_fnMap( oSettings, oInit, [
				"asStripeClasses",
				"ajax",
				"fnServerData",
				"fnFormatNumber",
				"sServerMethod",
				"aaSorting",
				"aaSortingFixed",
				"aLengthMenu",
				"sPaginationType",
				"sAjaxSource",
				"sAjaxDataProp",
				"iStateDuration",
				"sDom",
				"bSortCellsTop",
				"iTabIndex",
				"fnStateLoadCallback",
				"fnStateSaveCallback",
				"renderer",
				"searchDelay",
				"rowId",
				[ "iCookieDuration", "iStateDuration" ], // backwards compat
				[ "oSearch", "oPreviousSearch" ],
				[ "aoSearchCols", "aoPreSearchCols" ],
				[ "iDisplayLength", "_iDisplayLength" ]
			] );
			_fnMap( oSettings.oScroll, oInit, [
				[ "sScrollX", "sX" ],
				[ "sScrollXInner", "sXInner" ],
				[ "sScrollY", "sY" ],
				[ "bScrollCollapse", "bCollapse" ]
			] );
			_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
			
			/* Callback functions which are array driven */
			_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
			_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
			_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
			_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
			_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
			
			oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
			
			/* Browser support detection */
			_fnBrowserDetect( oSettings );
			
			var oClasses = oSettings.oClasses;
			
			$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
			$this.addClass( oClasses.sTable );
			
			
			if ( oSettings.iInitDisplayStart === undefined )
			{
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			if ( oInit.iDeferLoading !== null )
			{
				oSettings.bDeferLoading = true;
				var tmp = Array.isArray( oInit.iDeferLoading );
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}
			
			/* Language definitions */
			var oLanguage = oSettings.oLanguage;
			$.extend( true, oLanguage, oInit.oLanguage );
			
			if ( oLanguage.sUrl )
			{
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				$.ajax( {
					dataType: 'json',
					url: oLanguage.sUrl,
					success: function ( json ) {
						_fnCamelToHungarian( defaults.oLanguage, json );
						_fnLanguageCompat( json );
						$.extend( true, oLanguage, json );
			
						_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);
						_fnInitialise( oSettings );
					},
					error: function () {
						// Error occurred loading language file, continue on as best we can
						_fnInitialise( oSettings );
					}
				} );
				bInitHandedOff = true;
			}
			else {
				_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);
			}
			
			/*
			 * Stripes
			 */
			if ( oInit.asStripeClasses === null )
			{
				oSettings.asStripeClasses =[
					oClasses.sStripeOdd,
					oClasses.sStripeEven
				];
			}
			
			/* Remove row stripe classes if they are already on the table row */
			var stripeClasses = oSettings.asStripeClasses;
			var rowOne = $this.children('tbody').find('tr').eq(0);
			if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
				return rowOne.hasClass(el);
			} ) ) !== -1 ) {
				$('tbody tr', this).removeClass( stripeClasses.join(' ') );
				oSettings.asDestroyStripes = stripeClasses.slice();
			}
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if ( nThead.length !== 0 )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[0] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			
			/* If not given a column array, generate one with nulls */
			if ( oInit.aoColumns === null )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
			{
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Apply the column definitions */
			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			
			/* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
			if ( rowOne.length ) {
				var a = function ( cell, name ) {
					return cell.getAttribute( 'data-'+name ) !== null ? name : null;
				};
			
				$( rowOne[0] ).children('th, td').each( function (i, cell) {
					var col = oSettings.aoColumns[i];
			
					if ( col.mData === i ) {
						var sort = a( cell, 'sort' ) || a( cell, 'order' );
						var filter = a( cell, 'filter' ) || a( cell, 'search' );
			
						if ( sort !== null || filter !== null ) {
							col.mData = {
								_:      i+'.display',
								sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
								type:   sort !== null   ? i+'.@data-'+sort   : undefined,
								filter: filter !== null ? i+'.@data-'+filter : undefined
							};
			
							_fnColumnOptions( oSettings, i );
						}
					}
				} );
			}
			
			var features = oSettings.oFeatures;
			var loadedInit = function () {
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
			
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined ) {
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
			
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
			
				if ( features.bSort ) {
					_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
			
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
			
							_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
			
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, 'sc' );
			
			
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
			
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each( function () {
					this._captionSide = $(this).css('caption-side');
				} );
			
				var thead = $this.children('thead');
				if ( thead.length === 0 ) {
					thead = $('<thead/>').appendTo($this);
				}
				oSettings.nTHead = thead[0];
			
				var tbody = $this.children('tbody');
				if ( tbody.length === 0 ) {
					tbody = $('<tbody/>').insertAfter(thead);
				}
				oSettings.nTBody = tbody[0];
			
				var tfoot = $this.children('tfoot');
				if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") ) {
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo($this);
				}
			
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length > 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
			
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData ) {
					for ( i=0 ; i<oInit.aaData.length ; i++ ) {
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' ) {
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
				}
			
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
			
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false ) {
					_fnInitialise( oSettings );
				}
			};
			
			/* Must be done after everything which can be overridden by the state saving! */
			_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
			
			if ( oInit.bStateSave )
			{
				features.bStateSave = true;
				_fnLoadState( oSettings, oInit, loadedInit );
			}
			else {
				loadedInit();
			}
			
		} );
		_that = null;
		return this;
	};

	
	/*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don't leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
	
	
	// Defined else where
	//  _selector_run
	//  _selector_opts
	//  _selector_first
	//  _selector_row_indexes
	
	var _ext; // DataTable.ext
	var _Api; // DataTable.Api
	var _api_register; // DataTable.Api.register
	var _api_registerPlural; // DataTable.Api.registerPlural
	
	var _re_dic = {};
	var _re_new_lines = /[\r\n\u2028]/g;
	var _re_html = /<.*?>/g;
	
	// This is not strict ISO8601 - Date.parse() is quite lax, although
	// implementations differ between browsers.
	var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
	
	// Escape regular expression special characters
	var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
	
	// http://en.wikipedia.org/wiki/Foreign_exchange_market
	// - \u20BD - Russian ruble.
	// - \u20a9 - South Korean Won
	// - \u20BA - Turkish Lira
	// - \u20B9 - Indian Rupee
	// - R - Brazil (R$) and South Africa
	// - fr - Swiss Franc
	// - kr - Swedish krona, Norwegian krone and Danish krone
	// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	// - É - Bitcoin
	// - Î - Ethereum
	//   standards as thousands separators.
	var _re_formatted_numeric = /['\u00A0,$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfkÉÎ]/gi;
	
	
	var _empty = function ( d ) {
		return !d || d === true || d === '-' ? true : false;
	};
	
	
	var _intVal = function ( s ) {
		var integer = parseInt( s, 10 );
		return !isNaN(integer) && isFinite(s) ? integer : null;
	};
	
	// Convert from a formatted number with characters other than `.` as the
	// decimal place, to a Javascript number
	var _numToDecimal = function ( num, decimalPoint ) {
		// Cache created regular expressions for speed as this function is called often
		if ( ! _re_dic[ decimalPoint ] ) {
			_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
		}
		return typeof num === 'string' && decimalPoint !== '.' ?
			num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
			num;
	};
	
	
	var _isNumber = function ( d, decimalPoint, formatted ) {
		var strType = typeof d === 'string';
	
		// If empty return immediately so there must be a number if it is a
		// formatted string (this stops the string "k", or "kr", etc being detected
		// as a formatted number for currency
		if ( _empty( d ) ) {
			return true;
		}
	
		if ( decimalPoint && strType ) {
			d = _numToDecimal( d, decimalPoint );
		}
	
		if ( formatted && strType ) {
			d = d.replace( _re_formatted_numeric, '' );
		}
	
		return !isNaN( parseFloat(d) ) && isFinite( d );
	};
	
	
	// A string without HTML in it can be considered to be HTML still
	var _isHtml = function ( d ) {
		return _empty( d ) || typeof d === 'string';
	};
	
	
	var _htmlNumeric = function ( d, decimalPoint, formatted ) {
		if ( _empty( d ) ) {
			return true;
		}
	
		var html = _isHtml( d );
		return ! html ?
			null :
			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
				true :
				null;
	};
	
	
	var _pluck = function ( a, prop, prop2 ) {
		var out = [];
		var i=0, ien=a.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[i] && a[i][ prop ] ) {
					out.push( a[i][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				if ( a[i] ) {
					out.push( a[i][ prop ] );
				}
			}
		}
	
		return out;
	};
	
	
	// Basically the same as _pluck, but rather than looping over `a` we use `order`
	// as the indexes to pick from `a`
	var _pluck_order = function ( a, order, prop, prop2 )
	{
		var out = [];
		var i=0, ien=order.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i<ien ; i++ ) {
				if ( a[ order[i] ][ prop ] ) {
					out.push( a[ order[i] ][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i<ien ; i++ ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	
		return out;
	};
	
	
	var _range = function ( len, start )
	{
		var out = [];
		var end;
	
		if ( start === undefined ) {
			start = 0;
			end = len;
		}
		else {
			end = start;
			start = len;
		}
	
		for ( var i=start ; i<end ; i++ ) {
			out.push( i );
		}
	
		return out;
	};
	
	
	var _removeEmpty = function ( a )
	{
		var out = [];
	
		for ( var i=0, ien=a.length ; i<ien ; i++ ) {
			if ( a[i] ) { // careful - will remove all falsy values!
				out.push( a[i] );
			}
		}
	
		return out;
	};
	
	
	var _stripHtml = function ( d ) {
		return d.replace( _re_html, '' );
	};
	
	
	/**
	 * Determine if all values in the array are unique. This means we can short
	 * cut the _unique method at the cost of a single loop. A sorted array is used
	 * to easily check the values.
	 *
	 * @param  {array} src Source array
	 * @return {boolean} true if all unique, false otherwise
	 * @ignore
	 */
	var _areAllUnique = function ( src ) {
		if ( src.length < 2 ) {
			return true;
		}
	
		var sorted = src.slice().sort();
		var last = sorted[0];
	
		for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
			if ( sorted[i] === last ) {
				return false;
			}
	
			last = sorted[i];
		}
	
		return true;
	};
	
	
	/**
	 * Find the unique elements in a source array.
	 *
	 * @param  {array} src Source array
	 * @return {array} Array of unique items
	 * @ignore
	 */
	var _unique = function ( src )
	{
		if ( _areAllUnique( src ) ) {
			return src.slice();
		}
	
		// A faster unique method is to use object keys to identify used values,
		// but this doesn't work with arrays or objects, which we must also
		// consider. See jsperf.com/compare-array-unique-versions/4 for more
		// information.
		var
			out = [],
			val,
			i, ien=src.length,
			j, k=0;
	
		again: for ( i=0 ; i<ien ; i++ ) {
			val = src[i];
	
			for ( j=0 ; j<k ; j++ ) {
				if ( out[j] === val ) {
					continue again;
				}
			}
	
			out.push( val );
			k++;
		}
	
		return out;
	};
	
	// Surprisingly this is faster than [].concat.apply
	// https://jsperf.com/flatten-an-array-loop-vs-reduce/2
	var _flatten = function (out, val) {
		if (Array.isArray(val)) {
			for (var i=0 ; i<val.length ; i++) {
				_flatten(out, val[i]);
			}
		}
		else {
			out.push(val);
		}
	  
		return out;
	}
	
	var _includes = function (search, start) {
		if (start === undefined) {
			start = 0;
		}
	
		return this.indexOf(search, start) !== -1;	
	};
	
	// Array.isArray polyfill.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
	if (! Array.isArray) {
	    Array.isArray = function(arg) {
	        return Object.prototype.toString.call(arg) === '[object Array]';
	    };
	}
	
	if (! Array.prototype.includes) {
		Array.prototype.includes = _includes;
	}
	
	// .trim() polyfill
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim
	if (!String.prototype.trim) {
	  String.prototype.trim = function () {
	    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	  };
	}
	
	if (! String.prototype.includes) {
		String.prototype.includes = _includes;
	}
	
	/**
	 * DataTables utility methods
	 * 
	 * This namespace provides helper methods that DataTables uses internally to
	 * create a DataTable, but which are not exclusively used only for DataTables.
	 * These methods can be used by extension authors to save the duplication of
	 * code.
	 *
	 *  @namespace
	 */
	DataTable.util = {
		/**
		 * Throttle the calls to a function. Arguments and context are maintained
		 * for the throttled function.
		 *
		 * @param {function} fn Function to be called
		 * @param {integer} freq Call frequency in mS
		 * @return {function} Wrapped function
		 */
		throttle: function ( fn, freq ) {
			var
				frequency = freq !== undefined ? freq : 200,
				last,
				timer;
	
			return function () {
				var
					that = this,
					now  = +new Date(),
					args = arguments;
	
				if ( last && now < last + frequency ) {
					clearTimeout( timer );
	
					timer = setTimeout( function () {
						last = undefined;
						fn.apply( that, args );
					}, frequency );
				}
				else {
					last = now;
					fn.apply( that, args );
				}
			};
		},
	
	
		/**
		 * Escape a string such that it can be used in a regular expression
		 *
		 *  @param {string} val string to escape
		 *  @returns {string} escaped string
		 */
		escapeRegex: function ( val ) {
			return val.replace( _re_escape_regex, '\\$1' );
		},
	
		/**
		 * Create a function that will write to a nested object or array
		 * @param {*} source JSON notation string
		 * @returns Write function
		 */
		set: function ( source ) {
			if ( $.isPlainObject( source ) ) {
				/* Unlike get, only the underscore (global) option is used for for
				 * setting data since we don't know the type here. This is why an object
				 * option is not documented for `mData` (which is read/write), but it is
				 * for `mRender` which is read only.
				 */
				return DataTable.util.set( source._ );
			}
			else if ( source === null ) {
				// Nothing to do when the data source is null
				return function () {};
			}
			else if ( typeof source === 'function' ) {
				return function (data, val, meta) {
					source( data, 'set', val, meta );
				};
			}
			else if ( typeof source === 'string' && (source.indexOf('.') !== -1 ||
					  source.indexOf('[') !== -1 || source.indexOf('(') !== -1) )
			{
				// Like the get, we need to get data from a nested object
				var setData = function (data, val, src) {
					var a = _fnSplitObjNotation( src ), b;
					var aLast = a[a.length-1];
					var arrayNotation, funcNotation, o, innerSrc;
		
					for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ ) {
						// Protect against prototype pollution
						if (a[i] === '__proto__' || a[i] === 'constructor') {
							throw new Error('Cannot set prototype values');
						}
		
						// Check if we are dealing with an array notation request
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
		
						if ( arrayNotation ) {
							a[i] = a[i].replace(__reArray, '');
							data[ a[i] ] = [];
		
							// Get the remainder of the nested object to set so we can recurse
							b = a.slice();
							b.splice( 0, i+1 );
							innerSrc = b.join('.');
		
							// Traverse each entry in the array setting the properties requested
							if ( Array.isArray( val ) ) {
								for ( var j=0, jLen=val.length ; j<jLen ; j++ ) {
									o = {};
									setData( o, val[j], innerSrc );
									data[ a[i] ].push( o );
								}
							}
							else {
								// We've been asked to save data to an array, but it
								// isn't array data to be saved. Best that can be done
								// is to just save the value.
								data[ a[i] ] = val;
							}
		
							// The inner call to setData has already traversed through the remainder
							// of the source and has set the data, thus we can exit here
							return;
						}
						else if ( funcNotation ) {
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]( val );
						}
		
						// If the nested object doesn't currently exist - since we are
						// trying to set the value - create it
						if ( data[ a[i] ] === null || data[ a[i] ] === undefined ) {
							data[ a[i] ] = {};
						}
						data = data[ a[i] ];
					}
		
					// Last item in the input - i.e, the actual set
					if ( aLast.match(__reFn ) ) {
						// Function call
						data = data[ aLast.replace(__reFn, '') ]( val );
					}
					else {
						// If array notation is used, we just want to strip it and use the property name
						// and assign the value. If it isn't used, then we get the result we want anyway
						data[ aLast.replace(__reArray, '') ] = val;
					}
				};
		
				return function (data, val) { // meta is also passed in, but not used
					return setData( data, val, source );
				};
			}
			else {
				// Array or flat object mapping
				return function (data, val) { // meta is also passed in, but not used
					data[source] = val;
				};
			}
		},
	
		/**
		 * Create a function that will read nested objects from arrays, based on JSON notation
		 * @param {*} source JSON notation string
		 * @returns Value read
		 */
		get: function ( source ) {
			if ( $.isPlainObject( source ) ) {
				// Build an object of get functions, and wrap them in a single call
				var o = {};
				$.each( source, function (key, val) {
					if ( val ) {
						o[key] = DataTable.util.get( val );
					}
				} );
		
				return function (data, type, row, meta) {
					var t = o[type] || o._;
					return t !== undefined ?
						t(data, type, row, meta) :
						data;
				};
			}
			else if ( source === null ) {
				// Give an empty string for rendering / sorting etc
				return function (data) { // type, row and meta also passed, but not used
					return data;
				};
			}
			else if ( typeof source === 'function' ) {
				return function (data, type, row, meta) {
					return source( data, type, row, meta );
				};
			}
			else if ( typeof source === 'string' && (source.indexOf('.') !== -1 ||
					  source.indexOf('[') !== -1 || source.indexOf('(') !== -1) )
			{
				/* If there is a . in the source string then the data source is in a
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediately
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var fetchData = function (data, type, src) {
					var arrayNotation, funcNotation, out, innerSrc;
		
					if ( src !== "" ) {
						var a = _fnSplitObjNotation( src );
		
						for ( var i=0, iLen=a.length ; i<iLen ; i++ ) {
							// Check if we are dealing with special notation
							arrayNotation = a[i].match(__reArray);
							funcNotation = a[i].match(__reFn);
		
							if ( arrayNotation ) {
								// Array notation
								a[i] = a[i].replace(__reArray, '');
		
								// Condition allows simply [] to be passed in
								if ( a[i] !== "" ) {
									data = data[ a[i] ];
								}
								out = [];
		
								// Get the remainder of the nested object to get
								a.splice( 0, i+1 );
								innerSrc = a.join('.');
		
								// Traverse each entry in the array getting the properties requested
								if ( Array.isArray( data ) ) {
									for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
										out.push( fetchData( data[j], type, innerSrc ) );
									}
								}
		
								// If a string is given in between the array notation indicators, that
								// is used to join the strings together, otherwise an array is returned
								var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
								data = (join==="") ? out : out.join(join);
		
								// The inner call to fetchData has already traversed through the remainder
								// of the source requested, so we exit from the loop
								break;
							}
							else if ( funcNotation ) {
								// Function call
								a[i] = a[i].replace(__reFn, '');
								data = data[ a[i] ]();
								continue;
							}
		
							if ( data === null || data[ a[i] ] === undefined ) {
								return undefined;
							}
	
							data = data[ a[i] ];
						}
					}
		
					return data;
				};
		
				return function (data, type) { // row and meta also passed, but not used
					return fetchData( data, type, source );
				};
			}
			else {
				// Array or flat object mapping
				return function (data, type) { // row and meta also passed, but not used
					return data[source];
				};
			}
		}
	};
	
	
	
	/**
	 * Create a mapping object that allows camel case parameters to be looked up
	 * for their Hungarian counterparts. The mapping is stored in a private
	 * parameter called `_hungarianMap` which can be accessed on the source object.
	 *  @param {object} o
	 *  @memberof DataTable#oApi
	 */
	function _fnHungarianMap ( o )
	{
		var
			hungarian = 'a aa ai ao as b fn i m o s ',
			match,
			newKey,
			map = {};
	
		$.each( o, function (key, val) {
			match = key.match(/^([^A-Z]+?)([A-Z])/);
	
			if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
			{
				newKey = key.replace( match[0], match[2].toLowerCase() );
				map[ newKey ] = key;
	
				if ( match[1] === 'o' )
				{
					_fnHungarianMap( o[key] );
				}
			}
		} );
	
		o._hungarianMap = map;
	}
	
	
	/**
	 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	 * created by _fnHungarianMap.
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 *  @memberof DataTable#oApi
	 */
	function _fnCamelToHungarian ( src, user, force )
	{
		if ( ! src._hungarianMap ) {
			_fnHungarianMap( src );
		}
	
		var hungarianKey;
	
		$.each( user, function (key, val) {
			hungarianKey = src._hungarianMap[ key ];
	
			if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
			{
				// For objects, we need to buzz down into the object to copy parameters
				if ( hungarianKey.charAt(0) === 'o' )
				{
					// Copy the camelCase options over to the hungarian
					if ( ! user[ hungarianKey ] ) {
						user[ hungarianKey ] = {};
					}
					$.extend( true, user[hungarianKey], user[key] );
	
					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
				}
				else {
					user[hungarianKey] = user[ key ];
				}
			}
		} );
	}
	
	
	/**
	 * Language compatibility - when certain options are given, and others aren't, we
	 * need to duplicate the values over, in order to provide backwards compatibility
	 * with older language files.
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnLanguageCompat( lang )
	{
		// Note the use of the Hungarian notation for the parameters in this method as
		// this is called after the mapping of camelCase to Hungarian
		var defaults = DataTable.defaults.oLanguage;
	
		// Default mapping
		var defaultDecimal = defaults.sDecimal;
		if ( defaultDecimal ) {
			_addNumericSort( defaultDecimal );
		}
	
		if ( lang ) {
			var zeroRecords = lang.sZeroRecords;
	
			// Backwards compatibility - if there is no sEmptyTable given, then use the same as
			// sZeroRecords - assuming that is given.
			if ( ! lang.sEmptyTable && zeroRecords &&
				defaults.sEmptyTable === "No data available in table" )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
			}
	
			// Likewise with loading records
			if ( ! lang.sLoadingRecords && zeroRecords &&
				defaults.sLoadingRecords === "Loading..." )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
			}
	
			// Old parameter name of the thousands separator mapped onto the new
			if ( lang.sInfoThousands ) {
				lang.sThousands = lang.sInfoThousands;
			}
	
			var decimal = lang.sDecimal;
			if ( decimal && defaultDecimal !== decimal ) {
				_addNumericSort( decimal );
			}
		}
	}
	
	
	/**
	 * Map one parameter onto another
	 *  @param {object} o Object to map
	 *  @param {*} knew The new parameter name
	 *  @param {*} old The old parameter name
	 */
	var _fnCompatMap = function ( o, knew, old ) {
		if ( o[ knew ] !== undefined ) {
			o[ old ] = o[ knew ];
		}
	};
	
	
	/**
	 * Provide backwards compatibility for the main DT options. Note that the new
	 * options are mapped onto the old parameters, so this is an external interface
	 * change only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatOpts ( init )
	{
		_fnCompatMap( init, 'ordering',      'bSort' );
		_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
		_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
		_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
		_fnCompatMap( init, 'order',         'aaSorting' );
		_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
		_fnCompatMap( init, 'paging',        'bPaginate' );
		_fnCompatMap( init, 'pagingType',    'sPaginationType' );
		_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
		_fnCompatMap( init, 'searching',     'bFilter' );
	
		// Boolean initialisation of x-scrolling
		if ( typeof init.sScrollX === 'boolean' ) {
			init.sScrollX = init.sScrollX ? '100%' : '';
		}
		if ( typeof init.scrollX === 'boolean' ) {
			init.scrollX = init.scrollX ? '100%' : '';
		}
	
		// Column search objects are in an array, so it needs to be converted
		// element by element
		var searchCols = init.aoSearchCols;
	
		if ( searchCols ) {
			for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
				if ( searchCols[i] ) {
					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
				}
			}
		}
	}
	
	
	/**
	 * Provide backwards compatibility for column options. Note that the new options
	 * are mapped onto the old parameters, so this is an external interface change
	 * only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatCols ( init )
	{
		_fnCompatMap( init, 'orderable',     'bSortable' );
		_fnCompatMap( init, 'orderData',     'aDataSort' );
		_fnCompatMap( init, 'orderSequence', 'asSorting' );
		_fnCompatMap( init, 'orderDataType', 'sortDataType' );
	
		// orderData can be given as an integer
		var dataSort = init.aDataSort;
		if ( typeof dataSort === 'number' && ! Array.isArray( dataSort ) ) {
			init.aDataSort = [ dataSort ];
		}
	}
	
	
	/**
	 * Browser feature detection for capabilities, quirks
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBrowserDetect( settings )
	{
		// We don't need to do this every time DataTables is constructed, the values
		// calculated are specific to the browser and OS configuration which we
		// don't expect to change between initialisations
		if ( ! DataTable.__browser ) {
			var browser = {};
			DataTable.__browser = browser;
	
			// Scrolling feature / quirks detection
			var n = $('<div/>')
				.css( {
					position: 'fixed',
					top: 0,
					left: $(window).scrollLeft()*-1, // allow for scrolling
					height: 1,
					width: 1,
					overflow: 'hidden'
				} )
				.append(
					$('<div/>')
						.css( {
							position: 'absolute',
							top: 1,
							left: 1,
							width: 100,
							overflow: 'scroll'
						} )
						.append(
							$('<div/>')
								.css( {
									width: '100%',
									height: 10
								} )
						)
				)
				.appendTo( 'body' );
	
			var outer = n.children();
			var inner = outer.children();
	
			// Numbers below, in order, are:
			// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
			//
			// IE6 XP:                           100 100 100  83
			// IE7 Vista:                        100 100 100  83
			// IE 8+ Windows:                     83  83 100  83
			// Evergreen Windows:                 83  83 100  83
			// Evergreen Mac with scrollbars:     85  85 100  85
			// Evergreen Mac without scrollbars: 100 100 100 100
	
			// Get scrollbar width
			browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
	
			// IE6/7 will oversize a width 100% element inside a scrolling element, to
			// include the width of the scrollbar, while other browsers ensure the inner
			// element is contained without forcing scrolling
			browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
	
			// In rtl text layout, some browsers (most, but not all) will place the
			// scrollbar on the left, rather than the right.
			browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
	
			// IE8- don't provide height and width for getBoundingClientRect
			browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
	
			n.remove();
		}
	
		$.extend( settings.oBrowser, DataTable.__browser );
		settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
	}
	
	
	/**
	 * Array.prototype reduce[Right] method, used for browsers which don't support
	 * JS 1.6. Done this way to reduce code size, since we iterate either way
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnReduce ( that, fn, init, start, end, inc )
	{
		var
			i = start,
			value,
			isSet = false;
	
		if ( init !== undefined ) {
			value = init;
			isSet = true;
		}
	
		while ( i !== end ) {
			if ( ! that.hasOwnProperty(i) ) {
				continue;
			}
	
			value = isSet ?
				fn( value, that[i], i, that ) :
				that[i];
	
			isSet = true;
			i += inc;
		}
	
		return value;
	}
	
	/**
	 * Add a column to the list used for the table with default values
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nTh The th element for this column
	 *  @memberof DataTable#oApi
	 */
	function _fnAddColumn( oSettings, nTh )
	{
		// Add column to aoColumns array
		var oDefaults = DataTable.defaults.column;
		var iCol = oSettings.aoColumns.length;
		var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
			"nTh": nTh ? nTh : document.createElement('th'),
			"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
			"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			"mData": oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		} );
		oSettings.aoColumns.push( oCol );
	
		// Add search object for column specific search. Note that the `searchCols[ iCol ]`
		// passed into extend can be undefined. This allows the user to give a default
		// with only some of the parameters defined, and also not give a default
		var searchCols = oSettings.aoPreSearchCols;
		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
	
		// Use the default column options function to initialise classes etc
		_fnColumnOptions( oSettings, iCol, $(nTh).data() );
	}
	
	
	/**
	 * Apply options for a column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iCol column index to consider
	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnOptions( oSettings, iCol, oOptions )
	{
		var oCol = oSettings.aoColumns[ iCol ];
		var oClasses = oSettings.oClasses;
		var th = $(oCol.nTh);
	
		// Try to get width information from the DOM. We can't get it from CSS
		// as we'd need to parse the CSS stylesheet. `width` option can override
		if ( ! oCol.sWidthOrig ) {
			// Width attribute
			oCol.sWidthOrig = th.attr('width') || null;
	
			// Style attribute
			var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
			if ( t ) {
				oCol.sWidthOrig = t[1];
			}
		}
	
		/* User specified column options */
		if ( oOptions !== undefined && oOptions !== null )
		{
			// Backwards compatibility
			_fnCompatCols( oOptions );
	
			// Map camel case parameters to their Hungarian counterparts
			_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );
	
			/* Backwards compatibility for mDataProp */
			if ( oOptions.mDataProp !== undefined && !oOptions.mData )
			{
				oOptions.mData = oOptions.mDataProp;
			}
	
			if ( oOptions.sType )
			{
				oCol._sManualType = oOptions.sType;
			}
	
			// `class` is a reserved word in Javascript, so we need to provide
			// the ability to use a valid name for the camel case input
			if ( oOptions.className && ! oOptions.sClass )
			{
				oOptions.sClass = oOptions.className;
			}
			if ( oOptions.sClass ) {
				th.addClass( oOptions.sClass );
			}
	
			$.extend( oCol, oOptions );
			_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
	
			/* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
			if ( oOptions.iDataSort !== undefined )
			{
				oCol.aDataSort = [ oOptions.iDataSort ];
			}
			_fnMap( oCol, oOptions, "aDataSort" );
		}
	
		/* Cache the data get and set functions for speed */
		var mDataSrc = oCol.mData;
		var mData = _fnGetObjectDataFn( mDataSrc );
		var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
	
		var attrTest = function( src ) {
			return typeof src === 'string' && src.indexOf('@') !== -1;
		};
		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
		);
		oCol._setter = null;
	
		oCol.fnGetData = function (rowData, type, meta) {
			var innerData = mData( rowData, type, undefined, meta );
	
			return mRender && type ?
				mRender( innerData, type, rowData, meta ) :
				innerData;
		};
		oCol.fnSetData = function ( rowData, val, meta ) {
			return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
		};
	
		// Indicate if DataTables should read DOM data as an object or array
		// Used in _fnGetRowElements
		if ( typeof mDataSrc !== 'number' ) {
			oSettings._rowReadObject = true;
		}
	
		/* Feature sorting overrides column specific when off */
		if ( !oSettings.oFeatures.bSort )
		{
			oCol.bSortable = false;
			th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
		}
	
		/* Check that the class assignment is correct for sorting */
		var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
		var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
		if ( !oCol.bSortable || (!bAsc && !bDesc) )
		{
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = "";
		}
		else if ( bAsc && !bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		}
		else if ( !bAsc && bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		}
		else
		{
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}
	
	
	/**
	 * Adjust the table column widths for new data. Note: you would probably want to
	 * do a redraw after calling this function!
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAdjustColumnSizing ( settings )
	{
		/* Not interested in doing column width calculation if auto-width is disabled */
		if ( settings.oFeatures.bAutoWidth !== false )
		{
			var columns = settings.aoColumns;
	
			_fnCalculateColumnWidths( settings );
			for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}
	
		var scroll = settings.oScroll;
		if ( scroll.sY !== '' || scroll.sX !== '')
		{
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, null, 'column-sizing', [settings] );
	}
	
	
	/**
	 * Convert the index of a visible column to the index in the data array (take account
	 * of hidden columns)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iMatch Visible column index to lookup
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnVisibleToColumnIndex( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	
		return typeof aiVis[iMatch] === 'number' ?
			aiVis[iMatch] :
			null;
	}
	
	
	/**
	 * Convert the index of an index in the data array and convert it to the visible
	 *   column index (take account of hidden columns)
	 *  @param {int} iMatch Column index to lookup
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnIndexToVisible( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		var iPos = $.inArray( iMatch, aiVis );
	
		return iPos !== -1 ? iPos : null;
	}
	
	
	/**
	 * Get the number of visible columns
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the number of visible columns
	 *  @memberof DataTable#oApi
	 */
	function _fnVisbleColumns( oSettings )
	{
		var vis = 0;
	
		// No reduce in IE8, use a loop for now
		$.each( oSettings.aoColumns, function ( i, col ) {
			if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
				vis++;
			}
		} );
	
		return vis;
	}
	
	
	/**
	 * Get an array of column indexes that match a given property
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sParam Parameter in aoColumns to look for - typically
	 *    bVisible or bSearchable
	 *  @returns {array} Array of indexes with matched properties
	 *  @memberof DataTable#oApi
	 */
	function _fnGetColumns( oSettings, sParam )
	{
		var a = [];
	
		$.map( oSettings.aoColumns, function(val, i) {
			if ( val[sParam] ) {
				a.push( i );
			}
		} );
	
		return a;
	}
	
	
	/**
	 * Calculate the 'type' of a column
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnTypes ( settings )
	{
		var columns = settings.aoColumns;
		var data = settings.aoData;
		var types = DataTable.ext.type.detect;
		var i, ien, j, jen, k, ken;
		var col, cell, detectedType, cache;
	
		// For each column, spin over the 
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			col = columns[i];
			cache = [];
	
			if ( ! col.sType && col._sManualType ) {
				col.sType = col._sManualType;
			}
			else if ( ! col.sType ) {
				for ( j=0, jen=types.length ; j<jen ; j++ ) {
					for ( k=0, ken=data.length ; k<ken ; k++ ) {
						// Use a cache array so we only need to get the type data
						// from the formatter once (when using multiple detectors)
						if ( cache[k] === undefined ) {
							cache[k] = _fnGetCellData( settings, k, i, 'type' );
						}
	
						detectedType = types[j]( cache[k], settings );
	
						// If null, then this type can't apply to this column, so
						// rather than testing all cells, break out. There is an
						// exception for the last type which is `html`. We need to
						// scan all rows since it is possible to mix string and HTML
						// types
						if ( ! detectedType && j !== types.length-1 ) {
							break;
						}
	
						// Only a single match is needed for html type since it is
						// bottom of the pile and very similar to string - but it
						// must not be empty
						if ( detectedType === 'html' && ! _empty(cache[k]) ) {
							break;
						}
					}
	
					// Type is valid for all data points in the column - use this
					// type
					if ( detectedType ) {
						col.sType = detectedType;
						break;
					}
				}
	
				// Fall back - if no type was detected, always use string
				if ( ! col.sType ) {
					col.sType = 'string';
				}
			}
		}
	}
	
	
	/**
	 * Take the column definitions and static columns arrays and calculate how
	 * they relate to column indexes. The callback function will then apply the
	 * definition found for a column to a suitable configuration object.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	 *  @param {array} aoCols The aoColumns array that defines columns individually
	 *  @param {function} fn Callback function - takes two parameters, the calculated
	 *    column index and the definition for that column.
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
	{
		var i, iLen, j, jLen, k, kLen, def;
		var columns = oSettings.aoColumns;
	
		// Column definitions with aTargets
		if ( aoColDefs )
		{
			/* Loop over the definitions array - loop in reverse so first instance has priority */
			for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
			{
				def = aoColDefs[i];
	
				/* Each definition can target multiple columns, as it is an array */
				var aTargets = def.targets !== undefined ?
					def.targets :
					def.aTargets;
	
				if ( ! Array.isArray( aTargets ) )
				{
					aTargets = [ aTargets ];
				}
	
				for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
				{
					if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
					{
						/* Add columns that we don't yet know about */
						while( columns.length <= aTargets[j] )
						{
							_fnAddColumn( oSettings );
						}
	
						/* Integer, basic index */
						fn( aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
					{
						/* Negative integer, right to left column counting */
						fn( columns.length+aTargets[j], def );
					}
					else if ( typeof aTargets[j] === 'string' )
					{
						/* Class name matching on TH element */
						for ( k=0, kLen=columns.length ; k<kLen ; k++ )
						{
							if ( aTargets[j] == "_all" ||
							     $(columns[k].nTh).hasClass( aTargets[j] ) )
							{
								fn( k, def );
							}
						}
					}
				}
			}
		}
	
		// Statically defined columns array
		if ( aoCols )
		{
			for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
			{
				fn( i, aoCols[i] );
			}
		}
	}
	
	/**
	 * Add a data array to the table, creating DOM node etc. This is the parallel to
	 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	 * DOM source.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aData data array to be added
	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	 *  @memberof DataTable#oApi
	 */
	function _fnAddData ( oSettings, aDataIn, nTr, anTds )
	{
		/* Create the object for storing information about this new row */
		var iRow = oSettings.aoData.length;
		var oData = $.extend( true, {}, DataTable.models.oRow, {
			src: nTr ? 'dom' : 'data',
			idx: iRow
		} );
	
		oData._aData = aDataIn;
		oSettings.aoData.push( oData );
	
		/* Create the cells */
		var nTd, sThisType;
		var columns = oSettings.aoColumns;
	
		// Invalidate the column types as the new data needs to be revalidated
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			columns[i].sType = null;
		}
	
		/* Add to the display array */
		oSettings.aiDisplayMaster.push( iRow );
	
		var id = oSettings.rowIdFn( aDataIn );
		if ( id !== undefined ) {
			oSettings.aIds[ id ] = oData;
		}
	
		/* Create the DOM information, or register it if already present */
		if ( nTr || ! oSettings.oFeatures.bDeferRender )
		{
			_fnCreateTr( oSettings, iRow, nTr, anTds );
		}
	
		return iRow;
	}
	
	
	/**
	 * Add one or more TR elements to the table. Generally we'd expect to
	 * use this for reading data from a DOM sourced table, but it could be
	 * used for an TR element. Note that if a TR is given, it is used (i.e.
	 * it is not cloned).
	 *  @param {object} settings dataTables settings object
	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	 *  @returns {array} Array of indexes for the added rows
	 *  @memberof DataTable#oApi
	 */
	function _fnAddTr( settings, trs )
	{
		var row;
	
		// Allow an individual node to be passed in
		if ( ! (trs instanceof $) ) {
			trs = $(trs);
		}
	
		return trs.map( function (i, el) {
			row = _fnGetRowElements( settings, el );
			return _fnAddData( settings, row.data, el, row.cells );
		} );
	}
	
	
	/**
	 * Take a TR element and convert it to an index in aoData
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n the TR element to find
	 *  @returns {int} index if the node is found, null if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToDataIndex( oSettings, n )
	{
		return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
	}
	
	
	/**
	 * Take a TD element and convert it into a column data index (not the visible index)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow The row number the TD/TH can be found in
	 *  @param {node} n The TD/TH element to find
	 *  @returns {int} index if the node is found, -1 if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToColumnIndex( oSettings, iRow, n )
	{
		return $.inArray( n, oSettings.aoData[ iRow ].anCells );
	}
	
	
	/**
	 * Get the data for a given cell from the internal cache, taking into account data mapping
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')
	 *  @returns {*} Cell data
	 *  @memberof DataTable#oApi
	 */
	function _fnGetCellData( settings, rowIdx, colIdx, type )
	{
		if (type === 'search') {
			type = 'filter';
		}
		else if (type === 'order') {
			type = 'sort';
		}
	
		var draw           = settings.iDraw;
		var col            = settings.aoColumns[colIdx];
		var rowData        = settings.aoData[rowIdx]._aData;
		var defaultContent = col.sDefaultContent;
		var cellData       = col.fnGetData( rowData, type, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		} );
	
		if ( cellData === undefined ) {
			if ( settings.iDrawError != draw && defaultContent === null ) {
				_fnLog( settings, 0, "Requested unknown parameter "+
					(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
					" for row "+rowIdx+", column "+colIdx, 4 );
				settings.iDrawError = draw;
			}
			return defaultContent;
		}
	
		// When the data source is null and a specific data type is requested (i.e.
		// not the original data), we can use default column data
		if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
			cellData = defaultContent;
		}
		else if ( typeof cellData === 'function' ) {
			// If the data source is a function, then we run it and use the return,
			// executing in the scope of the data object (for instances)
			return cellData.call( rowData );
		}
	
		if ( cellData === null && type === 'display' ) {
			return '';
		}
	
		if ( type === 'filter' ) {
			var fomatters = DataTable.ext.type.search;
	
			if ( fomatters[ col.sType ] ) {
				cellData = fomatters[ col.sType ]( cellData );
			}
		}
	
		return cellData;
	}
	
	
	/**
	 * Set the value for a specific cell, into the internal data cache
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {*} val Value to set
	 *  @memberof DataTable#oApi
	 */
	function _fnSetCellData( settings, rowIdx, colIdx, val )
	{
		var col     = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;
	
		col.fnSetData( rowData, val, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		}  );
	}
	
	
	// Private variable that is used to match action syntax in the data property object
	var __reArray = /\[.*?\]$/;
	var __reFn = /\(\)$/;
	
	/**
	 * Split string on periods, taking into account escaped periods
	 * @param  {string} str String to split
	 * @return {array} Split string
	 */
	function _fnSplitObjNotation( str )
	{
		return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
			return s.replace(/\\\./g, '.');
		} );
	}
	
	
	/**
	 * Return a function that can be used to get data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data get function
	 *  @memberof DataTable#oApi
	 */
	var _fnGetObjectDataFn = DataTable.util.get;
	
	
	/**
	 * Return a function that can be used to set data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data set function
	 *  @memberof DataTable#oApi
	 */
	var _fnSetObjectDataFn = DataTable.util.set;
	
	
	/**
	 * Return an array with the full table data
	 *  @param {object} oSettings dataTables settings object
	 *  @returns array {array} aData Master data array
	 *  @memberof DataTable#oApi
	 */
	function _fnGetDataMaster ( settings )
	{
		return _pluck( settings.aoData, '_aData' );
	}
	
	
	/**
	 * Nuke the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnClearTable( settings )
	{
		settings.aoData.length = 0;
		settings.aiDisplayMaster.length = 0;
		settings.aiDisplay.length = 0;
		settings.aIds = {};
	}
	
	
	 /**
	 * Take an array of integers (index array) and remove a target integer (value - not
	 * the key!)
	 *  @param {array} a Index array to target
	 *  @param {int} iTarget value to find
	 *  @memberof DataTable#oApi
	 */
	function _fnDeleteIndex( a, iTarget, splice )
	{
		var iTargetIndex = -1;
	
		for ( var i=0, iLen=a.length ; i<iLen ; i++ )
		{
			if ( a[i] == iTarget )
			{
				iTargetIndex = i;
			}
			else if ( a[i] > iTarget )
			{
				a[i]--;
			}
		}
	
		if ( iTargetIndex != -1 && splice === undefined )
		{
			a.splice( iTargetIndex, 1 );
		}
	}
	
	
	/**
	 * Mark cached data as invalid such that a re-read of the data will occur when
	 * the cached data is next requested. Also update from the data source object.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {int}    rowIdx   Row index to invalidate
	 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	 *     or 'data'
	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	 *     row will be invalidated
	 * @memberof DataTable#oApi
	 *
	 * @todo For the modularisation of v1.11 this will need to become a callback, so
	 *   the sort and filter methods can subscribe to it. That will required
	 *   initialisation options for sorting, which is why it is not already baked in
	 */
	function _fnInvalidate( settings, rowIdx, src, colIdx )
	{
		var row = settings.aoData[ rowIdx ];
		var i, ien;
		var cellWrite = function ( cell, col ) {
			// This is very frustrating, but in IE if you just write directly
			// to innerHTML, and elements that are overwritten are GC'ed,
			// even if there is a reference to them elsewhere
			while ( cell.childNodes.length ) {
				cell.removeChild( cell.firstChild );
			}
	
			cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
		};
	
		// Are we reading last data from DOM or the data object?
		if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
			// Read the data from the DOM
			row._aData = _fnGetRowElements(
					settings, row, colIdx, colIdx === undefined ? undefined : row._aData
				)
				.data;
		}
		else {
			// Reading from data object, update the DOM
			var cells = row.anCells;
	
			if ( cells ) {
				if ( colIdx !== undefined ) {
					cellWrite( cells[colIdx], colIdx );
				}
				else {
					for ( i=0, ien=cells.length ; i<ien ; i++ ) {
						cellWrite( cells[i], i );
					}
				}
			}
		}
	
		// For both row and cell invalidation, the cached data for sorting and
		// filtering is nulled out
		row._aSortData = null;
		row._aFilterData = null;
	
		// Invalidate the type for a specific column (if given) or all columns since
		// the data might have changed
		var cols = settings.aoColumns;
		if ( colIdx !== undefined ) {
			cols[ colIdx ].sType = null;
		}
		else {
			for ( i=0, ien=cols.length ; i<ien ; i++ ) {
				cols[i].sType = null;
			}
	
			// Update DataTables special `DT_*` attributes for the row
			_fnRowAttributes( settings, row );
		}
	}
	
	
	/**
	 * Build a data source object from an HTML row, reading the contents of the
	 * cells that are in the row.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {node|object} TR element from which to read data or existing row
	 *   object from which to re-read the data from the cells
	 * @param {int} [colIdx] Optional column index
	 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	 *   parameter should also be given and will be used to write the data into.
	 *   Only the column in question will be written
	 * @returns {object} Object with two parameters: `data` the data read, in
	 *   document order, and `cells` and array of nodes (they can be useful to the
	 *   caller, so rather than needing a second traversal to get them, just return
	 *   them from here).
	 * @memberof DataTable#oApi
	 */
	function _fnGetRowElements( settings, row, colIdx, d )
	{
		var
			tds = [],
			td = row.firstChild,
			name, col, o, i=0, contents,
			columns = settings.aoColumns,
			objectRead = settings._rowReadObject;
	
		// Allow the data object to be passed in, or construct
		d = d !== undefined ?
			d :
			objectRead ?
				{} :
				[];
	
		var attr = function ( str, td  ) {
			if ( typeof str === 'string' ) {
				var idx = str.indexOf('@');
	
				if ( idx !== -1 ) {
					var attr = str.substring( idx+1 );
					var setter = _fnSetObjectDataFn( str );
					setter( d, td.getAttribute( attr ) );
				}
			}
		};
	
		// Read data from a cell and store into the data object
		var cellProcess = function ( cell ) {
			if ( colIdx === undefined || colIdx === i ) {
				col = columns[i];
				contents = (cell.innerHTML).trim();
	
				if ( col && col._bAttrSrc ) {
					var setter = _fnSetObjectDataFn( col.mData._ );
					setter( d, contents );
	
					attr( col.mData.sort, cell );
					attr( col.mData.type, cell );
					attr( col.mData.filter, cell );
				}
				else {
					// Depending on the `data` option for the columns the data can
					// be read to either an object or an array.
					if ( objectRead ) {
						if ( ! col._setter ) {
							// Cache the setter function
							col._setter = _fnSetObjectDataFn( col.mData );
						}
						col._setter( d, contents );
					}
					else {
						d[i] = contents;
					}
				}
			}
	
			i++;
		};
	
		if ( td ) {
			// `tr` element was passed in
			while ( td ) {
				name = td.nodeName.toUpperCase();
	
				if ( name == "TD" || name == "TH" ) {
					cellProcess( td );
					tds.push( td );
				}
	
				td = td.nextSibling;
			}
		}
		else {
			// Existing row object passed in
			tds = row.anCells;
	
			for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
				cellProcess( tds[j] );
			}
		}
	
		// Read the ID from the DOM if present
		var rowNode = row.firstChild ? row : row.nTr;
	
		if ( rowNode ) {
			var id = rowNode.getAttribute( 'id' );
	
			if ( id ) {
				_fnSetObjectDataFn( settings.rowId )( d, id );
			}
		}
	
		return {
			data: d,
			cells: tds
		};
	}
	/**
	 * Create a new TR element (and it's TD children) for a row
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow Row to consider
	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @memberof DataTable#oApi
	 */
	function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
	{
		var
			row = oSettings.aoData[iRow],
			rowData = row._aData,
			cells = [],
			nTr, nTd, oCol,
			i, iLen, create;
	
		if ( row.nTr === null )
		{
			nTr = nTrIn || document.createElement('tr');
	
			row.nTr = nTr;
			row.anCells = cells;
	
			/* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
			nTr._DT_RowIndex = iRow;
	
			/* Special parameters can be given by the data source to be used on the row */
			_fnRowAttributes( oSettings, row );
	
			/* Process each column */
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
				create = nTrIn ? false : true;
	
				nTd = create ? document.createElement( oCol.sCellType ) : anTds[i];
				nTd._DT_CellIndex = {
					row: iRow,
					column: i
				};
				
				cells.push( nTd );
	
				// Need to create the HTML if new, or if a rendering function is defined
				if ( create || ((oCol.mRender || oCol.mData !== i) &&
					 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
				)) {
					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
				}
	
				/* Add user defined class */
				if ( oCol.sClass )
				{
					nTd.className += ' '+oCol.sClass;
				}
	
				// Visibility - add or remove as required
				if ( oCol.bVisible && ! nTrIn )
				{
					nTr.appendChild( nTd );
				}
				else if ( ! oCol.bVisible && nTrIn )
				{
					nTd.parentNode.removeChild( nTd );
				}
	
				if ( oCol.fnCreatedCell )
				{
					oCol.fnCreatedCell.call( oSettings.oInstance,
						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
					);
				}
			}
	
			_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells] );
		}
	}
	
	
	/**
	 * Add attributes to a row based on the special `DT_*` parameters in a data
	 * source object.
	 *  @param {object} settings DataTables settings object
	 *  @param {object} DataTables row object for the row to be modified
	 *  @memberof DataTable#oApi
	 */
	function _fnRowAttributes( settings, row )
	{
		var tr = row.nTr;
		var data = row._aData;
	
		if ( tr ) {
			var id = settings.rowIdFn( data );
	
			if ( id ) {
				tr.id = id;
			}
	
			if ( data.DT_RowClass ) {
				// Remove any classes added by DT_RowClass before
				var a = data.DT_RowClass.split(' ');
				row.__rowc = row.__rowc ?
					_unique( row.__rowc.concat( a ) ) :
					a;
	
				$(tr)
					.removeClass( row.__rowc.join(' ') )
					.addClass( data.DT_RowClass );
			}
	
			if ( data.DT_RowAttr ) {
				$(tr).attr( data.DT_RowAttr );
			}
	
			if ( data.DT_RowData ) {
				$(tr).data( data.DT_RowData );
			}
		}
	}
	
	
	/**
	 * Create the HTML header for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBuildHead( oSettings )
	{
		var i, ien, cell, row, column;
		var thead = oSettings.nTHead;
		var tfoot = oSettings.nTFoot;
		var createHeader = $('th, td', thead).length === 0;
		var classes = oSettings.oClasses;
		var columns = oSettings.aoColumns;
	
		if ( createHeader ) {
			row = $('<tr/>').appendTo( thead );
		}
	
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			column = columns[i];
			cell = $( column.nTh ).addClass( column.sClass );
	
			if ( createHeader ) {
				cell.appendTo( row );
			}
	
			// 1.11 move into sorting
			if ( oSettings.oFeatures.bSort ) {
				cell.addClass( column.sSortingClass );
	
				if ( column.bSortable !== false ) {
					cell
						.attr( 'tabindex', oSettings.iTabIndex )
						.attr( 'aria-controls', oSettings.sTableId );
	
					_fnSortAttachListener( oSettings, column.nTh, i );
				}
			}
	
			if ( column.sTitle != cell[0].innerHTML ) {
				cell.html( column.sTitle );
			}
	
			_fnRenderer( oSettings, 'header' )(
				oSettings, cell, column, classes
			);
		}
	
		if ( createHeader ) {
			_fnDetectHeader( oSettings.aoHeader, thead );
		}
	
		/* Deal with the footer - add classes if required */
		$(thead).children('tr').children('th, td').addClass( classes.sHeaderTH );
		$(tfoot).children('tr').children('th, td').addClass( classes.sFooterTH );
	
		// Cache the footer cells. Note that we only take the cells from the first
		// row in the footer. If there is more than one row the user wants to
		// interact with, they need to use the table().foot() method. Note also this
		// allows cells to be used for multiple columns using colspan
		if ( tfoot !== null ) {
			var cells = oSettings.aoFooter[0];
	
			for ( i=0, ien=cells.length ; i<ien ; i++ ) {
				column = columns[i];
				column.nTf = cells[i].cell;
	
				if ( column.sClass ) {
					$(column.nTf).addClass( column.sClass );
				}
			}
		}
	}
	
	
	/**
	 * Draw the header (or footer) element based on the column visibility states. The
	 * methodology here is to use the layout array from _fnDetectHeader, modified for
	 * the instantaneous column visibility, to construct the new layout. The grid is
	 * traversed over cell at a time in a rows x columns grid fashion, although each
	 * cell insert can cover multiple elements in the grid - which is tracks using the
	 * aApplied array. Cell inserts in the grid will only occur where there isn't
	 * already a cell in that position.
	 *  @param {object} oSettings dataTables settings object
	 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	 *  @memberof DataTable#oApi
	 */
	function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
	{
		var i, iLen, j, jLen, k, kLen, n, nLocalTr;
		var aoLocal = [];
		var aApplied = [];
		var iColumns = oSettings.aoColumns.length;
		var iRowspan, iColspan;
	
		if ( ! aoSource )
		{
			return;
		}
	
		if (  bIncludeHidden === undefined )
		{
			bIncludeHidden = false;
		}
	
		/* Make a copy of the master layout array, but without the visible columns in it */
		for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
		{
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;
	
			/* Remove any columns which are currently hidden */
			for ( j=iColumns-1 ; j>=0 ; j-- )
			{
				if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
				{
					aoLocal[i].splice( j, 1 );
				}
			}
	
			/* Prep the applied array - it needs an element for each row */
			aApplied.push( [] );
		}
	
		for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
		{
			nLocalTr = aoLocal[i].nTr;
	
			/* All cells are going to be replaced, so empty out the row */
			if ( nLocalTr )
			{
				while( (n = nLocalTr.firstChild) )
				{
					nLocalTr.removeChild( n );
				}
			}
	
			for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
			{
				iRowspan = 1;
				iColspan = 1;
	
				/* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
				if ( aApplied[i][j] === undefined )
				{
					nLocalTr.appendChild( aoLocal[i][j].cell );
					aApplied[i][j] = 1;
	
					/* Expand the cell to cover as many rows as needed */
					while ( aoLocal[i+iRowspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
					{
						aApplied[i+iRowspan][j] = 1;
						iRowspan++;
					}
	
					/* Expand the cell to cover as many columns as needed */
					while ( aoLocal[i][j+iColspan] !== undefined &&
					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
					{
						/* Must update the applied array over the rows for the columns */
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aApplied[i+k][j+iColspan] = 1;
						}
						iColspan++;
					}
	
					/* Do the actual expansion in the DOM */
					$(aoLocal[i][j].cell)
						.attr('rowspan', iRowspan)
						.attr('colspan', iColspan);
				}
			}
		}
	}
	
	
	/**
	 * Insert the required TR nodes into the table for display
	 *  @param {object} oSettings dataTables settings object
	 *  @param ajaxComplete true after ajax call to complete rendering
	 *  @memberof DataTable#oApi
	 */
	function _fnDraw( oSettings, ajaxComplete )
	{
		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
		var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
		if ( $.inArray( false, aPreDraw ) !== -1 )
		{
			_fnProcessingDisplay( oSettings, false );
			return;
		}
	
		var i, iLen, n;
		var anRows = [];
		var iRowCount = 0;
		var asStripeClasses = oSettings.asStripeClasses;
		var iStripes = asStripeClasses.length;
		var iOpenRows = oSettings.aoOpenRows.length;
		var oLang = oSettings.oLanguage;
		var iInitDisplayStart = oSettings.iInitDisplayStart;
		var bServerSide = _fnDataSource( oSettings ) == 'ssp';
		var aiDisplay = oSettings.aiDisplay;
	
		oSettings.bDrawing = true;
	
		/* Check and see if we have an initial draw position from state saving */
		if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
		{
			oSettings._iDisplayStart = bServerSide ?
				iInitDisplayStart :
				iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
					0 :
					iInitDisplayStart;
	
			oSettings.iInitDisplayStart = -1;
		}
	
		var iDisplayStart = oSettings._iDisplayStart;
		var iDisplayEnd = oSettings.fnDisplayEnd();
	
		/* Server-side processing draw intercept */
		if ( oSettings.bDeferLoading )
		{
			oSettings.bDeferLoading = false;
			oSettings.iDraw++;
			_fnProcessingDisplay( oSettings, false );
		}
		else if ( !bServerSide )
		{
			oSettings.iDraw++;
		}
		else if ( !oSettings.bDestroying && !ajaxComplete)
		{
			_fnAjaxUpdate( oSettings );
			return;
		}
	
		if ( aiDisplay.length !== 0 )
		{
			var iStart = bServerSide ? 0 : iDisplayStart;
			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
	
			for ( var j=iStart ; j<iEnd ; j++ )
			{
				var iDataIndex = aiDisplay[j];
				var aoData = oSettings.aoData[ iDataIndex ];
				if ( aoData.nTr === null )
				{
					_fnCreateTr( oSettings, iDataIndex );
				}
	
				var nRow = aoData.nTr;
	
				/* Remove the old striping classes and then add the new one */
				if ( iStripes !== 0 )
				{
					var sStripe = asStripeClasses[ iRowCount % iStripes ];
					if ( aoData._sRowStripe != sStripe )
					{
						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
						aoData._sRowStripe = sStripe;
					}
				}
	
				// Row callback functions - might want to manipulate the row
				// iRowCount and j are not currently documented. Are they at all
				// useful?
				_fnCallbackFire( oSettings, 'aoRowCallback', null,
					[nRow, aoData._aData, iRowCount, j, iDataIndex] );
	
				anRows.push( nRow );
				iRowCount++;
			}
		}
		else
		{
			/* Table is empty - create a row with an empty message in it */
			var sZero = oLang.sZeroRecords;
			if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
			{
				sZero = oLang.sLoadingRecords;
			}
			else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
			{
				sZero = oLang.sEmptyTable;
			}
	
			anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
				.append( $('<td />', {
					'valign':  'top',
					'colSpan': _fnVisbleColumns( oSettings ),
					'class':   oSettings.oClasses.sRowEmpty
				} ).html( sZero ) )[0];
		}
	
		/* Header and footer callbacks */
		_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		var body = $(oSettings.nTBody);
	
		body.children().detach();
		body.append( $(anRows) );
	
		/* Call all required callback functions for the end of a draw */
		_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
	
		/* Draw is complete, sorting and filtering must be as well */
		oSettings.bSorted = false;
		oSettings.bFiltered = false;
		oSettings.bDrawing = false;
	}
	
	
	/**
	 * Redraw the table - taking account of the various features which are enabled
	 *  @param {object} oSettings dataTables settings object
	 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	 *    the paging is reset to the first page
	 *  @memberof DataTable#oApi
	 */
	function _fnReDraw( settings, holdPosition )
	{
		var
			features = settings.oFeatures,
			sort     = features.bSort,
			filter   = features.bFilter;
	
		if ( sort ) {
			_fnSort( settings );
		}
	
		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	
		if ( holdPosition !== true ) {
			settings._iDisplayStart = 0;
		}
	
		// Let any modules know about the draw hold position state (used by
		// scrolling internally)
		settings._drawHold = holdPosition;
	
		_fnDraw( settings );
	
		settings._drawHold = false;
	}
	
	
	/**
	 * Add the options to the page HTML for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAddOptionsHtml ( oSettings )
	{
		var classes = oSettings.oClasses;
		var table = $(oSettings.nTable);
		var holding = $('<div/>').insertBefore( table ); // Holding element for speed
		var features = oSettings.oFeatures;
	
		// All DataTables are wrapped in a div
		var insert = $('<div/>', {
			id:      oSettings.sTableId+'_wrapper',
			'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
		} );
	
		oSettings.nHolding = holding[0];
		oSettings.nTableWrapper = insert[0];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
	
		/* Loop over the user set positioning and place the elements as needed */
		var aDom = oSettings.sDom.split('');
		var featureNode, cOption, nNewNode, cNext, sAttr, j;
		for ( var i=0 ; i<aDom.length ; i++ )
		{
			featureNode = null;
			cOption = aDom[i];
	
			if ( cOption == '<' )
			{
				/* New container div */
				nNewNode = $('<div/>')[0];
	
				/* Check to see if we should append an id and/or a class name to the container */
				cNext = aDom[i+1];
				if ( cNext == "'" || cNext == '"' )
				{
					sAttr = "";
					j = 2;
					while ( aDom[i+j] != cNext )
					{
						sAttr += aDom[i+j];
						j++;
					}
	
					/* Replace jQuery UI constants @todo depreciated */
					if ( sAttr == "H" )
					{
						sAttr = classes.sJUIHeader;
					}
					else if ( sAttr == "F" )
					{
						sAttr = classes.sJUIFooter;
					}
	
					/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
					 * breaks the string into parts and applies them as needed
					 */
					if ( sAttr.indexOf('.') != -1 )
					{
						var aSplit = sAttr.split('.');
						nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
						nNewNode.className = aSplit[1];
					}
					else if ( sAttr.charAt(0) == "#" )
					{
						nNewNode.id = sAttr.substr(1, sAttr.length-1);
					}
					else
					{
						nNewNode.className = sAttr;
					}
	
					i += j; /* Move along the position array */
				}
	
				insert.append( nNewNode );
				insert = $(nNewNode);
			}
			else if ( cOption == '>' )
			{
				/* End container div */
				insert = insert.parent();
			}
			// @todo Move options into their own plugins?
			else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
			{
				/* Length */
				featureNode = _fnFeatureHtmlLength( oSettings );
			}
			else if ( cOption == 'f' && features.bFilter )
			{
				/* Filter */
				featureNode = _fnFeatureHtmlFilter( oSettings );
			}
			else if ( cOption == 'r' && features.bProcessing )
			{
				/* pRocessing */
				featureNode = _fnFeatureHtmlProcessing( oSettings );
			}
			else if ( cOption == 't' )
			{
				/* Table */
				featureNode = _fnFeatureHtmlTable( oSettings );
			}
			else if ( cOption ==  'i' && features.bInfo )
			{
				/* Info */
				featureNode = _fnFeatureHtmlInfo( oSettings );
			}
			else if ( cOption == 'p' && features.bPaginate )
			{
				/* Pagination */
				featureNode = _fnFeatureHtmlPaginate( oSettings );
			}
			else if ( DataTable.ext.feature.length !== 0 )
			{
				/* Plug-in features */
				var aoFeatures = DataTable.ext.feature;
				for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
				{
					if ( cOption == aoFeatures[k].cFeature )
					{
						featureNode = aoFeatures[k].fnInit( oSettings );
						break;
					}
				}
			}
	
			/* Add to the 2D features array */
			if ( featureNode )
			{
				var aanFeatures = oSettings.aanFeatures;
	
				if ( ! aanFeatures[cOption] )
				{
					aanFeatures[cOption] = [];
				}
	
				aanFeatures[cOption].push( featureNode );
				insert.append( featureNode );
			}
		}
	
		/* Built our DOM structure - replace the holding div with what we want */
		holding.replaceWith( insert );
		oSettings.nHolding = null;
	}
	
	
	/**
	 * Use the DOM source to create up an array of header cells. The idea here is to
	 * create a layout grid (array) of rows x columns, which contains a reference
	 * to the cell that that point in the grid (regardless of col/rowspan), such that
	 * any column / row could be removed and the new grid constructed
	 *  @param array {object} aLayout Array to store the calculated layout in
	 *  @param {node} nThead The header/footer element for the table
	 *  @memberof DataTable#oApi
	 */
	function _fnDetectHeader ( aLayout, nThead )
	{
		var nTrs = $(nThead).children('tr');
		var nTr, nCell;
		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		var bUnique;
		var fnShiftCol = function ( a, i, j ) {
			var k = a[i];
	                while ( k[j] ) {
				j++;
			}
			return j;
		};
	
		aLayout.splice( 0, aLayout.length );
	
		/* We know how many rows there are in the layout - so prep it */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			aLayout.push( [] );
		}
	
		/* Calculate a layout array */
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			nTr = nTrs[i];
			iColumn = 0;
	
			/* For every cell in the row... */
			nCell = nTr.firstChild;
			while ( nCell ) {
				if ( nCell.nodeName.toUpperCase() == "TD" ||
				     nCell.nodeName.toUpperCase() == "TH" )
				{
					/* Get the col and rowspan attributes from the DOM and sanitise them */
					iColspan = nCell.getAttribute('colspan') * 1;
					iRowspan = nCell.getAttribute('rowspan') * 1;
					iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
					iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
	
					/* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
					iColShifted = fnShiftCol( aLayout, i, iColumn );
	
					/* Cache calculation for unique columns */
					bUnique = iColspan === 1 ? true : false;
	
					/* If there is col / rowspan, copy the information into the layout grid */
					for ( l=0 ; l<iColspan ; l++ )
					{
						for ( k=0 ; k<iRowspan ; k++ )
						{
							aLayout[i+k][iColShifted+l] = {
								"cell": nCell,
								"unique": bUnique
							};
							aLayout[i+k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}
	
	
	/**
	 * Get an array of unique th elements, one for each column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nHeader automatically detect the layout from this node - optional
	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	 *  @returns array {node} aReturn list of unique th's
	 *  @memberof DataTable#oApi
	 */
	function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
	{
		var aReturn = [];
		if ( !aLayout )
		{
			aLayout = oSettings.aoHeader;
			if ( nHeader )
			{
				aLayout = [];
				_fnDetectHeader( aLayout, nHeader );
			}
		}
	
		for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
		{
			for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
			{
				if ( aLayout[i][j].unique &&
					 (!aReturn[j] || !oSettings.bSortCellsTop) )
				{
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}
	
		return aReturn;
	}
	
	/**
	 * Create an Ajax call based on the table's settings, taking into account that
	 * parameters can have multiple forms, and backwards compatibility.
	 *
	 * @param {object} oSettings dataTables settings object
	 * @param {array} data Data to send to the server, required by
	 *     DataTables - may be augmented by developer callbacks
	 * @param {function} fn Callback function to run when data is obtained
	 */
	function _fnBuildAjax( oSettings, data, fn )
	{
		// Compatibility with 1.9-, allow fnServerData and event to manipulate
		_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
	
		// Convert to object based for 1.10+ if using the old array scheme which can
		// come from server-side processing or serverParams
		if ( data && Array.isArray(data) ) {
			var tmp = {};
			var rbracket = /(.*?)\[\]$/;
	
			$.each( data, function (key, val) {
				var match = val.name.match(rbracket);
	
				if ( match ) {
					// Support for arrays
					var name = match[0];
	
					if ( ! tmp[ name ] ) {
						tmp[ name ] = [];
					}
					tmp[ name ].push( val.value );
				}
				else {
					tmp[val.name] = val.value;
				}
			} );
			data = tmp;
		}
	
		var ajaxData;
		var ajax = oSettings.ajax;
		var instance = oSettings.oInstance;
		var callback = function ( json ) {
			var status = oSettings.jqXhr
				? oSettings.jqXhr.status
				: null;
	
			if ( json === null || (typeof status === 'number' && status == 204 ) ) {
				json = {};
				_fnAjaxDataSrc( oSettings, json, [] );
			}
	
			var error = json.error || json.sError;
			if ( error ) {
				_fnLog( oSettings, 0, error );
			}
	
			oSettings.json = json;
	
			_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
			fn( json );
		};
	
		if ( $.isPlainObject( ajax ) && ajax.data )
		{
			ajaxData = ajax.data;
	
			var newData = typeof ajaxData === 'function' ?
				ajaxData( data, oSettings ) :  // fn can manipulate data or return
				ajaxData;                      // an object object or array to merge
	
			// If the function returned something, use that alone
			data = typeof ajaxData === 'function' && newData ?
				newData :
				$.extend( true, data, newData );
	
			// Remove the data property as we've resolved it already and don't want
			// jQuery to do it again (it is restored at the end of the function)
			delete ajax.data;
		}
	
		var baseAjax = {
			"data": data,
			"success": callback,
			"dataType": "json",
			"cache": false,
			"type": oSettings.sServerMethod,
			"error": function (xhr, error, thrown) {
				var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );
	
				if ( $.inArray( true, ret ) === -1 ) {
					if ( error == "parsererror" ) {
						_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
					}
					else if ( xhr.readyState === 4 ) {
						_fnLog( oSettings, 0, 'Ajax error', 7 );
					}
				}
	
				_fnProcessingDisplay( oSettings, false );
			}
		};
	
		// Store the data submitted for the API
		oSettings.oAjaxData = data;
	
		// Allow plug-ins and external processes to modify the data
		_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
	
		if ( oSettings.fnServerData )
		{
			// DataTables 1.9- compatibility
			oSettings.fnServerData.call( instance,
				oSettings.sAjaxSource,
				$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
					return { name: key, value: val };
				} ),
				callback,
				oSettings
			);
		}
		else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
		{
			// DataTables 1.9- compatibility
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
				url: ajax || oSettings.sAjaxSource
			} ) );
		}
		else if ( typeof ajax === 'function' )
		{
			// Is a function - let the caller define what needs to be done
			oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
		}
		else
		{
			// Object to extend the base settings
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
	
			// Restore for next time around
			ajax.data = ajaxData;
		}
	}
	
	
	/**
	 * Update the table using an Ajax call
	 *  @param {object} settings dataTables settings object
	 *  @returns {boolean} Block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdate( settings )
	{
		settings.iDraw++;
		_fnProcessingDisplay( settings, true );
	
		_fnBuildAjax(
			settings,
			_fnAjaxParameters( settings ),
			function(json) {
				_fnAjaxUpdateDraw( settings, json );
			}
		);
	}
	
	
	/**
	 * Build up the parameters in an object needed for a server-side processing
	 * request. Note that this is basically done twice, is different ways - a modern
	 * method which is used by default in DataTables 1.10 which uses objects and
	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	 * option is set.
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {bool} block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxParameters( settings )
	{
		var
			columns = settings.aoColumns,
			columnCount = columns.length,
			features = settings.oFeatures,
			preSearch = settings.oPreviousSearch,
			preColSearch = settings.aoPreSearchCols,
			i, data = [], dataProp, column, columnSearch,
			sort = _fnSortFlatten( settings ),
			displayStart = settings._iDisplayStart,
			displayLength = features.bPaginate !== false ?
				settings._iDisplayLength :
				-1;
	
		var param = function ( name, value ) {
			data.push( { 'name': name, 'value': value } );
		};
	
		// DataTables 1.9- compatible method
		param( 'sEcho',          settings.iDraw );
		param( 'iColumns',       columnCount );
		param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
		param( 'iDisplayStart',  displayStart );
		param( 'iDisplayLength', displayLength );
	
		// DataTables 1.10+ method
		var d = {
			draw:    settings.iDraw,
			columns: [],
			order:   [],
			start:   displayStart,
			length:  displayLength,
			search:  {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};
	
		for ( i=0 ; i<columnCount ; i++ ) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
	
			d.columns.push( {
				data:       dataProp,
				name:       column.sName,
				searchable: column.bSearchable,
				orderable:  column.bSortable,
				search:     {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			} );
	
			param( "mDataProp_"+i, dataProp );
	
			if ( features.bFilter ) {
				param( 'sSearch_'+i,     columnSearch.sSearch );
				param( 'bRegex_'+i,      columnSearch.bRegex );
				param( 'bSearchable_'+i, column.bSearchable );
			}
	
			if ( features.bSort ) {
				param( 'bSortable_'+i, column.bSortable );
			}
		}
	
		if ( features.bFilter ) {
			param( 'sSearch', preSearch.sSearch );
			param( 'bRegex', preSearch.bRegex );
		}
	
		if ( features.bSort ) {
			$.each( sort, function ( i, val ) {
				d.order.push( { column: val.col, dir: val.dir } );
	
				param( 'iSortCol_'+i, val.col );
				param( 'sSortDir_'+i, val.dir );
			} );
	
			param( 'iSortingCols', sort.length );
		}
	
		// If the legacy.ajax parameter is null, then we automatically decide which
		// form to use, based on sAjaxSource
		var legacy = DataTable.ext.legacy.ajax;
		if ( legacy === null ) {
			return settings.sAjaxSource ? data : d;
		}
	
		// Otherwise, if legacy has been specified then we use that to decide on the
		// form
		return legacy ? data : d;
	}
	
	
	/**
	 * Data the data from the server (nuking the old) and redraw the table
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} json json data return from the server.
	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	 *  @param {array} json.aaData The data to display on this page
	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdateDraw ( settings, json )
	{
		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
		// Support both
		var compat = function ( old, modern ) {
			return json[old] !== undefined ? json[old] : json[modern];
		};
	
		var data = _fnAjaxDataSrc( settings, json );
		var draw            = compat( 'sEcho',                'draw' );
		var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
		var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
	
		if ( draw !== undefined ) {
			// Protect against out of sequence returns
			if ( draw*1 < settings.iDraw ) {
				return;
			}
			settings.iDraw = draw * 1;
		}
	
		// No data in returned object, so rather than an array, we show an empty table
		if ( ! data ) {
			data = [];
		}
	
		_fnClearTable( settings );
		settings._iRecordsTotal   = parseInt(recordsTotal, 10);
		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
	
		for ( var i=0, ien=data.length ; i<ien ; i++ ) {
			_fnAddData( settings, data[i] );
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();
	
		_fnDraw( settings, true );
	
		if ( ! settings._bInitComplete ) {
			_fnInitComplete( settings, json );
		}
	
		_fnProcessingDisplay( settings, false );
	}
	
	
	/**
	 * Get the data from the JSON data source to use for drawing a table. Using
	 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	 * source object, or from a processing function.
	 *  @param {object} oSettings dataTables settings object
	 *  @param  {object} json Data source object / array from the server
	 *  @return {array} Array of data to use
	 */
	 function _fnAjaxDataSrc ( oSettings, json, write )
	 {
		var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
			oSettings.ajax.dataSrc :
			oSettings.sAjaxDataProp; // Compatibility with 1.9-.
	
		if ( ! write ) {
			if ( dataSrc === 'data' ) {
				// If the default, then we still want to support the old style, and safely ignore
				// it if possible
				return json.aaData || json[dataSrc];
			}
	
			return dataSrc !== "" ?
				_fnGetObjectDataFn( dataSrc )( json ) :
				json;
		}
	
		// set
		_fnSetObjectDataFn( dataSrc )( json, write );
	}
	
	/**
	 * Generate the node required for filtering text
	 *  @returns {node} Filter control element
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlFilter ( settings )
	{
		var classes = settings.oClasses;
		var tableId = settings.sTableId;
		var language = settings.oLanguage;
		var previousSearch = settings.oPreviousSearch;
		var features = settings.aanFeatures;
		var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
	
		var str = language.sSearch;
		str = str.match(/_INPUT_/) ?
			str.replace('_INPUT_', input) :
			str+input;
	
		var filter = $('<div/>', {
				'id': ! features.f ? tableId+'_filter' : null,
				'class': classes.sFilter
			} )
			.append( $('<label/>' ).append( str ) );
	
		var searchFn = function(event) {
			/* Update all other filter input elements for the new display */
			var n = features.f;
			var val = !this.value ? "" : this.value; // mental IE8 fix :-(
			if(previousSearch.return && event.key !== "Enter") {
				return;
			}
			/* Now do the filter */
			if ( val != previousSearch.sSearch ) {
				_fnFilterComplete( settings, {
					"sSearch": val,
					"bRegex": previousSearch.bRegex,
					"bSmart": previousSearch.bSmart ,
					"bCaseInsensitive": previousSearch.bCaseInsensitive,
					"return": previousSearch.return
				} );
	
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			}
		};
	
		var searchDelay = settings.searchDelay !== null ?
			settings.searchDelay :
			_fnDataSource( settings ) === 'ssp' ?
				400 :
				0;
	
		var jqFilter = $('input', filter)
			.val( previousSearch.sSearch )
			.attr( 'placeholder', language.sSearchPlaceholder )
			.on(
				'keyup.DT search.DT input.DT paste.DT cut.DT',
				searchDelay ?
					_fnThrottle( searchFn, searchDelay ) :
					searchFn
			)
			.on( 'mouseup', function(e) {
				// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
				// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
				// checks the value to see if it has changed. In other browsers it won't have.
				setTimeout( function () {
					searchFn.call(jqFilter[0], e);
				}, 10);
			} )
			.on( 'keypress.DT', function(e) {
				/* Prevent form submission */
				if ( e.keyCode == 13 ) {
					return false;
				}
			} )
			.attr('aria-controls', tableId);
	
		// Update the input elements whenever the table is filtered
		$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
			if ( settings === s ) {
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame...
				try {
					if ( jqFilter[0] !== document.activeElement ) {
						jqFilter.val( previousSearch.sSearch );
					}
				}
				catch ( e ) {}
			}
		} );
	
		return filter[0];
	}
	
	
	/**
	 * Filter the table using both the global filter and column based filtering
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oSearch search information
	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterComplete ( oSettings, oInput, iForce )
	{
		var oPrevSearch = oSettings.oPreviousSearch;
		var aoPrevSearch = oSettings.aoPreSearchCols;
		var fnSaveFilter = function ( oFilter ) {
			/* Save the filtering values */
			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			oPrevSearch.return = oFilter.return;
		};
		var fnRegex = function ( o ) {
			// Backwards compatibility with the bEscapeRegex option
			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
		};
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo As per sort - can this be moved into an event handler?
		_fnColumnTypes( oSettings );
	
		/* In server-side processing all filtering is done by the server, so no point hanging around here */
		if ( _fnDataSource( oSettings ) != 'ssp' )
		{
			/* Global filter */
			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive, oInput.return );
			fnSaveFilter( oInput );
	
			/* Now do the individual column filter */
			for ( var i=0 ; i<aoPrevSearch.length ; i++ )
			{
				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
			}
	
			/* Custom filtering */
			_fnFilterCustom( oSettings );
		}
		else
		{
			fnSaveFilter( oInput );
		}
	
		/* Tell the draw function we have been filtering */
		oSettings.bFiltered = true;
		_fnCallbackFire( oSettings, null, 'search', [oSettings] );
	}
	
	
	/**
	 * Apply custom filtering functions
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCustom( settings )
	{
		var filters = DataTable.ext.search;
		var displayRows = settings.aiDisplay;
		var row, rowIdx;
	
		for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
			var rows = [];
	
			// Loop over each row and see if it should be included
			for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
				rowIdx = displayRows[ j ];
				row = settings.aoData[ rowIdx ];
	
				if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
					rows.push( rowIdx );
				}
			}
	
			// So the array reference doesn't break set the results into the
			// existing array
			displayRows.length = 0;
			$.merge( displayRows, rows );
		}
	}
	
	
	/**
	 * Filter the table on a per-column basis
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sInput string to filter on
	 *  @param {int} iColumn column to filter
	 *  @param {bool} bRegex treat search string as a regular expression or not
	 *  @param {bool} bSmart use smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
	{
		if ( searchStr === '' ) {
			return;
		}
	
		var data;
		var out = [];
		var display = settings.aiDisplay;
		var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
	
		for ( var i=0 ; i<display.length ; i++ ) {
			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
	
			if ( rpSearch.test( data ) ) {
				out.push( display[i] );
			}
		}
	
		settings.aiDisplay = out;
	}
	
	
	/**
	 * Filter the data table based on user input and draw the table
	 *  @param {object} settings dataTables settings object
	 *  @param {string} input string to filter on
	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	 *  @param {bool} regex treat as a regular expression or not
	 *  @param {bool} smart perform smart filtering or not
	 *  @param {bool} caseInsensitive Do case insensitive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
	{
		var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
		var prevSearch = settings.oPreviousSearch.sSearch;
		var displayMaster = settings.aiDisplayMaster;
		var display, invalidated, i;
		var filtered = [];
	
		// Need to take account of custom filtering functions - always filter
		if ( DataTable.ext.search.length !== 0 ) {
			force = true;
		}
	
		// Check if any of the rows were invalidated
		invalidated = _fnFilterData( settings );
	
		// If the input is blank - we just want the full data set
		if ( input.length <= 0 ) {
			settings.aiDisplay = displayMaster.slice();
		}
		else {
			// New search - start from the master array
			if ( invalidated ||
				 force ||
				 regex ||
				 prevSearch.length > input.length ||
				 input.indexOf(prevSearch) !== 0 ||
				 settings.bSorted // On resort, the display master needs to be
				                  // re-filtered since indexes will have changed
			) {
				settings.aiDisplay = displayMaster.slice();
			}
	
			// Search the display array
			display = settings.aiDisplay;
	
			for ( i=0 ; i<display.length ; i++ ) {
				if ( rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
					filtered.push( display[i] );
				}
			}
	
			settings.aiDisplay = filtered;
		}
	}
	
	
	/**
	 * Build a regular expression object suitable for searching a table
	 *  @param {string} sSearch string to search for
	 *  @param {bool} bRegex treat as a regular expression or not
	 *  @param {bool} bSmart perform smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @returns {RegExp} constructed object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
	{
		search = regex ?
			search :
			_fnEscapeRegex( search );
		
		if ( smart ) {
			/* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 * 
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
			var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
				if ( word.charAt(0) === '"' ) {
					var m = word.match( /^"(.*)"$/ );
					word = m ? m[1] : word;
				}
	
				return word.replace('"', '');
			} );
	
			search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
		}
	
		return new RegExp( search, caseInsensitive ? 'i' : '' );
	}
	
	
	/**
	 * Escape a string such that it can be used in a regular expression
	 *  @param {string} sVal string to escape
	 *  @returns {string} escaped string
	 *  @memberof DataTable#oApi
	 */
	var _fnEscapeRegex = DataTable.util.escapeRegex;
	
	var __filter_div = $('<div>')[0];
	var __filter_div_textContent = __filter_div.textContent !== undefined;
	
	// Update the filtering data for each row if needed (by invalidation or first run)
	function _fnFilterData ( settings )
	{
		var columns = settings.aoColumns;
		var column;
		var i, j, ien, jen, filterData, cellData, row;
		var wasInvalidated = false;
	
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aFilterData ) {
				filterData = [];
	
				for ( j=0, jen=columns.length ; j<jen ; j++ ) {
					column = columns[j];
	
					if ( column.bSearchable ) {
						cellData = _fnGetCellData( settings, i, j, 'filter' );
	
						// Search in DataTables 1.10 is string based. In 1.11 this
						// should be altered to also allow strict type checking.
						if ( cellData === null ) {
							cellData = '';
						}
	
						if ( typeof cellData !== 'string' && cellData.toString ) {
							cellData = cellData.toString();
						}
					}
					else {
						cellData = '';
					}
	
					// If it looks like there is an HTML entity in the string,
					// attempt to decode it so sorting works as expected. Note that
					// we could use a single line of jQuery to do this, but the DOM
					// method used here is much faster http://jsperf.com/html-decode
					if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
						__filter_div.innerHTML = cellData;
						cellData = __filter_div_textContent ?
							__filter_div.textContent :
							__filter_div.innerText;
					}
	
					if ( cellData.replace ) {
						cellData = cellData.replace(/[\r\n\u2028]/g, '');
					}
	
					filterData.push( cellData );
				}
	
				row._aFilterData = filterData;
				row._sFilterRow = filterData.join('  ');
				wasInvalidated = true;
			}
		}
	
		return wasInvalidated;
	}
	
	
	/**
	 * Convert from the internal Hungarian notation to camelCase for external
	 * interaction
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToCamel ( obj )
	{
		return {
			search:          obj.sSearch,
			smart:           obj.bSmart,
			regex:           obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}
	
	
	
	/**
	 * Convert from camelCase notation to the internal Hungarian. We could use the
	 * Hungarian convert function here, but this is cleaner
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToHung ( obj )
	{
		return {
			sSearch:          obj.search,
			bSmart:           obj.smart,
			bRegex:           obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}
	
	/**
	 * Generate the node required for the info display
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Information element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlInfo ( settings )
	{
		var
			tid = settings.sTableId,
			nodes = settings.aanFeatures.i,
			n = $('<div/>', {
				'class': settings.oClasses.sInfo,
				'id': ! nodes ? tid+'_info' : null
			} );
	
		if ( ! nodes ) {
			// Update display on each draw
			settings.aoDrawCallback.push( {
				"fn": _fnUpdateInfo,
				"sName": "information"
			} );
	
			n
				.attr( 'role', 'status' )
				.attr( 'aria-live', 'polite' );
	
			// Table is described by our info div
			$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
		}
	
		return n[0];
	}
	
	
	/**
	 * Update the information elements in the display
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnUpdateInfo ( settings )
	{
		/* Show information about the table */
		var nodes = settings.aanFeatures.i;
		if ( nodes.length === 0 ) {
			return;
		}
	
		var
			lang  = settings.oLanguage,
			start = settings._iDisplayStart+1,
			end   = settings.fnDisplayEnd(),
			max   = settings.fnRecordsTotal(),
			total = settings.fnRecordsDisplay(),
			out   = total ?
				lang.sInfo :
				lang.sInfoEmpty;
	
		if ( total !== max ) {
			/* Record set after filtering */
			out += ' ' + lang.sInfoFiltered;
		}
	
		// Convert the macros
		out += lang.sInfoPostFix;
		out = _fnInfoMacros( settings, out );
	
		var callback = lang.fnInfoCallback;
		if ( callback !== null ) {
			out = callback.call( settings.oInstance,
				settings, start, end, max, total, out
			);
		}
	
		$(nodes).html( out );
	}
	
	
	function _fnInfoMacros ( settings, str )
	{
		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
		// internally
		var
			formatter  = settings.fnFormatNumber,
			start      = settings._iDisplayStart+1,
			len        = settings._iDisplayLength,
			vis        = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return str.
			replace(/_START_/g, formatter.call( settings, start ) ).
			replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
			replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
			replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
			replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
			replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
	}
	
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnInitialise ( settings )
	{
		var i, iLen, iAjaxStart=settings.iInitDisplayStart;
		var columns = settings.aoColumns, column;
		var features = settings.oFeatures;
		var deferLoading = settings.bDeferLoading; // value modified by the draw
	
		/* Ensure that the table data is fully initialised */
		if ( ! settings.bInitialised ) {
			setTimeout( function(){ _fnInitialise( settings ); }, 200 );
			return;
		}
	
		/* Show the display HTML options */
		_fnAddOptionsHtml( settings );
	
		/* Build and draw the header / footer for the table */
		_fnBuildHead( settings );
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );
	
		/* Calculate sizes for columns */
		if ( features.bAutoWidth ) {
			_fnCalculateColumnWidths( settings );
		}
	
		for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
			column = columns[i];
	
			if ( column.sWidth ) {
				column.nTh.style.width = _fnStringToCss( column.sWidth );
			}
		}
	
		_fnCallbackFire( settings, null, 'preInit', [settings] );
	
		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw( settings );
	
		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		var dataSrc = _fnDataSource( settings );
		if ( dataSrc != 'ssp' || deferLoading ) {
			// if there is an ajax source load the data
			if ( dataSrc == 'ajax' ) {
				_fnBuildAjax( settings, [], function(json) {
					var aData = _fnAjaxDataSrc( settings, json );
	
					// Got the data - add it to the table
					for ( i=0 ; i<aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}
	
					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;
	
					_fnReDraw( settings );
	
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings, json );
				}, settings );
			}
			else {
				_fnProcessingDisplay( settings, false );
				_fnInitComplete( settings );
			}
		}
	}
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	 *    with client-side processing (optional)
	 *  @memberof DataTable#oApi
	 */
	function _fnInitComplete ( settings, json )
	{
		settings._bInitComplete = true;
	
		// When data was added after the initialisation (data or Ajax) we need to
		// calculate the column sizing
		if ( json || settings.oInit.aaData ) {
			_fnAdjustColumnSizing( settings );
		}
	
		_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
		_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
	}
	
	
	function _fnLengthChange ( settings, val )
	{
		var len = parseInt( val, 10 );
		settings._iDisplayLength = len;
	
		_fnLengthOverflow( settings );
	
		// Fire length change event
		_fnCallbackFire( settings, null, 'length', [settings, len] );
	}
	
	
	/**
	 * Generate the node required for user display length changing
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Display length feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlLength ( settings )
	{
		var
			classes  = settings.oClasses,
			tableId  = settings.sTableId,
			menu     = settings.aLengthMenu,
			d2       = Array.isArray( menu[0] ),
			lengths  = d2 ? menu[0] : menu,
			language = d2 ? menu[1] : menu;
	
		var select = $('<select/>', {
			'name':          tableId+'_length',
			'aria-controls': tableId,
			'class':         classes.sLengthSelect
		} );
	
		for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
			select[0][ i ] = new Option(
				typeof language[i] === 'number' ?
					settings.fnFormatNumber( language[i] ) :
					language[i],
				lengths[i]
			);
		}
	
		var div = $('<div><label/></div>').addClass( classes.sLength );
		if ( ! settings.aanFeatures.l ) {
			div[0].id = tableId+'_length';
		}
	
		div.children().append(
			settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
		);
	
		// Can't use `select` variable as user might provide their own and the
		// reference is broken by the use of outerHTML
		$('select', div)
			.val( settings._iDisplayLength )
			.on( 'change.DT', function(e) {
				_fnLengthChange( settings, $(this).val() );
				_fnDraw( settings );
			} );
	
		// Update node value whenever anything changes the table's length
		$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
			if ( settings === s ) {
				$('select', div).val( len );
			}
		} );
	
		return div[0];
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
	
	/**
	 * Generate the node required for default pagination
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Pagination feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlPaginate ( settings )
	{
		var
			type   = settings.sPaginationType,
			plugin = DataTable.ext.pager[ type ],
			modern = typeof plugin === 'function',
			redraw = function( settings ) {
				_fnDraw( settings );
			},
			node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
			features = settings.aanFeatures;
	
		if ( ! modern ) {
			plugin.fnInit( settings, node, redraw );
		}
	
		/* Add a draw callback for the pagination on first instance, to update the paging display */
		if ( ! features.p )
		{
			node.id = settings.sTableId+'_paginate';
	
			settings.aoDrawCallback.push( {
				"fn": function( settings ) {
					if ( modern ) {
						var
							start      = settings._iDisplayStart,
							len        = settings._iDisplayLength,
							visRecords = settings.fnRecordsDisplay(),
							all        = len === -1,
							page = all ? 0 : Math.ceil( start / len ),
							pages = all ? 1 : Math.ceil( visRecords / len ),
							buttons = plugin(page, pages),
							i, ien;
	
						for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
							_fnRenderer( settings, 'pageButton' )(
								settings, features.p[i], i, buttons, page, pages
							);
						}
					}
					else {
						plugin.fnUpdate( settings, redraw );
					}
				},
				"sName": "pagination"
			} );
		}
	
		return node;
	}
	
	
	/**
	 * Alter the display settings to change the page
	 *  @param {object} settings DataTables settings object
	 *  @param {string|int} action Paging action to take: "first", "previous",
	 *    "next" or "last" or page number to jump to (integer)
	 *  @param [bool] redraw Automatically draw the update or not
	 *  @returns {bool} true page has changed, false - no change
	 *  @memberof DataTable#oApi
	 */
	function _fnPageChange ( settings, action, redraw )
	{
		var
			start     = settings._iDisplayStart,
			len       = settings._iDisplayLength,
			records   = settings.fnRecordsDisplay();
	
		if ( records === 0 || len === -1 )
		{
			start = 0;
		}
		else if ( typeof action === "number" )
		{
			start = action * len;
	
			if ( start > records )
			{
				start = 0;
			}
		}
		else if ( action == "first" )
		{
			start = 0;
		}
		else if ( action == "previous" )
		{
			start = len >= 0 ?
				start - len :
				0;
	
			if ( start < 0 )
			{
			  start = 0;
			}
		}
		else if ( action == "next" )
		{
			if ( start + len < records )
			{
				start += len;
			}
		}
		else if ( action == "last" )
		{
			start = Math.floor( (records-1) / len) * len;
		}
		else
		{
			_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
		}
	
		var changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;
	
		if ( changed ) {
			_fnCallbackFire( settings, null, 'page', [settings] );
	
			if ( redraw ) {
				_fnDraw( settings );
			}
		}
	
		return changed;
	}
	
	
	
	/**
	 * Generate the node required for the processing node
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Processing element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlProcessing ( settings )
	{
		return $('<div/>', {
				'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
				'class': settings.oClasses.sProcessing
			} )
			.html( settings.oLanguage.sProcessing )
			.insertBefore( settings.nTable )[0];
	}
	
	
	/**
	 * Display or hide the processing indicator
	 *  @param {object} settings dataTables settings object
	 *  @param {bool} show Show the processing indicator (true) or not (false)
	 *  @memberof DataTable#oApi
	 */
	function _fnProcessingDisplay ( settings, show )
	{
		if ( settings.oFeatures.bProcessing ) {
			$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
		}
	
		_fnCallbackFire( settings, null, 'processing', [settings, show] );
	}
	
	/**
	 * Add any control elements for the table - specifically scrolling
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Node to add to the DOM
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlTable ( settings )
	{
		var table = $(settings.nTable);
	
		// Scrolling from here on in
		var scroll = settings.oScroll;
	
		if ( scroll.sX === '' && scroll.sY === '' ) {
			return settings.nTable;
		}
	
		var scrollX = scroll.sX;
		var scrollY = scroll.sY;
		var classes = settings.oClasses;
		var caption = table.children('caption');
		var captionSide = caption.length ? caption[0]._captionSide : null;
		var headerClone = $( table[0].cloneNode(false) );
		var footerClone = $( table[0].cloneNode(false) );
		var footer = table.children('tfoot');
		var _div = '<div/>';
		var size = function ( s ) {
			return !s ? null : _fnStringToCss( s );
		};
	
		if ( ! footer.length ) {
			footer = null;
		}
	
		/*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
		var scroller = $( _div, { 'class': classes.sScrollWrapper } )
			.append(
				$(_div, { 'class': classes.sScrollHead } )
					.css( {
						overflow: 'hidden',
						position: 'relative',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollHeadInner } )
							.css( {
								'box-sizing': 'content-box',
								width: scroll.sXInner || '100%'
							} )
							.append(
								headerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'top' ? caption : null )
									.append(
										table.children('thead')
									)
							)
					)
			)
			.append(
				$(_div, { 'class': classes.sScrollBody } )
					.css( {
						position: 'relative',
						overflow: 'auto',
						width: size( scrollX )
					} )
					.append( table )
			);
	
		if ( footer ) {
			scroller.append(
				$(_div, { 'class': classes.sScrollFoot } )
					.css( {
						overflow: 'hidden',
						border: 0,
						width: scrollX ? size(scrollX) : '100%'
					} )
					.append(
						$(_div, { 'class': classes.sScrollFootInner } )
							.append(
								footerClone
									.removeAttr('id')
									.css( 'margin-left', 0 )
									.append( captionSide === 'bottom' ? caption : null )
									.append(
										table.children('tfoot')
									)
							)
					)
			);
		}
	
		var children = scroller.children();
		var scrollHead = children[0];
		var scrollBody = children[1];
		var scrollFoot = footer ? children[2] : null;
	
		// When the body is scrolled, then we also want to scroll the headers
		if ( scrollX ) {
			$(scrollBody).on( 'scroll.DT', function (e) {
				var scrollLeft = this.scrollLeft;
	
				scrollHead.scrollLeft = scrollLeft;
	
				if ( footer ) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			} );
		}
	
		$(scrollBody).css('max-height', scrollY);
		if (! scroll.bCollapse) {
			$(scrollBody).css('height', scrollY);
		}
	
		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;
	
		// On redraw - align columns
		settings.aoDrawCallback.push( {
			"fn": _fnScrollDraw,
			"sName": "scrolling"
		} );
	
		return scroller[0];
	}
	
	
	
	/**
	 * Update the header, footer and body tables for resizing - i.e. column
	 * alignment.
	 *
	 * Welcome to the most horrible function DataTables. The process that this
	 * function follows is basically:
	 *   1. Re-create the table inside the scrolling div
	 *   2. Take live measurements from the DOM
	 *   3. Apply the measurements to align the columns
	 *   4. Clean up
	 *
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnScrollDraw ( settings )
	{
		// Given that this is such a monster function, a lot of variables are use
		// to try and keep the minimised size as small as possible
		var
			scroll         = settings.oScroll,
			scrollX        = scroll.sX,
			scrollXInner   = scroll.sXInner,
			scrollY        = scroll.sY,
			barWidth       = scroll.iBarWidth,
			divHeader      = $(settings.nScrollHead),
			divHeaderStyle = divHeader[0].style,
			divHeaderInner = divHeader.children('div'),
			divHeaderInnerStyle = divHeaderInner[0].style,
			divHeaderTable = divHeaderInner.children('table'),
			divBodyEl      = settings.nScrollBody,
			divBody        = $(divBodyEl),
			divBodyStyle   = divBodyEl.style,
			divFooter      = $(settings.nScrollFoot),
			divFooterInner = divFooter.children('div'),
			divFooterTable = divFooterInner.children('table'),
			header         = $(settings.nTHead),
			table          = $(settings.nTable),
			tableEl        = table[0],
			tableStyle     = tableEl.style,
			footer         = settings.nTFoot ? $(settings.nTFoot) : null,
			browser        = settings.oBrowser,
			ie67           = browser.bScrollOversize,
			dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
			headerTrgEls, footerTrgEls,
			headerSrcEls, footerSrcEls,
			headerCopy, footerCopy,
			headerWidths=[], footerWidths=[],
			headerContent=[], footerContent=[],
			idx, correction, sanityWidth,
			zeroOut = function(nSizer) {
				var style = nSizer.style;
				style.paddingTop = "0";
				style.paddingBottom = "0";
				style.borderTopWidth = "0";
				style.borderBottomWidth = "0";
				style.height = 0;
			};
	
		// If the scrollbar visibility has changed from the last draw, we need to
		// adjust the column sizes as the table width will have changed to account
		// for the scrollbar
		var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
		
		if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
			settings.scrollBarVis = scrollBarVis;
			_fnAdjustColumnSizing( settings );
			return; // adjust column sizing will call this function again
		}
		else {
			settings.scrollBarVis = scrollBarVis;
		}
	
		/*
		 * 1. Re-create the table inside the scrolling div
		 */
	
		// Remove the old minimised thead and tfoot elements in the inner table
		table.children('thead, tfoot').remove();
	
		if ( footer ) {
			footerCopy = footer.clone().prependTo( table );
			footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
			footerSrcEls = footerCopy.find('tr');
		}
	
		// Clone the current header and footer elements and then place it into the inner table
		headerCopy = header.clone().prependTo( table );
		headerTrgEls = header.find('tr'); // original header is in its own table
		headerSrcEls = headerCopy.find('tr');
		headerCopy.find('th, td').removeAttr('tabindex');
	
	
		/*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
	
		// Remove old sizing and apply the calculated column widths
		// Get the unique column headers in the newly created (cloned) header. We want to apply the
		// calculated sizes to this header
		if ( ! scrollX )
		{
			divBodyStyle.width = '100%';
			divHeader[0].style.width = '100%';
		}
	
		$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
			idx = _fnVisibleToColumnIndex( settings, i );
			el.style.width = settings.aoColumns[idx].sWidth;
		} );
	
		if ( footer ) {
			_fnApplyToChildren( function(n) {
				n.style.width = "";
			}, footerSrcEls );
		}
	
		// Size the table as a whole
		sanityWidth = table.outerWidth();
		if ( scrollX === "" ) {
			// No x scrolling
			tableStyle.width = "100%";
	
			// IE7 will make the width of the table when 100% include the scrollbar
			// - which is shouldn't. When there is a scrollbar we need to take this
			// into account.
			if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
			}
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
		else if ( scrollXInner !== "" ) {
			// legacy x scroll inner has been given - use it
			tableStyle.width = _fnStringToCss(scrollXInner);
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
	
		// Hidden header should have zero height, so remove padding and borders. Then
		// set the width based on the real headers
	
		// Apply all styles in one pass
		_fnApplyToChildren( zeroOut, headerSrcEls );
	
		// Read all widths in next pass
		_fnApplyToChildren( function(nSizer) {
			var style = window.getComputedStyle ?
				window.getComputedStyle(nSizer).width :
				_fnStringToCss( $(nSizer).width() );
	
			headerContent.push( nSizer.innerHTML );
			headerWidths.push( style );
		}, headerSrcEls );
	
		// Apply all widths in final pass
		_fnApplyToChildren( function(nToSize, i) {
			nToSize.style.width = headerWidths[i];
		}, headerTrgEls );
	
		$(headerSrcEls).height(0);
	
		/* Same again with the footer if we have one */
		if ( footer )
		{
			_fnApplyToChildren( zeroOut, footerSrcEls );
	
			_fnApplyToChildren( function(nSizer) {
				footerContent.push( nSizer.innerHTML );
				footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, footerSrcEls );
	
			_fnApplyToChildren( function(nToSize, i) {
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls );
	
			$(footerSrcEls).height(0);
		}
	
	
		/*
		 * 3. Apply the measurements
		 */
	
		// "Hide" the header and footer that we used for the sizing. We need to keep
		// the content of the cell so that the width applied to the header and body
		// both match, but we want to hide it completely. We want to also fix their
		// width to what they currently are
		_fnApplyToChildren( function(nSizer, i) {
			nSizer.innerHTML = '<div class="dataTables_sizing">'+headerContent[i]+'</div>';
			nSizer.childNodes[0].style.height = "0";
			nSizer.childNodes[0].style.overflow = "hidden";
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls );
	
		if ( footer )
		{
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing">'+footerContent[i]+'</div>';
				nSizer.childNodes[0].style.height = "0";
				nSizer.childNodes[0].style.overflow = "hidden";
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls );
		}
	
		// Sanity check that the table is of a sensible width. If not then we are going to get
		// misalignment - try to prevent this by not allowing the table to shrink below its min width
		if ( table.outerWidth() < sanityWidth )
		{
			// The min width depends upon if we have a vertical scrollbar visible or not */
			correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
				divBody.css('overflow-y') == "scroll")) ?
					sanityWidth+barWidth :
					sanityWidth;
	
			// IE6/7 are a law unto themselves...
			if ( ie67 && (divBodyEl.scrollHeight >
				divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
			) {
				tableStyle.width = _fnStringToCss( correction-barWidth );
			}
	
			// And give the user a warning that we've stopped the table getting too small
			if ( scrollX === "" || scrollXInner !== "" ) {
				_fnLog( settings, 1, 'Possible column misalignment', 6 );
			}
		}
		else
		{
			correction = '100%';
		}
	
		// Apply to the container elements
		divBodyStyle.width = _fnStringToCss( correction );
		divHeaderStyle.width = _fnStringToCss( correction );
	
		if ( footer ) {
			settings.nScrollFoot.style.width = _fnStringToCss( correction );
		}
	
	
		/*
		 * 4. Clean up
		 */
		if ( ! scrollY ) {
			/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don't want to do it in any other browsers.
			 */
			if ( ie67 ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
			}
		}
	
		/* Finally set the width's of the header and footer tables */
		var iOuterWidth = table.outerWidth();
		divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
	
		// Figure out if there are scrollbar present - if so then we need a the header and footer to
		// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
		var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
		var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
	
		if ( footer ) {
			divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
		}
	
		// Correct DOM ordering for colgroup - comes before the thead
		table.children('colgroup').insertBefore( table.children('thead') );
	
		/* Adjust the position of the header in case we loose the y-scrollbar */
		divBody.trigger('scroll');
	
		// If sorting or filtering has occurred, jump the scrolling back to the top
		// only if we aren't holding the position
		if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
			divBodyEl.scrollTop = 0;
		}
	}
	
	
	
	/**
	 * Apply a given function to the display child nodes of an element array (typically
	 * TD children of TR rows
	 *  @param {function} fn Method to apply to the objects
	 *  @param array {nodes} an1 List of elements to look through for display children
	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyToChildren( fn, an1, an2 )
	{
		var index=0, i=0, iLen=an1.length;
		var nNode1, nNode2;
	
		while ( i < iLen ) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : null;
	
			while ( nNode1 ) {
				if ( nNode1.nodeType === 1 ) {
					if ( an2 ) {
						fn( nNode1, nNode2, index );
					}
					else {
						fn( nNode1, index );
					}
	
					index++;
				}
	
				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : null;
			}
	
			i++;
		}
	}
	
	
	
	var __re_html_remove = /<.*?>/g;
	
	
	/**
	 * Calculate the width of columns for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnCalculateColumnWidths ( oSettings )
	{
		var
			table = oSettings.nTable,
			columns = oSettings.aoColumns,
			scroll = oSettings.oScroll,
			scrollY = scroll.sY,
			scrollX = scroll.sX,
			scrollXInner = scroll.sXInner,
			columnCount = columns.length,
			visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
			headerCells = $('th', oSettings.nTHead),
			tableWidthAttr = table.getAttribute('width'), // from DOM element
			tableContainer = table.parentNode,
			userInputs = false,
			i, column, columnIdx, width, outerWidth,
			browser = oSettings.oBrowser,
			ie67 = browser.bScrollOversize;
	
		var styleWidth = table.style.width;
		if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
			tableWidthAttr = styleWidth;
		}
	
		/* Convert any user input sizes into pixel sizes */
		for ( i=0 ; i<visibleColumns.length ; i++ ) {
			column = columns[ visibleColumns[i] ];
	
			if ( column.sWidth !== null ) {
				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
	
				userInputs = true;
			}
		}
	
		/* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
		if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
		     columnCount == _fnVisbleColumns( oSettings ) &&
		     columnCount == headerCells.length
		) {
			for ( i=0 ; i<columnCount ; i++ ) {
				var colIdx = _fnVisibleToColumnIndex( oSettings, i );
	
				if ( colIdx !== null ) {
					columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
				}
			}
		}
		else
		{
			// Otherwise construct a single row, worst case, table with the widest
			// node in the data, assign any user defined widths, then insert it into
			// the DOM and allow the browser to do all the hard work of calculating
			// table widths
			var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
				.css( 'visibility', 'hidden' )
				.removeAttr( 'id' );
	
			// Clean up the table body
			tmpTable.find('tbody tr').remove();
			var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );
	
			// Clone the table header and footer - we can't use the header / footer
			// from the cloned table, since if scrolling is active, the table's
			// real header and footer are contained in different table tags
			tmpTable.find('thead, tfoot').remove();
			tmpTable
				.append( $(oSettings.nTHead).clone() )
				.append( $(oSettings.nTFoot).clone() );
	
			// Remove any assigned widths from the footer (from scrolling)
			tmpTable.find('tfoot th, tfoot td').css('width', '');
	
			// Apply custom sizing to the cloned header
			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
	
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
	
				headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
					_fnStringToCss( column.sWidthOrig ) :
					'';
	
				// For scrollX we need to force the column width otherwise the
				// browser will collapse it. If this width is smaller than the
				// width the column requires, then it will have no effect
				if ( column.sWidthOrig && scrollX ) {
					$( headerCells[i] ).append( $('<div/>').css( {
						width: column.sWidthOrig,
						margin: 0,
						padding: 0,
						border: 0,
						height: 1
					} ) );
				}
			}
	
			// Find the widest cell for each column and put it into the table
			if ( oSettings.aoData.length ) {
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					columnIdx = visibleColumns[i];
					column = columns[ columnIdx ];
	
					$( _fnGetWidestNode( oSettings, columnIdx ) )
						.clone( false )
						.append( column.sContentPadding )
						.appendTo( tr );
				}
			}
	
			// Tidy the temporary table - remove name attributes so there aren't
			// duplicated in the dom (radio elements for example)
			$('[name]', tmpTable).removeAttr('name');
	
			// Table has been built, attach to the document so we can work with it.
			// A holding element is used, positioned at the top of the container
			// with minimal height, so it has no effect on if the container scrolls
			// or not. Otherwise it might trigger scrolling when it actually isn't
			// needed
			var holder = $('<div/>').css( scrollX || scrollY ?
					{
						position: 'absolute',
						top: 0,
						left: 0,
						height: 1,
						right: 0,
						overflow: 'hidden'
					} :
					{}
				)
				.append( tmpTable )
				.appendTo( tableContainer );
	
			// When scrolling (X or Y) we want to set the width of the table as 
			// appropriate. However, when not scrolling leave the table width as it
			// is. This results in slightly different, but I think correct behaviour
			if ( scrollX && scrollXInner ) {
				tmpTable.width( scrollXInner );
			}
			else if ( scrollX ) {
				tmpTable.css( 'width', 'auto' );
				tmpTable.removeAttr('width');
	
				// If there is no width attribute or style, then allow the table to
				// collapse
				if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
					tmpTable.width( tableContainer.clientWidth );
				}
			}
			else if ( scrollY ) {
				tmpTable.width( tableContainer.clientWidth );
			}
			else if ( tableWidthAttr ) {
				tmpTable.width( tableWidthAttr );
			}
	
			// Get the width of each column in the constructed table - we need to
			// know the inner width (so it can be assigned to the other table's
			// cells) and the outer width so we can calculate the full width of the
			// table. This is safe since DataTables requires a unique cell for each
			// column, but if ever a header can span multiple columns, this will
			// need to be modified.
			var total = 0;
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				var cell = $(headerCells[i]);
				var border = cell.outerWidth() - cell.width();
	
				// Use getBounding... where possible (not IE8-) because it can give
				// sub-pixel accuracy, which we then want to round up!
				var bounding = browser.bBounding ?
					Math.ceil( headerCells[i].getBoundingClientRect().width ) :
					cell.outerWidth();
	
				// Total is tracked to remove any sub-pixel errors as the outerWidth
				// of the table might not equal the total given here (IE!).
				total += bounding;
	
				// Width for each column to use
				columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
			}
	
			table.style.width = _fnStringToCss( total );
	
			// Finished with the table - ditch it
			holder.remove();
		}
	
		// If there is a width attr, we want to attach an event listener which
		// allows the table sizing to automatically adjust when the window is
		// resized. Use the width attr rather than CSS, since we can't know if the
		// CSS is a relative value or absolute - DOM read is always px.
		if ( tableWidthAttr ) {
			table.style.width = _fnStringToCss( tableWidthAttr );
		}
	
		if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
			var bindResize = function () {
				$(window).on('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
					_fnAdjustColumnSizing( oSettings );
				} ) );
			};
	
			// IE6/7 will crash if we bind a resize event handler on page load.
			// To be removed in 1.11 which drops IE6/7 support
			if ( ie67 ) {
				setTimeout( bindResize, 1000 );
			}
			else {
				bindResize();
			}
	
			oSettings._reszEvt = true;
		}
	}
	
	
	/**
	 * Throttle the calls to a function. Arguments and context are maintained for
	 * the throttled function
	 *  @param {function} fn Function to be called
	 *  @param {int} [freq=200] call frequency in mS
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#oApi
	 */
	var _fnThrottle = DataTable.util.throttle;
	
	
	/**
	 * Convert a CSS unit width to pixels (e.g. 2em)
	 *  @param {string} width width to be converted
	 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
	function _fnConvertToWidth ( width, parent )
	{
		if ( ! width ) {
			return 0;
		}
	
		var n = $('<div/>')
			.css( 'width', _fnStringToCss( width ) )
			.appendTo( parent || document.body );
	
		var val = n[0].offsetWidth;
		n.remove();
	
		return val;
	}
	
	
	/**
	 * Get the widest node
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {node} widest table node
	 *  @memberof DataTable#oApi
	 */
	function _fnGetWidestNode( settings, colIdx )
	{
		var idx = _fnGetMaxLenString( settings, colIdx );
		if ( idx < 0 ) {
			return null;
		}
	
		var data = settings.aoData[ idx ];
		return ! data.nTr ? // Might not have been created when deferred rendering
			$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
			data.anCells[ colIdx ];
	}
	
	
	/**
	 * Get the maximum strlen for each data column
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {string} max string length for each column
	 *  @memberof DataTable#oApi
	 */
	function _fnGetMaxLenString( settings, colIdx )
	{
		var s, max=-1, maxIdx = -1;
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
			s = s.replace( __re_html_remove, '' );
			s = s.replace( /&nbsp;/g, ' ' );
	
			if ( s.length > max ) {
				max = s.length;
				maxIdx = i;
			}
		}
	
		return maxIdx;
	}
	
	
	/**
	 * Append a CSS unit (only if required) to a string
	 *  @param {string} value to css-ify
	 *  @returns {string} value with css unit
	 *  @memberof DataTable#oApi
	 */
	function _fnStringToCss( s )
	{
		if ( s === null ) {
			return '0px';
		}
	
		if ( typeof s == 'number' ) {
			return s < 0 ?
				'0px' :
				s+'px';
		}
	
		// Check it has a unit character already
		return s.match(/\d$/) ?
			s+'px' :
			s;
	}
	
	
	
	function _fnSortFlatten ( settings )
	{
		var
			i, iLen, k, kLen,
			aSort = [],
			aiOrig = [],
			aoColumns = settings.aoColumns,
			aDataSort, iCol, sType, srcCol,
			fixed = settings.aaSortingFixed,
			fixedObj = $.isPlainObject( fixed ),
			nestedSort = [],
			add = function ( a ) {
				if ( a.length && ! Array.isArray( a[0] ) ) {
					// 1D array
					nestedSort.push( a );
				}
				else {
					// 2D array
					$.merge( nestedSort, a );
				}
			};
	
		// Build the sort array, with pre-fix and post-fix options if they have been
		// specified
		if ( Array.isArray( fixed ) ) {
			add( fixed );
		}
	
		if ( fixedObj && fixed.pre ) {
			add( fixed.pre );
		}
	
		add( settings.aaSorting );
	
		if (fixedObj && fixed.post ) {
			add( fixed.post );
		}
	
		for ( i=0 ; i<nestedSort.length ; i++ )
		{
			srcCol = nestedSort[i][0];
			aDataSort = aoColumns[ srcCol ].aDataSort;
	
			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';
	
				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
				}
	
				aSort.push( {
					src:       srcCol,
					col:       iCol,
					dir:       nestedSort[i][1],
					index:     nestedSort[i]._idx,
					type:      sType,
					formatter: DataTable.ext.type.order[ sType+"-pre" ]
				} );
			}
		}
	
		return aSort;
	}
	
	/**
	 * Change the order of the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 *  @todo This really needs split up!
	 */
	function _fnSort ( oSettings )
	{
		var
			i, ien, iLen, j, jLen, k, kLen,
			sDataType, nTh,
			aiOrig = [],
			oExtSort = DataTable.ext.type.order,
			aoData = oSettings.aoData,
			aoColumns = oSettings.aoColumns,
			aDataSort, data, iCol, sType, oSort,
			formatters = 0,
			sortCol,
			displayMaster = oSettings.aiDisplayMaster,
			aSort;
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo Can this be moved into a 'data-ready' handler which is called when
		//   data is going to be used in the table?
		_fnColumnTypes( oSettings );
	
		aSort = _fnSortFlatten( oSettings );
	
		for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
			sortCol = aSort[i];
	
			// Track if we can use the fast sort algorithm
			if ( sortCol.formatter ) {
				formatters++;
			}
	
			// Load the data needed for the sort, for each cell
			_fnSortData( oSettings, sortCol.col );
		}
	
		/* No sorting required if server-side or no sorting array */
		if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
		{
			// Create a value - key array of the current row positions such that we can use their
			// current position during the sort, if values match, in order to perform stable sorting
			for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
				aiOrig[ displayMaster[i] ] = i;
			}
	
			/* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
			 * follow on it's own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort['string-asc']('data11', 'data12');
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort['numeric-desc']('data21', 'data22');
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
			if ( formatters === aSort.length ) {
				// All sort types have formatting functions
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, test, sort,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						test = x<y ? -1 : x>y ? 1 : 0;
						if ( test !== 0 ) {
							return sort.dir === 'asc' ? test : -test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
			else {
				// Depreciated - remove in 1.11 (providing a plug-in option)
				// Not all sort types have formatting methods, so we have to call their sorting
				// methods.
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, l, test, sort, fn,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k<len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
						test = fn( x, y );
						if ( test !== 0 ) {
							return test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x<y ? -1 : x>y ? 1 : 0;
				} );
			}
		}
	
		/* Tell the draw function that we have sorted the data */
		oSettings.bSorted = true;
	}
	
	
	function _fnSortAria ( settings )
	{
		var label;
		var nextSort;
		var columns = settings.aoColumns;
		var aSort = _fnSortFlatten( settings );
		var oAria = settings.oLanguage.oAria;
	
		// ARIA attributes - need to loop all columns, to update all (removing old
		// attributes as needed)
		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
		{
			var col = columns[i];
			var asSorting = col.asSorting;
			var sTitle = col.ariaTitle || col.sTitle.replace( /<.*?>/g, "" );
			var th = col.nTh;
	
			// IE7 is throwing an error when setting these properties with jQuery's
			// attr() and removeAttr() methods...
			th.removeAttribute('aria-sort');
	
			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
			if ( col.bSortable ) {
				if ( aSort.length > 0 && aSort[0].col == i ) {
					th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
					nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
				}
				else {
					nextSort = asSorting[0];
				}
	
				label = sTitle + ( nextSort === "asc" ?
					oAria.sSortAscending :
					oAria.sSortDescending
				);
			}
			else {
				label = sTitle;
			}
	
			th.setAttribute('aria-label', label);
		}
	}
	
	
	/**
	 * Function to run on user sort request
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {boolean} [append=false] Append the requested sort to the existing
	 *    sort if true (i.e. multi-column sort)
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortListener ( settings, colIdx, append, callback )
	{
		var col = settings.aoColumns[ colIdx ];
		var sorting = settings.aaSorting;
		var asSorting = col.asSorting;
		var nextSortIdx;
		var next = function ( a, overflow ) {
			var idx = a._idx;
			if ( idx === undefined ) {
				idx = $.inArray( a[1], asSorting );
			}
	
			return idx+1 < asSorting.length ?
				idx+1 :
				overflow ?
					null :
					0;
		};
	
		// Convert to 2D array if needed
		if ( typeof sorting[0] === 'number' ) {
			sorting = settings.aaSorting = [ sorting ];
		}
	
		// If appending the sort then we are multi-column sorting
		if ( append && settings.oFeatures.bSortMulti ) {
			// Are we already doing some kind of sort on this column?
			var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
	
			if ( sortIdx !== -1 ) {
				// Yes, modify the sort
				nextSortIdx = next( sorting[sortIdx], true );
	
				if ( nextSortIdx === null && sorting.length === 1 ) {
					nextSortIdx = 0; // can't remove sorting completely
				}
	
				if ( nextSortIdx === null ) {
					sorting.splice( sortIdx, 1 );
				}
				else {
					sorting[sortIdx][1] = asSorting[ nextSortIdx ];
					sorting[sortIdx]._idx = nextSortIdx;
				}
			}
			else {
				// No sort on this column yet
				sorting.push( [ colIdx, asSorting[0], 0 ] );
				sorting[sorting.length-1]._idx = 0;
			}
		}
		else if ( sorting.length && sorting[0][0] == colIdx ) {
			// Single column - already sorting on this column, modify the sort
			nextSortIdx = next( sorting[0] );
	
			sorting.length = 1;
			sorting[0][1] = asSorting[ nextSortIdx ];
			sorting[0]._idx = nextSortIdx;
		}
		else {
			// Single column - sort only on this column
			sorting.length = 0;
			sorting.push( [ colIdx, asSorting[0] ] );
			sorting[0]._idx = 0;
		}
	
		// Run the sort by calling a full redraw
		_fnReDraw( settings );
	
		// callback used for async user interaction
		if ( typeof callback == 'function' ) {
			callback( settings );
		}
	}
	
	
	/**
	 * Attach a sort handler (click) to a node
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
	{
		var col = settings.aoColumns[ colIdx ];
	
		_fnBindAction( attachTo, {}, function (e) {
			/* If the column is not sortable - don't to anything */
			if ( col.bSortable === false ) {
				return;
			}
	
			// If processing is enabled use a timeout to allow the processing
			// display to be shown - otherwise to it synchronously
			if ( settings.oFeatures.bProcessing ) {
				_fnProcessingDisplay( settings, true );
	
				setTimeout( function() {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
	
					// In server-side processing, the draw callback will remove the
					// processing display
					if ( _fnDataSource( settings ) !== 'ssp' ) {
						_fnProcessingDisplay( settings, false );
					}
				}, 0 );
			}
			else {
				_fnSortListener( settings, colIdx, e.shiftKey, callback );
			}
		} );
	}
	
	
	/**
	 * Set the sorting classes on table's body, Note: it is safe to call this function
	 * when bSort and bSortClasses are false
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSortingClasses( settings )
	{
		var oldSort = settings.aLastSort;
		var sortClass = settings.oClasses.sSortColumn;
		var sort = _fnSortFlatten( settings );
		var features = settings.oFeatures;
		var i, ien, colIdx;
	
		if ( features.bSort && features.bSortClasses ) {
			// Remove old sorting classes
			for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
				colIdx = oldSort[i].src;
	
				// Remove column sorting
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.removeClass( sortClass + (i<2 ? i+1 : 3) );
			}
	
			// Add new column sorting
			for ( i=0, ien=sort.length ; i<ien ; i++ ) {
				colIdx = sort[i].src;
	
				$( _pluck( settings.aoData, 'anCells', colIdx ) )
					.addClass( sortClass + (i<2 ? i+1 : 3) );
			}
		}
	
		settings.aLastSort = sort;
	}
	
	
	// Get the data to sort a column, be it from cache, fresh (populating the
	// cache), or from a sort formatter
	function _fnSortData( settings, idx )
	{
		// Custom sorting function - provided by the sort data type
		var column = settings.aoColumns[ idx ];
		var customSort = DataTable.ext.order[ column.sSortDataType ];
		var customData;
	
		if ( customSort ) {
			customData = customSort.call( settings.oInstance, settings, idx,
				_fnColumnIndexToVisible( settings, idx )
			);
		}
	
		// Use / populate cache
		var row, cellData;
		var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	
		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aSortData ) {
				row._aSortData = [];
			}
	
			if ( ! row._aSortData[idx] || customSort ) {
				cellData = customSort ?
					customData[i] : // If there was a custom sort function, use data from there
					_fnGetCellData( settings, i, idx, 'sort' );
	
				row._aSortData[ idx ] = formatter ?
					formatter( cellData ) :
					cellData;
			}
		}
	}
	
	
	
	/**
	 * Save the state of a table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSaveState ( settings )
	{
		if (settings._bLoadingState) {
			return;
		}
	
		/* Store the interesting variables */
		var state = {
			time:    +new Date(),
			start:   settings._iDisplayStart,
			length:  settings._iDisplayLength,
			order:   $.extend( true, [], settings.aaSorting ),
			search:  _fnSearchToCamel( settings.oPreviousSearch ),
			columns: $.map( settings.aoColumns, function ( col, i ) {
				return {
					visible: col.bVisible,
					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
				};
			} )
		};
	
		settings.oSavedState = state;
		_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
		
		if ( settings.oFeatures.bStateSave && !settings.bDestroying )
		{
			settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
		}	
	}
	
	
	/**
	 * Attempt to load a saved table state
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oInit DataTables init object so we can override settings
	 *  @param {function} callback Callback to execute when the state has been loaded
	 *  @memberof DataTable#oApi
	 */
	function _fnLoadState ( settings, oInit, callback )
	{
		if ( ! settings.oFeatures.bStateSave ) {
			callback();
			return;
		}
	
		var loaded = function(state) {
			_fnImplementState(settings, state, callback);
		}
	
		var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );
	
		if ( state !== undefined ) {
			_fnImplementState( settings, state, callback );
		}
		// otherwise, wait for the loaded callback to be executed
	
		return true;
	}
	
	function _fnImplementState ( settings, s, callback) {
		var i, ien;
		var columns = settings.aoColumns;
		settings._bLoadingState = true;
	
		// When StateRestore was introduced the state could now be implemented at any time
		// Not just initialisation. To do this an api instance is required in some places
		var api = settings._bInitComplete ? new DataTable.Api(settings) : null;
	
		if ( ! s || ! s.time ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Allow custom and plug-in manipulation functions to alter the saved data set and
		// cancelling of loading by returning false
		var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
		if ( $.inArray( false, abStateLoad ) !== -1 ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Reject old data
		var duration = settings.iStateDuration;
		if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Number of columns have changed - all bets are off, no restore of settings
		if ( s.columns && columns.length !== s.columns.length ) {
			settings._bLoadingState = false;
			callback();
			return;
		}
	
		// Store the saved state so it might be accessed at any time
		settings.oLoadedState = $.extend( true, {}, s );
	
		// Restore key features - todo - for 1.11 this needs to be done by
		// subscribed events
		if ( s.start !== undefined ) {
			settings._iDisplayStart    = s.start;
			if(api === null) {
				settings.iInitDisplayStart = s.start;
			}
		}
		if ( s.length !== undefined ) {
			settings._iDisplayLength   = s.length;
		}
	
		// Order
		if ( s.order !== undefined ) {
			settings.aaSorting = [];
			$.each( s.order, function ( i, col ) {
				settings.aaSorting.push( col[0] >= columns.length ?
					[ 0, col[1] ] :
					col
				);
			} );
		}
	
		// Search
		if ( s.search !== undefined ) {
			$.extend( settings.oPreviousSearch, _fnSearchToHung( s.search ) );
		}
	
		// Columns
		if ( s.columns ) {
			for ( i=0, ien=s.columns.length ; i<ien ; i++ ) {
				var col = s.columns[i];
	
				// Visibility
				if ( col.visible !== undefined ) {
					// If the api is defined, the table has been initialised so we need to use it rather than internal settings
					if (api) {
						// Don't redraw the columns on every iteration of this loop, we will do this at the end instead
						api.column(i).visible(col.visible, false);
					}
					else {
						columns[i].bVisible = col.visible;
					}
				}
	
				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
				}
			}
			
			// If the api is defined then we need to adjust the columns once the visibility has been changed
			if (api) {
				api.columns.adjust();
			}
		}
	
		settings._bLoadingState = false;
		_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
		callback();
	};
	
	
	/**
	 * Return the settings object for a particular table
	 *  @param {node} table table we are using as a dataTable
	 *  @returns {object} Settings object - or null if not found
	 *  @memberof DataTable#oApi
	 */
	function _fnSettingsFromNode ( table )
	{
		var settings = DataTable.settings;
		var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
	
		return idx !== -1 ?
			settings[ idx ] :
			null;
	}
	
	
	/**
	 * Log an error message
	 *  @param {object} settings dataTables settings object
	 *  @param {int} level log error messages, or display them to the user
	 *  @param {string} msg error message
	 *  @param {int} tn Technical note id to get more information about the error.
	 *  @memberof DataTable#oApi
	 */
	function _fnLog( settings, level, msg, tn )
	{
		msg = 'DataTables warning: '+
			(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;
	
		if ( tn ) {
			msg += '. For more information about this error, please see '+
			'http://datatables.net/tn/'+tn;
		}
	
		if ( ! level  ) {
			// Backwards compatibility pre 1.10
			var ext = DataTable.ext;
			var type = ext.sErrMode || ext.errMode;
	
			if ( settings ) {
				_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
			}
	
			if ( type == 'alert' ) {
				alert( msg );
			}
			else if ( type == 'throw' ) {
				throw new Error(msg);
			}
			else if ( typeof type == 'function' ) {
				type( settings, tn, msg );
			}
		}
		else if ( window.console && console.log ) {
			console.log( msg );
		}
	}
	
	
	/**
	 * See if a property is defined on one object, if so assign it to the other object
	 *  @param {object} ret target object
	 *  @param {object} src source object
	 *  @param {string} name property
	 *  @param {string} [mappedName] name to map too - optional, name used if not given
	 *  @memberof DataTable#oApi
	 */
	function _fnMap( ret, src, name, mappedName )
	{
		if ( Array.isArray( name ) ) {
			$.each( name, function (i, val) {
				if ( Array.isArray( val ) ) {
					_fnMap( ret, src, val[0], val[1] );
				}
				else {
					_fnMap( ret, src, val );
				}
			} );
	
			return;
		}
	
		if ( mappedName === undefined ) {
			mappedName = name;
		}
	
		if ( src[name] !== undefined ) {
			ret[mappedName] = src[name];
		}
	}
	
	
	/**
	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	 * shallow copy arrays. The reason we need to do this, is that we don't want to
	 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	 * able to override them, but we do want to deep copy arrays.
	 *  @param {object} out Object to extend
	 *  @param {object} extender Object from which the properties will be applied to
	 *      out
	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	 *      independent copy with the exception of the `data` or `aaData` parameters
	 *      if they are present. This is so you can pass in a collection to
	 *      DataTables and have that used as your data source without breaking the
	 *      references
	 *  @returns {object} out Reference, just for convenience - out === the return.
	 *  @memberof DataTable#oApi
	 *  @todo This doesn't take account of arrays inside the deep copied objects.
	 */
	function _fnExtend( out, extender, breakRefs )
	{
		var val;
	
		for ( var prop in extender ) {
			if ( extender.hasOwnProperty(prop) ) {
				val = extender[prop];
	
				if ( $.isPlainObject( val ) ) {
					if ( ! $.isPlainObject( out[prop] ) ) {
						out[prop] = {};
					}
					$.extend( true, out[prop], val );
				}
				else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val) ) {
					out[prop] = val.slice();
				}
				else {
					out[prop] = val;
				}
			}
		}
	
		return out;
	}
	
	
	/**
	 * Bind an event handers to allow a click or return key to activate the callback.
	 * This is good for accessibility since a return on the keyboard will have the
	 * same effect as a click, if the element has focus.
	 *  @param {element} n Element to bind the action to
	 *  @param {object} oData Data object to pass to the triggered function
	 *  @param {function} fn Callback function for when the event is triggered
	 *  @memberof DataTable#oApi
	 */
	function _fnBindAction( n, oData, fn )
	{
		$(n)
			.on( 'click.DT', oData, function (e) {
					$(n).trigger('blur'); // Remove focus outline for mouse users
					fn(e);
				} )
			.on( 'keypress.DT', oData, function (e){
					if ( e.which === 13 ) {
						e.preventDefault();
						fn(e);
					}
				} )
			.on( 'selectstart.DT', function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
				} );
	}
	
	
	/**
	 * Register a callback function. Easily allows a callback function to be added to
	 * an array store of callback functions that can then all be called together.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	 *  @param {function} fn Function to be called back
	 *  @param {string} sName Identifying name for the callback (i.e. a label)
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackReg( oSettings, sStore, fn, sName )
	{
		if ( fn )
		{
			oSettings[sStore].push( {
				"fn": fn,
				"sName": sName
			} );
		}
	}
	
	
	/**
	 * Fire callback functions and trigger events. Note that the loop over the
	 * callback array store is done backwards! Further note that you do not want to
	 * fire off triggers in time sensitive applications (for example cell creation)
	 * as its slow.
	 *  @param {object} settings dataTables settings object
	 *  @param {string} callbackArr Name of the array storage for the callbacks in
	 *      oSettings
	 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	 *      null no trigger is fired
	 *  @param {array} args Array of arguments to pass to the callback function /
	 *      trigger
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackFire( settings, callbackArr, eventName, args )
	{
		var ret = [];
	
		if ( callbackArr ) {
			ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
				return val.fn.apply( settings.oInstance, args );
			} );
		}
	
		if ( eventName !== null ) {
			var e = $.Event( eventName+'.dt' );
	
			$(settings.nTable).trigger( e, args );
	
			ret.push( e.result );
		}
	
		return ret;
	}
	
	
	function _fnLengthOverflow ( settings )
	{
		var
			start = settings._iDisplayStart,
			end = settings.fnDisplayEnd(),
			len = settings._iDisplayLength;
	
		/* If we have space to show extra rows (backing up from the end point - then do so */
		if ( start >= end )
		{
			start = end - len;
		}
	
		// Keep the start record on the current page
		start -= (start % len);
	
		if ( len === -1 || start < 0 )
		{
			start = 0;
		}
	
		settings._iDisplayStart = start;
	}
	
	
	function _fnRenderer( settings, type )
	{
		var renderer = settings.renderer;
		var host = DataTable.ext.renderer[type];
	
		if ( $.isPlainObject( renderer ) && renderer[type] ) {
			// Specific renderer for this type. If available use it, otherwise use
			// the default.
			return host[renderer[type]] || host._;
		}
		else if ( typeof renderer === 'string' ) {
			// Common renderer - if there is one available for this type use it,
			// otherwise use the default
			return host[renderer] || host._;
		}
	
		// Use the default
		return host._;
	}
	
	
	/**
	 * Detect the data source being used for the table. Used to simplify the code
	 * a little (ajax) and to make it compress a little smaller.
	 *
	 *  @param {object} settings dataTables settings object
	 *  @returns {string} Data source
	 *  @memberof DataTable#oApi
	 */
	function _fnDataSource ( settings )
	{
		if ( settings.oFeatures.bServerSide ) {
			return 'ssp';
		}
		else if ( settings.ajax || settings.sAjaxSource ) {
			return 'ajax';
		}
		return 'dom';
	}
	

	
	
	/**
	 * Computed structure of the DataTables API, defined by the options passed to
	 * `DataTable.Api.register()` when building the API.
	 *
	 * The structure is built in order to speed creation and extension of the Api
	 * objects since the extensions are effectively pre-parsed.
	 *
	 * The array is an array of objects with the following structure, where this
	 * base array represents the Api prototype base:
	 *
	 *     [
	 *       {
	 *         name:      'data'                -- string   - Property name
	 *         val:       function () {},       -- function - Api method (or undefined if just an object
	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	 *       },
	 *       {
	 *         name:     'row'
	 *         val:       {},
	 *         methodExt: [ ... ],
	 *         propExt:   [
	 *           {
	 *             name:      'data'
	 *             val:       function () {},
	 *             methodExt: [ ... ],
	 *             propExt:   [ ... ]
	 *           },
	 *           ...
	 *         ]
	 *       }
	 *     ]
	 *
	 * @type {Array}
	 * @ignore
	 */
	var __apiStruct = [];
	
	
	/**
	 * `Array.prototype` reference.
	 *
	 * @type object
	 * @ignore
	 */
	var __arrayProto = Array.prototype;
	
	
	/**
	 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	 * take several different forms for ease of use.
	 *
	 * Each of the input parameter types will be converted to a DataTables settings
	 * object where possible.
	 *
	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	 *   of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 *   * `DataTables.Api` - API instance
	 * @return {array|null} Matching DataTables settings objects. `null` or
	 *   `undefined` is returned if no matching DataTable is found.
	 * @ignore
	 */
	var _toSettings = function ( mixed )
	{
		var idx, jq;
		var settings = DataTable.settings;
		var tables = $.map( settings, function (el, i) {
			return el.nTable;
		} );
	
		if ( ! mixed ) {
			return [];
		}
		else if ( mixed.nTable && mixed.oApi ) {
			// DataTables settings object
			return [ mixed ];
		}
		else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
			// Table node
			idx = $.inArray( mixed, tables );
			return idx !== -1 ? [ settings[idx] ] : null;
		}
		else if ( mixed && typeof mixed.settings === 'function' ) {
			return mixed.settings().toArray();
		}
		else if ( typeof mixed === 'string' ) {
			// jQuery selector
			jq = $(mixed);
		}
		else if ( mixed instanceof $ ) {
			// jQuery object (also DataTables instance)
			jq = mixed;
		}
	
		if ( jq ) {
			return jq.map( function(i) {
				idx = $.inArray( this, tables );
				return idx !== -1 ? settings[idx] : null;
			} ).toArray();
		}
	};
	
	
	/**
	 * DataTables API class - used to control and interface with  one or more
	 * DataTables enhanced tables.
	 *
	 * The API class is heavily based on jQuery, presenting a chainable interface
	 * that you can use to interact with tables. Each instance of the API class has
	 * a "context" - i.e. the tables that it will operate on. This could be a single
	 * table, all tables on a page or a sub-set thereof.
	 *
	 * Additionally the API is designed to allow you to easily work with the data in
	 * the tables, retrieving and manipulating it as required. This is done by
	 * presenting the API class as an array like interface. The contents of the
	 * array depend upon the actions requested by each method (for example
	 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	 * return an array of objects or arrays depending upon your table's
	 * configuration). The API object has a number of array like methods (`push`,
	 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	 * `unique` etc) to assist your working with the data held in a table.
	 *
	 * Most methods (those which return an Api instance) are chainable, which means
	 * the return from a method call also has all of the methods available that the
	 * top level object had. For example, these two calls are equivalent:
	 *
	 *     // Not chained
	 *     api.row.add( {...} );
	 *     api.draw();
	 *
	 *     // Chained
	 *     api.row.add( {...} ).draw();
	 *
	 * @class DataTable.Api
	 * @param {array|object|string|jQuery} context DataTable identifier. This is
	 *   used to define which DataTables enhanced tables this API will operate on.
	 *   Can be one of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 * @param {array} [data] Data to initialise the Api instance with.
	 *
	 * @example
	 *   // Direct initialisation during DataTables construction
	 *   var api = $('#example').DataTable();
	 *
	 * @example
	 *   // Initialisation using a DataTables jQuery object
	 *   var api = $('#example').dataTable().api();
	 *
	 * @example
	 *   // Initialisation as a constructor
	 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	 */
	_Api = function ( context, data )
	{
		if ( ! (this instanceof _Api) ) {
			return new _Api( context, data );
		}
	
		var settings = [];
		var ctxSettings = function ( o ) {
			var a = _toSettings( o );
			if ( a ) {
				settings.push.apply( settings, a );
			}
		};
	
		if ( Array.isArray( context ) ) {
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				ctxSettings( context[i] );
			}
		}
		else {
			ctxSettings( context );
		}
	
		// Remove duplicates
		this.context = _unique( settings );
	
		// Initial data
		if ( data ) {
			$.merge( this, data );
		}
	
		// selector
		this.selector = {
			rows: null,
			cols: null,
			opts: null
		};
	
		_Api.extend( this, this, __apiStruct );
	};
	
	DataTable.Api = _Api;
	
	// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
	// isPlainObject.
	$.extend( _Api.prototype, {
		any: function ()
		{
			return this.count() !== 0;
		},
	
	
		concat:  __arrayProto.concat,
	
	
		context: [], // array of table settings objects
	
	
		count: function ()
		{
			return this.flatten().length;
		},
	
	
		each: function ( fn )
		{
			for ( var i=0, ien=this.length ; i<ien; i++ ) {
				fn.call( this, this[i], i, this );
			}
	
			return this;
		},
	
	
		eq: function ( idx )
		{
			var ctx = this.context;
	
			return ctx.length > idx ?
				new _Api( ctx[idx], this[idx] ) :
				null;
		},
	
	
		filter: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.filter ) {
				a = __arrayProto.filter.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					if ( fn.call( this, this[i], i, this ) ) {
						a.push( this[i] );
					}
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		flatten: function ()
		{
			var a = [];
			return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
		},
	
	
		join:    __arrayProto.join,
	
	
		indexOf: __arrayProto.indexOf || function (obj, start)
		{
			for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
				if ( this[i] === obj ) {
					return i;
				}
			}
			return -1;
		},
	
		iterator: function ( flatten, type, fn, alwaysNew ) {
			var
				a = [], ret,
				i, ien, j, jen,
				context = this.context,
				rows, items, item,
				selector = this.selector;
	
			// Argument shifting
			if ( typeof flatten === 'string' ) {
				alwaysNew = fn;
				fn = type;
				type = flatten;
				flatten = false;
			}
	
			for ( i=0, ien=context.length ; i<ien ; i++ ) {
				var apiInst = new _Api( context[i] );
	
				if ( type === 'table' ) {
					ret = fn.call( apiInst, context[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'columns' || type === 'rows' ) {
					// this has same length as context - one entry for each table
					ret = fn.call( apiInst, context[i], this[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
					// columns and rows share the same structure.
					// 'this' is an array of column indexes for each context
					items = this[i];
	
					if ( type === 'column-rows' ) {
						rows = _selector_row_indexes( context[i], selector.opts );
					}
	
					for ( j=0, jen=items.length ; j<jen ; j++ ) {
						item = items[j];
	
						if ( type === 'cell' ) {
							ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
						}
						else {
							ret = fn.call( apiInst, context[i], item, i, j, rows );
						}
	
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
				}
			}
	
			if ( a.length || alwaysNew ) {
				var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
				var apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				return api;
			}
			return this;
		},
	
	
		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
		{
			// Bit cheeky...
			return this.indexOf.apply( this.toArray.reverse(), arguments );
		},
	
	
		length:  0,
	
	
		map: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.map ) {
				a = __arrayProto.map.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i<ien ; i++ ) {
					a.push( fn.call( this, this[i], i ) );
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		pluck: function ( prop )
		{
			return this.map( function ( el ) {
				return el[ prop ];
			} );
		},
	
		pop:     __arrayProto.pop,
	
	
		push:    __arrayProto.push,
	
	
		// Does not return an API instance
		reduce: __arrayProto.reduce || function ( fn, init )
		{
			return _fnReduce( this, fn, init, 0, this.length, 1 );
		},
	
	
		reduceRight: __arrayProto.reduceRight || function ( fn, init )
		{
			return _fnReduce( this, fn, init, this.length-1, -1, -1 );
		},
	
	
		reverse: __arrayProto.reverse,
	
	
		// Object with rows, columns and opts
		selector: null,
	
	
		shift:   __arrayProto.shift,
	
	
		slice: function () {
			return new _Api( this.context, this );
		},
	
	
		sort:    __arrayProto.sort, // ? name - order?
	
	
		splice:  __arrayProto.splice,
	
	
		toArray: function ()
		{
			return __arrayProto.slice.call( this );
		},
	
	
		to$: function ()
		{
			return $( this );
		},
	
	
		toJQuery: function ()
		{
			return $( this );
		},
	
	
		unique: function ()
		{
			return new _Api( this.context, _unique(this) );
		},
	
	
		unshift: __arrayProto.unshift
	} );
	
	
	_Api.extend = function ( scope, obj, ext )
	{
		// Only extend API instances and static properties of the API
		if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
			return;
		}
	
		var
			i, ien,
			struct,
			methodScoping = function ( scope, fn, struc ) {
				return function () {
					var ret = fn.apply( scope, arguments );
	
					// Method extension
					_Api.extend( ret, ret, struc.methodExt );
					return ret;
				};
			};
	
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			struct = ext[i];
	
			// Value
			obj[ struct.name ] = struct.type === 'function' ?
				methodScoping( scope, struct.val, struct ) :
				struct.type === 'object' ?
					{} :
					struct.val;
	
			obj[ struct.name ].__dt_wrapper = true;
	
			// Property extension
			_Api.extend( scope, obj[ struct.name ], struct.propExt );
		}
	};
	
	
	// @todo - Is there need for an augment function?
	// _Api.augment = function ( inst, name )
	// {
	// 	// Find src object in the structure from the name
	// 	var parts = name.split('.');
	
	// 	_Api.extend( inst, obj );
	// };
	
	
	//     [
	//       {
	//         name:      'data'                -- string   - Property name
	//         val:       function () {},       -- function - Api method (or undefined if just an object
	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	//       },
	//       {
	//         name:     'row'
	//         val:       {},
	//         methodExt: [ ... ],
	//         propExt:   [
	//           {
	//             name:      'data'
	//             val:       function () {},
	//             methodExt: [ ... ],
	//             propExt:   [ ... ]
	//           },
	//           ...
	//         ]
	//       }
	//     ]
	
	_Api.register = _api_register = function ( name, val )
	{
		if ( Array.isArray( name ) ) {
			for ( var j=0, jen=name.length ; j<jen ; j++ ) {
				_Api.register( name[j], val );
			}
			return;
		}
	
		var
			i, ien,
			heir = name.split('.'),
			struct = __apiStruct,
			key, method;
	
		var find = function ( src, name ) {
			for ( var i=0, ien=src.length ; i<ien ; i++ ) {
				if ( src[i].name === name ) {
					return src[i];
				}
			}
			return null;
		};
	
		for ( i=0, ien=heir.length ; i<ien ; i++ ) {
			method = heir[i].indexOf('()') !== -1;
			key = method ?
				heir[i].replace('()', '') :
				heir[i];
	
			var src = find( struct, key );
			if ( ! src ) {
				src = {
					name:      key,
					val:       {},
					methodExt: [],
					propExt:   [],
					type:      'object'
				};
				struct.push( src );
			}
	
			if ( i === ien-1 ) {
				src.val = val;
				src.type = typeof val === 'function' ?
					'function' :
					$.isPlainObject( val ) ?
						'object' :
						'other';
			}
			else {
				struct = method ?
					src.methodExt :
					src.propExt;
			}
		}
	};
	
	_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
		_Api.register( pluralName, val );
	
		_Api.register( singularName, function () {
			var ret = val.apply( this, arguments );
	
			if ( ret === this ) {
				// Returned item is the API instance that was passed in, return it
				return this;
			}
			else if ( ret instanceof _Api ) {
				// New API instance returned, want the value from the first item
				// in the returned array for the singular result.
				return ret.length ?
					Array.isArray( ret[0] ) ?
						new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
						ret[0] :
					undefined;
			}
	
			// Non-API return - just fire it back
			return ret;
		} );
	};
	
	
	/**
	 * Selector for HTML tables. Apply the given selector to the give array of
	 * DataTables settings objects.
	 *
	 * @param {string|integer} [selector] jQuery selector string or integer
	 * @param  {array} Array of DataTables settings objects to be filtered
	 * @return {array}
	 * @ignore
	 */
	var __table_selector = function ( selector, a )
	{
		if ( Array.isArray(selector) ) {
			return $.map( selector, function (item) {
				return __table_selector(item, a);
			} );
		}
	
		// Integer is used to pick out a table by index
		if ( typeof selector === 'number' ) {
			return [ a[ selector ] ];
		}
	
		// Perform a jQuery selector on the table nodes
		var nodes = $.map( a, function (el, i) {
			return el.nTable;
		} );
	
		return $(nodes)
			.filter( selector )
			.map( function (i) {
				// Need to translate back from the table node to the settings
				var idx = $.inArray( this, nodes );
				return a[ idx ];
			} )
			.toArray();
	};
	
	
	
	/**
	 * Context selector for the API's context (i.e. the tables the API instance
	 * refers to.
	 *
	 * @name    DataTable.Api#tables
	 * @param {string|integer} [selector] Selector to pick which tables the iterator
	 *   should operate on. If not given, all tables in the current context are
	 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	 *   select multiple tables or as an integer to select a single table.
	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	 */
	_api_register( 'tables()', function ( selector ) {
		// A new instance is created if there was a selector specified
		return selector !== undefined && selector !== null ?
			new _Api( __table_selector( selector, this.context ) ) :
			this;
	} );
	
	
	_api_register( 'table()', function ( selector ) {
		var tables = this.tables( selector );
		var ctx = tables.context;
	
		// Truncate to the first matched table
		return ctx.length ?
			new _Api( ctx[0] ) :
			tables;
	} );
	
	
	_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTable;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().body()', 'table().body()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTBody;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().header()', 'table().header()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTHead;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTFoot;
		}, 1 );
	} );
	
	
	_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
		return this.iterator( 'table', function ( ctx ) {
			return ctx.nTableWrapper;
		}, 1 );
	} );
	
	
	
	/**
	 * Redraw the tables in the current context.
	 */
	_api_register( 'draw()', function ( paging ) {
		return this.iterator( 'table', function ( settings ) {
			if ( paging === 'page' ) {
				_fnDraw( settings );
			}
			else {
				if ( typeof paging === 'string' ) {
					paging = paging === 'full-hold' ?
						false :
						true;
				}
	
				_fnReDraw( settings, paging===false );
			}
		} );
	} );
	
	
	
	/**
	 * Get the current page index.
	 *
	 * @return {integer} Current page index (zero based)
	 *//**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * `integer` - The page index to jump to
	 *  * `string` - An action to take:
	 *    * `first` - Jump to first page.
	 *    * `next` - Jump to the next page
	 *    * `previous` - Jump to previous page
	 *    * `last` - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page()', function ( action ) {
		if ( action === undefined ) {
			return this.page.info().page; // not an expensive call
		}
	
		// else, have an action to take on all tables
		return this.iterator( 'table', function ( settings ) {
			_fnPageChange( settings, action );
		} );
	} );
	
	
	/**
	 * Paging information for the first table in the current context.
	 *
	 * If you require paging information for another table, use the `table()` method
	 * with a suitable selector.
	 *
	 * @return {object} Object with the following properties set:
	 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	 *  * `pages` - Total number of pages
	 *  * `start` - Display index for the first record shown on the current page
	 *  * `end` - Display index for the last record shown on the current page
	 *  * `length` - Display length (number of records). Note that generally `start
	 *    + length = end`, but this is not always true, for example if there are
	 *    only 2 records to show on the final page, with a length of 10.
	 *  * `recordsTotal` - Full data set length
	 *  * `recordsDisplay` - Data set length once the current filtering criterion
	 *    are applied.
	 */
	_api_register( 'page.info()', function ( action ) {
		if ( this.context.length === 0 ) {
			return undefined;
		}
	
		var
			settings   = this.context[0],
			start      = settings._iDisplayStart,
			len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
			visRecords = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return {
			"page":           all ? 0 : Math.floor( start / len ),
			"pages":          all ? 1 : Math.ceil( visRecords / len ),
			"start":          start,
			"end":            settings.fnDisplayEnd(),
			"length":         len,
			"recordsTotal":   settings.fnRecordsTotal(),
			"recordsDisplay": visRecords,
			"serverSide":     _fnDataSource( settings ) === 'ssp'
		};
	} );
	
	
	/**
	 * Get the current page length.
	 *
	 * @return {integer} Current page length. Note `-1` indicates that all records
	 *   are to be shown.
	 *//**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use `-1` to show all records.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'page.len()', function ( len ) {
		// Note that we can't call this function 'length()' because `length`
		// is a Javascript property of functions which defines how many arguments
		// the function expects.
		if ( len === undefined ) {
			return this.context.length !== 0 ?
				this.context[0]._iDisplayLength :
				undefined;
		}
	
		// else, set the page length
		return this.iterator( 'table', function ( settings ) {
			_fnLengthChange( settings, len );
		} );
	} );
	
	
	
	var __reload = function ( settings, holdPosition, callback ) {
		// Use the draw event to trigger a callback
		if ( callback ) {
			var api = new _Api( settings );
	
			api.one( 'draw', function () {
				callback( api.ajax.json() );
			} );
		}
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			_fnReDraw( settings, holdPosition );
		}
		else {
			_fnProcessingDisplay( settings, true );
	
			// Cancel an existing request
			var xhr = settings.jqXHR;
			if ( xhr && xhr.readyState !== 4 ) {
				xhr.abort();
			}
	
			// Trigger xhr
			_fnBuildAjax( settings, [], function( json ) {
				_fnClearTable( settings );
	
				var data = _fnAjaxDataSrc( settings, json );
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					_fnAddData( settings, data[i] );
				}
	
				_fnReDraw( settings, holdPosition );
				_fnProcessingDisplay( settings, false );
			} );
		}
	};
	
	
	/**
	 * Get the JSON response from the last Ajax request that DataTables made to the
	 * server. Note that this returns the JSON from the first table in the current
	 * context.
	 *
	 * @return {object} JSON received from the server.
	 */
	_api_register( 'ajax.json()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].json;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Get the data submitted in the last Ajax request
	 */
	_api_register( 'ajax.params()', function () {
		var ctx = this.context;
	
		if ( ctx.length > 0 ) {
			return ctx[0].oAjaxData;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Reload tables from the Ajax data source. Note that this function will
	 * automatically re-draw the table when the remote data has been loaded.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
		return this.iterator( 'table', function (settings) {
			__reload( settings, resetPaging===false, callback );
		} );
	} );
	
	
	/**
	 * Get the current Ajax URL. Note that this returns the URL from the first
	 * table in the current context.
	 *
	 * @return {string} Current Ajax source URL
	 *//**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url()', function ( url ) {
		var ctx = this.context;
	
		if ( url === undefined ) {
			// get
			if ( ctx.length === 0 ) {
				return undefined;
			}
			ctx = ctx[0];
	
			return ctx.ajax ?
				$.isPlainObject( ctx.ajax ) ?
					ctx.ajax.url :
					ctx.ajax :
				ctx.sAjaxSource;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( $.isPlainObject( settings.ajax ) ) {
				settings.ajax.url = url;
			}
			else {
				settings.ajax = url;
			}
			// No need to consider sAjaxSource here since DataTables gives priority
			// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
			// value of `sAjaxSource` redundant.
		} );
	} );
	
	
	/**
	 * Load data from the newly set Ajax URL. Note that this method is only
	 * available when `ajax.url()` is used to set a URL. Additionally, this method
	 * has the same effect as calling `ajax.reload()` but is provided for
	 * convenience when setting a new URL. Like `ajax.reload()` it will
	 * automatically redraw the table once the remote data has been loaded.
	 *
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
		// Same as a reload, but makes sense to present it for easy access after a
		// url change
		return this.iterator( 'table', function ( ctx ) {
			__reload( ctx, resetPaging===false, callback );
		} );
	} );
	
	
	
	
	var _selector_run = function ( type, selector, selectFn, settings, opts )
	{
		var
			out = [], res,
			a, i, ien, j, jen,
			selectorType = typeof selector;
	
		// Can't just check for isArray here, as an API or jQuery instance might be
		// given with their array like look
		if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
			selector = [ selector ];
		}
	
		for ( i=0, ien=selector.length ; i<ien ; i++ ) {
			// Only split on simple strings - complex expressions will be jQuery selectors
			a = selector[i] && selector[i].split && ! selector[i].match(/[\[\(:]/) ?
				selector[i].split(',') :
				[ selector[i] ];
	
			for ( j=0, jen=a.length ; j<jen ; j++ ) {
				res = selectFn( typeof a[j] === 'string' ? (a[j]).trim() : a[j] );
	
				if ( res && res.length ) {
					out = out.concat( res );
				}
			}
		}
	
		// selector extensions
		var ext = _ext.selector[ type ];
		if ( ext.length ) {
			for ( i=0, ien=ext.length ; i<ien ; i++ ) {
				out = ext[i]( settings, opts, out );
			}
		}
	
		return _unique( out );
	};
	
	
	var _selector_opts = function ( opts )
	{
		if ( ! opts ) {
			opts = {};
		}
	
		// Backwards compatibility for 1.9- which used the terminology filter rather
		// than search
		if ( opts.filter && opts.search === undefined ) {
			opts.search = opts.filter;
		}
	
		return $.extend( {
			search: 'none',
			order: 'current',
			page: 'all'
		}, opts );
	};
	
	
	var _selector_first = function ( inst )
	{
		// Reduce the API instance to the first item found
		for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
			if ( inst[i].length > 0 ) {
				// Assign the first element to the first item in the instance
				// and truncate the instance and context
				inst[0] = inst[i];
				inst[0].length = 1;
				inst.length = 1;
				inst.context = [ inst.context[i] ];
	
				return inst;
			}
		}
	
		// Not found - return an empty instance
		inst.length = 0;
		return inst;
	};
	
	
	var _selector_row_indexes = function ( settings, opts )
	{
		var
			i, ien, tmp, a=[],
			displayFiltered = settings.aiDisplay,
			displayMaster = settings.aiDisplayMaster;
	
		var
			search = opts.search,  // none, applied, removed
			order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
			page   = opts.page;    // all, current
	
		if ( _fnDataSource( settings ) == 'ssp' ) {
			// In server-side processing mode, most options are irrelevant since
			// rows not shown don't exist and the index order is the applied order
			// Removed is a special case - for consistency just return an empty
			// array
			return search === 'removed' ?
				[] :
				_range( 0, displayMaster.length );
		}
		else if ( page == 'current' ) {
			// Current page implies that order=current and filter=applied, since it is
			// fairly senseless otherwise, regardless of what order and search actually
			// are
			for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
				a.push( displayFiltered[i] );
			}
		}
		else if ( order == 'current' || order == 'applied' ) {
			if ( search == 'none') {
				a = displayMaster.slice();
			}
			else if ( search == 'applied' ) {
				a = displayFiltered.slice();
			}
			else if ( search == 'removed' ) {
				// O(n+m) solution by creating a hash map
				var displayFilteredMap = {};
	
				for ( var i=0, ien=displayFiltered.length ; i<ien ; i++ ) {
					displayFilteredMap[displayFiltered[i]] = null;
				}
	
				a = $.map( displayMaster, function (el) {
					return ! displayFilteredMap.hasOwnProperty(el) ?
						el :
						null;
				} );
			}
		}
		else if ( order == 'index' || order == 'original' ) {
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				if ( search == 'none' ) {
					a.push( i );
				}
				else { // applied | removed
					tmp = $.inArray( i, displayFiltered );
	
					if ((tmp === -1 && search == 'removed') ||
						(tmp >= 0   && search == 'applied') )
					{
						a.push( i );
					}
				}
			}
		}
	
		return a;
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
	var __row_selector = function ( settings, selector, opts )
	{
		var rows;
		var run = function ( sel ) {
			var selInt = _intVal( sel );
			var i, ien;
			var aoData = settings.aoData;
	
			// Short cut - selector is a number and no options provided (default is
			// all records, so no need to check if the index is in there, since it
			// must be - dev error if the index doesn't exist).
			if ( selInt !== null && ! opts ) {
				return [ selInt ];
			}
	
			if ( ! rows ) {
				rows = _selector_row_indexes( settings, opts );
			}
	
			if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
				// Selector - integer
				return [ selInt ];
			}
			else if ( sel === null || sel === undefined || sel === '' ) {
				// Selector - none
				return rows;
			}
	
			// Selector - function
			if ( typeof sel === 'function' ) {
				return $.map( rows, function (idx) {
					var row = aoData[ idx ];
					return sel( idx, row._aData, row.nTr ) ? idx : null;
				} );
			}
	
			// Selector - node
			if ( sel.nodeName ) {
				var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
				var cellIdx = sel._DT_CellIndex;
	
				if ( rowIdx !== undefined ) {
					// Make sure that the row is actually still present in the table
					return aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?
						[ rowIdx ] :
						[];
				}
				else if ( cellIdx ) {
					return aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?
						[ cellIdx.row ] :
						[];
				}
				else {
					var host = $(sel).closest('*[data-dt-row]');
					return host.length ?
						[ host.data('dt-row') ] :
						[];
				}
			}
	
			// ID selector. Want to always be able to select rows by id, regardless
			// of if the tr element has been created or not, so can't rely upon
			// jQuery here - hence a custom implementation. This does not match
			// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
			// but to select it using a CSS selector engine (like Sizzle or
			// querySelect) it would need to need to be escaped for some characters.
			// DataTables simplifies this for row selectors since you can select
			// only a row. A # indicates an id any anything that follows is the id -
			// unescaped.
			if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
				// get row index from id
				var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
				if ( rowObj !== undefined ) {
					return [ rowObj.idx ];
				}
	
				// need to fall through to jQuery in case there is DOM id that
				// matches
			}
			
			// Get nodes in the order from the `rows` array with null values removed
			var nodes = _removeEmpty(
				_pluck_order( settings.aoData, rows, 'nTr' )
			);
	
			// Selector - jQuery selector string, array of nodes or jQuery object/
			// As jQuery's .filter() allows jQuery objects to be passed in filter,
			// it also allows arrays, so this will cope with all three options
			return $(nodes)
				.filter( sel )
				.map( function () {
					return this._DT_RowIndex;
				} )
				.toArray();
		};
	
		return _selector_run( 'row', selector, run, settings, opts );
	};
	
	
	_api_register( 'rows()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __row_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in __row_selector?
		inst.selector.rows = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_register( 'rows().nodes()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return settings.aoData[ row ].nTr || undefined;
		}, 1 );
	} );
	
	_api_register( 'rows().data()', function () {
		return this.iterator( true, 'rows', function ( settings, rows ) {
			return _pluck_order( settings.aoData, rows, '_aData' );
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
		return this.iterator( 'row', function ( settings, row ) {
			var r = settings.aoData[ row ];
			return type === 'search' ? r._aFilterData : r._aSortData;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
		return this.iterator( 'row', function ( settings, row ) {
			_fnInvalidate( settings, row, src );
		} );
	} );
	
	_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
		return this.iterator( 'row', function ( settings, row ) {
			return row;
		}, 1 );
	} );
	
	_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
		var a = [];
		var context = this.context;
	
		// `iterator` will drop undefined values, but in this case we want them
		for ( var i=0, ien=context.length ; i<ien ; i++ ) {
			for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
				var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
				a.push( (hash === true ? '#' : '' )+ id );
			}
		}
	
		return new _Api( context, a );
	} );
	
	_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
		var that = this;
	
		this.iterator( 'row', function ( settings, row, thatIdx ) {
			var data = settings.aoData;
			var rowData = data[ row ];
			var i, ien, j, jen;
			var loopRow, loopCells;
	
			data.splice( row, 1 );
	
			// Update the cached indexes
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				loopRow = data[i];
				loopCells = loopRow.anCells;
	
				// Rows
				if ( loopRow.nTr !== null ) {
					loopRow.nTr._DT_RowIndex = i;
				}
	
				// Cells
				if ( loopCells !== null ) {
					for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
						loopCells[j]._DT_CellIndex.row = i;
					}
				}
			}
	
			// Delete from the display arrays
			_fnDeleteIndex( settings.aiDisplayMaster, row );
			_fnDeleteIndex( settings.aiDisplay, row );
			_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
	
			// For server-side processing tables - subtract the deleted row from the count
			if ( settings._iRecordsDisplay > 0 ) {
				settings._iRecordsDisplay--;
			}
	
			// Check for an 'overflow' they case for displaying the table
			_fnLengthOverflow( settings );
	
			// Remove the row's ID reference if there is one
			var id = settings.rowIdFn( rowData._aData );
			if ( id !== undefined ) {
				delete settings.aIds[ id ];
			}
		} );
	
		this.iterator( 'table', function ( settings ) {
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				settings.aoData[i].idx = i;
			}
		} );
	
		return this;
	} );
	
	
	_api_register( 'rows.add()', function ( rows ) {
		var newRows = this.iterator( 'table', function ( settings ) {
				var row, i, ien;
				var out = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
						out.push( _fnAddTr( settings, row )[0] );
					}
					else {
						out.push( _fnAddData( settings, row ) );
					}
				}
	
				return out;
			}, 1 );
	
		// Return an Api.rows() extended instance, so rows().nodes() etc can be used
		var modRows = this.rows( -1 );
		modRows.pop();
		$.merge( modRows, newRows );
	
		return modRows;
	} );
	
	
	
	
	
	/**
	 *
	 */
	_api_register( 'row()', function ( selector, opts ) {
		return _selector_first( this.rows( selector, opts ) );
	} );
	
	
	_api_register( 'row().data()', function ( data ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// Get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._aData :
				undefined;
		}
	
		// Set
		var row = ctx[0].aoData[ this[0] ];
		row._aData = data;
	
		// If the DOM has an id, and the data source is an array
		if ( Array.isArray( data ) && row.nTr && row.nTr.id ) {
			_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );
		}
	
		// Automatically invalidate
		_fnInvalidate( ctx[0], this[0], 'data' );
	
		return this;
	} );
	
	
	_api_register( 'row().node()', function () {
		var ctx = this.context;
	
		return ctx.length && this.length ?
			ctx[0].aoData[ this[0] ].nTr || null :
			null;
	} );
	
	
	_api_register( 'row.add()', function ( row ) {
		// Allow a jQuery object to be passed in - only a single row is added from
		// it though - the first element in the set
		if ( row instanceof $ && row.length ) {
			row = row[0];
		}
	
		var rows = this.iterator( 'table', function ( settings ) {
			if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
				return _fnAddTr( settings, row )[0];
			}
			return _fnAddData( settings, row );
		} );
	
		// Return an Api.rows() extended instance, with the newly added row selected
		return this.row( rows[0] );
	} );
	
	
	$(document).on('plugin-init.dt', function (e, context) {
		var api = new _Api( context );
		api.on( 'stateSaveParams', function ( e, settings, data ) {
			var indexes = api.rows().iterator( 'row', function ( settings, idx ) {
				return settings.aoData[idx]._detailsShow ? idx : undefined;
			});
	
			data.childRows = api.rows( indexes ).ids( true ).toArray();
		})
	
		var loaded = api.state.loaded();
	
		if ( loaded && loaded.childRows ) {
			api.rows( loaded.childRows ).every( function () {
				_fnCallbackFire( context, null, 'requestChild', [ this ] )
			})
		}
	})
	
	var __details_add = function ( ctx, row, data, klass )
	{
		// Convert to array of TR elements
		var rows = [];
		var addRow = function ( r, k ) {
			// Recursion to allow for arrays of jQuery objects
			if ( Array.isArray( r ) || r instanceof $ ) {
				for ( var i=0, ien=r.length ; i<ien ; i++ ) {
					addRow( r[i], k );
				}
				return;
			}
	
			// If we get a TR element, then just add it directly - up to the dev
			// to add the correct number of columns etc
			if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
				rows.push( r );
			}
			else {
				// Otherwise create a row with a wrapper
				var created = $('<tr><td></td></tr>').addClass( k );
				$('td', created)
					.addClass( k )
					.html( r )
					[0].colSpan = _fnVisbleColumns( ctx );
	
				rows.push( created[0] );
			}
		};
	
		addRow( data, klass );
	
		if ( row._details ) {
			row._details.detach();
		}
	
		row._details = $(rows);
	
		// If the children were already shown, that state should be retained
		if ( row._detailsShow ) {
			row._details.insertAfter( row.nTr );
		}
	};
	
	
	var __details_remove = function ( api, idx )
	{
		var ctx = api.context;
	
		if ( ctx.length ) {
			var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
	
			if ( row && row._details ) {
				row._details.remove();
	
				row._detailsShow = undefined;
				row._details = undefined;
				$( row.nTr ).removeClass( 'dt-hasChild' );
				_fnSaveState( ctx[0] );
			}
		}
	};
	
	
	var __details_display = function ( api, show ) {
		var ctx = api.context;
	
		if ( ctx.length && api.length ) {
			var row = ctx[0].aoData[ api[0] ];
	
			if ( row._details ) {
				row._detailsShow = show;
	
				if ( show ) {
					row._details.insertAfter( row.nTr );
					$( row.nTr ).addClass( 'dt-hasChild' );
				}
				else {
					row._details.detach();
					$( row.nTr ).removeClass( 'dt-hasChild' );
				}
	
				_fnCallbackFire( ctx[0], null, 'childRow', [ show, api.row( api[0] ) ] )
	
				__details_events( ctx[0] );
				_fnSaveState( ctx[0] );
			}
		}
	};
	
	
	var __details_events = function ( settings )
	{
		var api = new _Api( settings );
		var namespace = '.dt.DT_details';
		var drawEvent = 'draw'+namespace;
		var colvisEvent = 'column-visibility'+namespace;
		var destroyEvent = 'destroy'+namespace;
		var data = settings.aoData;
	
		api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
	
		if ( _pluck( data, '_details' ).length > 0 ) {
			// On each draw, insert the required elements into the document
			api.on( drawEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				api.rows( {page:'current'} ).eq(0).each( function (idx) {
					// Internal data grab
					var row = data[ idx ];
	
					if ( row._detailsShow ) {
						row._details.insertAfter( row.nTr );
					}
				} );
			} );
	
			// Column visibility change - update the colspan
			api.on( colvisEvent, function ( e, ctx, idx, vis ) {
				if ( settings !== ctx ) {
					return;
				}
	
				// Update the colspan for the details rows (note, only if it already has
				// a colspan)
				var row, visible = _fnVisbleColumns( ctx );
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					row = data[i];
	
					if ( row._details ) {
						row._details.children('td[colspan]').attr('colspan', visible );
					}
				}
			} );
	
			// Table destroyed - nuke any child rows
			api.on( destroyEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				for ( var i=0, ien=data.length ; i<ien ; i++ ) {
					if ( data[i]._details ) {
						__details_remove( api, i );
					}
				}
			} );
		}
	};
	
	// Strings for the method names to help minification
	var _emp = '';
	var _child_obj = _emp+'row().child';
	var _child_mth = _child_obj+'()';
	
	// data can be:
	//  tr
	//  string
	//  jQuery or array of any of the above
	_api_register( _child_mth, function ( data, klass ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// get
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ]._details :
				undefined;
		}
		else if ( data === true ) {
			// show
			this.child.show();
		}
		else if ( data === false ) {
			// remove
			__details_remove( this );
		}
		else if ( ctx.length && this.length ) {
			// set
			__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
		}
	
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.show()',
		_child_mth+'.show()' // only when `child()` was called with parameters (without
	], function ( show ) {   // it returns an object and this method is not executed)
		__details_display( this, true );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.hide()',
		_child_mth+'.hide()' // only when `child()` was called with parameters (without
	], function () {         // it returns an object and this method is not executed)
		__details_display( this, false );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+'.remove()',
		_child_mth+'.remove()' // only when `child()` was called with parameters (without
	], function () {           // it returns an object and this method is not executed)
		__details_remove( this );
		return this;
	} );
	
	
	_api_register( _child_obj+'.isShown()', function () {
		var ctx = this.context;
	
		if ( ctx.length && this.length ) {
			// _detailsShown as false or undefined will fall through to return false
			return ctx[0].aoData[ this[0] ]._detailsShow || false;
		}
		return false;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (>=0 count from left, <0 count from right)
	 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	 * "{string}:name"     - column name
	 * "{string}"          - jQuery selector on column header nodes
	 *
	 */
	
	// can be an array of these items, comma separated list, or an array of comma
	// separated lists
	
	var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
	
	
	// r1 and r2 are redundant - but it means that the parameters match for the
	// iterator callback in columns().data()
	var __columnData = function ( settings, column, r1, r2, rows ) {
		var a = [];
		for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
			a.push( _fnGetCellData( settings, rows[row], column ) );
		}
		return a;
	};
	
	
	var __column_selector = function ( settings, selector, opts )
	{
		var
			columns = settings.aoColumns,
			names = _pluck( columns, 'sName' ),
			nodes = _pluck( columns, 'nTh' );
	
		var run = function ( s ) {
			var selInt = _intVal( s );
	
			// Selector - all
			if ( s === '' ) {
				return _range( columns.length );
			}
	
			// Selector - index
			if ( selInt !== null ) {
				return [ selInt >= 0 ?
					selInt : // Count from left
					columns.length + selInt // Count from right (+ because its a negative value)
				];
			}
	
			// Selector = function
			if ( typeof s === 'function' ) {
				var rows = _selector_row_indexes( settings, opts );
	
				return $.map( columns, function (col, idx) {
					return s(
							idx,
							__columnData( settings, idx, 0, 0, rows ),
							nodes[ idx ]
						) ? idx : null;
				} );
			}
	
			// jQuery or string selector
			var match = typeof s === 'string' ?
				s.match( __re_column_selector ) :
				'';
	
			if ( match ) {
				switch( match[2] ) {
					case 'visIdx':
					case 'visible':
						var idx = parseInt( match[1], 10 );
						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = $.map( columns, function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
	
					case 'name':
						// match by name. `names` is column index complete and in order
						return $.map( names, function (name, i) {
							return name === match[1] ? i : null;
						} );
	
					default:
						return [];
				}
			}
	
			// Cell in the table body
			if ( s.nodeName && s._DT_CellIndex ) {
				return [ s._DT_CellIndex.column ];
			}
	
			// jQuery selector on the TH elements for the columns
			var jqResult = $( nodes )
				.filter( s )
				.map( function () {
					return $.inArray( this, nodes ); // `nodes` is column index complete and in order
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise a node which might have a `dt-column` data attribute, or be
			// a child or such an element
			var host = $(s).closest('*[data-dt-column]');
			return host.length ?
				[ host.data('dt-column') ] :
				[];
		};
	
		return _selector_run( 'column', selector, run, settings, opts );
	};
	
	
	var __setColumnVis = function ( settings, column, vis ) {
		var
			cols = settings.aoColumns,
			col  = cols[ column ],
			data = settings.aoData,
			row, cells, i, ien, tr;
	
		// Get
		if ( vis === undefined ) {
			return col.bVisible;
		}
	
		// Set
		// No change
		if ( col.bVisible === vis ) {
			return;
		}
	
		if ( vis ) {
			// Insert column
			// Need to decide if we should use appendChild or insertBefore
			var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
	
			for ( i=0, ien=data.length ; i<ien ; i++ ) {
				tr = data[i].nTr;
				cells = data[i].anCells;
	
				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
		else {
			// Remove column
			$( _pluck( settings.aoData, 'anCells', column ) ).detach();
		}
	
		// Common actions
		col.bVisible = vis;
	};
	
	
	_api_register( 'columns()', function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = '';
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = '';
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( 'table', function ( settings ) {
			return __column_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in _row_selector?
		inst.selector.cols = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTh;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].nTf;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().data()', 'column().data()', function () {
		return this.iterator( 'column-rows', __columnData, 1 );
	} );
	
	_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
		return this.iterator( 'column', function ( settings, column ) {
			return settings.aoColumns[column].mData;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows,
				type === 'search' ? '_aFilterData' : '_aSortData', column
			);
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
		}, 1 );
	} );
	
	_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
		var that = this;
		var ret = this.iterator( 'column', function ( settings, column ) {
			if ( vis === undefined ) {
				return settings.aoColumns[ column ].bVisible;
			} // else
			__setColumnVis( settings, column, vis );
		} );
	
		// Group the column visibility changes
		if ( vis !== undefined ) {
			this.iterator( 'table', function ( settings ) {
				// Redraw the header after changes
				_fnDrawHead( settings, settings.aoHeader );
				_fnDrawHead( settings, settings.aoFooter );
		
				// Update colspan for no records display. Child rows and extensions will use their own
				// listeners to do this - only need to update the empty table item here
				if ( ! settings.aiDisplay.length ) {
					$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
				}
		
				_fnSaveState( settings );
	
				// Second loop once the first is done for events
				that.iterator( 'column', function ( settings, column ) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				} );
	
				if ( calc === undefined || calc ) {
					that.columns.adjust();
				}
			});
		}
	
		return ret;
	} );
	
	_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
		return this.iterator( 'column', function ( settings, column ) {
			return type === 'visible' ?
				_fnColumnIndexToVisible( settings, column ) :
				column;
		}, 1 );
	} );
	
	_api_register( 'columns.adjust()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnAdjustColumnSizing( settings );
		}, 1 );
	} );
	
	_api_register( 'column.index()', function ( type, idx ) {
		if ( this.context.length !== 0 ) {
			var ctx = this.context[0];
	
			if ( type === 'fromVisible' || type === 'toData' ) {
				return _fnVisibleToColumnIndex( ctx, idx );
			}
			else if ( type === 'fromData' || type === 'toVisible' ) {
				return _fnColumnIndexToVisible( ctx, idx );
			}
		}
	} );
	
	_api_register( 'column()', function ( selector, opts ) {
		return _selector_first( this.columns( selector, opts ) );
	} );
	
	var __cell_selector = function ( settings, selector, opts )
	{
		var data = settings.aoData;
		var rows = _selector_row_indexes( settings, opts );
		var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
		var allCells = $(_flatten( [], cells ));
		var row;
		var columns = settings.aoColumns.length;
		var a, i, ien, j, o, host;
	
		var run = function ( s ) {
			var fnSelector = typeof s === 'function';
	
			if ( s === null || s === undefined || fnSelector ) {
				// All cells and function selectors
				a = [];
	
				for ( i=0, ien=rows.length ; i<ien ; i++ ) {
					row = rows[i];
	
					for ( j=0 ; j<columns ; j++ ) {
						o = {
							row: row,
							column: j
						};
	
						if ( fnSelector ) {
							// Selector - function
							host = data[ row ];
	
							if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
								a.push( o );
							}
						}
						else {
							// Selector - all
							a.push( o );
						}
					}
				}
	
				return a;
			}
			
			// Selector - index
			if ( $.isPlainObject( s ) ) {
				// Valid cell index and its in the array of selectable rows
				return s.column !== undefined && s.row !== undefined && $.inArray( s.row, rows ) !== -1 ?
					[s] :
					[];
			}
	
			// Selector - jQuery filtered cells
			var jqResult = allCells
				.filter( s )
				.map( function (i, el) {
					return { // use a new object, in case someone changes the values
						row:    el._DT_CellIndex.row,
						column: el._DT_CellIndex.column
	 				};
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise the selector is a node, and there is one last option - the
			// element might be a child of an element which has dt-row and dt-column
			// data attributes
			host = $(s).closest('*[data-dt-row]');
			return host.length ?
				[ {
					row: host.data('dt-row'),
					column: host.data('dt-column')
				} ] :
				[];
		};
	
		return _selector_run( 'cell', selector, run, settings, opts );
	};
	
	
	
	
	_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
		// Argument shifting
		if ( $.isPlainObject( rowSelector ) ) {
			// Indexes
			if ( rowSelector.row === undefined ) {
				// Selector options in first parameter
				opts = rowSelector;
				rowSelector = null;
			}
			else {
				// Cell index objects in first parameter
				opts = columnSelector;
				columnSelector = null;
			}
		}
		if ( $.isPlainObject( columnSelector ) ) {
			opts = columnSelector;
			columnSelector = null;
		}
	
		// Cell selector
		if ( columnSelector === null || columnSelector === undefined ) {
			return this.iterator( 'table', function ( settings ) {
				return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
			} );
		}
	
		// The default built in options need to apply to row and columns
		var internalOpts = opts ? {
			page: opts.page,
			order: opts.order,
			search: opts.search
		} : {};
	
		// Row + column selector
		var columns = this.columns( columnSelector, internalOpts );
		var rows = this.rows( rowSelector, internalOpts );
		var i, ien, j, jen;
	
		var cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {
			var a = [];
	
			for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
				for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
					a.push( {
						row:    rows[idx][i],
						column: columns[idx][j]
					} );
				}
			}
	
			return a;
		}, 1 );
	
		// There is currently only one extension which uses a cell selector extension
		// It is a _major_ performance drag to run this if it isn't needed, so this is
		// an extension specific check at the moment
		var cells = opts && opts.selected ?
			this.cells( cellsNoOpts, opts ) :
			cellsNoOpts;
	
		$.extend( cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		} );
	
		return cells;
	} );
	
	
	_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			var data = settings.aoData[ row ];
	
			return data && data.anCells ?
				data.anCells[ column ] :
				undefined;
		}, 1 );
	} );
	
	
	_api_register( 'cells().data()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
		type = type === 'search' ? '_aFilterData' : '_aSortData';
	
		return this.iterator( 'cell', function ( settings, row, column ) {
			return settings.aoData[ row ][ type ][ column ];
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column, type );
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
		return this.iterator( 'cell', function ( settings, row, column ) {
			return {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible( settings, column )
			};
		}, 1 );
	} );
	
	
	_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
		return this.iterator( 'cell', function ( settings, row, column ) {
			_fnInvalidate( settings, row, src, column );
		} );
	} );
	
	
	
	_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
		return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
	} );
	
	
	_api_register( 'cell().data()', function ( data ) {
		var ctx = this.context;
		var cell = this[0];
	
		if ( data === undefined ) {
			// Get
			return ctx.length && cell.length ?
				_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
				undefined;
		}
	
		// Set
		_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
		_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
	
		return this;
	} );
	
	
	
	/**
	 * Get current ordering (sorting) that has been applied to the table.
	 *
	 * @returns {array} 2D array containing the sorting information for the first
	 *   table in the current context. Each element in the parent array represents
	 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	 *   the column index that the sorting condition applies to, the second is the
	 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	 *   index of the sorting order from the `column.sorting` initialisation array.
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order()', function ( order, dir ) {
		var ctx = this.context;
	
		if ( order === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].aaSorting :
				undefined;
		}
	
		// set
		if ( typeof order === 'number' ) {
			// Simple column / direction passed in
			order = [ [ order, dir ] ];
		}
		else if ( order.length && ! Array.isArray( order[0] ) ) {
			// Arguments passed in (list of 1D arrays)
			order = Array.prototype.slice.call( arguments );
		}
		// otherwise a 2D array was passed in
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSorting = order.slice();
		} );
	} );
	
	
	/**
	 * Attach a sort listener to an element for a given column
	 *
	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	 *   listener to. This can take the form of a single DOM node, a jQuery
	 *   collection of nodes or a jQuery selector which will identify the node(s).
	 * @param {integer} column the column that a click on this node will sort on
	 * @param {function} [callback] callback function when sort is run
	 * @returns {DataTables.Api} this
	 */
	_api_register( 'order.listener()', function ( node, column, callback ) {
		return this.iterator( 'table', function ( settings ) {
			_fnSortAttachListener( settings, node, column, callback );
		} );
	} );
	
	
	_api_register( 'order.fixed()', function ( set ) {
		if ( ! set ) {
			var ctx = this.context;
			var fixed = ctx.length ?
				ctx[0].aaSortingFixed :
				undefined;
	
			return Array.isArray( fixed ) ?
				{ pre: fixed } :
				fixed;
		}
	
		return this.iterator( 'table', function ( settings ) {
			settings.aaSortingFixed = $.extend( true, {}, set );
		} );
	} );
	
	
	// Order by the selected column(s)
	_api_register( [
		'columns().order()',
		'column().order()'
	], function ( dir ) {
		var that = this;
	
		return this.iterator( 'table', function ( settings, i ) {
			var sort = [];
	
			$.each( that[i], function (j, col) {
				sort.push( [ col, dir ] );
			} );
	
			settings.aaSorting = sort;
		} );
	} );
	
	
	
	_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
		var ctx = this.context;
	
		if ( input === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].oPreviousSearch.sSearch :
				undefined;
		}
	
		// set
		return this.iterator( 'table', function ( settings ) {
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}
	
			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
				"sSearch": input+"",
				"bRegex":  regex === null ? false : regex,
				"bSmart":  smart === null ? true  : smart,
				"bCaseInsensitive": caseInsen === null ? true : caseInsen
			} ), 1 );
		} );
	} );
	
	
	_api_registerPlural(
		'columns().search()',
		'column().search()',
		function ( input, regex, smart, caseInsen ) {
			return this.iterator( 'column', function ( settings, column ) {
				var preSearch = settings.aoPreSearchCols;
	
				if ( input === undefined ) {
					// get
					return preSearch[ column ].sSearch;
				}
	
				// set
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
	
				$.extend( preSearch[ column ], {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} );
	
				_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
			} );
		}
	);
	
	/*
	 * State API methods
	 */
	
	_api_register( 'state()', function () {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	} );
	
	
	_api_register( 'state.clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			// Save an empty object
			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
		} );
	} );
	
	
	_api_register( 'state.loaded()', function () {
		return this.context.length ?
			this.context[0].oLoadedState :
			null;
	} );
	
	
	_api_register( 'state.save()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnSaveState( settings );
		} );
	} );
	
	
	
	/**
	 * Provide a common method for plug-ins to check the version of DataTables being
	 * used, in order to ensure compatibility.
	 *
	 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	 *    Note that the formats "X" and "X.Y" are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to
	 *    the required version, or false if this version of DataTales is not
	 *    suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	 */
	DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
	{
		var aThis = DataTable.version.split('.');
		var aThat = version.split('.');
		var iThis, iThat;
	
		for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
			iThis = parseInt( aThis[i], 10 ) || 0;
			iThat = parseInt( aThat[i], 10 ) || 0;
	
			// Parts are the same, keep comparing
			if (iThis === iThat) {
				continue;
			}
	
			// Parts are different, return immediately
			return iThis > iThat;
		}
	
		return true;
	};
	
	
	/**
	 * Check if a `<table>` node is a DataTable table already or not.
	 *
	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	 *      selector for the table to test. Note that if more than more than one
	 *      table is passed on, only the first will be checked
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	 *      $('#example').dataTable();
	 *    }
	 */
	DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
	{
		var t = $(table).get(0);
		var is = false;
	
		if ( table instanceof DataTable.Api ) {
			return true;
		}
	
		$.each( DataTable.settings, function (i, o) {
			var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
			var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
	
			if ( o.nTable === t || head === t || foot === t ) {
				is = true;
			}
		} );
	
		return is;
	};
	
	
	/**
	 * Get all DataTable tables that have been initialised - optionally you can
	 * select to get only currently visible tables.
	 *
	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	 *    or visible tables only.
	 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	 *    DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    $.each( $.fn.dataTable.tables(true), function () {
	 *      $(table).DataTable().columns.adjust();
	 *    } );
	 */
	DataTable.tables = DataTable.fnTables = function ( visible )
	{
		var api = false;
	
		if ( $.isPlainObject( visible ) ) {
			api = visible.api;
			visible = visible.visible;
		}
	
		var a = $.map( DataTable.settings, function (o) {
			if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
				return o.nTable;
			}
		} );
	
		return api ?
			new _Api( a ) :
			a;
	};
	
	
	/**
	 * Convert from camel case parameters to Hungarian notation. This is made public
	 * for the extensions to provide the same ability as DataTables core to accept
	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	 * parameters.
	 *
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 */
	DataTable.camelToHungarian = _fnCamelToHungarian;
	
	
	
	/**
	 *
	 */
	_api_register( '$()', function ( selector, opts ) {
		var
			rows   = this.rows( opts ).nodes(), // Get all rows
			jqRows = $(rows);
	
		return $( [].concat(
			jqRows.filter( selector ).toArray(),
			jqRows.find( selector ).toArray()
		) );
	} );
	
	
	// jQuery functions to operate on the tables
	$.each( [ 'on', 'one', 'off' ], function (i, key) {
		_api_register( key+'()', function ( /* event, handler */ ) {
			var args = Array.prototype.slice.call(arguments);
	
			// Add the `dt` namespace automatically if it isn't already present
			args[0] = $.map( args[0].split( /\s/ ), function ( e ) {
				return ! e.match(/\.dt\b/) ?
					e+'.dt' :
					e;
				} ).join( ' ' );
	
			var inst = $( this.tables().nodes() );
			inst[key].apply( inst, args );
			return this;
		} );
	} );
	
	
	_api_register( 'clear()', function () {
		return this.iterator( 'table', function ( settings ) {
			_fnClearTable( settings );
		} );
	} );
	
	
	_api_register( 'settings()', function () {
		return new _Api( this.context, this.context );
	} );
	
	
	_api_register( 'init()', function () {
		var ctx = this.context;
		return ctx.length ? ctx[0].oInit : null;
	} );
	
	
	_api_register( 'data()', function () {
		return this.iterator( 'table', function ( settings ) {
			return _pluck( settings.aoData, '_aData' );
		} ).flatten();
	} );
	
	
	_api_register( 'destroy()', function ( remove ) {
		remove = remove || false;
	
		return this.iterator( 'table', function ( settings ) {
			var orig      = settings.nTableWrapper.parentNode;
			var classes   = settings.oClasses;
			var table     = settings.nTable;
			var tbody     = settings.nTBody;
			var thead     = settings.nTHead;
			var tfoot     = settings.nTFoot;
			var jqTable   = $(table);
			var jqTbody   = $(tbody);
			var jqWrapper = $(settings.nTableWrapper);
			var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
			var i, ien;
	
			// Flag to note that the table is currently being destroyed - no action
			// should be taken
			settings.bDestroying = true;
	
			// Fire off the destroy callbacks for plug-ins etc
			_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
	
			// If not being removed from the document, make all columns visible
			if ( ! remove ) {
				new _Api( settings ).columns().visible( true );
			}
	
			// Blitz all `DT` namespaced events (these are internal events, the
			// lowercase, `dt` events are user subscribed and they are responsible
			// for removing them
			jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
			$(window).off('.DT-'+settings.sInstance);
	
			// When scrolling we had to break the table up - restore it
			if ( table != thead.parentNode ) {
				jqTable.children('thead').detach();
				jqTable.append( thead );
			}
	
			if ( tfoot && table != tfoot.parentNode ) {
				jqTable.children('tfoot').detach();
				jqTable.append( tfoot );
			}
	
			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses( settings );
	
			$( rows ).removeClass( settings.asStripeClasses.join(' ') );
	
			$('th, td', thead).removeClass( classes.sSortable+' '+
				classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
			);
	
			// Add the TR elements back into the table in their original order
			jqTbody.children().detach();
			jqTbody.append( rows );
	
			// Remove the DataTables generated nodes, events and classes
			var removedMethod = remove ? 'remove' : 'detach';
			jqTable[ removedMethod ]();
			jqWrapper[ removedMethod ]();
	
			// If we need to reattach the table to the document
			if ( ! remove && orig ) {
				// insertBefore acts like appendChild if !arg[1]
				orig.insertBefore( table, settings.nTableReinsertBefore );
	
				// Restore the width of the original table - was read from the style property,
				// so we can restore directly to that
				jqTable
					.css( 'width', settings.sDestroyWidth )
					.removeClass( classes.sTable );
	
				// If the were originally stripe classes - then we add them back here.
				// Note this is not fool proof (for example if not all rows had stripe
				// classes - but it's a good effort without getting carried away
				ien = settings.asDestroyStripes.length;
	
				if ( ien ) {
					jqTbody.children().each( function (i) {
						$(this).addClass( settings.asDestroyStripes[i % ien] );
					} );
				}
			}
	
			/* Remove the settings object from the settings array */
			var idx = $.inArray( settings, DataTable.settings );
			if ( idx !== -1 ) {
				DataTable.settings.splice( idx, 1 );
			}
		} );
	} );
	
	
	// Add the `every()` method for rows, columns and cells in a compact form
	$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
		_api_register( type+'s().every()', function ( fn ) {
			var opts = this.selector.opts;
			var api = this;
	
			return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
				// Rows and columns:
				//  arg1 - index
				//  arg2 - table counter
				//  arg3 - loop counter
				//  arg4 - undefined
				// Cells:
				//  arg1 - row index
				//  arg2 - column index
				//  arg3 - table counter
				//  arg4 - loop counter
				fn.call(
					api[ type ](
						arg1,
						type==='cell' ? arg2 : opts,
						type==='cell' ? opts : undefined
					),
					arg1, arg2, arg3, arg4
				);
			} );
		} );
	} );
	
	
	// i18n method for extensions to be able to use the language object from the
	// DataTable
	_api_register( 'i18n()', function ( token, def, plural ) {
		var ctx = this.context[0];
		var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
	
		if ( resolved === undefined ) {
			resolved = def;
		}
	
		if ( plural !== undefined && $.isPlainObject( resolved ) ) {
			resolved = resolved[ plural ] !== undefined ?
				resolved[ plural ] :
				resolved._;
		}
	
		return resolved.replace( '%d', plural ); // nb: plural might be undefined,
	} );
	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	 * only for non-release builds. See http://semver.org/ for more information.
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = "1.11.3";

	/**
	 * Private data store, containing all of the settings objects that are
	 * created for the tables on a given page.
	 *
	 * Note that the `DataTable.settings` object is aliased to
	 * `jQuery.fn.dataTableExt` through which it may be accessed and
	 * manipulated, or `jQuery.fn.dataTable.settings`.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];

	/**
	 * Object models container, for the various models that DataTables has
	 * available to it. These models define the objects that are used to hold
	 * the active state and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		"bCaseInsensitive": true,
	
		/**
		 * Applied search term
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sSearch": "",
	
		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		"bRegex": false,
	
		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		"bSmart": true,
	
		/**
		 * Flag to indicate if DataTables should only trigger a search when
		 * the return key is pressed.
		 *  @type boolean
		 *  @default false
		 */
		"return": false
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		"nTr": null,
	
		/**
		 * Array of TD elements for each row. This is null until the row has been
		 * created.
		 *  @type array nodes
		 *  @default []
		 */
		"anCells": null,
	
		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mData options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		"_aData": [],
	
		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aSortData": null,
	
		/**
		 * Per cell filtering data cache. As per the sort data cache, used to
		 * increase the performance of the filtering in DataTables
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_aFilterData": null,
	
		/**
		 * Filtering data cache. This is the same as the cell filtering cache, but
		 * in this case a string rather than an array. This is easily computed with
		 * a join on `_aFilterData`, but is provided as a cache so the join isn't
		 * needed on every search (memory traded for performance)
		 *  @type array
		 *  @default null
		 *  @private
		 */
		"_sFilterRow": null,
	
		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @private
		 */
		"_sRowStripe": "",
	
		/**
		 * Denote if the original data source was from the DOM, or the data source
		 * object. This is used for invalidating data, so DataTables can
		 * automatically read data from the original source, unless uninstructed
		 * otherwise.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"src": null,
	
		/**
		 * Index in the aoData array. This saves an indexOf lookup when we have the
		 * object, but want to know the index
		 *  @type integer
		 *  @default -1
		 *  @private
		 */
		"idx": -1
	};
	
	
	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 *
	 * Note that this object is related to {@link DataTable.defaults.column}
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * Column index. This could be worked out on-the-fly with $.inArray, but it
		 * is faster to just hold it as a variable
		 *  @type integer
		 *  @default null
		 */
		"idx": null,
	
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn't need to be the case).
		 *  @type array
		 */
		"aDataSort": null,
	
		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		"asSorting": null,
	
		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		"bSearchable": null,
	
		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		"bSortable": null,
	
		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		"bVisible": null,
	
		/**
		 * Store for manual type assignment using the `column.type` option. This
		 * is held in store so we can manipulate the column's `sType` property.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		"_sManualType": null,
	
		/**
		 * Flag to indicate if HTML5 data attributes should be used as the data
		 * source for filtering or sorting. True is either are.
		 *  @type boolean
		 *  @default false
		 *  @private
		 */
		"_bAttrSrc": false,
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		"fnCreatedCell": null,
	
		/**
		 * Function to get data from a cell in a column. You should <b>never</b>
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mData to function as
		 * required. This function is automatically assigned by the column
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get -
		 *    'display', 'type' 'filter' 'sort'
		 *  @returns {*} The data for the cell from the given row's data
		 *  @default null
		 */
		"fnGetData": null,
	
		/**
		 * Function to set data for a cell in the column. You should <b>never</b>
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mData to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		"fnSetData": null,
	
		/**
		 * Property to read the value for the cells in the column from the data
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mData": null,
	
		/**
		 * Partner property to mData which is used (only when defined) to get
		 * the data - i.e. it is basically the same as mData, but without the
		 * 'set' option, and also the data fed to it is the result from mData.
		 * This is the rendering method to match the data method of mData.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mRender": null,
	
		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		"nTh": null,
	
		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used
		 * in DataTables as such, but can be used for plug-ins to reference the
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		"nTf": null,
	
		/**
		 * The class to apply to all TD elements in the table's TBODY for the column
		 *  @type string
		 *  @default null
		 */
		"sClass": null,
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		"sContentPadding": null,
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		"sDefaultContent": null,
	
		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		"sName": null,
	
		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		"sSortDataType": 'std',
	
		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		"sSortingClass": null,
	
		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		"sSortingClassJUI": null,
	
		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		"sTitle": null,
	
		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		"sType": null,
	
		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		"sWidth": null,
	
		/**
		 * Width of the column when it was first "encountered"
		 *  @type string
		 *  @default null
		 */
		"sWidthOrig": null
	};
	
	
	/*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would add around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit).
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
	
	/**
	 * Initialisation options that can be given to DataTables at initialisation
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.data
		 *
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine" },
		 *          { "title": "Browser" },
		 *          { "title": "Platform" },
		 *          { "title": "Version" },
		 *          { "title": "Grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using an array of objects as a data source (`data`)
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "data": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "columns": [
		 *          { "title": "Engine",   "data": "engine" },
		 *          { "title": "Browser",  "data": "browser" },
		 *          { "title": "Platform", "data": "platform" },
		 *          { "title": "Version",  "data": "version" },
		 *          { "title": "Grade",    "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"aaData": null,
	
	
		/**
		 * If ordering is enabled, then DataTables will perform a first pass sort on
		 * initialisation. You can define which column(s) the sort is performed
		 * upon, and the sorting direction, with this variable. The `sorting` array
		 * should contain an array for each column to be sorted initially containing
		 * the column's index and a direction string ('asc' or 'desc').
		 *  @type array
		 *  @default [[0,'asc']]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.order
		 *
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
		 *
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "order": []
		 *      } );
		 *    } );
		 */
		"aaSorting": [[0,'asc']],
	
	
		/**
		 * This parameter is basically identical to the `sorting` parameter, but
		 * cannot be overridden by user interaction with the table. What this means
		 * is that you could have a column (visible or hidden) which the sorting
		 * will always be forced on first - any sorting after that (from the user)
		 * will then be performed as required. This can be useful for grouping rows
		 * together.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.orderFixed
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderFixed": [[0,'asc']]
		 *      } );
		 *    } )
		 */
		"aaSortingFixed": [],
	
	
		/**
		 * DataTables can be instructed to load data to display in the table from a
		 * Ajax source. This option defines how that Ajax call is made and where to.
		 *
		 * The `ajax` property has three different modes of operation, depending on
		 * how it is defined. These are:
		 *
		 * * `string` - Set the URL from where the data should be loaded from.
		 * * `object` - Define properties for `jQuery.ajax`.
		 * * `function` - Custom data get function
		 *
		 * `string`
		 * --------
		 *
		 * As a string, the `ajax` property simply defines the URL from which
		 * DataTables will load data.
		 *
		 * `object`
		 * --------
		 *
		 * As an object, the parameters in the object are passed to
		 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
		 * of the Ajax request. DataTables has a number of default parameters which
		 * you can override using this option. Please refer to the jQuery
		 * documentation for a full description of the options available, although
		 * the following parameters provide additional options in DataTables or
		 * require special consideration:
		 *
		 * * `data` - As with jQuery, `data` can be provided as an object, but it
		 *   can also be used as a function to manipulate the data DataTables sends
		 *   to the server. The function takes a single parameter, an object of
		 *   parameters with the values that DataTables has readied for sending. An
		 *   object may be returned which will be merged into the DataTables
		 *   defaults, or you can add the items to the object that was passed in and
		 *   not return anything from the function. This supersedes `fnServerParams`
		 *   from DataTables 1.9-.
		 *
		 * * `dataSrc` - By default DataTables will look for the property `data` (or
		 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
		 *   from an Ajax source or for server-side processing - this parameter
		 *   allows that property to be changed. You can use Javascript dotted
		 *   object notation to get a data source for multiple levels of nesting, or
		 *   it my be used as a function. As a function it takes a single parameter,
		 *   the JSON returned from the server, which can be manipulated as
		 *   required, with the returned value being that used by DataTables as the
		 *   data source for the table. This supersedes `sAjaxDataProp` from
		 *   DataTables 1.9-.
		 *
		 * * `success` - Should not be overridden it is used internally in
		 *   DataTables. To manipulate / transform the data returned by the server
		 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
		 *
		 * `function`
		 * ----------
		 *
		 * As a function, making the Ajax call is left up to yourself allowing
		 * complete control of the Ajax request. Indeed, if desired, a method other
		 * than Ajax could be used to obtain the required data, such as Web storage
		 * or an AIR database.
		 *
		 * The function is given four parameters and no return is required. The
		 * parameters are:
		 *
		 * 1. _object_ - Data to send to the server
		 * 2. _function_ - Callback function that must be executed when the required
		 *    data has been obtained. That data should be passed into the callback
		 *    as the only parameter
		 * 3. _object_ - DataTables settings object for the table
		 *
		 * Note that this supersedes `fnServerData` from DataTables 1.9-.
		 *
		 *  @type string|object|function
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.ajax
		 *  @since 1.10.0
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax.
		 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
		 *   $('#example').dataTable( {
		 *     "ajax": "data.json"
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
		 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": "tableData"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
		 *   // from a plain array rather than an array in an object
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": ""
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Manipulate the data returned from the server - add a link to data
		 *   // (note this can, should, be done using `render` for the column - this
		 *   // is just a simple example of how the data can be manipulated).
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "dataSrc": function ( json ) {
		 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
		 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
		 *         }
		 *         return json;
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Add data to the request
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "data": function ( d ) {
		 *         return {
		 *           "extra_search": $('#extra').val()
		 *         };
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Send request as POST
		 *   $('#example').dataTable( {
		 *     "ajax": {
		 *       "url": "data.json",
		 *       "type": "POST"
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get the data from localStorage (could interface with a form for
		 *   // adding, editing and removing rows).
		 *   $('#example').dataTable( {
		 *     "ajax": function (data, callback, settings) {
		 *       callback(
		 *         JSON.parse( localStorage.getItem('dataTablesData') )
		 *       );
		 *     }
		 *   } );
		 */
		"ajax": null,
	
	
		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be
		 * either a 1D array of options which will be used for both the displayed
		 * option and the value, or a 2D array which will use the array in the first
		 * position as the value, and the array in the second position as the
		 * displayed options (useful for language strings such as 'All').
		 *
		 * Note that the `pageLength` property will be automatically set to the
		 * first value given in this array, unless `pageLength` is also provided.
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.lengthMenu
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
		 */
		"aLengthMenu": [ 10, 25, 50, 100 ],
	
	
		/**
		 * The `columns` option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see
		 * {@link DataTable.defaults.column}. Note that if you use `columns` to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don't which
		 * to specify any options).
		 *  @member
		 *
		 *  @name DataTable.defaults.column
		 */
		"aoColumns": null,
	
		/**
		 * Very similar to `columns`, `columnDefs` allows you to target a specific
		 * column, multiple columns, or all columns, using the `targets` property of
		 * each object in the array. This allows great flexibility when creating
		 * tables, as the `columnDefs` arrays can be of any length, targeting the
		 * columns you specifically want. `columnDefs` may use any of the column
		 * options available: {@link DataTable.defaults.column}, but it _must_
		 * have `targets` defined in each object in the array. Values in the `targets`
		 * array may be:
		 *   <ul>
		 *     <li>a string - class name will be matched on the TH for the column</li>
		 *     <li>0 or a positive integer - column index counting from the left</li>
		 *     <li>a negative integer - column index counting from the right</li>
		 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
		 *   </ul>
		 *  @member
		 *
		 *  @name DataTable.defaults.columnDefs
		 */
		"aoColumnDefs": null,
	
	
		/**
		 * Basically the same as `search`, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size
		 * as the number of columns, and each element be an object with the parameters
		 * `search` and `escapeRegex` (the latter is optional). 'null' is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.searchCols
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchCols": [
		 *          null,
		 *          { "search": "My filter" },
		 *          null,
		 *          { "search": "^[0-9]", "escapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
		 */
		"aoSearchCols": [],
	
	
		/**
		 * An array of CSS classes that should be applied to displayed rows. This
		 * array may be of any length, and DataTables will apply each class
		 * sequentially, looping when required.
		 *  @type array
		 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
		 *    options</i>
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.stripeClasses
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
		 */
		"asStripeClasses": null,
	
	
		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using `columns`.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.autoWidth
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "autoWidth": false
		 *      } );
		 *    } );
		 */
		"bAutoWidth": true,
	
	
		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.deferRender
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajax": "sources/arrays.txt",
		 *        "deferRender": true
		 *      } );
		 *    } );
		 */
		"bDeferRender": false,
	
	
		/**
		 * Replace a DataTable which matches the given selector and replace it with
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.destroy
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "srollY": "200px",
		 *        "paginate": false
		 *      } );
		 *
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "filter": false,
		 *        "destroy": true
		 *      } );
		 *    } );
		 */
		"bDestroy": false,
	
	
		/**
		 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain 'true' - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * {@link DataTable.defaults.dom}.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.searching
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "searching": false
		 *      } );
		 *    } );
		 */
		"bFilter": true,
	
	
		/**
		 * Enable or disable the table information display. This shows information
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.info
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "info": false
		 *      } );
		 *    } );
		 */
		"bInfo": true,
	
	
		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.lengthChange
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "lengthChange": false
		 *      } );
		 *    } );
		 */
		"bLengthChange": true,
	
	
		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.paging
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "paging": false
		 *      } );
		 *    } );
		 */
		"bPaginate": true,
	
	
		/**
		 * Enable or disable the display of a 'processing' indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.processing
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "processing": true
		 *      } );
		 *    } );
		 */
		"bProcessing": false,
	
	
		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). `destroy` can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.retrieve
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *
		 *    function initTable ()
		 *    {
		 *      return $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false,
		 *        "retrieve": true
		 *      } );
		 *    }
		 *
		 *    function tableActions ()
		 *    {
		 *      var table = initTable();
		 *      // perform API operations with oTable
		 *    }
		 */
		"bRetrieve": false,
	
	
		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table's viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left "floating" further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table's viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollCollapse
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200",
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"bScrollCollapse": false,
	
	
		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * `ajax` parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverSide
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "xhr.php"
		 *      } );
		 *    } );
		 */
		"bServerSide": false,
	
	
		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the `sortable` option for each column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.ordering
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "ordering": false
		 *      } );
		 *    } );
		 */
		"bSort": true,
	
	
		/**
		 * Enable or display DataTables' ability to sort multiple columns at the
		 * same time (activated by shift-click by the user).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderMulti
		 *
		 *  @example
		 *    // Disable multiple column sorting ability
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderMulti": false
		 *      } );
		 *    } );
		 */
		"bSortMulti": true,
	
	
		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderCellsTop
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "orderCellsTop": true
		 *      } );
		 *    } );
		 */
		"bSortCellsTop": false,
	
	
		/**
		 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
		 * `sorting\_3` to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.orderClasses
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "orderClasses": false
		 *      } );
		 *    } );
		 */
		"bSortClasses": true,
	
	
		/**
		 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
		 * used to save table display information such as pagination information,
		 * display length, filtering and sorting. As such when the end user reloads
		 * the page the display display will match what thy had previously set up.
		 *
		 * Due to the use of `localStorage` the default state saving is not supported
		 * in IE6 or 7. If state saving is required in those browsers, use
		 * `stateSaveCallback` to provide a storage solution such as cookies.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.stateSave
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "stateSave": true
		 *      } );
		 *    } );
		 */
		"bStateSave": false,
	
	
		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} dataIndex The index of this row in the internal aoData array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.createdRow
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "createdRow": function( row, data, dataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" )
		 *          {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCreatedRow": null,
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.drawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "drawCallback": function( settings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnDrawCallback": null,
	
	
		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every 'draw' event.
		 *  @type function
		 *  @param {node} foot "TR" element for the footer
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.footerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "footerCallback": function( tfoot, data, start, end, display ) {
		 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
		 *        }
		 *      } );
		 *    } )
		 */
		"fnFooterCallback": null,
	
	
		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
		 * to have a comma separator for the 'thousands' units (e.g. 1 million is
		 * rendered as "1,000,000") to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} toFormat number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.formatNumber
		 *
		 *  @example
		 *    // Format a number using a single quote for the separator (note that
		 *    // this can also be done with the language.thousands option)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "formatNumber": function ( toFormat ) {
		 *          return toFormat.toString().replace(
		 *            /\B(?=(\d{3})+(?!\d))/g, "'"
		 *          );
		 *        };
		 *      } );
		 *    } );
		 */
		"fnFormatNumber": function ( toFormat ) {
			return toFormat.toString().replace(
				/\B(?=(\d{3})+(?!\d))/g,
				this.oLanguage.sThousands
			);
		},
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} head "TR" element for the header
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.headerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fheaderCallback": function( head, data, start, end, display ) {
		 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
		 *        }
		 *      } );
		 *    } )
		 */
		"fnHeaderCallback": null,
	
	
		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} start Starting position in data for the draw
		 *  @param {int} end End position in data for the draw
		 *  @param {int} max Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} total Total number of rows in the data set, after filtering
		 *  @param {string} pre The string that DataTables has formatted using it's
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.infoCallback
		 *
		 *  @example
		 *    $('#example').dataTable( {
		 *      "infoCallback": function( settings, start, end, max, total, pre ) {
		 *        return start +" to "+ end;
		 *      }
		 *    } );
		 */
		"fnInfoCallback": null,
	
	
		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.initComplete
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "initComplete": function(settings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
		 */
		"fnInitComplete": null,
	
	
		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.preDrawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "preDrawCallback": function( settings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnPreDrawCallback": null,
	
	
		/**
		 * This function allows you to 'post process' each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} row "TR" element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} displayIndex The display index for the current table draw
		 *  @param {int} displayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.rowCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( data[4] == "A" ) {
		 *            $('td:eq(4)', row).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnRowCallback": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * This parameter allows you to override the default function which obtains
		 * the data from the server so something more suitable for your application.
		 * For example you could use POST data, or pull information from a Gears or
		 * AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} source HTTP source to obtain the data from (`ajax`)
		 *  @param {array} data A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} callback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverData
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerData": null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 *  It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} data Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the data array passed in,
		 *    as this is passed by reference.
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverParams
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"fnServerParams": null,
	
	
		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} callback Callback that can be executed when done. It
		 *    should be passed the loaded state object.
		 *  @return {object} The DataTables state object to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadCallback": function (settings, callback) {
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              callback( json );
		 *            }
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadCallback": function ( settings ) {
			try {
				return JSON.parse(
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname
					)
				);
			} catch (e) {
				return {};
			}
		},
	
	
		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for
		 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
		 * a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that is to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoadParams": function (settings, data) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoadParams": null,
	
	
		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that was loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoaded
		 *
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateLoaded": function (settings, data) {
		 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoaded": null,
	
	
		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored By default DataTables will use `localStorage`
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveCallback": function (settings, data) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": data,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveCallback": function ( settings, data ) {
			try {
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname,
					JSON.stringify( data )
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the state to be saved. Called when the table
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or
		 * other state properties or modification. Note that for plug-in authors, you should
		 * use the `stateSaveParams` event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateSave": true,
		 *        "stateSaveParams": function (settings, data) {
		 *          data.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSaveParams": null,
	
	
		/**
		 * Duration for which the saved state information is considered valid. After this period
		 * has elapsed the state will be returned to the default.
		 * Value is given in seconds.
		 *  @type int
		 *  @default 7200 <i>(2 hours)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.stateDuration
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "stateDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
		 */
		"iStateDuration": 7200,
	
	
		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly). In the case
		 * where a filtering is applied to the table on initial load, this can be
		 * indicated by giving the parameter as an array, where the first element is
		 * the number of records available after filtering and the second element is the
		 * number of records without filtering (allowing the table information element
		 * to be shown correctly).
		 *  @type int | array
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.deferLoading
		 *
		 *  @example
		 *    // 57 records available in the table, no filtering applied
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": 57
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "serverSide": true,
		 *        "ajax": "scripts/server_processing.php",
		 *        "deferLoading": [ 57, 100 ],
		 *        "search": {
		 *          "search": "my_filter"
		 *        }
		 *      } );
		 *    } );
		 */
		"iDeferLoading": null,
	
	
		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (`lengthChange`) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pageLength
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pageLength": 50
		 *      } );
		 *    } )
		 */
		"iDisplayLength": 10,
	
	
		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be "20".
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.displayStart
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "displayStart": 20
		 *      } );
		 *    } )
		 */
		"iDisplayStart": 0,
	
	
		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a `tabindex` attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.tabIndex
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "tabIndex": 1
		 *      } );
		 *    } );
		 */
		"iTabIndex": 0,
	
	
		/**
		 * Classes that DataTables assigns to the various components and features
		 * that it adds to the HTML table. This allows classes to be configured
		 * during initialisation in addition to through the static
		 * {@link DataTable.ext.oStdClasses} object).
		 *  @namespace
		 *  @name DataTable.defaults.classes
		 */
		"oClasses": {},
	
	
		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 *  @name DataTable.defaults.language
		 */
		"oLanguage": {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 *  @name DataTable.defaults.language.aria
			 */
			"oAria": {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortAscending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortAscending": ": activate to sort column ascending",
	
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortDescending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "aria": {
				 *            "sortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortDescending": ": activate to sort column descending"
			},
	
			/**
			 * Pagination string used by DataTables for the built-in pagination
			 * control types.
			 *  @namespace
			 *  @name DataTable.defaults.language.paginate
			 */
			"oPaginate": {
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.first
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "first": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sFirst": "First",
	
	
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.last
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "last": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sLast": "Last",
	
	
				/**
				 * Text to use for the 'next' pagination button (to take the user to the
				 * next page).
				 *  @type string
				 *  @default Next
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.next
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "next": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sNext": "Next",
	
	
				/**
				 * Text to use for the 'previous' pagination button (to take the user to
				 * the previous page).
				 *  @type string
				 *  @default Previous
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.previous
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "paginate": {
				 *            "previous": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sPrevious": "Previous"
			},
	
			/**
			 * This string is shown in preference to `zeroRecords` when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of `zeroRecords` will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.emptyTable
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "emptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sEmptyTable": "No data available in table",
	
	
			/**
			 * This string gives information to the end user about the information
			 * that is current on display on the page. The following tokens can be
			 * used in the string and will be dynamically replaced as the table
			 * display updates. This tokens can be placed anywhere in the string, or
			 * removed as needed by the language requires:
			 *
			 * * `\_START\_` - Display index of the first record on the current page
			 * * `\_END\_` - Display index of the last record on the current page
			 * * `\_TOTAL\_` - Number of records in the table after filtering
			 * * `\_MAX\_` - Number of records in the table without filtering
			 * * `\_PAGE\_` - Current page number
			 * * `\_PAGES\_` - Total number of pages of data in the table
			 *
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.info
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "info": "Showing page _PAGE_ of _PAGES_"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
	
	
			/**
			 * Display information string for when the table is empty. Typically the
			 * format of this string should match `info`.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoEmpty
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",
	
	
			/**
			 * When a user filters the information in a table, this string is appended
			 * to the information (`info`) to give an idea of how strong the filtering
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoFiltered
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",
	
	
			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoPostFix
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "infoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoPostFix": "",
	
	
			/**
			 * This decimal place operator is a little different from the other
			 * language options since DataTables doesn't output floating point
			 * numbers, so it won't ever use this for display of a number. Rather,
			 * what this parameter does is modify the sort methods of the table so
			 * that numbers which are in a format which has a character other than
			 * a period (`.`) as a decimal place will be sorted numerically.
			 *
			 * Note that numbers with different decimal places cannot be shown in
			 * the same table and still be sortable, the table must be consistent.
			 * However, multiple different tables on the page can use different
			 * decimal place characters.
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.decimal
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "decimal": ","
			 *          "thousands": "."
			 *        }
			 *      } );
			 *    } );
			 */
			"sDecimal": "",
	
	
			/**
			 * DataTables has a build in number formatter (`formatNumber`) which is
			 * used to format large numbers that are used in the table information.
			 * By default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.thousands
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "thousands": "'"
			 *        }
			 *      } );
			 *    } );
			 */
			"sThousands": ",",
	
	
			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The '_MENU_' variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.lengthMenu
			 *
			 *  @example
			 *    // Language change only
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Language and options change
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "lengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
			 */
			"sLengthMenu": "Show _MENU_ entries",
	
	
			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.loadingRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "loadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
			 */
			"sLoadingRecords": "Loading...",
	
	
			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *  @default Processing...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.processing
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "processing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
			 */
			"sProcessing": "Processing...",
	
	
			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable "_INPUT_", if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If "_INPUT_" is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.search
			 *
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Filter records:"
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "search": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sSearch": "Search:",
	
	
			/**
			 * Assign a `placeholder` attribute to the search `input` element
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.searchPlaceholder
			 */
			"sSearchPlaceholder": "",
	
	
			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default <i>Empty string - i.e. disabled</i>
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.url
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
			 */
			"sUrl": "",
	
	
			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. `emptyTable` is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.zeroRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "language": {
			 *          "zeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
			 */
			"sZeroRecords": "No matching records found"
		},
	
	
		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the `search` parameter must be
		 * defined, but all other parameters are optional. When `regex` is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When `smart`
		 * DataTables will use it's smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.search
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "search": {"search": "Initial search"}
		 *      } );
		 *    } )
		 */
		"oSearch": $.extend( {}, DataTable.models.oSearch ),
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * By default DataTables will look for the property `data` (or `aaData` for
		 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
		 * source or for server-side processing - this parameter allows that
		 * property to be changed. You can use Javascript dotted object notation to
		 * get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default data
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxDataProp
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxDataProp": "data",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * You can instruct DataTables to load data from an external
		 * source using this parameter (use aData if you want to pass data in you
		 * already have). Simply provide a url a JSON object can be obtained from.
		 *  @type string
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxSource
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sAjaxSource": null,
	
	
		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   <ul>
		 *     <li>The following options are allowed:
		 *       <ul>
		 *         <li>'l' - Length changing</li>
		 *         <li>'f' - Filtering input</li>
		 *         <li>'t' - The table!</li>
		 *         <li>'i' - Information</li>
		 *         <li>'p' - Pagination</li>
		 *         <li>'r' - pRocessing</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following constants are allowed:
		 *       <ul>
		 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
		 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following syntax is expected:
		 *       <ul>
		 *         <li>'&lt;' and '&gt;' - div elements</li>
		 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
		 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
		 *       </ul>
		 *     </li>
		 *     <li>Examples:
		 *       <ul>
		 *         <li>'&lt;"wrapper"flipt&gt;'</li>
		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
		 *       </ul>
		 *     </li>
		 *   </ul>
		 *  @type string
		 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
		 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.dom
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
		 */
		"sDom": "lfrtip",
	
	
		/**
		 * Search delay option. This will throttle full table searches that use the
		 * DataTables provided search input element (it does not effect calls to
		 * `dt-api search()`, providing a delay before the search is made.
		 *  @type integer
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.searchDelay
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "searchDelay": 200
		 *      } );
		 *    } )
		 */
		"searchDelay": null,
	
	
		/**
		 * DataTables features six different built-in options for the buttons to
		 * display for pagination control:
		 *
		 * * `numbers` - Page number buttons only
		 * * `simple` - 'Previous' and 'Next' buttons only
		 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
		 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
		 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
		 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
		 *  
		 * Further methods can be added using {@link DataTable.ext.oPagination}.
		 *  @type string
		 *  @default simple_numbers
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pagingType
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "pagingType": "full_numbers"
		 *      } );
		 *    } )
		 */
		"sPaginationType": "simple_numbers",
	
	
		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a
		 * certain layout, or you have a large number of columns in the table, you
		 * can enable x-scrolling to show the table in a viewport, which can be
		 * scrolled. This property can be `true` which will allow the table to
		 * scroll horizontally when needed, or any CSS unit, or a number (in which
		 * case it will be treated as a pixel measurement). Setting as simply `true`
		 * is recommended.
		 *  @type boolean|string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollX
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": true,
		 *        "scrollCollapse": true
		 *      } );
		 *    } );
		 */
		"sScrollX": "",
	
	
		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * "over-sizing" the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollXInner
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollX": "100%",
		 *        "scrollXInner": "110%"
		 *      } );
		 *    } );
		 */
		"sScrollXInner": "",
	
	
		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, and enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can be any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollY
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "scrollY": "200px",
		 *        "paginate": false
		 *      } );
		 *    } );
		 */
		"sScrollY": "",
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through `ajax`, which should be used instead.
		 *
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverMethod
		 *
		 *  @deprecated 1.10. Please use `ajax` for this functionality now.
		 */
		"sServerMethod": "GET",
	
	
		/**
		 * DataTables makes use of renderers when displaying HTML elements for
		 * a table. These renderers can be added or modified by plug-ins to
		 * generate suitable mark-up for a site. For example the Bootstrap
		 * integration plug-in for DataTables uses a paging button renderer to
		 * display pagination buttons in the mark-up required by Bootstrap.
		 *
		 * For further information about the renderers available see
		 * DataTable.ext.renderer
		 *  @type string|object
		 *  @default null
		 *
		 *  @name DataTable.defaults.renderer
		 *
		 */
		"renderer": null,
	
	
		/**
		 * Set the data property name that DataTables should use to get a row's id
		 * to set as the `id` property in the node.
		 *  @type string
		 *  @default DT_RowId
		 *
		 *  @name DataTable.defaults.rowId
		 */
		"rowId": "DT_RowId"
	};
	
	_fnHungarianMap( DataTable.defaults );
	
	
	
	/*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
	
	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.column = {
		/**
		 * Define which column(s) an order will occur on for this column. This
		 * allows a column's ordering to take multiple columns into account when
		 * doing a sort or use the data from a different column. For example first
		 * name / last name columns make sense to do a multi-column sort over the
		 * two columns.
		 *  @type array|int
		 *  @default null <i>Takes the value of the column index automatically</i>
		 *
		 *  @name DataTable.defaults.column.orderData
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
		 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
		 *          { "orderData": 2, "targets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderData": [ 0, 1 ] },
		 *          { "orderData": [ 1, 0 ] },
		 *          { "orderData": 2 },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"aDataSort": null,
		"iDataSort": -1,
	
	
		/**
		 * You can control the default ordering direction, and even alter the
		 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
		 * using this parameter.
		 *  @type array
		 *  @default [ 'asc', 'desc' ]
		 *
		 *  @name DataTable.defaults.column.orderSequence
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
		 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          { "orderSequence": [ "asc" ] },
		 *          { "orderSequence": [ "desc", "asc", "asc" ] },
		 *          { "orderSequence": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"asSorting": [ 'asc', 'desc' ],
	
	
		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.searchable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "searchable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "searchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSearchable": true,
	
	
		/**
		 * Enable or disable ordering on this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.orderable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderable": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "orderable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSortable": true,
	
	
		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.visible
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "visible": false, "targets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "visible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bVisible": true,
	
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} td The TD node that has been created
		 *  @param {*} cellData The Data for the cell
		 *  @param {array|object} rowData The data for the whole row
		 *  @param {int} row The row index for the aoData data store
		 *  @param {int} col The column index for aoColumns
		 *
		 *  @name DataTable.defaults.column.createdCell
		 *  @dtopt Columns
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [3],
		 *          "createdCell": function (td, cellData, rowData, row, col) {
		 *            if ( cellData == "1.7" ) {
		 *              $(td).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		"fnCreatedCell": null,
	
	
		/**
		 * This parameter has been replaced by `data` in DataTables to ensure naming
		 * consistency. `dataProp` can still be used, as there is backwards
		 * compatibility in DataTables for this option, but it is strongly
		 * recommended that you use `data` in preference to `dataProp`.
		 *  @name DataTable.defaults.column.dataProp
		 */
	
	
		/**
		 * This property can be used to read data from any data source property,
		 * including deeply nested objects / properties. `data` can be given in a
		 * number of different ways which effect its behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object. Note that
		 *      function notation is recommended for use in `render` rather than
		 *      `data` as it is much simpler to use as a renderer.
		 * * `null` - use the original data source for the row rather than plucking
		 *   data directly from it. This action has effects on two other
		 *   initialisation options:
		 *    * `defaultContent` - When null is given as the `data` option and
		 *      `defaultContent` is specified for the column, the value defined by
		 *      `defaultContent` will be used for the cell.
		 *    * `render` - When null is used for the `data` option and the `render`
		 *      option is specified for the column, the whole data source for the
		 *      row is used for the renderer.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * `{array|object}` The data source for the row
		 *      * `{string}` The type call data requested - this will be 'set' when
		 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
		 *        when gathering data. Note that when `undefined` is given for the
		 *        type DataTables expects to get the raw data for the object back<
		 *      * `{*}` Data to set when the second parameter is 'set'.
		 *    * Return:
		 *      * The return value from the function is not required when 'set' is
		 *        the type of call, but otherwise the return is what will be used
		 *        for the data requested.
		 *
		 * Note that `data` is a getter and setter option. If you just require
		 * formatting of data for output, you will likely want to use `render` which
		 * is simply a getter and thus simpler to use.
		 *
		 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
		 * name change reflects the flexibility of this property and is consistent
		 * with the naming of mRender. If 'mDataProp' is given, then it will still
		 * be used by DataTables, as it automatically maps the old name to the new
		 * if required.
		 *
		 *  @type string|int|function|null
		 *  @default null <i>Use automatically calculated column index</i>
		 *
		 *  @name DataTable.defaults.column.data
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Read table data from objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {value},
		 *    //      "version": {value},
		 *    //      "grade": {value}
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/objects.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform" },
		 *          { "data": "version" },
		 *          { "data": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Read information from deeply nested objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      "engine": {value},
		 *    //      "browser": {value},
		 *    //      "platform": {
		 *    //         "inner": {value}
		 *    //      },
		 *    //      "details": [
		 *    //         {value}, {value}
		 *    //      ]
		 *    //   }
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          { "data": "platform.inner" },
		 *          { "data": "details.0" },
		 *          { "data": "details.1" }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `data` as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed display and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using default content
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null,
		 *          "defaultContent": "Click to edit"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using array notation - outputting a list from an array
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "name[, ]"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 */
		"mData": null,
	
	
		/**
		 * This property is the rendering partner to `data` and it is suggested that
		 * when you want to manipulate data for display (including filtering,
		 * sorting etc) without altering the underlying data for the table, use this
		 * property. `render` can be considered to be the the read only companion to
		 * `data` which is read / write (then as such more complex). Like `data`
		 * this option can be given in a number of different ways to effect its
		 * behaviour:
		 *
		 * * `integer` - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * `string` - read an object property from the data source. There are
		 *   three 'special' options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in `data`. For example: `browser.version` or
		 *      `browser.name`. If your object parameter name contains a period, use
		 *      `\\` to escape it - i.e. `first\\.name`.
		 *    * `[]` - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: `name[, ]` would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * `()` - Function notation. Adding `()` to the end of a parameter will
		 *      execute a function of the name given. For example: `browser()` for a
		 *      simple function on the data source, `browser.version()` for a
		 *      function in a nested property or even `browser().version` to get an
		 *      object property if the function called returns an object.
		 * * `object` - use different data for the different data types requested by
		 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
		 *   of the object is the data type the property refers to and the value can
		 *   defined using an integer, string or function using the same rules as
		 *   `render` normally does. Note that an `_` option _must_ be specified.
		 *   This is the default value to use if you haven't specified a value for
		 *   the data type requested by DataTables.
		 * * `function` - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * {array|object} The data source for the row (based on `data`)
		 *      * {string} The type call data requested - this will be 'filter',
		 *        'display', 'type' or 'sort'.
		 *      * {array|object} The full data source for the row (not based on
		 *        `data`)
		 *    * Return:
		 *      * The return value from the function is what will be used for the
		 *        data requested.
		 *
		 *  @type string|int|function|object|null
		 *  @default null Use the data source value.
		 *
		 *  @name DataTable.defaults.column.render
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Create a comma separated list from an array of objects
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "ajaxSource": "sources/deep.txt",
		 *        "columns": [
		 *          { "data": "engine" },
		 *          { "data": "browser" },
		 *          {
		 *            "data": "platform",
		 *            "render": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Execute a function to obtain data
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": "browserName()"
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // As an object, extracting different data for the different types
		 *    // This would be used with a data source such as:
		 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
		 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
		 *    // (which has both forms) is used for filtering for if a user inputs either format, while
		 *    // the formatted phone number is the one that is shown in the table.
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": null, // Use the full data source object for the renderer's source
		 *          "render": {
		 *            "_": "phone",
		 *            "filter": "phone_filter",
		 *            "display": "phone_display"
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Use as a function to create a link from the data source
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "data": "download_link",
		 *          "render": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 */
		"mRender": null,
	
	
		/**
		 * Change the cell type created for the column - either TD cells or TH cells. This
		 * can be useful as TH cells have semantic meaning in the table body, allowing them
		 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
		 *  @type string
		 *  @default td
		 *
		 *  @name DataTable.defaults.column.cellType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Make the first column use TH cells
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [ {
		 *          "targets": [ 0 ],
		 *          "cellType": "th"
		 *        } ]
		 *      } );
		 *    } );
		 */
		"sCellType": "td",
	
	
		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.class
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "class": "my_class", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "class": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sClass": "",
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn't need this!
		 *  @type string
		 *  @default <i>Empty string<i>
		 *
		 *  @name DataTable.defaults.column.contentPadding
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "contentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sContentPadding": "",
	
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because `data`
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *
		 *  @name DataTable.defaults.column.defaultContent
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit",
		 *            "targets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "data": null,
		 *            "defaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sDefaultContent": null,
	
	
		/**
		 * This parameter is only used in DataTables' server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default <i>Empty string</i>
		 *
		 *  @name DataTable.defaults.column.name
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "name": "engine", "targets": [ 0 ] },
		 *          { "name": "browser", "targets": [ 1 ] },
		 *          { "name": "platform", "targets": [ 2 ] },
		 *          { "name": "version", "targets": [ 3 ] },
		 *          { "name": "grade", "targets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "name": "engine" },
		 *          { "name": "browser" },
		 *          { "name": "platform" },
		 *          { "name": "version" },
		 *          { "name": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sName": "",
	
	
		/**
		 * Defines a data source type for the ordering which can be used to read
		 * real-time information from the table (updating the internally cached
		 * version) prior to ordering. This allows ordering to occur on user
		 * editable elements such as form inputs.
		 *  @type string
		 *  @default std
		 *
		 *  @name DataTable.defaults.column.orderDataType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
		 *          { "type": "numeric", "targets": [ 3 ] },
		 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
		 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          null,
		 *          null,
		 *          { "orderDataType": "dom-text" },
		 *          { "orderDataType": "dom-text", "type": "numeric" },
		 *          { "orderDataType": "dom-select" },
		 *          { "orderDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sSortDataType": "std",
	
	
		/**
		 * The title of this column.
		 *  @type string
		 *  @default null <i>Derived from the 'TH' value for this column in the
		 *    original HTML table.</i>
		 *
		 *  @name DataTable.defaults.column.title
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "title": "My column title", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "title": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sTitle": null,
	
	
		/**
		 * The type allows you to specify how the data for this column will be
		 * ordered. Four types (string, numeric, date and html (which will strip
		 * HTML tags before ordering)) are currently available. Note that only date
		 * formats understood by Javascript's Date() object will be accepted as type
		 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
		 * 'numeric', 'date' or 'html' (by default). Further types can be adding
		 * through plug-ins.
		 *  @type string
		 *  @default null <i>Auto-detected from raw data</i>
		 *
		 *  @name DataTable.defaults.column.type
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "type": "html", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "type": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sType": null,
	
	
		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null <i>Automatic</i>
		 *
		 *  @name DataTable.defaults.column.width
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using `columnDefs`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columnDefs": [
		 *          { "width": "20%", "targets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using `columns`
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "columns": [
		 *          { "width": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sWidth": null
	};
	
	_fnHungarianMap( DataTable.defaults.column );
	
	
	
	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 *
	 * Note that this object is related to {@link DataTable.defaults} but this
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		"oFeatures": {
	
			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoWidth": null,
	
			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all for DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bDeferRender": null,
	
			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the 'f' option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bFilter": null,
	
			/**
			 * Table information element (the 'Showing x of y records' div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfo": null,
	
			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bLengthChange": null,
	
			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bPaginate": null,
	
			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bProcessing": null,
	
			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bServerSide": null,
	
			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSort": null,
	
			/**
			 * Multi-column sorting
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortMulti": null,
	
			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortClasses": null,
	
			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bStateSave": null
		},
	
	
		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		"oScroll": {
			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bCollapse": null,
	
			/**
			 * Width of the scrollbar for the web-browser's platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			"iBarWidth": 0,
	
			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sX": null,
	
			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			"sXInner": null,
	
			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sY": null
		},
	
		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		"oLanguage": {
			/**
			 * Information callback function. See
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default null
			 */
			"fnInfoCallback": null
		},
	
		/**
		 * Browser support parameters
		 *  @namespace
		 */
		"oBrowser": {
			/**
			 * Indicate if the browser incorrectly calculates width:100% inside a
			 * scrolling element (IE6/7)
			 *  @type boolean
			 *  @default false
			 */
			"bScrollOversize": false,
	
			/**
			 * Determine if the vertical scrollbar is on the right or left of the
			 * scrolling container - needed for rtl language layout, although not
			 * all browsers move the scrollbar (Safari).
			 *  @type boolean
			 *  @default false
			 */
			"bScrollbarLeft": false,
	
			/**
			 * Flag for if `getBoundingClientRect` is fully supported or not
			 *  @type boolean
			 *  @default false
			 */
			"bBounding": false,
	
			/**
			 * Browser scrollbar width
			 *  @type integer
			 *  @default 0
			 */
			"barWidth": 0
		},
	
	
		"ajax": null,
	
	
		/**
		 * Array referencing the nodes which are used for the features. The
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   <ul>
		 *     <li>'l' - Length changing</li>
		 *     <li>'f' - Filtering input</li>
		 *     <li>'t' - The table!</li>
		 *     <li>'i' - Information</li>
		 *     <li>'p' - Pagination</li>
		 *     <li>'r' - pRocessing</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aanFeatures": [],
	
		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		"aoData": [],
	
		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		"aiDisplay": [],
	
		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		"aiDisplayMaster": [],
	
		/**
		 * Map of row ids to data indexes
		 *  @type object
		 *  @default {}
		 */
		"aIds": {},
	
		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		"aoColumns": [],
	
		/**
		 * Store information about the table's header
		 *  @type array
		 *  @default []
		 */
		"aoHeader": [],
	
		/**
		 * Store information about the table's footer
		 *  @type array
		 *  @default []
		 */
		"aoFooter": [],
	
		/**
		 * Store the applied global search information in case we want to force a
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		"oPreviousSearch": {},
	
		/**
		 * Store the applied search for each column - see
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		"aoPreSearchCols": [],
	
		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * <ul>
		 *   <li>Index 0 - column number</li>
		 *   <li>Index 1 - current sorting direction</li>
		 * </ul>
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		"aaSorting": null,
	
		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aaSortingFixed": [],
	
		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"asStripeClasses": null,
	
		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		"asDestroyStripes": [],
	
		/**
		 * If restoring a table - we should restore its width
		 *  @type int
		 *  @default 0
		 */
		"sDestroyWidth": 0,
	
		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		"aoRowCallback": [],
	
		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoHeaderCallback": [],
	
		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoFooterCallback": [],
	
		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		"aoDrawCallback": [],
	
		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		"aoRowCreatedCallback": [],
	
		/**
		 * Callback functions for just before the table is redrawn. A return of
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		"aoPreDrawCallback": [],
	
		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		"aoInitComplete": [],
	
	
		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		"aoStateSaveParams": [],
	
		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		"aoStateLoadParams": [],
	
		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		"aoStateLoaded": [],
	
		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sTableId": "",
	
		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		"nTable": null,
	
		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		"nTHead": null,
	
		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		"nTFoot": null,
	
		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		"nTBody": null,
	
		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		"nTableWrapper": null,
	
		/**
		 * Indicate if when using server-side processing the loading of data
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		"bDeferLoading": false,
	
		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		"bInitialised": false,
	
		/**
		 * Information about open rows. Each object in the array has the parameters
		 * 'nTr' and 'nParent'
		 *  @type array
		 *  @default []
		 */
		"aoOpenRows": [],
	
		/**
		 * Dictate the positioning of DataTables' control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sDom": null,
	
		/**
		 * Search delay (in mS)
		 *  @type integer
		 *  @default null
		 */
		"searchDelay": null,
	
		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default two_button
		 */
		"sPaginationType": "two_button",
	
		/**
		 * The state duration (for `stateSave`) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		"iStateDuration": 0,
	
		/**
		 * Array of callback functions for state saving. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object
		 *       (i.e. '"param": [ 0, 1, 2]')</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateSave": [],
	
		/**
		 * Array of callback functions for state loading. Each array element is an
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the object stored. May return false to cancel state loading</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateLoad": [],
	
		/**
		 * State that was saved. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oSavedState": null,
	
		/**
		 * State that was loaded. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oLoadedState": null,
	
		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sAjaxSource": null,
	
		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sAjaxDataProp": null,
	
		/**
		 * The last jQuery XHR object that was used for server-side data gathering.
		 * This can be used for working with the XHR information in one of the
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		"jqXHR": null,
	
		/**
		 * JSON returned from the server in the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"json": undefined,
	
		/**
		 * Data submitted as part of the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		"oAjaxData": undefined,
	
		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnServerData": null,
	
		/**
		 * Functions which are called prior to sending an Ajax request so extra
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		"aoServerParams": [],
	
		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sServerMethod": null,
	
		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnFormatNumber": null,
	
		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aLengthMenu": null,
	
		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		"iDraw": 0,
	
		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		"bDrawing": false,
	
		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		"iDrawError": -1,
	
		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		"_iDisplayLength": 10,
	
		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		"_iDisplayStart": 0,
	
		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		"_iRecordsTotal": 0,
	
		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		"_iRecordsDisplay": 0,
	
		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		"oClasses": {},
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bFiltered": false,
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bSorted": false,
	
		/**
		 * Indicate that if multiple rows are in the header and there is more than
		 * one unique cell per column, if the top one (true) or bottom one (false)
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bSortCellsTop": null,
	
		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		"oInit": null,
	
		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		"aoDestroyCallback": [],
	
	
		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		"fnRecordsTotal": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsTotal * 1 :
				this.aiDisplayMaster.length;
		},
	
		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		"fnRecordsDisplay": function ()
		{
			return _fnDataSource( this ) == 'ssp' ?
				this._iRecordsDisplay * 1 :
				this.aiDisplay.length;
		},
	
		/**
		 * Get the display end point - aiDisplay index
		 *  @type function
		 */
		"fnDisplayEnd": function ()
		{
			var
				len      = this._iDisplayLength,
				start    = this._iDisplayStart,
				calc     = start + len,
				records  = this.aiDisplay.length,
				features = this.oFeatures,
				paginate = features.bPaginate;
	
			if ( features.bServerSide ) {
				return paginate === false || len === -1 ?
					start + records :
					Math.min( start+len, this._iRecordsDisplay );
			}
			else {
				return ! paginate || calc>records || len===-1 ?
					records :
					calc;
			}
		},
	
		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		"oInstance": null,
	
		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		"sInstance": null,
	
		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		"iTabIndex": 0,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollHead": null,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		"nScrollFoot": null,
	
		/**
		 * Last applied sort
		 *  @type array
		 *  @default []
		 */
		"aLastSort": [],
	
		/**
		 * Stored plug-in instances
		 *  @type object
		 *  @default {}
		 */
		"oPlugins": {},
	
		/**
		 * Function used to get a row's id from the row's data
		 *  @type function
		 *  @default null
		 */
		"rowIdFn": null,
	
		/**
		 * Data location where to store a row's id
		 *  @type string
		 *  @default null
		 */
		"rowId": null
	};

	/**
	 * Extension object for DataTables that is used to provide all extension
	 * options.
	 *
	 * Note that the `DataTable.ext` object is available through
	 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	
	
	/**
	 * DataTables extensions
	 * 
	 * This namespace acts as a collection area for plug-ins that can be used to
	 * extend DataTables capabilities. Indeed many of the build in methods
	 * use this method to provide their own capabilities (sorting methods for
	 * example).
	 *
	 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	 * reasons
	 *
	 *  @namespace
	 */
	DataTable.ext = _ext = {
		/**
		 * Buttons. For use with the Buttons extension for DataTables. This is
		 * defined here so other extensions can define buttons regardless of load
		 * order. It is _not_ used by DataTables core.
		 *
		 *  @type object
		 *  @default {}
		 */
		buttons: {},
	
	
		/**
		 * Element class names
		 *
		 *  @type object
		 *  @default {}
		 */
		classes: {},
	
	
		/**
		 * DataTables build type (expanded by the download builder)
		 *
		 *  @type string
		 */
		builder: "-source-",
	
	
		/**
		 * Error reporting.
		 * 
		 * How should DataTables report an error. Can take the value 'alert',
		 * 'throw', 'none' or a function.
		 *
		 *  @type string|function
		 *  @default alert
		 */
		errMode: "alert",
	
	
		/**
		 * Feature plug-ins.
		 * 
		 * This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are then available for
		 * use through the `dom` initialisation option.
		 * 
		 * Each feature plug-in is described by an object which must have the
		 * following properties:
		 * 
		 * * `fnInit` - function that is used to initialise the plug-in,
		 * * `cFeature` - a character so the feature can be enabled by the `dom`
		 *   instillation option. This is case sensitive.
		 *
		 * The `fnInit` function has the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 *
		 * And the following return is expected:
		 * 
		 * * {node|null} The element which contains your feature. Note that the
		 *   return may also be void if your plug-in does not require to inject any
		 *   DOM elements into DataTables control (`dom`) - for example this might
		 *   be useful when developing a plug-in which allows table control via
		 *   keyboard entry
		 *
		 *  @type array
		 *
		 *  @example
		 *    $.fn.dataTable.ext.features.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T"
		 *    } );
		 */
		feature: [],
	
	
		/**
		 * Row searching.
		 * 
		 * This method of searching is complimentary to the default type based
		 * searching, and a lot more comprehensive as it allows you complete control
		 * over the searching logic. Each element in this array is a function
		 * (parameters described below) that is called for every row in the table,
		 * and your logic decides if it should be included in the searching data set
		 * or not.
		 *
		 * Searching functions have the following input parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{array|object}` Data for the row to be processed (same as the
		 *    original format that was passed in as the data source, or an array
		 *    from a DOM data source
		 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
		 *    can be useful to retrieve the `TR` element if you need DOM interaction.
		 *
		 * And the following return is expected:
		 *
		 * * {boolean} Include the row in the searched result set (true) or not
		 *   (false)
		 *
		 * Note that as with the main search ability in DataTables, technically this
		 * is "filtering", since it is subtractive. However, for consistency in
		 * naming we call it searching here.
		 *
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom search being applied to the
		 *    // fourth column (i.e. the data[3] index) based on two input values
		 *    // from the end-user, matching the data in a certain range.
		 *    $.fn.dataTable.ext.search.push(
		 *      function( settings, data, dataIndex ) {
		 *        var min = document.getElementById('min').value * 1;
		 *        var max = document.getElementById('max').value * 1;
		 *        var version = data[3] == "-" ? 0 : data[3]*1;
		 *
		 *        if ( min == "" && max == "" ) {
		 *          return true;
		 *        }
		 *        else if ( min == "" && version < max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && "" == max ) {
		 *          return true;
		 *        }
		 *        else if ( min < version && version < max ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		search: [],
	
	
		/**
		 * Selector extensions
		 *
		 * The `selector` option can be used to extend the options available for the
		 * selector modifier options (`selector-modifier` object data type) that
		 * each of the three built in selector types offer (row, column and cell +
		 * their plural counterparts). For example the Select extension uses this
		 * mechanism to provide an option to select only rows, columns and cells
		 * that have been marked as selected by the end user (`{selected: true}`),
		 * which can be used in conjunction with the existing built in selector
		 * options.
		 *
		 * Each property is an array to which functions can be pushed. The functions
		 * take three attributes:
		 *
		 * * Settings object for the host table
		 * * Options object (`selector-modifier` object type)
		 * * Array of selected item indexes
		 *
		 * The return is an array of the resulting item indexes after the custom
		 * selector has been applied.
		 *
		 *  @type object
		 */
		selector: {
			cell: [],
			column: [],
			row: []
		},
	
	
		/**
		 * Internal functions, exposed for used in plug-ins.
		 * 
		 * Please note that you should not need to use the internal methods for
		 * anything other than a plug-in (and even then, try to avoid if possible).
		 * The internal function may change between releases.
		 *
		 *  @type object
		 *  @default {}
		 */
		internal: {},
	
	
		/**
		 * Legacy configuration options. Enable and disable legacy options that
		 * are available in DataTables.
		 *
		 *  @type object
		 */
		legacy: {
			/**
			 * Enable / disable DataTables 1.9 compatible server-side processing
			 * requests
			 *
			 *  @type boolean
			 *  @default null
			 */
			ajax: null
		},
	
	
		/**
		 * Pagination plug-in methods.
		 * 
		 * Each entry in this object is a function and defines which buttons should
		 * be shown by the pagination rendering method that is used for the table:
		 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
		 * buttons are displayed in the document, while the functions here tell it
		 * what buttons to display. This is done by returning an array of button
		 * descriptions (what each button will do).
		 *
		 * Pagination types (the four built in options and any additional plug-in
		 * options defined here) can be used through the `paginationType`
		 * initialisation parameter.
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{int} page` The current page index
		 * 2. `{int} pages` The number of pages in the table
		 *
		 * Each function is expected to return an array where each element of the
		 * array can be one of:
		 *
		 * * `first` - Jump to first page when activated
		 * * `last` - Jump to last page when activated
		 * * `previous` - Show previous page when activated
		 * * `next` - Show next page when activated
		 * * `{int}` - Show page of the index given
		 * * `{array}` - A nested array containing the above elements to add a
		 *   containing 'DIV' element (might be useful for styling).
		 *
		 * Note that DataTables v1.9- used this object slightly differently whereby
		 * an object with two functions would be defined for each plug-in. That
		 * ability is still supported by DataTables 1.10+ to provide backwards
		 * compatibility, but this option of use is now decremented and no longer
		 * documented in DataTables 1.10+.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Show previous, next and current page buttons only
		 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
		 *      return [ 'previous', page, 'next' ];
		 *    };
		 */
		pager: {},
	
	
		renderer: {
			pageButton: {},
			header: {}
		},
	
	
		/**
		 * Ordering plug-ins - custom data source
		 * 
		 * The extension options for ordering of data available here is complimentary
		 * to the default type based ordering that DataTables typically uses. It
		 * allows much greater control over the the data that is being used to
		 * order a column, but is necessarily therefore more complex.
		 * 
		 * This type of ordering is useful if you want to do ordering based on data
		 * live from the DOM (for example the contents of an 'input' element) rather
		 * than just the static string that DataTables knows of.
		 * 
		 * The way these plug-ins work is that you create an array of the values you
		 * wish to be ordering for the column in question and then return that
		 * array. The data in the array much be in the index order of the rows in
		 * the table (not the currently ordering order!). Which order data gathering
		 * function is run here depends on the `dt-init columns.orderDataType`
		 * parameter that is used for the column (if any).
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. `{object}` DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. `{int}` Target column index
		 *
		 * Each function is expected to return an array:
		 *
		 * * `{array}` Data for the column to be ordering upon
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Ordering using `input` node values
		 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
		 *    {
		 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
		 *        return $('input', td).val();
		 *      } );
		 *    }
		 */
		order: {},
	
	
		/**
		 * Type based plug-ins.
		 *
		 * Each column in DataTables has a type assigned to it, either by automatic
		 * detection or by direct assignment using the `type` option for the column.
		 * The type of a column will effect how it is ordering and search (plug-ins
		 * can also make use of the column type if required).
		 *
		 * @namespace
		 */
		type: {
			/**
			 * Type detection functions.
			 *
			 * The functions defined in this object are used to automatically detect
			 * a column's type, making initialisation of DataTables super easy, even
			 * when complex data is in the table.
			 *
			 * The functions defined take two parameters:
			 *
		     *  1. `{*}` Data from the column cell to be analysed
		     *  2. `{settings}` DataTables settings object. This can be used to
		     *     perform context specific type detection - for example detection
		     *     based on language settings such as using a comma for a decimal
		     *     place. Generally speaking the options from the settings will not
		     *     be required
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Data type detected, or null if unknown (and thus
			 *   pass it on to the other type detection functions.
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Currency type detection plug-in:
			 *    $.fn.dataTable.ext.type.detect.push(
			 *      function ( data, settings ) {
			 *        // Check the numeric part
			 *        if ( ! data.substring(1).match(/[0-9]/) ) {
			 *          return null;
			 *        }
			 *
			 *        // Check prefixed by currency
			 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
			 *          return 'currency';
			 *        }
			 *        return null;
			 *      }
			 *    );
			 */
			detect: [],
	
	
			/**
			 * Type based search formatting.
			 *
			 * The type based searching functions can be used to pre-format the
			 * data to be search on. For example, it can be used to strip HTML
			 * tags or to de-format telephone numbers for numeric only searching.
			 *
			 * Note that is a search is not defined for a column of a given type,
			 * no search formatting will be performed.
			 * 
			 * Pre-processing of searching data plug-ins - When you assign the sType
			 * for a column (or have it automatically detected for you by DataTables
			 * or a type detection plug-in), you will typically be using this for
			 * custom sorting, but it can also be used to provide custom searching
			 * by allowing you to pre-processing the data and returning the data in
			 * the format that should be searched upon. This is done by adding
			 * functions this object with a parameter name which matches the sType
			 * for that target column. This is the corollary of <i>afnSortData</i>
			 * for searching data.
			 *
			 * The functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for searching
			 *
			 * Each function is expected to return:
			 *
			 * * `{string|null}` Formatted string that will be used for the searching.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
			 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
			 *    }
			 */
			search: {},
	
	
			/**
			 * Type based ordering.
			 *
			 * The column type tells DataTables what ordering to apply to the table
			 * when a column is sorted upon. The order for each type that is defined,
			 * is defined by the functions available in this object.
			 *
			 * Each ordering option can be described by three properties added to
			 * this object:
			 *
			 * * `{type}-pre` - Pre-formatting function
			 * * `{type}-asc` - Ascending order function
			 * * `{type}-desc` - Descending order function
			 *
			 * All three can be used together, only `{type}-pre` or only
			 * `{type}-asc` and `{type}-desc` together. It is generally recommended
			 * that only `{type}-pre` is used, as this provides the optimal
			 * implementation in terms of speed, although the others are provided
			 * for compatibility with existing Javascript sort functions.
			 *
			 * `{type}-pre`: Functions defined take a single parameter:
			 *
		     *  1. `{*}` Data from the column cell to be prepared for ordering
			 *
			 * And return:
			 *
			 * * `{*}` Data to be sorted upon
			 *
			 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
			 * functions, taking two parameters:
			 *
		     *  1. `{*}` Data to compare to the second parameter
		     *  2. `{*}` Data to compare to the first parameter
			 *
			 * And returning:
			 *
			 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
			 *   than the second parameter, ===0 if the two parameters are equal and
			 *   >0 if the first parameter should be sorted height than the second
			 *   parameter.
			 * 
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Numeric ordering of formatted numbers with a pre-formatter
			 *    $.extend( $.fn.dataTable.ext.type.order, {
			 *      "string-pre": function(x) {
			 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
			 *        return parseFloat( a );
			 *      }
			 *    } );
			 *
			 *  @example
			 *    // Case-sensitive string ordering, with no pre-formatting method
			 *    $.extend( $.fn.dataTable.ext.order, {
			 *      "string-case-asc": function(x,y) {
			 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			 *      },
			 *      "string-case-desc": function(x,y) {
			 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			 *      }
			 *    } );
			 */
			order: {}
		},
	
		/**
		 * Unique DataTables instance counter
		 *
		 * @type int
		 * @private
		 */
		_unique: 0,
	
	
		//
		// Depreciated
		// The following properties are retained for backwards compatibility only.
		// The should not be used in new projects and will be removed in a future
		// version
		//
	
		/**
		 * Version check function.
		 *  @type function
		 *  @depreciated Since 1.10
		 */
		fnVersionCheck: DataTable.fnVersionCheck,
	
	
		/**
		 * Index for what 'this' index API functions should use
		 *  @type int
		 *  @deprecated Since v1.10
		 */
		iApiIndex: 0,
	
	
		/**
		 * jQuery UI class container
		 *  @type object
		 *  @deprecated Since v1.10
		 */
		oJUIClasses: {},
	
	
		/**
		 * Software version
		 *  @type string
		 *  @deprecated Since v1.10
		 */
		sVersion: DataTable.version
	};
	
	
	//
	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	//
	$.extend( _ext, {
		afnFiltering: _ext.search,
		aTypes:       _ext.type.detect,
		ofnSearch:    _ext.type.search,
		oSort:        _ext.type.order,
		afnSortData:  _ext.order,
		aoFeatures:   _ext.feature,
		oApi:         _ext.internal,
		oStdClasses:  _ext.classes,
		oPagination:  _ext.pager
	} );
	
	
	$.extend( DataTable.ext.classes, {
		"sTable": "dataTable",
		"sNoFooter": "no-footer",
	
		/* Paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "current",
		"sPageButtonDisabled": "disabled",
	
		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",
	
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
	
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
	
		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_desc_disabled",
		"sSortableDesc": "sorting_asc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
	
		/* Filtering */
		"sFilterInput": "",
	
		/* Page length */
		"sLengthSelect": "",
	
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",
	
		/* Misc */
		"sHeaderTH": "",
		"sFooterTH": "",
	
		// Deprecated
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",
		"sJUIHeader": "",
		"sJUIFooter": ""
	} );
	
	
	var extPagination = DataTable.ext.pager;
	
	function _numbers ( page, pages ) {
		var
			numbers = [],
			buttons = extPagination.numbers_length,
			half = Math.floor( buttons / 2 ),
			i = 1;
	
		if ( pages <= buttons ) {
			numbers = _range( 0, pages );
		}
		else if ( page <= half ) {
			numbers = _range( 0, buttons-2 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
		}
		else if ( page >= pages - 1 - half ) {
			numbers = _range( pages-(buttons-2), pages );
			numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
			numbers.splice( 0, 0, 0 );
		}
		else {
			numbers = _range( page-half+2, page+half-1 );
			numbers.push( 'ellipsis' );
			numbers.push( pages-1 );
			numbers.splice( 0, 0, 'ellipsis' );
			numbers.splice( 0, 0, 0 );
		}
	
		numbers.DT_el = 'span';
		return numbers;
	}
	
	
	$.extend( extPagination, {
		simple: function ( page, pages ) {
			return [ 'previous', 'next' ];
		},
	
		full: function ( page, pages ) {
			return [  'first', 'previous', 'next', 'last' ];
		},
	
		numbers: function ( page, pages ) {
			return [ _numbers(page, pages) ];
		},
	
		simple_numbers: function ( page, pages ) {
			return [ 'previous', _numbers(page, pages), 'next' ];
		},
	
		full_numbers: function ( page, pages ) {
			return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
		},
		
		first_last_numbers: function (page, pages) {
	 		return ['first', _numbers(page, pages), 'last'];
	 	},
	
		// For testing and plug-ins to use
		_numbers: _numbers,
	
		// Number of number buttons (including ellipsis) to show. _Must be odd!_
		numbers_length: 7
	} );
	
	
	$.extend( true, DataTable.ext.renderer, {
		pageButton: {
			_: function ( settings, host, idx, buttons, page, pages ) {
				var classes = settings.oClasses;
				var lang = settings.oLanguage.oPaginate;
				var aria = settings.oLanguage.oAria.paginate || {};
				var btnDisplay, btnClass, counter=0;
	
				var attach = function( container, buttons ) {
					var i, ien, node, button, tabIndex;
					var disabledClass = classes.sPageButtonDisabled;
					var clickHandler = function ( e ) {
						_fnPageChange( settings, e.data.action, true );
					};
	
					for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
						button = buttons[i];
	
						if ( Array.isArray( button ) ) {
							var inner = $( '<'+(button.DT_el || 'div')+'/>' )
								.appendTo( container );
							attach( inner, button );
						}
						else {
							btnDisplay = null;
							btnClass = button;
							tabIndex = settings.iTabIndex;
	
							switch ( button ) {
								case 'ellipsis':
									container.append('<span class="ellipsis">&#x2026;</span>');
									break;
	
								case 'first':
									btnDisplay = lang.sFirst;
	
									if ( page === 0 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'previous':
									btnDisplay = lang.sPrevious;
	
									if ( page === 0 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'next':
									btnDisplay = lang.sNext;
	
									if ( pages === 0 || page === pages-1 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								case 'last':
									btnDisplay = lang.sLast;
	
									if ( pages === 0 || page === pages-1 ) {
										tabIndex = -1;
										btnClass += ' ' + disabledClass;
									}
									break;
	
								default:
									btnDisplay = settings.fnFormatNumber( button + 1 );
									btnClass = page === button ?
										classes.sPageButtonActive : '';
									break;
							}
	
							if ( btnDisplay !== null ) {
								node = $('<a>', {
										'class': classes.sPageButton+' '+btnClass,
										'aria-controls': settings.sTableId,
										'aria-label': aria[ button ],
										'data-dt-idx': counter,
										'tabindex': tabIndex,
										'id': idx === 0 && typeof button === 'string' ?
											settings.sTableId +'_'+ button :
											null
									} )
									.html( btnDisplay )
									.appendTo( container );
	
								_fnBindAction(
									node, {action: button}, clickHandler
								);
	
								counter++;
							}
						}
					}
				};
	
				// IE9 throws an 'unknown error' if document.activeElement is used
				// inside an iframe or frame. Try / catch the error. Not good for
				// accessibility, but neither are frames.
				var activeEl;
	
				try {
					// Because this approach is destroying and recreating the paging
					// elements, focus is lost on the select button which is bad for
					// accessibility. So we want to restore focus once the draw has
					// completed
					activeEl = $(host).find(document.activeElement).data('dt-idx');
				}
				catch (e) {}
	
				attach( $(host).empty(), buttons );
	
				if ( activeEl !== undefined ) {
					$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
				}
			}
		}
	} );
	
	
	
	// Built in type detection. See model.ext.aTypes for information about
	// what is required from this methods.
	$.extend( DataTable.ext.type.detect, [
		// Plain numbers - first since V8 detects some plain numbers as dates
		// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal ) ? 'num'+decimal : null;
		},
	
		// Dates (only those recognised by the browser's Date.parse)
		function ( d, settings )
		{
			// V8 tries _very_ hard to make a string passed into `Date.parse()`
			// valid, so we need to use a regex to restrict date formats. Use a
			// plug-in for anything other than ISO8601 style strings
			if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
		},
	
		// Formatted numbers
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
		},
	
		// HTML numeric
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
		},
	
		// HTML numeric, formatted
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
		},
	
		// HTML (this is strict checking - there must be html)
		function ( d, settings )
		{
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
				'html' : null;
		}
	] );
	
	
	
	// Filter formatting functions. See model.ext.ofnSearch for information about
	// what is required from these methods.
	// 
	// Note that additional search methods are added for the html numbers and
	// html formatted numbers by `_addNumericSort()` when we know what the decimal
	// place is
	
	
	$.extend( DataTable.ext.type.search, {
		html: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data
						.replace( _re_new_lines, " " )
						.replace( _re_html, "" ) :
					'';
		},
	
		string: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === 'string' ?
					data.replace( _re_new_lines, " " ) :
					data;
		}
	} );
	
	
	
	var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
		if ( d !== 0 && (!d || d === '-') ) {
			return -Infinity;
		}
	
		// If a decimal place other than `.` is used, it needs to be given to the
		// function so we can detect it and replace with a `.` which is the only
		// decimal place Javascript recognises - it is not locale aware.
		if ( decimalPlace ) {
			d = _numToDecimal( d, decimalPlace );
		}
	
		if ( d.replace ) {
			if ( re1 ) {
				d = d.replace( re1, '' );
			}
	
			if ( re2 ) {
				d = d.replace( re2, '' );
			}
		}
	
		return d * 1;
	};
	
	
	// Add the numeric 'deformatting' functions for sorting and search. This is done
	// in a function to provide an easy ability for the language options to add
	// additional methods if a non-period decimal place is used.
	function _addNumericSort ( decimalPlace ) {
		$.each(
			{
				// Plain numbers
				"num": function ( d ) {
					return __numericReplace( d, decimalPlace );
				},
	
				// Formatted numbers
				"num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_formatted_numeric );
				},
	
				// HTML numeric
				"html-num": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html );
				},
	
				// HTML numeric, formatted
				"html-num-fmt": function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
				}
			},
			function ( key, fn ) {
				// Add the ordering method
				_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
	
				// For HTML types add a search formatter that will strip the HTML
				if ( key.match(/^html\-/) ) {
					_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
				}
			}
		);
	}
	
	
	// Default sort methods
	$.extend( _ext.type.order, {
		// Dates
		"date-pre": function ( d ) {
			var ts = Date.parse( d );
			return isNaN(ts) ? -Infinity : ts;
		},
	
		// html
		"html-pre": function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					a.replace( /<.*?>/g, "" ).toLowerCase() :
					a+'';
		},
	
		// string
		"string-pre": function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		},
	
		// string-asc and -desc are retained only for compatibility with the old
		// sort methods
		"string-asc": function ( x, y ) {
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
	
		"string-desc": function ( x, y ) {
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		}
	} );
	
	
	// Numeric sorting types - order doesn't matter here
	_addNumericSort( '' );
	
	
	$.extend( true, DataTable.ext.renderer, {
		header: {
			_: function ( settings, cell, column, classes ) {
				// No additional mark-up required
				// Attach a sort listener to update on sort - note that using the
				// `DT` namespace will allow the event to be removed automatically
				// on destroy, while the `dt` namespaced event is the one we are
				// listening for
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) { // need to check this this is the host
						return;               // table, not a nested one
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass(
							classes.sSortAsc +' '+
							classes.sSortDesc
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
				} );
			},
	
			jqueryui: function ( settings, cell, column, classes ) {
				$('<div/>')
					.addClass( classes.sSortJUIWrapper )
					.append( cell.contents() )
					.append( $('<span/>')
						.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
					)
					.appendTo( cell );
	
				// Attach a sort listener to update on sort
				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) {
						return;
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortDesc :
								column.sSortingClass
						);
	
					cell
						.find( 'span.'+classes.sSortIcon )
						.removeClass(
							classes.sSortJUIAsc +" "+
							classes.sSortJUIDesc +" "+
							classes.sSortJUI +" "+
							classes.sSortJUIAscAllowed +" "+
							classes.sSortJUIDescAllowed
						)
						.addClass( columns[ colIdx ] == 'asc' ?
							classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
								classes.sSortJUIDesc :
								column.sSortingClassJUI
						);
				} );
			}
		}
	} );
	
	/*
	 * Public helper functions. These aren't used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
	
	var __htmlEscapeEntities = function ( d ) {
		if (Array.isArray(d)) {
			d = d.join(',');
		}
	
		return typeof d === 'string' ?
			d
				.replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/"/g, '&quot;') :
			d;
	};
	
	/**
	 * Helpers for `columns.render`.
	 *
	 * The options defined here can be used with the `columns.render` initialisation
	 * option to provide a display renderer. The following functions are defined:
	 *
	 * * `number` - Will format numeric data (defined by `columns.data`) for
	 *   display, retaining the original unformatted data for sorting and filtering.
	 *   It takes 5 parameters:
	 *   * `string` - Thousands grouping separator
	 *   * `string` - Decimal point indicator
	 *   * `integer` - Number of decimal points to show
	 *   * `string` (optional) - Prefix.
	 *   * `string` (optional) - Postfix (/suffix).
	 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
	 *   parameters.
	 *
	 * @example
	 *   // Column definition using the number renderer
	 *   {
	 *     data: "salary",
	 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	 *   }
	 *
	 * @namespace
	 */
	DataTable.render = {
		number: function ( thousands, decimal, precision, prefix, postfix ) {
			return {
				display: function ( d ) {
					if ( typeof d !== 'number' && typeof d !== 'string' ) {
						return d;
					}
	
					var negative = d < 0 ? '-' : '';
					var flo = parseFloat( d );
	
					// If NaN then there isn't much formatting that we can do - just
					// return immediately, escaping any HTML (this was supposed to
					// be a number after all)
					if ( isNaN( flo ) ) {
						return __htmlEscapeEntities( d );
					}
	
					flo = flo.toFixed( precision );
					d = Math.abs( flo );
	
					var intPart = parseInt( d, 10 );
					var floatPart = precision ?
						decimal+(d - intPart).toFixed( precision ).substring( 2 ):
						'';
	
					// If zero, then can't have a negative prefix
					if (intPart === 0 && parseFloat(floatPart) === 0) {
						negative = '';
					}
	
					return negative + (prefix||'') +
						intPart.toString().replace(
							/\B(?=(\d{3})+(?!\d))/g, thousands
						) +
						floatPart +
						(postfix||'');
				}
			};
		},
	
		text: function () {
			return {
				display: __htmlEscapeEntities,
				filter: __htmlEscapeEntities
			};
		}
	};
	
	
	/*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
	
	
	/**
	 * Create a wrapper function for exporting an internal functions to an external API.
	 *  @param {string} fn API function name
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#internal
	 */
	function _fnExternApiFunc (fn)
	{
		return function() {
			var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
				Array.prototype.slice.call(arguments)
			);
			return DataTable.ext.internal[fn].apply( this, args );
		};
	}
	
	
	/**
	 * Reference to internal functions for use by plug-in developers. Note that
	 * these methods are references to internal functions and are considered to be
	 * private. If you use these methods, be aware that they are liable to change
	 * between versions.
	 *  @namespace
	 */
	$.extend( DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidate: _fnInvalidate,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnImplementState: _fnImplementState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnExtend: _fnExtend,
		_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
		                                // in 1.10, so this dead-end function is
		                                // added to prevent errors
	} );
	

	// jQuery access
	$.fn.dataTable = DataTable;

	// Provide access to the host jQuery object (circular reference)
	DataTable.$ = $;

	// Legacy aliases
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;

	// With a capital `D` we return a DataTables API instance rather than a
	// jQuery object
	$.fn.DataTable = function ( opts ) {
		return $(this).dataTable( opts ).api();
	};

	// All properties that are available to $.fn.dataTable should also be
	// available on $.fn.DataTable
	$.each( DataTable, function ( prop, val ) {
		$.fn.DataTable[ prop ] = val;
	} );

	return DataTable;
}));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZGF0YXRhYmxlc19uZXQtZGF0ZXRpbWVfZGlzdF9kYXRhVGFibGVzX2RhdGVUaW1lX2pzLW5vZGVfbW9kdWxlc19kYXRhdGFiLWEyMmUxYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsa0dBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFvQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7QUMxaEREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxFQUFFLGlDQUFRLENBQUMseUVBQVEsRUFBRSw4R0FBb0IsRUFBRSxzSEFBeUIsQ0FBQyxtQ0FBRTtBQUN2RTtBQUNBLEdBQUc7QUFBQSxrR0FBRTtBQUNMO0FBQ0EsTUFBTSxFQXFCSjtBQUNGLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7OztBQ3JDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsa0dBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFpQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUSxRQUFRO0FBQzVCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztB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QUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGdCQUFnQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxtQ0FBbUM7QUFDbkMscUNBQXFDO0FBQ3JDLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGdCQUFnQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEUsMkRBQTJELE1BQU07QUFDakUsd0RBQXdELE1BQU07QUFDOUQsc0RBQXNELE1BQU07QUFDNUQsNERBQTRELE1BQU07QUFDbEU7QUFDQSxzREFBc0QsTUFBTTtBQUM1RCw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUE0RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxrRUFBa0UsU0FBUztBQUMzRTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw0QkFBNEI7QUFDeEY7QUFDQTtBQUNBLG9GQUFvRixnQkFBZ0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQ0FBb0MseUVBQXlFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSwyQ0FBMkMsbUJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCLCtCQUErQjtBQUN2RjtBQUNBLDJCQUEyQjtBQUMzQixvRkFBb0YsZ0JBQWdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQXdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHlCQUF5QixNQUFNO0FBQy9CLGlDQUFpQyxPQUFPLEVBQUUsTUFBTTtBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0Esb0VBQW9FLGdCQUFnQjtBQUNwRjtBQUNBLDRFQUE0RSxnQkFBZ0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlDQUFpQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUNBQWlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQkFBbUI7QUFDOUU7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7O0FBSUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWCxvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksV0FBVyxJQUFJLFdBQVcsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLFFBQVEsRUFBRSxTQUFTLEVBQUU7QUFDM0Y7QUFDQTtBQUNBLGtHQUFrRyxLQUFLO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsR0FBRztBQUNoQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGFBQWE7QUFDekI7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixtQkFBbUIsU0FBUztBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhDQUE4QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxjQUFjO0FBQ2QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsS0FBSztBQUNsQixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xC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Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGFBQWEsT0FBTztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUMsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtQkFBbUI7QUFDeEIsTUFBTSxRQUFRO0FBQ2QsTUFBTSxRQUFRLHVCQUF1QixRQUFRO0FBQzdDLE1BQU0sT0FBTztBQUNiLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsY0FBYztBQUM1QixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkJBQTZCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLHNCQUFzQixNQUFNLEtBQUssTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVLE1BQU0sZUFBZSxJQUFJLFdBQVc7QUFDdEUsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pELGdCQUFnQix5Q0FBeUM7QUFDekQsZ0JBQWdCO0FB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QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkJBQTZCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnM1L2pzL2RhdGFUYWJsZXMuYm9vdHN0cmFwNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtZGF0ZXRpbWUvZGlzdC9kYXRhVGFibGVzLmRhdGVUaW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1zY3JvbGxlci1iczUvanMvc2Nyb2xsZXIuYm9vdHN0cmFwNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2Nyb2xsZXIvanMvZGF0YVRhYmxlcy5zY3JvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VhcmNoYnVpbGRlci1iczUvanMvc2VhcmNoQnVpbGRlci5ib290c3RyYXA1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1zZWFyY2hidWlsZGVyL2pzL2RhdGFUYWJsZXMuc2VhcmNoQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VhcmNocGFuZXMtYnM1L2pzL3NlYXJjaFBhbmVzLmJvb3RzdHJhcDUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXNlYXJjaHBhbmVzL2pzL2RhdGFUYWJsZXMuc2VhcmNoUGFuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXNlbGVjdC1iczUvanMvc2VsZWN0LmJvb3RzdHJhcDUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXNlbGVjdC9qcy9kYXRhVGFibGVzLnNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQvanMvanF1ZXJ5LmRhdGFUYWJsZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIERhdGFUYWJsZXMgQm9vdHN0cmFwIDUgaW50ZWdyYXRpb25cbiAqIDIwMjAgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIERhdGFUYWJsZXMgaW50ZWdyYXRpb24gZm9yIEJvb3RzdHJhcCA0LiBUaGlzIHJlcXVpcmVzIEJvb3RzdHJhcCA1IGFuZFxuICogRGF0YVRhYmxlcyAxLjEwIG9yIG5ld2VyLlxuICpcbiAqIFRoaXMgZmlsZSBzZXRzIHRoZSBkZWZhdWx0cyBhbmQgYWRkcyBvcHRpb25zIHRvIERhdGFUYWJsZXMgdG8gc3R5bGUgaXRzXG4gKiBjb250cm9scyB1c2luZyBCb290c3RyYXAuIFNlZSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbWFudWFsL3N0eWxpbmcvYm9vdHN0cmFwXG4gKiBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi5cbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICl7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQvLyBSZXF1aXJlIERhdGFUYWJsZXMsIHdoaWNoIGF0dGFjaGVzIHRvIGpRdWVyeSwgaW5jbHVkaW5nXG5cdFx0XHRcdC8vIGpRdWVyeSBpZiBuZWVkZWQgYW5kIGhhdmUgYSAkIHByb3BlcnR5IHNvIHdlIGNhbiBhY2Nlc3MgdGhlXG5cdFx0XHRcdC8vIGpRdWVyeSBvYmplY3QgdGhhdCBpcyB1c2VkXG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vKiBTZXQgdGhlIGRlZmF1bHRzIGZvciBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uICovXG4kLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmRlZmF1bHRzLCB7XG5cdGRvbTpcblx0XHRcIjwncm93JzwnY29sLXNtLTEyIGNvbC1tZC02J2w+PCdjb2wtc20tMTIgY29sLW1kLTYnZj4+XCIgK1xuXHRcdFwiPCdyb3cnPCdjb2wtc20tMTIndHI+PlwiICtcblx0XHRcIjwncm93JzwnY29sLXNtLTEyIGNvbC1tZC01J2k+PCdjb2wtc20tMTIgY29sLW1kLTcncD4+XCIsXG5cdHJlbmRlcmVyOiAnYm9vdHN0cmFwJ1xufSApO1xuXG5cbi8qIERlZmF1bHQgY2xhc3MgbW9kaWZpY2F0aW9uICovXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdHNXcmFwcGVyOiAgICAgIFwiZGF0YVRhYmxlc193cmFwcGVyIGR0LWJvb3RzdHJhcDVcIixcblx0c0ZpbHRlcklucHV0OiAgXCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXCIsXG5cdHNMZW5ndGhTZWxlY3Q6IFwiZm9ybS1zZWxlY3QgZm9ybS1zZWxlY3Qtc21cIixcblx0c1Byb2Nlc3Npbmc6ICAgXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmcgY2FyZFwiLFxuXHRzUGFnZUJ1dHRvbjogICBcInBhZ2luYXRlX2J1dHRvbiBwYWdlLWl0ZW1cIlxufSApO1xuXG5cbi8qIEJvb3RzdHJhcCBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyICovXG5EYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b24uYm9vdHN0cmFwID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9zdCwgaWR4LCBidXR0b25zLCBwYWdlLCBwYWdlcyApIHtcblx0dmFyIGFwaSAgICAgPSBuZXcgRGF0YVRhYmxlLkFwaSggc2V0dGluZ3MgKTtcblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0dmFyIGxhbmcgICAgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHR2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcblx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cblx0dmFyIGF0dGFjaCA9IGZ1bmN0aW9uKCBjb250YWluZXIsIGJ1dHRvbnMgKSB7XG5cdFx0dmFyIGksIGllbiwgbm9kZSwgYnV0dG9uO1xuXHRcdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRpZiAoICEkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgYXBpLnBhZ2UoKSAhPSBlLmRhdGEuYWN0aW9uICkge1xuXHRcdFx0XHRhcGkucGFnZSggZS5kYXRhLmFjdGlvbiApLmRyYXcoICdwYWdlJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0YnV0dG9uID0gYnV0dG9uc1tpXTtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBidXR0b24gKSApIHtcblx0XHRcdFx0YXR0YWNoKCBjb250YWluZXIsIGJ1dHRvbiApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGJ0bkRpc3BsYXkgPSAnJztcblx0XHRcdFx0YnRuQ2xhc3MgPSAnJztcblxuXHRcdFx0XHRzd2l0Y2ggKCBidXR0b24gKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZWxsaXBzaXMnOlxuXHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9ICcmI3gyMDI2Oyc7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9ICdkaXNhYmxlZCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2ZpcnN0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc05leHQ7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlIDwgcGFnZXMtMSA/XG5cdFx0XHRcdFx0XHRcdCcnIDogJyBkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsYXN0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNMYXN0O1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzLTEgP1xuXHRcdFx0XHRcdFx0XHQnJyA6ICcgZGlzYWJsZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBidXR0b24gKyAxO1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBwYWdlID09PSBidXR0b24gP1xuXHRcdFx0XHRcdFx0XHQnYWN0aXZlJyA6ICcnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJ0bkRpc3BsYXkgKSB7XG5cdFx0XHRcdFx0bm9kZSA9ICQoJzxsaT4nLCB7XG5cdFx0XHRcdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24rJyAnK2J0bkNsYXNzLFxuXHRcdFx0XHRcdFx0XHQnaWQnOiBpZHggPT09IDAgJiYgdHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLnNUYWJsZUlkICsnXycrIGJ1dHRvbiA6XG5cdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8YT4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0J2hyZWYnOiAnIycsXG5cdFx0XHRcdFx0XHRcdFx0J2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdFx0XHRcdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFbIGJ1dHRvbiBdLFxuXHRcdFx0XHRcdFx0XHRcdCdkYXRhLWR0LWlkeCc6IGNvdW50ZXIsXG5cdFx0XHRcdFx0XHRcdFx0J3RhYmluZGV4Jzogc2V0dGluZ3MuaVRhYkluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6ICdwYWdlLWxpbmsnXG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHQuaHRtbCggYnRuRGlzcGxheSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdFx0c2V0dGluZ3Mub0FwaS5fZm5CaW5kQWN0aW9uKFxuXHRcdFx0XHRcdFx0bm9kZSwge2FjdGlvbjogYnV0dG9ufSwgY2xpY2tIYW5kbGVyXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcblx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4gXG5cdHZhciBhY3RpdmVFbDtcblxuXHR0cnkge1xuXHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0Ly8gY29tcGxldGVkXG5cdFx0YWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cdH1cblx0Y2F0Y2ggKGUpIHt9XG5cblx0YXR0YWNoKFxuXHRcdCQoaG9zdCkuZW1wdHkoKS5odG1sKCc8dWwgY2xhc3M9XCJwYWdpbmF0aW9uXCIvPicpLmNoaWxkcmVuKCd1bCcpLFxuXHRcdGJ1dHRvbnNcblx0KTtcblxuXHRpZiAoIGFjdGl2ZUVsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0JChob3N0KS5maW5kKCAnW2RhdGEtZHQtaWR4PScrYWN0aXZlRWwrJ10nICkudHJpZ2dlcignZm9jdXMnKTtcblx0fVxufTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlO1xufSkpO1xuIiwiLyohIERhdGVUaW1lIHBpY2tlciBmb3IgRGF0YVRhYmxlcy5uZXQgdjEuMS4xXG4gKlxuICogwqkgU3ByeU1lZGlhIEx0ZCwgYWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2U6IE1JVCBkYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIERhdGVUaW1lIHBpY2tlciBmb3IgRGF0YVRhYmxlcy5uZXRcbiAqIEB2ZXJzaW9uICAgICAxLjEuMVxuICogQGZpbGUgICAgICAgIGRhdGFUYWJsZXMuZGF0ZVRpbWUuanNcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkXG4gKiBAY29udGFjdCAgICAgd3d3LmRhdGF0YWJsZXMubmV0L2NvbnRhY3RcbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICl7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggWydqcXVlcnknXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFN1cHBvcnRlZCBmb3JtYXR0aW5nIGFuZCBwYXJzaW5nIGxpYnJhcmllczpcbi8vICogTW9tZW50XG4vLyAqIEx1eG9uXG4vLyAqIERheUpTXG52YXIgZGF0ZUxpYjtcblxuLypcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBhIERhdGVUaW1lIEdVSSBwaWNrZXIgKGNhbGVuZGFyIGFuZCB0aW1lIGlucHV0KS4gT25seSB0aGVcbiAqIGZvcm1hdCBZWVlZLU1NLUREIGlzIHN1cHBvcnRlZCB3aXRob3V0IGFkZGl0aW9uYWwgc29mdHdhcmUsIGJ1dCB0aGUgZW5kIHVzZXJcbiAqIGV4cGVyaWVuY2UgY2FuIGJlIGdyZWF0bHkgZW5oYW5jZWQgYnkgaW5jbHVkaW5nIHRoZSBtb21lbnRqcywgZGF5anMgb3IgbHV4b24gbGlicmFyeVxuICogd2hpY2ggcHJvdmlkZSBkYXRlIC8gdGltZSBwYXJzaW5nIGFuZCBmb3JtYXR0aW5nIG9wdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlIEhUTUw1IGRhdGUgYW5kIGRhdGV0aW1lIGlucHV0XG4gKiB0eXBlcyBhcmUgbm90IHdpZGVseSBzdXBwb3J0ZWQgaW4gZGVza3RvcCBicm93c2Vycy5cbiAqXG4gKiBDb25zdHJ1Y3RlZCBieSB1c2luZzpcbiAqXG4gKiAgICAgbmV3IERhdGVUaW1lKCBpbnB1dCwgb3B0cyApXG4gKlxuICogd2hlcmUgYGlucHV0YCBpcyB0aGUgSFRNTCBpbnB1dCBlbGVtZW50IHRvIHVzZSBhbmQgYG9wdHNgIGlzIGFuIG9iamVjdCBvZlxuICogb3B0aW9ucyBiYXNlZCBvbiB0aGUgYERhdGVUaW1lLmRlZmF1bHRzYCBvYmplY3QuXG4gKi9cbnZhciBEYXRlVGltZSA9IGZ1bmN0aW9uICggaW5wdXQsIG9wdHMgKSB7XG5cdC8vIEF0dGVtcHQgdG8gYXV0byBkZXRlY3QgdGhlIGZvcm1hdHRpbmcgbGlicmFyeSAoaWYgdGhlcmUgaXMgb25lKS4gSGF2aW5nIGl0IGluXG5cdC8vIHRoZSBjb25zdHJ1Y3RvciBhbGxvd3MgbG9hZCBvcmRlciBpbmRlcGVuZGVuY2UuXG5cdGlmICh0eXBlb2YgZGF0ZUxpYiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRkYXRlTGliID0gd2luZG93Lm1vbWVudFxuXHRcdFx0PyB3aW5kb3cubW9tZW50XG5cdFx0XHQ6IHdpbmRvdy5kYXlqc1xuXHRcdFx0XHQ/IHdpbmRvdy5kYXlqc1xuXHRcdFx0XHQ6IHdpbmRvdy5sdXhvblxuXHRcdFx0XHRcdD8gd2luZG93Lmx1eG9uXG5cdFx0XHRcdFx0OiBudWxsO1xuXHR9XG5cblx0dGhpcy5jID0gJC5leHRlbmQoIHRydWUsIHt9LCBEYXRlVGltZS5kZWZhdWx0cywgb3B0cyApO1xuXHR2YXIgY2xhc3NQcmVmaXggPSB0aGlzLmMuY2xhc3NQcmVmaXg7XG5cdHZhciBpMThuID0gdGhpcy5jLmkxOG47XG5cblx0Ly8gT25seSBJUzg2MDEgZGF0ZXMgYXJlIHN1cHBvcnRlZCB3aXRob3V0IG1vbWVudCwgZGF5anMgb3IgbHV4b25cblx0aWYgKCAhIGRhdGVMaWIgJiYgdGhpcy5jLmZvcm1hdCAhPT0gJ1lZWVktTU0tREQnICkge1xuXHRcdHRocm93IFwiRGF0ZVRpbWU6IFdpdGhvdXQgbW9tZW50anMsIGRheWpzIG9yIGx1eG9uIG9ubHkgdGhlIGZvcm1hdCAnWVlZWS1NTS1ERCcgY2FuIGJlIHVzZWRcIjtcblx0fVxuXG5cdC8vIE1pbiBhbmQgbWF4IG5lZWQgdG8gYmUgYERhdGVgIG9iamVjdHMgaW4gdGhlIGNvbmZpZ1xuXHRpZiAodHlwZW9mIHRoaXMuYy5taW5EYXRlID09PSAnc3RyaW5nJykge1xuXHRcdHRoaXMuYy5taW5EYXRlID0gbmV3IERhdGUodGhpcy5jLm1pbkRhdGUpO1xuXHR9XG5cdGlmICh0eXBlb2YgdGhpcy5jLm1heERhdGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0dGhpcy5jLm1heERhdGUgPSBuZXcgRGF0ZSh0aGlzLmMubWF4RGF0ZSk7XG5cdH1cblxuXHR2YXIgdGltZUJsb2NrID0gZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiAnPGRpdiBjbGFzcz1cIicrY2xhc3NQcmVmaXgrJy10aW1lYmxvY2tcIj4nK1xuXHRcdFx0JzwvZGl2Pic7XG5cdH07XG5cblx0dmFyIGdhcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gJzxzcGFuPjo8L3NwYW4+Jztcblx0fTtcblxuXHQvLyBET00gc3RydWN0dXJlXG5cdHZhciBzdHJ1Y3R1cmUgPSAkKFxuXHRcdCc8ZGl2IGNsYXNzPVwiJytjbGFzc1ByZWZpeCsnXCI+Jytcblx0XHRcdCc8ZGl2IGNsYXNzPVwiJytjbGFzc1ByZWZpeCsnLWRhdGVcIj4nK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cIicrY2xhc3NQcmVmaXgrJy10aXRsZVwiPicrXG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctaWNvbkxlZnRcIj4nK1xuXHRcdFx0XHRcdFx0JzxidXR0b24gdGl0bGU9XCInK2kxOG4ucHJldmlvdXMrJ1wiPicraTE4bi5wcmV2aW91cysnPC9idXR0b24+Jytcblx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cIicrY2xhc3NQcmVmaXgrJy1pY29uUmlnaHRcIj4nK1xuXHRcdFx0XHRcdFx0JzxidXR0b24gdGl0bGU9XCInK2kxOG4ubmV4dCsnXCI+JytpMThuLm5leHQrJzwvYnV0dG9uPicrXG5cdFx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctbGFiZWxcIj4nK1xuXHRcdFx0XHRcdFx0JzxzcGFuPjwvc3Bhbj4nK1xuXHRcdFx0XHRcdFx0JzxzZWxlY3QgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctbW9udGhcIj48L3NlbGVjdD4nK1xuXHRcdFx0XHRcdCc8L2Rpdj4nK1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiJytjbGFzc1ByZWZpeCsnLWxhYmVsXCI+Jytcblx0XHRcdFx0XHRcdCc8c3Bhbj48L3NwYW4+Jytcblx0XHRcdFx0XHRcdCc8c2VsZWN0IGNsYXNzPVwiJytjbGFzc1ByZWZpeCsnLXllYXJcIj48L3NlbGVjdD4nK1xuXHRcdFx0XHRcdCc8L2Rpdj4nK1xuXHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctYnV0dG9uc1wiPicrXG5cdFx0XHRcdFx0JzxhIGNsYXNzPVwiJytjbGFzc1ByZWZpeCsnLWNsZWFyXCI+JytpMThuLmNsZWFyKyc8L2E+Jytcblx0XHRcdFx0XHQnPGEgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctdG9kYXlcIj4nK2kxOG4udG9kYXkrJzwvYT4nK1xuXHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctY2FsZW5kYXJcIj48L2Rpdj4nK1xuXHRcdFx0JzwvZGl2PicrXG5cdFx0XHQnPGRpdiBjbGFzcz1cIicrY2xhc3NQcmVmaXgrJy10aW1lXCI+Jytcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2NsYXNzUHJlZml4KyctaG91cnNcIj48L2Rpdj4nK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cIicrY2xhc3NQcmVmaXgrJy1taW51dGVzXCI+PC9kaXY+Jytcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2NsYXNzUHJlZml4Kyctc2Vjb25kc1wiPjwvZGl2PicrXG5cdFx0XHQnPC9kaXY+Jytcblx0XHRcdCc8ZGl2IGNsYXNzPVwiJytjbGFzc1ByZWZpeCsnLWVycm9yXCI+PC9kaXY+Jytcblx0XHQnPC9kaXY+J1xuXHQpO1xuXG5cdHRoaXMuZG9tID0ge1xuXHRcdGNvbnRhaW5lcjogc3RydWN0dXJlLFxuXHRcdGRhdGU6ICAgICAgc3RydWN0dXJlLmZpbmQoICcuJytjbGFzc1ByZWZpeCsnLWRhdGUnICksXG5cdFx0dGl0bGU6ICAgICBzdHJ1Y3R1cmUuZmluZCggJy4nK2NsYXNzUHJlZml4KyctdGl0bGUnICksXG5cdFx0Y2FsZW5kYXI6ICBzdHJ1Y3R1cmUuZmluZCggJy4nK2NsYXNzUHJlZml4KyctY2FsZW5kYXInICksXG5cdFx0dGltZTogICAgICBzdHJ1Y3R1cmUuZmluZCggJy4nK2NsYXNzUHJlZml4KyctdGltZScgKSxcblx0XHRlcnJvcjogICAgIHN0cnVjdHVyZS5maW5kKCAnLicrY2xhc3NQcmVmaXgrJy1lcnJvcicgKSxcblx0XHRidXR0b25zOiAgICAgc3RydWN0dXJlLmZpbmQoICcuJytjbGFzc1ByZWZpeCsnLWJ1dHRvbnMnICksXG5cdFx0Y2xlYXI6ICAgICBzdHJ1Y3R1cmUuZmluZCggJy4nK2NsYXNzUHJlZml4KyctY2xlYXInICksXG5cdFx0dG9kYXk6ICAgICBzdHJ1Y3R1cmUuZmluZCggJy4nK2NsYXNzUHJlZml4KyctdG9kYXknICksXG5cdFx0aW5wdXQ6ICAgICAkKGlucHV0KVxuXHR9O1xuXG5cdHRoaXMucyA9IHtcblx0XHQvKiogQHR5cGUge0RhdGV9IERhdGUgdmFsdWUgdGhhdCB0aGUgcGlja2VyIGhhcyBjdXJyZW50bHkgc2VsZWN0ZWQgKi9cblx0XHRkOiBudWxsLFxuXG5cdFx0LyoqIEB0eXBlIHtEYXRlfSBEYXRlIG9mIHRoZSBjYWxlbmRhciAtIG1pZ2h0IG5vdCBtYXRjaCB0aGUgdmFsdWUgKi9cblx0XHRkaXNwbGF5OiBudWxsLFxuXG5cdFx0LyoqIEB0eXBlIHtudW1iZXJ9IFVzZWQgdG8gc2VsZWN0IG1pbnV0ZXMgaW4gYSByYW5nZSB3aGVyZSB0aGUgcmFuZ2UgYmFzZSBpcyBpdHNlbGYgdW5hdmFpbGFibGUgKi9cblx0XHRtaW51dGVzUmFuZ2U6IG51bGwsXG5cblx0XHQvKiogQHR5cGUge251bWJlcn0gVXNlZCB0byBzZWxlY3QgbWludXRlcyBpbiBhIHJhbmdlIHdoZXJlIHRoZSByYW5nZSBiYXNlIGlzIGl0c2VsZiB1bmF2YWlsYWJsZSAqL1xuXHRcdHNlY29uZHNSYW5nZTogbnVsbCxcblxuXHRcdC8qKiBAdHlwZSB7U3RyaW5nfSBVbmlxdWUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhpcyBpbnN0YW5jZSAqL1xuXHRcdG5hbWVzcGFjZTogJ2RhdGVpbWUtJysoRGF0ZVRpbWUuX2luc3RhbmNlKyspLFxuXG5cdFx0LyoqIEB0eXBlIHtPYmplY3R9IFBhcnRzIG9mIHRoZSBwaWNrZXIgdGhhdCBzaG91bGQgYmUgc2hvd24gKi9cblx0XHRwYXJ0czoge1xuXHRcdFx0ZGF0ZTogICAgdGhpcy5jLmZvcm1hdC5tYXRjaCggL1tZTURdfEwoPyFUKXxsLyApICE9PSBudWxsLFxuXHRcdFx0dGltZTogICAgdGhpcy5jLmZvcm1hdC5tYXRjaCggL1tIaG1dfExUfExUUy8gKSAhPT0gbnVsbCxcblx0XHRcdHNlY29uZHM6IHRoaXMuYy5mb3JtYXQuaW5kZXhPZiggJ3MnICkgICAhPT0gLTEsXG5cdFx0XHRob3VyczEyOiB0aGlzLmMuZm9ybWF0Lm1hdGNoKCAvW2hhQV0vICkgIT09IG51bGxcblx0XHR9XG5cdH07XG5cblx0dGhpcy5kb20uY29udGFpbmVyXG5cdFx0LmFwcGVuZCggdGhpcy5kb20uZGF0ZSApXG5cdFx0LmFwcGVuZCggdGhpcy5kb20udGltZSApXG5cdFx0LmFwcGVuZCggdGhpcy5kb20uZXJyb3IgKTtcblxuXHR0aGlzLmRvbS5kYXRlXG5cdFx0LmFwcGVuZCggdGhpcy5kb20udGl0bGUgKVxuXHRcdC5hcHBlbmQoIHRoaXMuZG9tLmJ1dHRvbnMgKVxuXHRcdC5hcHBlbmQoIHRoaXMuZG9tLmNhbGVuZGFyICk7XG5cblx0dGhpcy5fY29uc3RydWN0b3IoKTtcbn07XG5cbiQuZXh0ZW5kKCBEYXRlVGltZS5wcm90b3R5cGUsIHtcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogUHVibGljXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIERlc3Ryb3kgdGhlIGNvbnRyb2xcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9oaWRlKHRydWUpO1xuXHRcdHRoaXMuZG9tLmNvbnRhaW5lci5vZmYoKS5lbXB0eSgpO1xuXHRcdHRoaXMuZG9tLmlucHV0XG5cdFx0XHQucmVtb3ZlQXR0cignYXV0b2NvbXBsZXRlJylcblx0XHRcdC5vZmYoJy5kYXRldGltZScpO1xuXHR9LFxuXG5cdGVycm9yTXNnOiBmdW5jdGlvbiAoIG1zZyApIHtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLmRvbS5lcnJvcjtcblxuXHRcdGlmICggbXNnICkge1xuXHRcdFx0ZXJyb3IuaHRtbCggbXNnICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZXJyb3IuZW1wdHkoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faGlkZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIGRhdGUgKSB7XG5cdFx0dGhpcy5jLm1heERhdGUgPSB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZydcblx0XHRcdD8gbmV3IERhdGUoZGF0ZSlcblx0XHRcdDogZGF0ZTtcblxuXHRcdHRoaXMuX29wdGlvbnNUaXRsZSgpO1xuXHRcdHRoaXMuX3NldENhbGFuZGVyKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggZGF0ZSApIHtcblx0XHR0aGlzLmMubWluRGF0ZSA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJ1xuXHRcdFx0PyBuZXcgRGF0ZShkYXRlKVxuXHRcdFx0OiBkYXRlO1xuXG5cdFx0dGhpcy5fb3B0aW9uc1RpdGxlKCk7XG5cdFx0dGhpcy5fc2V0Q2FsYW5kZXIoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhbiBlbGVtZW50IGJlbG9uZ3MgdG8gdGhpcyBjb250cm9sXG5cdCAqXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgRWxlbWVudCB0byBjaGVja1xuXHQgKiBAcmV0dXJuIHtib29sZWFufSAgIHRydWUgaWYgb3duZWQgYnkgdGhpcyBjb250cm9sLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdG93bnM6IGZ1bmN0aW9uICggbm9kZSApIHtcblx0XHRyZXR1cm4gJChub2RlKS5wYXJlbnRzKCkuZmlsdGVyKCB0aGlzLmRvbS5jb250YWluZXIgKS5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgLyBzZXQgdGhlIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ3xEYXRlfSBzZXQgICBWYWx1ZSB0byBzZXRcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gW3dyaXRlPXRydWVdIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGZvcm1hdHRlZCB2YWx1ZVxuXHQgKiAgIHNob3VsZCBiZSB3cml0dGVuIGludG8gdGhlIGlucHV0IGVsZW1lbnRcblx0ICovXG5cdHZhbDogZnVuY3Rpb24gKCBzZXQsIHdyaXRlICkge1xuXHRcdGlmICggc2V0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zLmQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZXQgaW5zdGFuY2VvZiBEYXRlICkge1xuXHRcdFx0dGhpcy5zLmQgPSB0aGlzLl9kYXRlVG9VdGMoIHNldCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2V0ID09PSBudWxsIHx8IHNldCA9PT0gJycgKSB7XG5cdFx0XHR0aGlzLnMuZCA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZXQgPT09ICctLW5vdycgKSB7XG5cdFx0XHR0aGlzLnMuZCA9IG5ldyBEYXRlKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2Ygc2V0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIGx1eG9uIHVzZXMgZGlmZmVyZW50IG1ldGhvZCBuYW1lcyBzbyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGVtXG5cdFx0XHRpZihkYXRlTGliICYmIGRhdGVMaWIgPT0gd2luZG93Lmx1eG9uKSB7XG5cdFx0XHRcdHZhciBsdXhEVCA9IGRhdGVMaWIuRGF0ZVRpbWUuZnJvbUZvcm1hdChzZXQsIHRoaXMuYy5mb3JtYXQpXG5cdFx0XHRcdHRoaXMucy5kID0gbHV4RFQuaXNWYWxpZCA/IGx1eERULnRvSlNEYXRlKCkgOiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGRhdGVMaWIgKSB7XG5cdFx0XHRcdC8vIFVzZSBtb21lbnQsIGRheWpzIG9yIGx1eG9uIGlmIHBvc3NpYmxlIChldmVuIGZvciBJU084NjAxIHN0cmluZ3MsIHNpbmNlIGl0XG5cdFx0XHRcdC8vIHdpbGwgY29ycmVjdGx5IGhhbmRsZSAwMDAwLTAwLTAwIGFuZCB0aGUgbGlrZSlcblx0XHRcdFx0dmFyIG0gPSBkYXRlTGliLnV0Yyggc2V0LCB0aGlzLmMuZm9ybWF0LCB0aGlzLmMubG9jYWxlLCB0aGlzLmMuc3RyaWN0ICk7XG5cdFx0XHRcdHRoaXMucy5kID0gbS5pc1ZhbGlkKCkgPyBtLnRvRGF0ZSgpIDogbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBFbHNlIG11c3QgYmUgdXNpbmcgSVNPODYwMSB3aXRob3V0IGEgZGF0ZSBsaWJyYXJ5IChjb25zdHJ1Y3RvciB3b3VsZFxuXHRcdFx0XHQvLyBoYXZlIHRocm93biBhbiBlcnJvciBvdGhlcndpc2UpXG5cdFx0XHRcdHZhciBtYXRjaCA9IHNldC5tYXRjaCgvKFxcZHs0fSlcXC0oXFxkezJ9KVxcLShcXGR7Mn0pLyApO1xuXHRcdFx0XHR0aGlzLnMuZCA9IG1hdGNoID9cblx0XHRcdFx0XHRuZXcgRGF0ZSggRGF0ZS5VVEMobWF0Y2hbMV0sIG1hdGNoWzJdLTEsIG1hdGNoWzNdKSApIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggd3JpdGUgfHwgd3JpdGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5zLmQgKSB7XG5cdFx0XHRcdHRoaXMuX3dyaXRlT3V0cHV0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gVGhlIGlucHV0IHZhbHVlIHdhcyBub3QgdmFsaWQuLi5cblx0XHRcdFx0dGhpcy5kb20uaW5wdXQudmFsKCBzZXQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBOZWVkIHNvbWV0aGluZyB0byBkaXNwbGF5XG5cdFx0dGhpcy5zLmRpc3BsYXkgPSB0aGlzLnMuZFxuXHRcdFx0PyBuZXcgRGF0ZSggdGhpcy5zLmQudG9TdHJpbmcoKSApXG5cdFx0XHQ6IG5ldyBEYXRlKCk7XG5cblx0XHQvLyBTZXQgdGhlIGRheSBvZiB0aGUgbW9udGggdG8gYmUgMSBzbyBjaGFuZ2luZyBiZXR3ZWVuIG1vbnRocyBkb2Vzbid0XG4gICAgICAgIC8vIHJ1biBpbnRvIGlzc3VlcyB3aGVuIGdvaW5nIGZyb20gZGF5IDMxIHRvIDI4IChmb3IgZXhhbXBsZSlcblx0XHR0aGlzLnMuZGlzcGxheS5zZXRVVENEYXRlKCAxICk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIGRpc3BsYXkgZWxlbWVudHMgZm9yIHRoZSBuZXcgdmFsdWVcblx0XHR0aGlzLl9zZXRUaXRsZSgpO1xuXHRcdHRoaXMuX3NldENhbGFuZGVyKCk7XG5cdFx0dGhpcy5fc2V0VGltZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBDb25zdHJ1Y3RvclxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBCdWlsZCB0aGUgY29udHJvbCBhbmQgYXNzaWduIGluaXRpYWwgZXZlbnQgaGFuZGxlcnNcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgY2xhc3NQcmVmaXggPSB0aGlzLmMuY2xhc3NQcmVmaXg7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmRvbS5pbnB1dC52YWwoKTtcblxuXHRcdHZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjdXJyID0gdGhhdC5kb20uaW5wdXQudmFsKCk7XG5cblx0XHRcdGlmIChjdXJyICE9PSBsYXN0KSB7XG5cdFx0XHRcdHRoYXQuYy5vbkNoYW5nZS5jYWxsKCB0aGF0LCBjdXJyLCB0aGF0LnMuZCwgdGhhdC5kb20uaW5wdXQgKTtcblx0XHRcdFx0bGFzdCA9IGN1cnI7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmICggISB0aGlzLnMucGFydHMuZGF0ZSApIHtcblx0XHRcdHRoaXMuZG9tLmRhdGUuY3NzKCAnZGlzcGxheScsICdub25lJyApO1xuXHRcdH1cblxuXHRcdGlmICggISB0aGlzLnMucGFydHMudGltZSApIHtcblx0XHRcdHRoaXMuZG9tLnRpbWUuY3NzKCAnZGlzcGxheScsICdub25lJyApO1xuXHRcdH1cblxuXHRcdGlmICggISB0aGlzLnMucGFydHMuc2Vjb25kcyApIHtcblx0XHRcdHRoaXMuZG9tLnRpbWUuY2hpbGRyZW4oJ2Rpdi4nK2NsYXNzUHJlZml4Kyctc2Vjb25kcycpLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5kb20udGltZS5jaGlsZHJlbignc3BhbicpLmVxKDEpLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGlmICggISB0aGlzLmMuYnV0dG9ucy5jbGVhciApIHtcblx0XHRcdHRoaXMuZG9tLmNsZWFyLmNzcyggJ2Rpc3BsYXknLCAnbm9uZScgKTtcblx0XHR9XG5cblx0XHRpZiAoICEgdGhpcy5jLmJ1dHRvbnMudG9kYXkgKSB7XG5cdFx0XHR0aGlzLmRvbS50b2RheS5jc3MoICdkaXNwbGF5JywgJ25vbmUnICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVuZGVyIHRoZSBvcHRpb25zXG5cdFx0dGhpcy5fb3B0aW9uc1RpdGxlKCk7XG5cblx0XHQkKGRvY3VtZW50KS5vbignaTE4bi5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncykge1xuXHRcdFx0aWYgKHNldHRpbmdzLm9MYW5ndWFnZS5kYXRldGltZSkge1xuXHRcdFx0XHQkLmV4dGVuZCh0cnVlLCB0aGF0LmMuaTE4biwgc2V0dGluZ3Mub0xhbmd1YWdlLmRhdGV0aW1lKTtcblx0XHRcdFx0dGhhdC5fb3B0aW9uc1RpdGxlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBXaGVuIGF0dGFjaGVkIHRvIGEgaGlkZGVuIGlucHV0LCB3ZSBhbHdheXMgc2hvdyB0aGUgaW5wdXQgcGlja2VyLCBhbmRcblx0XHQvLyBkbyBzbyBpbmxpbmVcblx0XHRpZiAodGhpcy5kb20uaW5wdXQuYXR0cigndHlwZScpID09PSAnaGlkZGVuJykge1xuXHRcdFx0dGhpcy5kb20uY29udGFpbmVyLmFkZENsYXNzKCdpbmxpbmUnKTtcblx0XHRcdHRoaXMuYy5hdHRhY2hUbyA9ICdpbnB1dCc7XG5cblx0XHRcdHRoaXMudmFsKCB0aGlzLmRvbS5pbnB1dC52YWwoKSwgZmFsc2UgKTtcblx0XHRcdHRoaXMuX3Nob3coKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRpZiAobGFzdCkge1xuXHRcdFx0dGhpcy52YWwoIGxhc3QsIGZhbHNlICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciB0aGUgZGlzcGxheSBvZiB0aGUgd2lkZ2V0IHdoZW4gY2xpY2tpbmcgb3IgZm9jdXNpbmcgb24gdGhlXG5cdFx0Ly8gaW5wdXQgZWxlbWVudFxuXHRcdHRoaXMuZG9tLmlucHV0XG5cdFx0XHQuYXR0cignYXV0b2NvbXBsZXRlJywgJ29mZicpXG5cdFx0XHQub24oJ2ZvY3VzLmRhdGV0aW1lIGNsaWNrLmRhdGV0aW1lJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBJZiBhbHJlYWR5IHZpc2libGUgLSBkb24ndCBkbyBhbnl0aGluZ1xuXHRcdFx0XHRpZiAoIHRoYXQuZG9tLmNvbnRhaW5lci5pcygnOnZpc2libGUnKSB8fCB0aGF0LmRvbS5pbnB1dC5pcygnOmRpc2FibGVkJykgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSW4gY2FzZSB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgYnkgdGV4dFxuXHRcdFx0XHR0aGF0LnZhbCggdGhhdC5kb20uaW5wdXQudmFsKCksIGZhbHNlICk7XG5cblx0XHRcdFx0dGhhdC5fc2hvdygpO1xuXHRcdFx0fSApXG5cdFx0XHQub24oJ2tleXVwLmRhdGV0aW1lJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGNhbGVuZGFyJ3MgZGlzcGxheWVkIHZhbHVlIGFzIHRoZSB1c2VyIHR5cGVzXG5cdFx0XHRcdGlmICggdGhhdC5kb20uY29udGFpbmVyLmlzKCc6dmlzaWJsZScpICkge1xuXHRcdFx0XHRcdHRoYXQudmFsKCB0aGF0LmRvbS5pbnB1dC52YWwoKSwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0Ly8gTWFpbiBldmVudCBoYW5kbGVycyBmb3IgaW5wdXQgaW4gdGhlIHdpZGdldFxuXHRcdHRoaXMuZG9tLmNvbnRhaW5lclxuXHRcdFx0Lm9uKCAnY2hhbmdlJywgJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHNlbGVjdCA9ICQodGhpcyk7XG5cdFx0XHRcdHZhciB2YWwgPSBzZWxlY3QudmFsKCk7XG5cblx0XHRcdFx0aWYgKCBzZWxlY3QuaGFzQ2xhc3MoY2xhc3NQcmVmaXgrJy1tb250aCcpICkge1xuXHRcdFx0XHRcdC8vIE1vbnRoIHNlbGVjdFxuXHRcdFx0XHRcdHRoYXQuX2NvcnJlY3RNb250aCggdGhhdC5zLmRpc3BsYXksIHZhbCApO1xuXHRcdFx0XHRcdHRoYXQuX3NldFRpdGxlKCk7XG5cdFx0XHRcdFx0dGhhdC5fc2V0Q2FsYW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggc2VsZWN0Lmhhc0NsYXNzKGNsYXNzUHJlZml4KycteWVhcicpICkge1xuXHRcdFx0XHRcdC8vIFllYXIgc2VsZWN0XG5cdFx0XHRcdFx0dGhhdC5zLmRpc3BsYXkuc2V0VVRDRnVsbFllYXIoIHZhbCApO1xuXHRcdFx0XHRcdHRoYXQuX3NldFRpdGxlKCk7XG5cdFx0XHRcdFx0dGhhdC5fc2V0Q2FsYW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggc2VsZWN0Lmhhc0NsYXNzKGNsYXNzUHJlZml4KyctaG91cnMnKSB8fCBzZWxlY3QuaGFzQ2xhc3MoY2xhc3NQcmVmaXgrJy1hbXBtJykgKSB7XG5cdFx0XHRcdFx0Ly8gSG91cnMgLSBuZWVkIHRvIHRha2UgYWNjb3VudCBvZiBBTS9QTSBpbnB1dCBpZiBwcmVzZW50XG5cdFx0XHRcdFx0aWYgKCB0aGF0LnMucGFydHMuaG91cnMxMiApIHtcblx0XHRcdFx0XHRcdHZhciBob3VycyA9ICQodGhhdC5kb20uY29udGFpbmVyKS5maW5kKCcuJytjbGFzc1ByZWZpeCsnLWhvdXJzJykudmFsKCkgKiAxO1xuXHRcdFx0XHRcdFx0dmFyIHBtID0gJCh0aGF0LmRvbS5jb250YWluZXIpLmZpbmQoJy4nK2NsYXNzUHJlZml4KyctYW1wbScpLnZhbCgpID09PSAncG0nO1xuXG5cdFx0XHRcdFx0XHR0aGF0LnMuZC5zZXRVVENIb3VycyggaG91cnMgPT09IDEyICYmICFwbSA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHRwbSAmJiBob3VycyAhPT0gMTIgP1xuXHRcdFx0XHRcdFx0XHRcdGhvdXJzICsgMTIgOlxuXHRcdFx0XHRcdFx0XHRcdGhvdXJzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoYXQucy5kLnNldFVUQ0hvdXJzKCB2YWwgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGF0Ll9zZXRUaW1lKCk7XG5cdFx0XHRcdFx0dGhhdC5fd3JpdGVPdXRwdXQoIHRydWUgKTtcblxuXHRcdFx0XHRcdG9uQ2hhbmdlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHNlbGVjdC5oYXNDbGFzcyhjbGFzc1ByZWZpeCsnLW1pbnV0ZXMnKSApIHtcblx0XHRcdFx0XHQvLyBNaW51dGVzIHNlbGVjdFxuXHRcdFx0XHRcdHRoYXQucy5kLnNldFVUQ01pbnV0ZXMoIHZhbCApO1xuXHRcdFx0XHRcdHRoYXQuX3NldFRpbWUoKTtcblx0XHRcdFx0XHR0aGF0Ll93cml0ZU91dHB1dCggdHJ1ZSApO1xuXG5cdFx0XHRcdFx0b25DaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggc2VsZWN0Lmhhc0NsYXNzKGNsYXNzUHJlZml4Kyctc2Vjb25kcycpICkge1xuXHRcdFx0XHRcdC8vIFNlY29uZHMgc2VsZWN0XG5cdFx0XHRcdFx0dGhhdC5zLmQuc2V0U2Vjb25kcyggdmFsICk7XG5cdFx0XHRcdFx0dGhhdC5fc2V0VGltZSgpO1xuXHRcdFx0XHRcdHRoYXQuX3dyaXRlT3V0cHV0KCB0cnVlICk7XG5cblx0XHRcdFx0XHRvbkNoYW5nZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhhdC5kb20uaW5wdXQuZm9jdXMoKTtcblx0XHRcdFx0dGhhdC5fcG9zaXRpb24oKTtcblx0XHRcdH0gKVxuXHRcdFx0Lm9uKCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR2YXIgZCA9IHRoYXQucy5kO1xuXHRcdFx0XHR2YXIgbm9kZU5hbWUgPSBlLnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbm9kZU5hbWUgPT09ICdzcGFuJyA/XG5cdFx0XHRcdFx0ZS50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRcdFx0ZS50YXJnZXQ7XG5cblx0XHRcdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRcdGlmICggbm9kZU5hbWUgPT09ICdhJyApIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHRpZiAoJCh0YXJnZXQpLmhhc0NsYXNzKGNsYXNzUHJlZml4KyctY2xlYXInKSkge1xuXHRcdFx0XHRcdFx0Ly8gQ2xlYXIgdGhlIHZhbHVlIGFuZCBkb24ndCBjaGFuZ2UgdGhlIGRpc3BsYXlcblx0XHRcdFx0XHRcdHRoYXQucy5kID0gbnVsbDtcblx0XHRcdFx0XHRcdHRoYXQuZG9tLmlucHV0LnZhbCgnJyk7XG5cdFx0XHRcdFx0XHR0aGF0Ll93cml0ZU91dHB1dCgpO1xuXHRcdFx0XHRcdFx0dGhhdC5fc2V0Q2FsYW5kZXIoKTtcblx0XHRcdFx0XHRcdHRoYXQuX3NldFRpbWUoKTtcblxuXHRcdFx0XHRcdFx0b25DaGFuZ2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoJCh0YXJnZXQpLmhhc0NsYXNzKGNsYXNzUHJlZml4KyctdG9kYXknKSkge1xuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY2hhbmdlIHRoZSB2YWx1ZSwgYnV0IGp1bXAgdG8gdGhlIG1vbnRoXG5cdFx0XHRcdFx0XHQvLyBjb250YWluaW5nIHRvZGF5XG5cdFx0XHRcdFx0XHR0aGF0LnMuZGlzcGxheSA9IG5ldyBEYXRlKCk7XG5cblx0XHRcdFx0XHRcdHRoYXQuX3NldFRpdGxlKCk7XG5cdFx0XHRcdFx0XHR0aGF0Ll9zZXRDYWxhbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSAnYnV0dG9uJyApIHtcblx0XHRcdFx0XHR2YXIgYnV0dG9uID0gJCh0YXJnZXQpO1xuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBidXR0b24ucGFyZW50KCk7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudC5oYXNDbGFzcygnZGlzYWJsZWQnKSAmJiAhIHBhcmVudC5oYXNDbGFzcygncmFuZ2UnKSApIHtcblx0XHRcdFx0XHRcdGJ1dHRvbi5ibHVyKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQuaGFzQ2xhc3MoY2xhc3NQcmVmaXgrJy1pY29uTGVmdCcpICkge1xuXHRcdFx0XHRcdFx0Ly8gUHJldmlvdXMgbW9udGhcblx0XHRcdFx0XHRcdHRoYXQucy5kaXNwbGF5LnNldFVUQ01vbnRoKCB0aGF0LnMuZGlzcGxheS5nZXRVVENNb250aCgpLTEgKTtcblx0XHRcdFx0XHRcdHRoYXQuX3NldFRpdGxlKCk7XG5cdFx0XHRcdFx0XHR0aGF0Ll9zZXRDYWxhbmRlcigpO1xuXG5cdFx0XHRcdFx0XHR0aGF0LmRvbS5pbnB1dC5mb2N1cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggcGFyZW50Lmhhc0NsYXNzKGNsYXNzUHJlZml4KyctaWNvblJpZ2h0JykgKSB7XG5cdFx0XHRcdFx0XHQvLyBOZXh0IG1vbnRoXG5cdFx0XHRcdFx0XHR0aGF0Ll9jb3JyZWN0TW9udGgoIHRoYXQucy5kaXNwbGF5LCB0aGF0LnMuZGlzcGxheS5nZXRVVENNb250aCgpKzEgKTtcblx0XHRcdFx0XHRcdHRoYXQuX3NldFRpdGxlKCk7XG5cdFx0XHRcdFx0XHR0aGF0Ll9zZXRDYWxhbmRlcigpO1xuXG5cdFx0XHRcdFx0XHR0aGF0LmRvbS5pbnB1dC5mb2N1cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggYnV0dG9uLnBhcmVudHMoJy4nK2NsYXNzUHJlZml4KyctdGltZScpLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHZhciB2YWwgPSBidXR0b24uZGF0YSgndmFsdWUnKTtcblx0XHRcdFx0XHRcdHZhciB1bml0ID0gYnV0dG9uLmRhdGEoJ3VuaXQnKTtcblxuXHRcdFx0XHRcdFx0ZCA9IHRoYXQuX25lZWRWYWx1ZSgpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVuaXQgPT09ICdtaW51dGVzJyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBwYXJlbnQuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgcGFyZW50Lmhhc0NsYXNzKCdyYW5nZScpICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQucy5taW51dGVzUmFuZ2UgPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0dGhhdC5fc2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGF0LnMubWludXRlc1JhbmdlID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIHVuaXQgPT09ICdzZWNvbmRzJyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBwYXJlbnQuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgcGFyZW50Lmhhc0NsYXNzKCdyYW5nZScpICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQucy5zZWNvbmRzUmFuZ2UgPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0dGhhdC5fc2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGF0LnMuc2Vjb25kc1JhbmdlID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBTcGVjaWZpYyB0byBob3VycyBmb3IgMTJoIGNsb2NrXG5cdFx0XHRcdFx0XHRpZiAoIHZhbCA9PT0gJ2FtJyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBkLmdldFVUQ0hvdXJzKCkgPj0gMTIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gZC5nZXRVVENIb3VycygpIC0gMTI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggdmFsID09PSAncG0nICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGQuZ2V0VVRDSG91cnMoKSA8IDEyICkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9IGQuZ2V0VVRDSG91cnMoKSArIDEyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgc2V0ID0gdW5pdCA9PT0gJ2hvdXJzJyA/XG5cdFx0XHRcdFx0XHRcdCdzZXRVVENIb3VycycgOlxuXHRcdFx0XHRcdFx0XHR1bml0ID09PSAnbWludXRlcycgP1xuXHRcdFx0XHRcdFx0XHRcdCdzZXRVVENNaW51dGVzJyA6XG5cdFx0XHRcdFx0XHRcdFx0J3NldFNlY29uZHMnO1xuXG5cdFx0XHRcdFx0XHRkW3NldF0oIHZhbCApO1xuXHRcdFx0XHRcdFx0dGhhdC5fc2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0dGhhdC5fd3JpdGVPdXRwdXQoIHRydWUgKTtcblx0XHRcdFx0XHRcdG9uQ2hhbmdlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQ2FsZW5kYXIgY2xpY2tcblx0XHRcdFx0XHRcdGQgPSB0aGF0Ll9uZWVkVmFsdWUoKTtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuJ3QgYmUgY2VydGFpbiB0aGF0IHRoZSBjdXJyZW50IGRheSB3aWxsIGV4aXN0IGluXG5cdFx0XHRcdFx0XHQvLyB0aGUgbmV3IG1vbnRoLCBhbmQgbGlrZXdpc2UgZG9uJ3Qga25vdyB0aGF0IHRoZVxuXHRcdFx0XHRcdFx0Ly8gbmV3IGRheSB3aWxsIGV4aXN0IGluIHRoZSBvbGQgbW9udGgsIEJ1dCAxIGFsd2F5c1xuXHRcdFx0XHRcdFx0Ly8gZG9lcywgc28gd2UgY2FuIGNoYW5nZSB0aGUgbW9udGggd2l0aG91dCB3b3JyeSBvZiBhXG5cdFx0XHRcdFx0XHQvLyByZWNhbGN1bGF0aW9uIGJlaW5nIGRvbmUgYXV0b21hdGljYWxseSBieSBgRGF0ZWBcblx0XHRcdFx0XHRcdGQuc2V0VVRDRGF0ZSggMSApO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENGdWxsWWVhciggYnV0dG9uLmRhdGEoJ3llYXInKSApO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENNb250aCggYnV0dG9uLmRhdGEoJ21vbnRoJykgKTtcblx0XHRcdFx0XHRcdGQuc2V0VVRDRGF0ZSggYnV0dG9uLmRhdGEoJ2RheScpICk7XG5cblx0XHRcdFx0XHRcdHRoYXQuX3dyaXRlT3V0cHV0KCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGhpZGUgaWYgdGhlcmUgaXMgYSB0aW1lIHBpY2tlciwgc2luY2Ugd2Ugd2FudCB0b1xuXHRcdFx0XHRcdFx0Ly8gYmUgYWJsZSB0byBzZWxlY3QgYSB0aW1lIGFzIHdlbGwuXG5cdFx0XHRcdFx0XHRpZiAoICEgdGhhdC5zLnBhcnRzLnRpbWUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYW5ub3lpbmcgYnV0IElFIGhhcyBzb21lIGtpbmQgb2YgYXN5bmNcblx0XHRcdFx0XHRcdFx0Ly8gYmVoYXZpb3VyIHdpdGggZm9jdXMgYW5kIHRoZSBmb2N1cyBmcm9tIHRoZSBhYm92ZVxuXHRcdFx0XHRcdFx0XHQvLyB3cml0ZSB3b3VsZCBvY2N1ciBhZnRlciB0aGlzIGhpZGUgLSByZXN1bHRpbmcgaW4gdGhlXG5cdFx0XHRcdFx0XHRcdC8vIGNhbGVuZGFyIG9wZW5pbmcgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQuX2hpZGUoKTtcblx0XHRcdFx0XHRcdFx0fSwgMTAgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGF0Ll9zZXRDYWxhbmRlcigpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRvbkNoYW5nZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBDbGljayBhbnl3aGVyZSBlbHNlIGluIHRoZSB3aWRnZXQgLSByZXR1cm4gZm9jdXMgdG8gdGhlXG5cdFx0XHRcdFx0Ly8gaW5wdXQgZWxlbWVudFxuXHRcdFx0XHRcdHRoYXQuZG9tLmlucHV0LmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblxuXG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIFByaXZhdGVcblx0ICovXG5cblx0LyoqXG5cdCAqIENvbXBhcmUgdGhlIGRhdGUgcGFydCBvbmx5IG9mIHR3byBkYXRlcyAtIHRoaXMgaXMgbWFkZSBzdXBlciBlYXN5IGJ5IHRoZVxuXHQgKiB0b0RhdGVTdHJpbmcgbWV0aG9kIVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtEYXRlfSBhIERhdGUgMVxuXHQgKiBAcGFyYW0gIHtEYXRlfSBiIERhdGUgMlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbXBhcmVEYXRlczogZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gQ2FuJ3QgdXNlIHRvRGF0ZVN0cmluZyBhcyB0aGF0IGNvbnZlcnRzIHRvIGxvY2FsIHRpbWVcblx0XHQvLyBsdXhvbiB1c2VzIGRpZmZlcmVudCBtZXRob2QgbmFtZXMgc28gbmVlZCB0byBiZSBhYmxlIHRvIGNhbGwgdGhlbVxuXHRcdHJldHVybiBkYXRlTGliICYmIGRhdGVMaWIgPT0gd2luZG93Lmx1eG9uXG5cdFx0XHQ/IGRhdGVMaWIuRGF0ZVRpbWUuZnJvbUpTRGF0ZShhKS50b0lTT0RhdGUoKSA9PT0gZGF0ZUxpYi5EYXRlVGltZS5mcm9tSlNEYXRlKGIpLnRvSVNPRGF0ZSgpXG5cdFx0XHQ6IHRoaXMuX2RhdGVUb1V0Y1N0cmluZyhhKSA9PT0gdGhpcy5fZGF0ZVRvVXRjU3RyaW5nKGIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBXaGVuIGNoYW5naW5nIG1vbnRoLCB0YWtlIGFjY291bnQgb2YgdGhlIGZhY3QgdGhhdCBzb21lIG1vbnRocyBkb24ndCBoYXZlXG5cdCAqIHRoZSBzYW1lIG51bWJlciBvZiBkYXlzLiBGb3IgZXhhbXBsZSBnb2luZyBmcm9tIEphbnVhcnkgdG8gRmVicnVhcnkgeW91XG5cdCAqIGNhbiBoYXZlIHRoZSAzMXN0IG9mIEphbiBzZWxlY3RlZCBhbmQganVzdCBhZGQgYSBtb250aCBzaW5jZSB0aGUgZGF0ZVxuXHQgKiB3b3VsZCBzdGlsbCBiZSAzMSwgYW5kIHRodXMgZHJvcCB5b3UgaW50byBNYXJjaC5cblx0ICpcblx0ICogQHBhcmFtICB7RGF0ZX0gZGF0ZSAgRGF0ZSAtIHdpbGwgYmUgbW9kaWZpZWRcblx0ICogQHBhcmFtICB7aW50ZWdlcn0gbW9udGggTW9udGggdG8gc2V0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY29ycmVjdE1vbnRoOiBmdW5jdGlvbiAoIGRhdGUsIG1vbnRoICkge1xuXHRcdHZhciBkYXlzID0gdGhpcy5fZGF5c0luTW9udGgoIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgbW9udGggKTtcblx0XHR2YXIgY29ycmVjdERheXMgPSBkYXRlLmdldFVUQ0RhdGUoKSA+IGRheXM7XG5cblx0XHRkYXRlLnNldFVUQ01vbnRoKCBtb250aCApO1xuXG5cdFx0aWYgKCBjb3JyZWN0RGF5cyApIHtcblx0XHRcdGRhdGUuc2V0VVRDRGF0ZSggZGF5cyApO1xuXHRcdFx0ZGF0ZS5zZXRVVENNb250aCggbW9udGggKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBtZXRob2QuIEJhc2VkIG9uXG5cdCAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4ODE5NTEgYnkgTWF0dGkgVmlya2t1bmVuXG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IHllYXIgIFllYXJcblx0ICogQHBhcmFtICB7aW50ZWdlcn0gbW9udGggTW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGF5c0luTW9udGg6IGZ1bmN0aW9uICggeWVhciwgbW9udGggKSB7XG5cdFx0Ly8gXG5cdFx0dmFyIGlzTGVhcCA9ICgoeWVhciAlIDQpID09PSAwICYmICgoeWVhciAlIDEwMCkgIT09IDAgfHwgKHllYXIgJSA0MDApID09PSAwKSk7XG5cdFx0dmFyIG1vbnRocyA9IFszMSwgKGlzTGVhcCA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cblx0XHRyZXR1cm4gbW9udGhzW21vbnRoXTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IGRhdGUgb2JqZWN0IHdoaWNoIGhhcyB0aGUgVVRDIHZhbHVlcyBzZXQgdG8gdGhlIGxvY2FsIHRpbWUuXG5cdCAqIFRoaXMgYWxsb3dzIHRoZSBsb2NhbCB0aW1lIHRvIGJlIHVzZWQgZGlyZWN0bHkgZm9yIHRoZSBsaWJyYXJ5IHdoaWNoXG5cdCAqIGFsd2F5cyBiYXNlcyBpdHMgY2FsY3VsYXRpb25zIGFuZCBkaXNwbGF5IG9uIFVUQy5cblx0ICpcblx0ICogQHBhcmFtICB7RGF0ZX0gcyBEYXRlIHRvIFwiY29udmVydFwiXG5cdCAqIEByZXR1cm4ge0RhdGV9ICAgU2hpZnRlZCBkYXRlXG5cdCAqL1xuXHRfZGF0ZVRvVXRjOiBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKCBEYXRlLlVUQyhcblx0XHRcdHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpLCBzLmdldERhdGUoKSxcblx0XHRcdHMuZ2V0SG91cnMoKSwgcy5nZXRNaW51dGVzKCksIHMuZ2V0U2Vjb25kcygpXG5cdFx0KSApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBVVEMgSVNPODYwMSBkYXRlIHBhcnQgZnJvbSBhIGRhdGUgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSAge0RhdGV9IGQgRGF0ZSB0byBcImNvbnZlcnRcIlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IElTTyBmb3JtYXR0ZWQgZGF0ZVxuXHQgKi9cblx0X2RhdGVUb1V0Y1N0cmluZzogZnVuY3Rpb24gKCBkICkge1xuXHRcdC8vIGx1eG9uIHVzZXMgZGlmZmVyZW50IG1ldGhvZCBuYW1lcyBzbyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGVtXG5cdFx0cmV0dXJuIGRhdGVMaWIgJiYgZGF0ZUxpYiA9PSB3aW5kb3cubHV4b25cblx0XHRcdD8gZGF0ZUxpYi5EYXRlVGltZS5mcm9tSlNEYXRlKGQpLnRvSVNPRGF0ZSgpXG5cdFx0XHQ6IGQuZ2V0VVRDRnVsbFllYXIoKSsnLScrXG5cdFx0XHRcdHRoaXMuX3BhZChkLmdldFVUQ01vbnRoKCkrMSkrJy0nK1xuXHRcdFx0XHR0aGlzLl9wYWQoZC5nZXRVVENEYXRlKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRoZSBjb250cm9sIGFuZCByZW1vdmUgZXZlbnRzIHJlbGF0ZWQgdG8gaXRzIGRpc3BsYXlcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oaWRlOiBmdW5jdGlvbiAoZGVzdHJveSkge1xuXHRcdGlmICghIGRlc3Ryb3kgJiYgdGhpcy5kb20uaW5wdXQuYXR0cigndHlwZScpID09PSAnaGlkZGVuJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBuYW1lc3BhY2UgPSB0aGlzLnMubmFtZXNwYWNlO1xuXG5cdFx0dGhpcy5kb20uY29udGFpbmVyLmRldGFjaCgpO1xuXG5cdFx0JCh3aW5kb3cpLm9mZiggJy4nK25hbWVzcGFjZSApO1xuXHRcdCQoZG9jdW1lbnQpLm9mZiggJ2tleWRvd24uJytuYW1lc3BhY2UgKTtcblx0XHQkKCdkaXYuZGF0YVRhYmxlc19zY3JvbGxCb2R5Jykub2ZmKCAnc2Nyb2xsLicrbmFtZXNwYWNlICk7XG5cdFx0JCgnZGl2LkRURV9Cb2R5X0NvbnRlbnQnKS5vZmYoICdzY3JvbGwuJytuYW1lc3BhY2UgKTtcblx0XHQkKCdib2R5Jykub2ZmKCAnY2xpY2suJytuYW1lc3BhY2UgKTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydCBhIDI0IGhvdXIgdmFsdWUgdG8gYSAxMiBob3VyIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IHZhbCAyNCBob3VyIHZhbHVlXG5cdCAqIEByZXR1cm4ge2ludGVnZXJ9ICAgICAxMiBob3VyIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaG91cnMyNFRvMTI6IGZ1bmN0aW9uICggdmFsICkge1xuXHRcdHJldHVybiB2YWwgPT09IDAgP1xuXHRcdFx0MTIgOlxuXHRcdFx0dmFsID4gMTIgP1xuXHRcdFx0XHR2YWwgLSAxMiA6XG5cdFx0XHRcdHZhbDtcblx0fSxcblxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGRheSBpbiB0aGUgY2FsZW5kYXIgLSB0aGlzIGlzIGJhc2ljYWxseVxuXHQgKiBhbmQgSFRNTCBjZWxsIHdpdGggYSBidXR0b24gdGhhdCBoYXMgZGF0YSBhdHRyaWJ1dGVzIHNvIHdlIGtub3cgd2hhdCB3YXNcblx0ICogY2xpY2tlZCBvbiAoaWYgaXQgaXMgY2xpY2tlZCBvbikgYW5kIGEgYnVuY2ggb2YgY2xhc3NlcyBmb3Igc3R5bGluZy5cblx0ICpcblx0ICogQHBhcmFtICB7b2JqZWN0fSBkYXkgRGF5IG9iamVjdCBmcm9tIHRoZSBgX2h0bWxNb250aGAgbWV0aG9kXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gICAgIEhUTUwgY2VsbFxuXHQgKi9cblx0X2h0bWxEYXk6IGZ1bmN0aW9uKCBkYXkgKVxuXHR7XG5cdFx0aWYgKCBkYXkuZW1wdHkgKSB7XG5cdFx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cImVtcHR5XCI+PC90ZD4nO1xuXHRcdH1cblxuXHRcdHZhciBjbGFzc2VzID0gWyAnc2VsZWN0YWJsZScgXTtcblx0XHR2YXIgY2xhc3NQcmVmaXggPSB0aGlzLmMuY2xhc3NQcmVmaXg7XG5cblx0XHRpZiAoIGRheS5kaXNhYmxlZCApIHtcblx0XHRcdGNsYXNzZXMucHVzaCggJ2Rpc2FibGVkJyApO1xuXHRcdH1cblxuXHRcdGlmICggZGF5LnRvZGF5ICkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCAnbm93JyApO1xuXHRcdH1cblxuXHRcdGlmICggZGF5LnNlbGVjdGVkICkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCAnc2VsZWN0ZWQnICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8dGQgZGF0YS1kYXk9XCInICsgZGF5LmRheSArICdcIiBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcblx0XHRcdFx0JzxidXR0b24gY2xhc3M9XCInK2NsYXNzUHJlZml4KyctYnV0dG9uICcrY2xhc3NQcmVmaXgrJy1kYXlcIiB0eXBlPVwiYnV0dG9uXCIgJyArJ2RhdGEteWVhcj1cIicgKyBkYXkueWVhciArICdcIiBkYXRhLW1vbnRoPVwiJyArIGRheS5tb250aCArICdcIiBkYXRhLWRheT1cIicgKyBkYXkuZGF5ICsgJ1wiPicgK1xuXHRcdFx0XHRcdCc8c3Bhbj4nK2RheS5kYXkrJzwvc3Bhbj4nK1xuXHRcdFx0XHQnPC9idXR0b24+JyArXG5cdFx0XHQnPC90ZD4nO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCBmb3IgYSBtb250aCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGNhbGVuZGFyIHRhYmxlLlxuXHQgKiBcblx0ICogQmFzZWQgdXBvbiB0aGUgbG9naWMgdXNlZCBpbiBQaWthZGF5IC0gTUlUIGxpY2Vuc2VkXG5cdCAqIENvcHlyaWdodCAoYykgMjAxNCBEYXZpZCBCdXNoZWxsXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYnVzaGVsbC9QaWthZGF5XG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IHllYXIgIFllYXJcblx0ICogQHBhcmFtICB7aW50ZWdlcn0gbW9udGggTW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ2FsZW5kYXIgbW9udGggSFRNTFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2h0bWxNb250aDogZnVuY3Rpb24gKCB5ZWFyLCBtb250aCApIHtcblx0XHR2YXIgbm93ICAgID0gdGhpcy5fZGF0ZVRvVXRjKCBuZXcgRGF0ZSgpICksXG5cdFx0XHRkYXlzICAgPSB0aGlzLl9kYXlzSW5Nb250aCggeWVhciwgbW9udGggKSxcblx0XHRcdGJlZm9yZSA9IG5ldyBEYXRlKCBEYXRlLlVUQyh5ZWFyLCBtb250aCwgMSkgKS5nZXRVVENEYXkoKSxcblx0XHRcdGRhdGEgICA9IFtdLFxuXHRcdFx0cm93ICAgID0gW107XG5cblx0XHRpZiAoIHRoaXMuYy5maXJzdERheSA+IDAgKSB7XG5cdFx0XHRiZWZvcmUgLT0gdGhpcy5jLmZpcnN0RGF5O1xuXG5cdFx0XHRpZiAoYmVmb3JlIDwgMCkge1xuXHRcdFx0XHRiZWZvcmUgKz0gNztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2VsbHMgPSBkYXlzICsgYmVmb3JlLFxuXHRcdFx0YWZ0ZXIgPSBjZWxscztcblxuXHRcdHdoaWxlICggYWZ0ZXIgPiA3ICkge1xuXHRcdFx0YWZ0ZXIgLT0gNztcblx0XHR9XG5cblx0XHRjZWxscyArPSA3IC0gYWZ0ZXI7XG5cblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuYy5taW5EYXRlO1xuXHRcdHZhciBtYXhEYXRlID0gdGhpcy5jLm1heERhdGU7XG5cblx0XHRpZiAoIG1pbkRhdGUgKSB7XG5cdFx0XHRtaW5EYXRlLnNldFVUQ0hvdXJzKDApO1xuXHRcdFx0bWluRGF0ZS5zZXRVVENNaW51dGVzKDApO1xuXHRcdFx0bWluRGF0ZS5zZXRTZWNvbmRzKDApO1xuXHRcdH1cblxuXHRcdGlmICggbWF4RGF0ZSApIHtcblx0XHRcdG1heERhdGUuc2V0VVRDSG91cnMoMjMpO1xuXHRcdFx0bWF4RGF0ZS5zZXRVVENNaW51dGVzKDU5KTtcblx0XHRcdG1heERhdGUuc2V0U2Vjb25kcyg1OSk7XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGk9MCwgcj0wIDsgaTxjZWxscyA7IGkrKyApIHtcblx0XHRcdHZhciBkYXkgICAgICA9IG5ldyBEYXRlKCBEYXRlLlVUQyh5ZWFyLCBtb250aCwgMSArIChpIC0gYmVmb3JlKSkgKSxcblx0XHRcdFx0c2VsZWN0ZWQgPSB0aGlzLnMuZCA/IHRoaXMuX2NvbXBhcmVEYXRlcyhkYXksIHRoaXMucy5kKSA6IGZhbHNlLFxuXHRcdFx0XHR0b2RheSAgICA9IHRoaXMuX2NvbXBhcmVEYXRlcyhkYXksIG5vdyksXG5cdFx0XHRcdGVtcHR5ICAgID0gaSA8IGJlZm9yZSB8fCBpID49IChkYXlzICsgYmVmb3JlKSxcblx0XHRcdFx0ZGlzYWJsZWQgPSAobWluRGF0ZSAmJiBkYXkgPCBtaW5EYXRlKSB8fFxuXHRcdFx0XHQgICAgICAgICAgIChtYXhEYXRlICYmIGRheSA+IG1heERhdGUpO1xuXG5cdFx0XHR2YXIgZGlzYWJsZURheXMgPSB0aGlzLmMuZGlzYWJsZURheXM7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRpc2FibGVEYXlzICkgJiYgJC5pbkFycmF5KCBkYXkuZ2V0VVRDRGF5KCksIGRpc2FibGVEYXlzICkgIT09IC0xICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIGRpc2FibGVEYXlzID09PSAnZnVuY3Rpb24nICYmIGRpc2FibGVEYXlzKCBkYXkgKSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF5Q29uZmlnID0ge1xuXHRcdFx0XHRkYXk6ICAgICAgMSArIChpIC0gYmVmb3JlKSxcblx0XHRcdFx0bW9udGg6ICAgIG1vbnRoLFxuXHRcdFx0XHR5ZWFyOiAgICAgeWVhcixcblx0XHRcdFx0c2VsZWN0ZWQ6IHNlbGVjdGVkLFxuXHRcdFx0XHR0b2RheTogICAgdG9kYXksXG5cdFx0XHRcdGRpc2FibGVkOiBkaXNhYmxlZCxcblx0XHRcdFx0ZW1wdHk6ICAgIGVtcHR5XG5cdFx0XHR9O1xuXG5cdFx0XHRyb3cucHVzaCggdGhpcy5faHRtbERheShkYXlDb25maWcpICk7XG5cblx0XHRcdGlmICggKytyID09PSA3ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYy5zaG93V2Vla051bWJlciApIHtcblx0XHRcdFx0XHRyb3cudW5zaGlmdCggdGhpcy5faHRtbFdlZWtPZlllYXIoaSAtIGJlZm9yZSwgbW9udGgsIHllYXIpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkYXRhLnB1c2goICc8dHI+Jytyb3cuam9pbignJykrJzwvdHI+JyApO1xuXHRcdFx0XHRyb3cgPSBbXTtcblx0XHRcdFx0ciA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNsYXNzUHJlZml4ID0gdGhpcy5jLmNsYXNzUHJlZml4O1xuXHRcdHZhciBjbGFzc05hbWUgPSBjbGFzc1ByZWZpeCsnLXRhYmxlJztcblx0XHRpZiAoIHRoaXMuYy5zaG93V2Vla051bWJlciApIHtcblx0XHRcdGNsYXNzTmFtZSArPSAnIHdlZWtOdW1iZXInO1xuXHRcdH1cblxuXHRcdC8vIFNob3cgLyBoaWRlIG1vbnRoIGljb25zIGJhc2VkIG9uIG1pbi9tYXhcblx0XHRpZiAoIG1pbkRhdGUgKSB7XG5cdFx0XHR2YXIgdW5kZXJNaW4gPSBtaW5EYXRlID49IG5ldyBEYXRlKCBEYXRlLlVUQyh5ZWFyLCBtb250aCwgMSwgMCwgMCwgMCApICk7XG5cblx0XHRcdHRoaXMuZG9tLnRpdGxlLmZpbmQoJ2Rpdi4nK2NsYXNzUHJlZml4KyctaWNvbkxlZnQnKVxuXHRcdFx0XHQuY3NzKCAnZGlzcGxheScsIHVuZGVyTWluID8gJ25vbmUnIDogJ2Jsb2NrJyApO1xuXHRcdH1cblxuXHRcdGlmICggbWF4RGF0ZSApIHtcblx0XHRcdHZhciBvdmVyTWF4ID0gbWF4RGF0ZSA8IG5ldyBEYXRlKCBEYXRlLlVUQyh5ZWFyLCBtb250aCsxLCAxLCAwLCAwLCAwICkgKTtcblxuXHRcdFx0dGhpcy5kb20udGl0bGUuZmluZCgnZGl2LicrY2xhc3NQcmVmaXgrJy1pY29uUmlnaHQnKVxuXHRcdFx0XHQuY3NzKCAnZGlzcGxheScsIG92ZXJNYXggPyAnbm9uZScgOiAnYmxvY2snICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8dGFibGUgY2xhc3M9XCInK2NsYXNzTmFtZSsnXCI+JyArXG5cdFx0XHRcdCc8dGhlYWQ+Jytcblx0XHRcdFx0XHR0aGlzLl9odG1sTW9udGhIZWFkKCkgK1xuXHRcdFx0XHQnPC90aGVhZD4nK1xuXHRcdFx0XHQnPHRib2R5PicrXG5cdFx0XHRcdFx0ZGF0YS5qb2luKCcnKSArXG5cdFx0XHRcdCc8L3Rib2R5PicrXG5cdFx0XHQnPC90YWJsZT4nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIGNhbGVuZGFyIHRhYmxlJ3MgaGVhZGVyICh3ZWVrIGRheXMpXG5cdCAqXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCBjZWxscyBmb3IgdGhlIHJvd1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2h0bWxNb250aEhlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYSA9IFtdO1xuXHRcdHZhciBmaXJzdERheSA9IHRoaXMuYy5maXJzdERheTtcblx0XHR2YXIgaTE4biA9IHRoaXMuYy5pMThuO1xuXG5cdFx0Ly8gVGFrZSBhY2NvdW50IG9mIHRoZSBmaXJzdCBkYXkgc2hpZnRcblx0XHR2YXIgZGF5TmFtZSA9IGZ1bmN0aW9uICggZGF5ICkge1xuXHRcdFx0ZGF5ICs9IGZpcnN0RGF5O1xuXG5cdFx0XHR3aGlsZSAoZGF5ID49IDcpIHtcblx0XHRcdFx0ZGF5IC09IDc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpMThuLndlZWtkYXlzW2RheV07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBFbXB0eSBjZWxsIGluIHRoZSBoZWFkZXJcblx0XHRpZiAoIHRoaXMuYy5zaG93V2Vla051bWJlciApIHtcblx0XHRcdGEucHVzaCggJzx0aD48L3RoPicgKTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaT0wIDsgaTw3IDsgaSsrICkge1xuXHRcdFx0YS5wdXNoKCAnPHRoPicrZGF5TmFtZSggaSApKyc8L3RoPicgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYS5qb2luKCcnKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgY2VsbCB0aGF0IGNvbnRhaW5zIHdlZWsgb2YgdGhlIHllYXIgLSBJU084NjAxXG5cdCAqXG5cdCAqIEJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYxMTc4MTQvIGFuZFxuXHQgKiBodHRwOi8vdGVjaGJsb2cucHJvY3VyaW9zLm5sL2svbjYxOC9uZXdzL3ZpZXcvMzM3OTYvMTQ4NjMvXG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IGQgRGF5IG9mIG1vbnRoXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IG0gTW9udGggb2YgeWVhciAoemVybyBpbmRleClcblx0ICogQHBhcmFtICB7aW50ZWdlcn0geSBZZWFyXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gICBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9odG1sV2Vla09mWWVhcjogZnVuY3Rpb24gKCBkLCBtLCB5ICkge1xuXHRcdHZhciBkYXRlID0gbmV3IERhdGUoIHksIG0sIGQsIDAsIDAsIDAsIDAgKTtcblxuXHRcdC8vIEZpcnN0IHdlZWsgb2YgdGhlIHllYXIgYWx3YXlzIGhhcyA0dGggSmFudWFyeSBpbiBpdFxuXHRcdGRhdGUuc2V0RGF0ZSggZGF0ZS5nZXREYXRlKCkgKyA0IC0gKGRhdGUuZ2V0RGF5KCkgfHwgNykgKTtcblxuXHRcdHZhciBvbmVKYW4gPSBuZXcgRGF0ZSggeSwgMCwgMSApO1xuXHRcdHZhciB3ZWVrTnVtID0gTWF0aC5jZWlsKCAoICggKGRhdGUgLSBvbmVKYW4pIC8gODY0MDAwMDApICsgMSkvNyApO1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCInK3RoaXMuYy5jbGFzc1ByZWZpeCsnLXdlZWtcIj4nICsgd2Vla051bSArICc8L3RkPic7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBpbnN0YW5jZSBoYXMgYSBkYXRlIG9iamVjdCB2YWx1ZSAtIGl0IG1pZ2h0IGJlIG51bGwuXG5cdCAqIElmIGlzIGRvZXNuJ3Qgc2V0IG9uZSB0byBub3cuXG5cdCAqIEByZXR1cm5zIEEgRGF0ZSBvYmplY3Rcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9uZWVkVmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoICEgdGhpcy5zLmQgKSB7XG5cdFx0XHR0aGlzLnMuZCA9IHRoaXMuX2RhdGVUb1V0YyggbmV3IERhdGUoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnMuZDtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIG9wdGlvbiBlbGVtZW50cyBmcm9tIGEgcmFuZ2UgaW4gYW4gYXJyYXlcblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSBzZWxlY3RvciBDbGFzcyBuYW1lIHVuaXF1ZSB0byB0aGUgc2VsZWN0IGVsZW1lbnQgdG8gdXNlXG5cdCAqIEBwYXJhbSAge2FycmF5fSB2YWx1ZXMgICBBcnJheSBvZiB2YWx1ZXNcblx0ICogQHBhcmFtICB7YXJyYXl9IFtsYWJlbHNdIEFycmF5IG9mIGxhYmVscy4gSWYgZ2l2ZW4gbXVzdCBiZSB0aGUgc2FtZVxuXHQgKiAgIGxlbmd0aCBhcyB0aGUgdmFsdWVzIHBhcmFtZXRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9vcHRpb25zOiBmdW5jdGlvbiAoIHNlbGVjdG9yLCB2YWx1ZXMsIGxhYmVscyApIHtcblx0XHRpZiAoICEgbGFiZWxzICkge1xuXHRcdFx0bGFiZWxzID0gdmFsdWVzO1xuXHRcdH1cblxuXHRcdHZhciBzZWxlY3QgPSB0aGlzLmRvbS5jb250YWluZXIuZmluZCgnc2VsZWN0LicrdGhpcy5jLmNsYXNzUHJlZml4KyctJytzZWxlY3Rvcik7XG5cdFx0c2VsZWN0LmVtcHR5KCk7XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dmFsdWVzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0c2VsZWN0LmFwcGVuZCggJzxvcHRpb24gdmFsdWU9XCInK3ZhbHVlc1tpXSsnXCI+JytsYWJlbHNbaV0rJzwvb3B0aW9uPicgKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBhbiBvcHRpb24gYW5kIHVwZGF0ZSB0aGUgb3B0aW9uJ3Mgc3BhbiBwYWlyIChzaW5jZSB0aGUgc2VsZWN0IGVsZW1lbnRcblx0ICogaGFzIG9wYWNpdHkgMCBmb3Igc3R5bGluZylcblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSBzZWxlY3RvciBDbGFzcyBuYW1lIHVuaXF1ZSB0byB0aGUgc2VsZWN0IGVsZW1lbnQgdG8gdXNlXG5cdCAqIEBwYXJhbSAgeyp9ICAgICAgdmFsICAgICAgVmFsdWUgdG8gc2V0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfb3B0aW9uU2V0OiBmdW5jdGlvbiAoIHNlbGVjdG9yLCB2YWwgKSB7XG5cdFx0dmFyIHNlbGVjdCA9IHRoaXMuZG9tLmNvbnRhaW5lci5maW5kKCdzZWxlY3QuJyt0aGlzLmMuY2xhc3NQcmVmaXgrJy0nK3NlbGVjdG9yKTtcblx0XHR2YXIgc3BhbiA9IHNlbGVjdC5wYXJlbnQoKS5jaGlsZHJlbignc3BhbicpO1xuXG5cdFx0c2VsZWN0LnZhbCggdmFsICk7XG5cblx0XHR2YXIgc2VsZWN0ZWQgPSBzZWxlY3QuZmluZCgnb3B0aW9uOnNlbGVjdGVkJyk7XG5cdFx0c3Bhbi5odG1sKCBzZWxlY3RlZC5sZW5ndGggIT09IDAgP1xuXHRcdFx0c2VsZWN0ZWQudGV4dCgpIDpcblx0XHRcdHRoaXMuYy5pMThuLnVua25vd25cblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGltZSBvcHRpb25zIGxpc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdW5pdCBUaW1lIHVuaXQgLSBob3VycywgbWludXRlcyBvciBzZWNvbmRzXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IGNvdW50IENvdW50IHJhbmdlIC0gMTIsIDI0IG9yIDYwXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IHZhbCBFeGlzdGluZyB2YWx1ZSBmb3IgdGhpcyB1bml0XG5cdCAqIEBwYXJhbSAge2ludGVnZXJbXX0gYWxsb3dlZCBWYWx1ZXMgYWxsb3cgZm9yIHNlbGVjdGlvblxuXHQgKiBAcGFyYW0gIHtpbnRlZ2VyfSByYW5nZSBPdmVycmlkZSByYW5nZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X29wdGlvbnNUaW1lOiBmdW5jdGlvbiAoIHVuaXQsIGNvdW50LCB2YWwsIGFsbG93ZWQsIHJhbmdlICkge1xuXHRcdHZhciBjbGFzc1ByZWZpeCA9IHRoaXMuYy5jbGFzc1ByZWZpeDtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5kb20uY29udGFpbmVyLmZpbmQoJ2Rpdi4nK2NsYXNzUHJlZml4KyctJyt1bml0KTtcblx0XHR2YXIgaSwgajtcblx0XHR2YXIgcmVuZGVyID0gY291bnQgPT09IDEyID9cblx0XHRcdGZ1bmN0aW9uIChpKSB7IHJldHVybiBpOyB9IDpcblx0XHRcdHRoaXMuX3BhZDtcblx0XHR2YXIgY2xhc3NQcmVmaXggPSB0aGlzLmMuY2xhc3NQcmVmaXg7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IGNsYXNzUHJlZml4KyctdGFibGUnO1xuXHRcdHZhciBpMThuID0gdGhpcy5jLmkxOG47XG5cblx0XHRpZiAoICEgY29udGFpbmVyLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYSA9ICcnO1xuXHRcdHZhciBzcGFuID0gMTA7XG5cdFx0dmFyIGJ1dHRvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbGFiZWwsIGNsYXNzTmFtZSkge1xuXHRcdFx0Ly8gU2hpZnQgdGhlIHZhbHVlIGZvciBQTVxuXHRcdFx0aWYgKCBjb3VudCA9PT0gMTIgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0aWYgKHZhbCA+PSAxMiApIHtcblx0XHRcdFx0XHR2YWx1ZSArPSAxMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PSAxMikge1xuXHRcdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh2YWx1ZSA9PSAyNCkge1xuXHRcdFx0XHRcdHZhbHVlID0gMTI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNlbGVjdGVkID0gdmFsID09PSB2YWx1ZSB8fCAodmFsdWUgPT09ICdhbScgJiYgdmFsIDwgMTIpIHx8ICh2YWx1ZSA9PT0gJ3BtJyAmJiB2YWwgPj0gMTIpID9cblx0XHRcdFx0J3NlbGVjdGVkJyA6XG5cdFx0XHRcdCcnO1xuXHRcdFx0XG5cdFx0XHRpZiAoYWxsb3dlZCAmJiAkLmluQXJyYXkodmFsdWUsIGFsbG93ZWQpID09PSAtMSkge1xuXHRcdFx0XHRzZWxlY3RlZCArPSAnIGRpc2FibGVkJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cdFx0XHRcdHNlbGVjdGVkICs9ICcgJytjbGFzc05hbWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwic2VsZWN0YWJsZSAnK3NlbGVjdGVkKydcIj4nICtcblx0XHRcdFx0JzxidXR0b24gY2xhc3M9XCInK2NsYXNzUHJlZml4KyctYnV0dG9uICcrY2xhc3NQcmVmaXgrJy1kYXlcIiB0eXBlPVwiYnV0dG9uXCIgZGF0YS11bml0PVwiJyt1bml0KydcIiBkYXRhLXZhbHVlPVwiJyt2YWx1ZSsgJ1wiPicgK1xuXHRcdFx0XHRcdCc8c3Bhbj4nK2xhYmVsKyc8L3NwYW4+Jytcblx0XHRcdFx0JzwvYnV0dG9uPicgK1xuXHRcdFx0JzwvdGQ+Jztcblx0XHR9XG5cblx0XHRpZiAoIGNvdW50ID09PSAxMiApIHtcblx0XHRcdC8vIEhvdXJzIHdpdGggQU0vUE1cblx0XHRcdGEgKz0gJzx0cj4nO1xuXHRcdFx0XG5cdFx0XHRmb3IgKCBpPTEgOyBpPD02IDsgaSsrICkge1xuXHRcdFx0XHRhICs9IGJ1dHRvbihpLCByZW5kZXIoaSkpO1xuXHRcdFx0fVxuXHRcdFx0YSArPSBidXR0b24oJ2FtJywgaTE4bi5hbVBtWzBdKTtcblxuXHRcdFx0YSArPSAnPC90cj4nO1xuXHRcdFx0YSArPSAnPHRyPic7XG5cblx0XHRcdGZvciAoIGk9NyA7IGk8PTEyIDsgaSsrICkge1xuXHRcdFx0XHRhICs9IGJ1dHRvbihpLCByZW5kZXIoaSkpO1xuXHRcdFx0fVxuXHRcdFx0YSArPSBidXR0b24oJ3BtJywgaTE4bi5hbVBtWzFdKTtcblx0XHRcdGEgKz0gJzwvdHI+JztcblxuXHRcdFx0c3BhbiA9IDc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBjb3VudCA9PT0gMjQgKSB7XG5cdFx0XHQvLyBIb3VycyAtIDI0XG5cdFx0XHR2YXIgYyA9IDA7XG5cdFx0XHRmb3IgKGo9MCA7IGo8NCA7IGorKyApIHtcblx0XHRcdFx0YSArPSAnPHRyPic7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8NiA7IGkrKyApIHtcblx0XHRcdFx0XHRhICs9IGJ1dHRvbihjLCByZW5kZXIoYykpO1xuXHRcdFx0XHRcdGMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRhICs9ICc8L3RyPic7XG5cdFx0XHR9XG5cblx0XHRcdHNwYW4gPSA2O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE1pbnV0ZXMgYW5kIHNlY29uZHNcblx0XHRcdGEgKz0gJzx0cj4nO1xuXHRcdFx0Zm9yIChqPTAgOyBqPDYwIDsgais9MTAgKSB7XG5cdFx0XHRcdGEgKz0gYnV0dG9uKGosIHJlbmRlcihqKSwgJ3JhbmdlJyk7XG5cdFx0XHR9XG5cdFx0XHRhICs9ICc8L3RyPic7XG5cdFx0XHRcblx0XHRcdC8vIFNsaWdodCBoYWNrIHRvIGFsbG93IGZvciB0aGUgZGlmZmVyZW50IG51bWJlciBvZiBjb2x1bW5zXG5cdFx0XHRhICs9ICc8L3Rib2R5PjwvdGhlYWQ+PHRhYmxlIGNsYXNzPVwiJytjbGFzc05hbWUrJyAnK2NsYXNzTmFtZSsnLW5vc3BhY2VcIj48dGJvZHk+JztcblxuXHRcdFx0dmFyIHN0YXJ0ID0gcmFuZ2UgIT09IG51bGwgP1xuXHRcdFx0XHRyYW5nZSA6XG5cdFx0XHRcdE1hdGguZmxvb3IoIHZhbCAvIDEwICkqMTA7XG5cblx0XHRcdGEgKz0gJzx0cj4nO1xuXHRcdFx0Zm9yIChqPXN0YXJ0KzEgOyBqPHN0YXJ0KzEwIDsgaisrICkge1xuXHRcdFx0XHRhICs9IGJ1dHRvbihqLCByZW5kZXIoaikpO1xuXHRcdFx0fVxuXHRcdFx0YSArPSAnPC90cj4nO1xuXG5cdFx0XHRzcGFuID0gNjtcblx0XHR9XG5cblx0XHRjb250YWluZXJcblx0XHRcdC5lbXB0eSgpXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwiJytjbGFzc05hbWUrJ1wiPicrXG5cdFx0XHRcdFx0Jzx0aGVhZD48dHI+PHRoIGNvbHNwYW49XCInK3NwYW4rJ1wiPicrXG5cdFx0XHRcdFx0XHRpMThuW3VuaXRdICtcblx0XHRcdFx0XHQnPC90aD48L3RyPjwvdGhlYWQ+Jytcblx0XHRcdFx0XHQnPHRib2R5PicrXG5cdFx0XHRcdFx0XHRhK1xuXHRcdFx0XHRcdCc8L3Rib2R5PicrXG5cdFx0XHRcdCc8L3RhYmxlPidcblx0XHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgb3B0aW9ucyBmb3IgdGhlIG1vbnRoIGFuZCB5ZWFyXG5cdCAqXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IHllYXIgIFllYXJcblx0ICogQHBhcmFtICB7aW50ZWdlcn0gbW9udGggTW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfb3B0aW9uc1RpdGxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGkxOG4gPSB0aGlzLmMuaTE4bjtcblx0XHR2YXIgbWluID0gdGhpcy5jLm1pbkRhdGU7XG5cdFx0dmFyIG1heCA9IHRoaXMuYy5tYXhEYXRlO1xuXHRcdHZhciBtaW5ZZWFyID0gbWluID8gbWluLmdldEZ1bGxZZWFyKCkgOiBudWxsO1xuXHRcdHZhciBtYXhZZWFyID0gbWF4ID8gbWF4LmdldEZ1bGxZZWFyKCkgOiBudWxsO1xuXG5cdFx0dmFyIGkgPSBtaW5ZZWFyICE9PSBudWxsID8gbWluWWVhciA6IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIHRoaXMuYy55ZWFyUmFuZ2U7XG5cdFx0dmFyIGogPSBtYXhZZWFyICE9PSBudWxsID8gbWF4WWVhciA6IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSArIHRoaXMuYy55ZWFyUmFuZ2U7XG5cblx0XHR0aGlzLl9vcHRpb25zKCAnbW9udGgnLCB0aGlzLl9yYW5nZSggMCwgMTEgKSwgaTE4bi5tb250aHMgKTtcblx0XHR0aGlzLl9vcHRpb25zKCAneWVhcicsIHRoaXMuX3JhbmdlKCBpLCBqICkgKTtcblx0fSxcblxuXHQvKipcblx0ICogU2ltcGxlIHR3byBkaWdpdCBwYWRcblx0ICpcblx0ICogQHBhcmFtICB7aW50ZWdlcn0gaSAgICAgIFZhbHVlIHRoYXQgbWlnaHQgbmVlZCBwYWRkaW5nXG5cdCAqIEByZXR1cm4ge3N0cmluZ3xpbnRlZ2VyfSBQYWRkZWQgdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wYWQ6IGZ1bmN0aW9uICggaSApIHtcblx0XHRyZXR1cm4gaTwxMCA/ICcwJytpIDogaTtcblx0fSxcblxuXHQvKipcblx0ICogUG9zaXRpb24gdGhlIGNhbGVuZGFyIHRvIGxvb2sgYXR0YWNoZWQgdG8gdGhlIGlucHV0IGVsZW1lbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmMuYXR0YWNoVG8gPT09ICdpbnB1dCcgPyB0aGlzLmRvbS5pbnB1dC5wb3NpdGlvbigpIDogdGhpcy5kb20uaW5wdXQub2Zmc2V0KCk7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuZG9tLmNvbnRhaW5lcjtcblx0XHR2YXIgaW5wdXRIZWlnaHQgPSB0aGlzLmRvbS5pbnB1dC5vdXRlckhlaWdodCgpO1xuXG5cdFx0aWYgKGNvbnRhaW5lci5oYXNDbGFzcygnaW5saW5lJykpIHtcblx0XHRcdGNvbnRhaW5lci5pbnNlcnRBZnRlciggdGhpcy5kb20uaW5wdXQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucy5wYXJ0cy5kYXRlICYmIHRoaXMucy5wYXJ0cy50aW1lICYmICQod2luZG93KS53aWR0aCgpID4gNTUwICkge1xuXHRcdFx0Y29udGFpbmVyLmFkZENsYXNzKCdob3Jpem9udGFsJyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNsYXNzKCdob3Jpem9udGFsJyk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5jLmF0dGFjaFRvID09PSAnaW5wdXQnKSB7XG5cdFx0XHRjb250YWluZXJcblx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdHRvcDogb2Zmc2V0LnRvcCArIGlucHV0SGVpZ2h0LFxuXHRcdFx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0XG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuaW5zZXJ0QWZ0ZXIoIHRoaXMuZG9tLmlucHV0ICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y29udGFpbmVyXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHR0b3A6IG9mZnNldC50b3AgKyBpbnB1dEhlaWdodCxcblx0XHRcdFx0XHRsZWZ0OiBvZmZzZXQubGVmdFxuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZFRvKCAnYm9keScgKTtcblx0XHR9XG5cblx0XHR2YXIgY2FsSGVpZ2h0ID0gY29udGFpbmVyLm91dGVySGVpZ2h0KCk7XG5cdFx0dmFyIGNhbFdpZHRoID0gY29udGFpbmVyLm91dGVyV2lkdGgoKTtcblx0XHR2YXIgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG5cdFx0Ly8gQ29ycmVjdCB0byB0aGUgYm90dG9tXG5cdFx0aWYgKCBvZmZzZXQudG9wICsgaW5wdXRIZWlnaHQgKyBjYWxIZWlnaHQgLSBzY3JvbGxUb3AgPiAkKHdpbmRvdykuaGVpZ2h0KCkgKSB7XG5cdFx0XHR2YXIgbmV3VG9wID0gb2Zmc2V0LnRvcCAtIGNhbEhlaWdodDtcblxuXHRcdFx0Y29udGFpbmVyLmNzcyggJ3RvcCcsIG5ld1RvcCA8IDAgPyAwIDogbmV3VG9wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29ycmVjdCB0byB0aGUgcmlnaHRcblx0XHRpZiAoIGNhbFdpZHRoICsgb2Zmc2V0LmxlZnQgPiAkKHdpbmRvdykud2lkdGgoKSApIHtcblx0XHRcdHZhciBuZXdMZWZ0ID0gJCh3aW5kb3cpLndpZHRoKCkgLSBjYWxXaWR0aDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgZWxlbWVudHMgd2hpY2ggYXJlIGluc2lkZSBhIHBvc2l0aW9uIGFic29sdXRlIGVsZW1lbnRcblx0XHRcdGlmICh0aGlzLmMuYXR0YWNoVG8gPT09ICdpbnB1dCcpIHtcblx0XHRcdFx0bmV3TGVmdCAtPSAkKGNvbnRhaW5lcikub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCkubGVmdDtcblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbmVyLmNzcyggJ2xlZnQnLCBuZXdMZWZ0IDwgMCA/IDAgOiBuZXdMZWZ0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBzaW1wbGUgYXJyYXkgd2l0aCBhIHJhbmdlIG9mIHZhbHVlc1xuXHQgKlxuXHQgKiBAcGFyYW0gIHtpbnRlZ2VyfSBzdGFydCAgIFN0YXJ0IHZhbHVlIChpbmNsdXNpdmUpXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IGVuZCAgICAgRW5kIHZhbHVlIChpbmNsdXNpdmUpXG5cdCAqIEBwYXJhbSAge2ludGVnZXJ9IFtpbmM9MV0gSW5jcmVtZW50IHZhbHVlXG5cdCAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgQ3JlYXRlZCBhcnJheVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3JhbmdlOiBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQsIGluYyApIHtcblx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0aWYgKCAhIGluYyApIHtcblx0XHRcdGluYyA9IDE7XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGk9c3RhcnQgOyBpPD1lbmQgOyBpKz1pbmMgKSB7XG5cdFx0XHRhLnB1c2goIGkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYTtcblx0fSxcblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBjYWxlbmRhciBiYXNlZCBvbiB0aGUgZGlzcGxheSBkYXRlIC0gdGhpcyBpcyBhIGRlc3RydWN0aXZlXG5cdCAqIG9wZXJhdGlvblxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldENhbGFuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCB0aGlzLnMuZGlzcGxheSApIHtcblx0XHRcdHRoaXMuZG9tLmNhbGVuZGFyXG5cdFx0XHRcdC5lbXB0eSgpXG5cdFx0XHRcdC5hcHBlbmQoIHRoaXMuX2h0bWxNb250aChcblx0XHRcdFx0XHR0aGlzLnMuZGlzcGxheS5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRcdHRoaXMucy5kaXNwbGF5LmdldFVUQ01vbnRoKClcblx0XHRcdFx0KSApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBtb250aCBhbmQgeWVhciBmb3IgdGhlIGNhbGVuZGFyIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRpc3BsYXkgZGF0ZVxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldFRpdGxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fb3B0aW9uU2V0KCAnbW9udGgnLCB0aGlzLnMuZGlzcGxheS5nZXRVVENNb250aCgpICk7XG5cdFx0dGhpcy5fb3B0aW9uU2V0KCAneWVhcicsIHRoaXMucy5kaXNwbGF5LmdldFVUQ0Z1bGxZZWFyKCkgKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSB0aW1lIGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB3aWRnZXRcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXRUaW1lOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkID0gdGhpcy5zLmQ7XG5cdFx0XG5cdFx0Ly8gbHV4b24gdXNlcyBkaWZmZXJlbnQgbWV0aG9kIG5hbWVzIHNvIG5lZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoZW0uIFRoaXMgaGFwcGVucyBhIGZldyB0aW1lIGxhdGVyIGluIHRoaXMgbWV0aG9kIHRvb1xuXHRcdHZhciBsdXhEVCA9IG51bGxcblx0XHRpZiAoZGF0ZUxpYiAmJiBkYXRlTGliID09IHdpbmRvdy5sdXhvbikge1xuXHRcdFx0bHV4RFQgPSBkYXRlTGliLkRhdGVUaW1lLmZyb21KU0RhdGUoZCk7XG5cdFx0fVxuXG5cdFx0dmFyIGhvdXJzID0gbHV4RFQgIT0gbnVsbFxuXHRcdFx0PyBsdXhEVC5ob3VyXG5cdFx0XHQ6IGRcblx0XHRcdFx0PyBkLmdldFVUQ0hvdXJzKClcblx0XHRcdFx0OiAwO1xuXG5cdFx0dmFyIGFsbG93ZWQgPSBmdW5jdGlvbiAoIHByb3AgKSB7IC8vIEJhY2t3YXJkcyBjb21wdCB3aXRoIGBJbmNyZW1lbnRgIG9wdGlvblxuXHRcdFx0cmV0dXJuIHRoYXQuY1twcm9wKydBdmFpbGFibGUnXSA/XG5cdFx0XHRcdHRoYXQuY1twcm9wKydBdmFpbGFibGUnXSA6XG5cdFx0XHRcdHRoYXQuX3JhbmdlKCAwLCA1OSwgdGhhdC5jW3Byb3ArJ0luY3JlbWVudCddICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fb3B0aW9uc1RpbWUoICdob3VycycsIHRoaXMucy5wYXJ0cy5ob3VyczEyID8gMTIgOiAyNCwgaG91cnMsIHRoaXMuYy5ob3Vyc0F2YWlsYWJsZSApXG5cdFx0dGhpcy5fb3B0aW9uc1RpbWUoXG5cdFx0XHQnbWludXRlcycsXG5cdFx0XHQ2MCxcblx0XHRcdGx1eERUICE9IG51bGxcblx0XHRcdFx0PyBsdXhEVC5taW51dGVcblx0XHRcdFx0OiBkXG5cdFx0XHRcdFx0PyBkLmdldFVUQ01pbnV0ZXMoKVxuXHRcdFx0XHRcdDogMCwgYWxsb3dlZCgnbWludXRlcycpLFxuXHRcdFx0dGhpcy5zLm1pbnV0ZXNSYW5nZVxuXHRcdCk7XG5cdFx0dGhpcy5fb3B0aW9uc1RpbWUoXG5cdFx0XHQnc2Vjb25kcycsXG5cdFx0XHQ2MCxcblx0XHRcdGx1eERUICE9IG51bGxcblx0XHRcdFx0PyBsdXhEVC5zZWNvbmRcblx0XHRcdFx0OiBkXG5cdFx0XHRcdFx0PyBkLmdldFNlY29uZHMoKVxuXHRcdFx0XHRcdDogMCxcblx0XHRcdGFsbG93ZWQoJ3NlY29uZHMnKSxcblx0XHRcdHRoaXMucy5zZWNvbmRzUmFuZ2Vcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93IHRoZSB3aWRnZXQgYW5kIGFkZCBldmVudHMgdG8gdGhlIGRvY3VtZW50IHJlcXVpcmVkIG9ubHkgd2hpbGUgaXRcblx0ICogaXMgZGlzcGxheWVkXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Nob3c6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IHRoaXMucy5uYW1lc3BhY2U7XG5cblx0XHR0aGlzLl9wb3NpdGlvbigpO1xuXG5cdFx0Ly8gTmVlZCB0byByZXBvc2l0aW9uIG9uIHNjcm9sbFxuXHRcdCQod2luZG93KS5vbiggJ3Njcm9sbC4nK25hbWVzcGFjZSsnIHJlc2l6ZS4nK25hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5fcG9zaXRpb24oKTtcblx0XHR9ICk7XG5cblx0XHQkKCdkaXYuRFRFX0JvZHlfQ29udGVudCcpLm9uKCAnc2Nyb2xsLicrbmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0Ll9wb3NpdGlvbigpO1xuXHRcdH0gKTtcblxuXHRcdCQoJ2Rpdi5kYXRhVGFibGVzX3Njcm9sbEJvZHknKS5vbiggJ3Njcm9sbC4nK25hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5fcG9zaXRpb24oKTtcblx0XHR9ICk7XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5kb20uaW5wdXRbMF0ub2Zmc2V0UGFyZW50O1xuXG5cdFx0aWYgKCBvZmZzZXRQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgKSB7XG5cdFx0XHQkKG9mZnNldFBhcmVudCkub24oICdzY3JvbGwuJytuYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5fcG9zaXRpb24oKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBPbiB0YWIgZm9jdXMgd2lsbCBtb3ZlIHRvIGEgZGlmZmVyZW50IGZpZWxkIChubyBrZXlib2FyZCBuYXZpZ2F0aW9uXG5cdFx0Ly8gaW4gdGhlIGRhdGUgcGlja2VyIC0gdGhpcyBtaWdodCBuZWVkIHRvIGJlIGNoYW5nZWQpLlxuXHRcdCQoZG9jdW1lbnQpLm9uKCAna2V5ZG93bi4nK25hbWVzcGFjZSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0ZS5rZXlDb2RlID09PSA5ICB8fCAvLyB0YWJcblx0XHRcdFx0ZS5rZXlDb2RlID09PSAyNyB8fCAvLyBlc2Ncblx0XHRcdFx0ZS5rZXlDb2RlID09PSAxMyAgICAvLyByZXR1cm5cblx0XHRcdCkge1xuXHRcdFx0XHR0aGF0Ll9oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gSGlkZSBpZiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSB3aWRnZXQgLSBidXQgaW4gYSBkaWZmZXJlbnQgY2xpY2tcblx0XHQvLyBldmVudCBmcm9tIHRoZSBvbmUgdGhhdCB3YXMgdXNlZCB0byB0cmlnZ2VyIHRoZSBzaG93IChidWJibGUgYW5kXG5cdFx0Ly8gaW5saW5lKVxuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdCQoJ2JvZHknKS5vbiggJ2NsaWNrLicrbmFtZXNwYWNlLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9ICQoZS50YXJnZXQpLnBhcmVudHMoKTtcblxuXHRcdFx0XHRpZiAoICEgcGFyZW50cy5maWx0ZXIoIHRoYXQuZG9tLmNvbnRhaW5lciApLmxlbmd0aCAmJiBlLnRhcmdldCAhPT0gdGhhdC5kb20uaW5wdXRbMF0gKSB7XG5cdFx0XHRcdFx0dGhhdC5faGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSwgMTAgKTtcblx0fSxcblxuXHQvKipcblx0ICogV3JpdGUgdGhlIGZvcm1hdHRlZCBzdHJpbmcgdG8gdGhlIGlucHV0IGVsZW1lbnQgdGhpcyBjb250cm9sIGlzIGF0dGFjaGVkXG5cdCAqIHRvXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfd3JpdGVPdXRwdXQ6IGZ1bmN0aW9uICggZm9jdXMgKSB7XG5cdFx0dmFyIGRhdGUgPSB0aGlzLnMuZDtcblx0XHR2YXIgb3V0ID0gJyc7XG5cblx0XHQvLyBVc2UgbW9tZW50LCBkYXlqcyBvciBsdXhvbiBpZiBwb3NzaWJsZSAtIG90aGVyd2lzZSBpdCBtdXN0IGJlIElTTzg2MDEgKG9yIHRoZVxuXHRcdC8vIGNvbnN0cnVjdG9yIHdvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yKVxuXHRcdC8vIGx1eG9uIHVzZXMgZGlmZmVyZW50IG1ldGhvZCBuYW1lcyBzbyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGVtLlxuXHRcdGlmIChkYXRlKSB7XG5cdFx0XHRvdXQgPSBkYXRlTGliICYmIGRhdGVMaWIgPT0gd2luZG93Lmx1eG9uXG5cdFx0XHQ/IGRhdGVMaWIuRGF0ZVRpbWUuZnJvbUpTRGF0ZSh0aGlzLnMuZCkudG9Gb3JtYXQodGhpcy5jLmZvcm1hdClcblx0XHRcdDogZGF0ZUxpYiA/XG5cdFx0XHRcdGRhdGVMaWIudXRjKCBkYXRlLCB1bmRlZmluZWQsIHRoaXMuYy5sb2NhbGUsIHRoaXMuYy5zdHJpY3QgKS5mb3JtYXQoIHRoaXMuYy5mb3JtYXQgKSA6XG5cdFx0XHRcdGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArJy0nK1xuXHRcdFx0XHRcdHRoaXMuX3BhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSArJy0nK1xuXHRcdFx0XHRcdHRoaXMuX3BhZChkYXRlLmdldFVUQ0RhdGUoKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kb20uaW5wdXRcblx0XHRcdC52YWwoIG91dCApXG5cdFx0XHQudHJpZ2dlcignY2hhbmdlJywge3dyaXRlOiBkYXRlfSk7XG5cdFx0XG5cdFx0aWYgKCB0aGlzLmRvbS5pbnB1dC5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICkge1xuXHRcdFx0dGhpcy52YWwob3V0LCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBmb2N1cyApIHtcblx0XHRcdHRoaXMuZG9tLmlucHV0LmZvY3VzKCk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVXNlIGEgc3BlY2lmaWNtb21lbnQgY29tcGF0aWJsZSBkYXRlIGxpYnJhcnlcbiAqL1xuRGF0ZVRpbWUudXNlID0gZnVuY3Rpb24gKGxpYikge1xuXHRkYXRlTGliID0gbGliO1xufTtcblxuLyoqXG4gKiBGb3IgZ2VuZXJhdGluZyB1bmlxdWUgbmFtZXNwYWNlc1xuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5EYXRlVGltZS5faW5zdGFuY2UgPSAwO1xuXG4vKipcbiAqIERlZmF1bHRzIGZvciB0aGUgZGF0ZSB0aW1lIHBpY2tlclxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkRhdGVUaW1lLmRlZmF1bHRzID0ge1xuXHRhdHRhY2hUbzogJ2JvZHknLFxuXG5cdGJ1dHRvbnM6IHtcblx0XHRjbGVhcjogZmFsc2UsXG5cdFx0dG9kYXk6IGZhbHNlXG5cdH0sXG5cblx0Ly8gTm90IGRvY3VtZW50ZWQgLSBjb3VsZCBiZSBhbiBpbnRlcm5hbCBwcm9wZXJ0eVxuXHRjbGFzc1ByZWZpeDogJ2R0LWRhdGV0aW1lJyxcblxuXHQvLyBmdW5jdGlvbiBvciBhcnJheSBvZiBpbnRzXG5cdGRpc2FibGVEYXlzOiBudWxsLFxuXG5cdC8vIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMDogU3VuZGF5LCAxOiBNb25kYXksIGV0Yylcblx0Zmlyc3REYXk6IDEsXG5cblx0Zm9ybWF0OiAnWVlZWS1NTS1ERCcsXG5cblx0aG91cnNBdmFpbGFibGU6IG51bGwsXG5cblx0aTE4bjoge1xuXHRcdGNsZWFyOiAgICAnQ2xlYXInLFxuXHRcdHByZXZpb3VzOiAnUHJldmlvdXMnLFxuXHRcdG5leHQ6ICAgICAnTmV4dCcsXG5cdFx0bW9udGhzOiAgIFsgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInIF0sXG5cdFx0d2Vla2RheXM6IFsgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcgXSxcblx0XHRhbVBtOiAgICAgWyAnYW0nLCAncG0nIF0sXG5cdFx0aG91cnM6ICAgICdIb3VyJyxcblx0XHRtaW51dGVzOiAgJ01pbnV0ZScsXG5cdFx0c2Vjb25kczogICdTZWNvbmQnLFxuXHRcdHVua25vd246ICAnLScsXG5cdFx0dG9kYXk6ICAgICdUb2RheSdcblx0fSxcblxuXHRtYXhEYXRlOiBudWxsLFxuXG5cdG1pbkRhdGU6IG51bGwsXG5cblx0bWludXRlc0F2YWlsYWJsZTogbnVsbCxcblxuXHRtaW51dGVzSW5jcmVtZW50OiAxLCAvLyBkZXByZWNhdGVkXG5cblx0c3RyaWN0OiB0cnVlLFxuXG5cdGxvY2FsZTogJ2VuJyxcblxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCkge30sXG5cblx0c2Vjb25kc0F2YWlsYWJsZTogbnVsbCxcblxuXHRzZWNvbmRzSW5jcmVtZW50OiAxLCAvLyBkZXByZWNhdGVkXG5cblx0Ly8gc2hvdyB0aGUgSVNPIHdlZWsgbnVtYmVyIGF0IHRoZSBoZWFkIG9mIHRoZSByb3dcblx0c2hvd1dlZWtOdW1iZXI6IGZhbHNlLFxuXG5cdC8vIG92ZXJydWxlZCBieSBtYXggLyBtaW4gZGF0ZVxuXHR5ZWFyUmFuZ2U6IDI1XG59O1xuXG5EYXRlVGltZS52ZXJzaW9uID0gJzEuMS4xJztcblxuLy8gR2xvYmFsIGV4cG9ydCAtIGlmIG5vIGNvbmZsaWN0c1xuaWYgKCEgd2luZG93LkRhdGVUaW1lKSB7XG5cdHdpbmRvdy5EYXRlVGltZSA9IERhdGVUaW1lO1xufVxuXG4vLyBNYWtlIGF2YWlsYWJsZSB2aWEgalF1ZXJ5XG4kLmZuLmR0RGF0ZVRpbWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdG5ldyBEYXRlVGltZSh0aGlzLCBvcHRpb25zKTtcblx0fSk7XG59XG5cbi8vIEF0dGFjaCB0byBEYXRhVGFibGVzIGlmIHByZXNlbnRcbmlmICgkLmZuLmRhdGFUYWJsZSkge1xuXHQkLmZuLmRhdGFUYWJsZS5EYXRlVGltZSA9IERhdGVUaW1lO1xuXHQkLmZuLkRhdGFUYWJsZS5EYXRlVGltZSA9IERhdGVUaW1lO1xuXG5cdGlmICgkLmZuLmRhdGFUYWJsZS5FZGl0b3IpIHtcblx0XHQkLmZuLmRhdGFUYWJsZS5FZGl0b3IuRGF0ZVRpbWUgPSBEYXRlVGltZTtcblx0fVxufVxuXG5yZXR1cm4gRGF0ZVRpbWU7XG5cbn0pKTtcbiIsIi8qISBCb290c3RyYXAgNSBzdHlsaW5nIHdyYXBwZXIgZm9yIFNjcm9sbGVyXG4gKiDCqTIwMTggU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldC1iczUnLCAnZGF0YXRhYmxlcy5uZXQtc2Nyb2xsZXInXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnM1Jykocm9vdCwgJCkuJDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQuZm4uZGF0YVRhYmxlLlNjcm9sbGVyICkge1xuXHRcdFx0XHRyZXF1aXJlKCdkYXRhdGFibGVzLm5ldC1zY3JvbGxlcicpKHJvb3QsICQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cbnJldHVybiAkLmZuLmRhdGFUYWJsZTtcblxufSkpOyIsIi8qISBTY3JvbGxlciAyLjAuNVxuICogwqkyMDExLTIwMjEgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5ICAgICBTY3JvbGxlclxuICogQGRlc2NyaXB0aW9uIFZpcnR1YWwgcmVuZGVyaW5nIGZvciBEYXRhVGFibGVzXG4gKiBAdmVyc2lvbiAgICAgMi4wLjVcbiAqIEBmaWxlICAgICAgICBkYXRhVGFibGVzLnNjcm9sbGVyLmpzXG4gKiBAYXV0aG9yICAgICAgU3ByeU1lZGlhIEx0ZCAod3d3LnNwcnltZWRpYS5jby51aylcbiAqIEBjb250YWN0ICAgICB3d3cuc3ByeW1lZGlhLmNvLnVrL2NvbnRhY3RcbiAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAxMS0yMDIxIFNwcnlNZWRpYSBMdGQuXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBmcmVlIHNvZnR3YXJlLCBhdmFpbGFibGUgdW5kZXIgdGhlIGZvbGxvd2luZyBsaWNlbnNlOlxuICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0XG4gKiBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgbGljZW5zZSBmaWxlcyBmb3IgZGV0YWlscy5cbiAqXG4gKiBGb3IgZGV0YWlscyBwbGVhc2UgcmVmZXIgdG86IGh0dHA6Ly93d3cuZGF0YXRhYmxlcy5uZXRcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vKipcbiAqIFNjcm9sbGVyIGlzIGEgdmlydHVhbCByZW5kZXJpbmcgcGx1Zy1pbiBmb3IgRGF0YVRhYmxlcyB3aGljaCBhbGxvd3MgbGFyZ2VcbiAqIGRhdGFzZXRzIHRvIGJlIGRyYXduIG9uIHNjcmVlbiBldmVyeSBxdWlja2x5LiBXaGF0IHRoZSB2aXJ0dWFsIHJlbmRlcmluZyBtZWFuc1xuICogaXMgdGhhdCBvbmx5IHRoZSB2aXNpYmxlIHBvcnRpb24gb2YgdGhlIHRhYmxlIChhbmQgYSBiaXQgdG8gZWl0aGVyIHNpZGUgdG8gbWFrZVxuICogdGhlIHNjcm9sbGluZyBzbW9vdGgpIGlzIGRyYXduLCB3aGlsZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBnaXZlcyB0aGVcbiAqIHZpc3VhbCBpbXByZXNzaW9uIHRoYXQgdGhlIHdob2xlIHRhYmxlIGlzIHZpc2libGUuIFRoaXMgaXMgZG9uZSBieSBtYWtpbmcgdXNlXG4gKiBvZiB0aGUgcGFnaW5hdGlvbiBhYmlsaXRpZXMgb2YgRGF0YVRhYmxlcyBhbmQgbW92aW5nIHRoZSB0YWJsZSBhcm91bmQgaW4gdGhlXG4gKiBzY3JvbGxpbmcgY29udGFpbmVyIERhdGFUYWJsZXMgYWRkcyB0byB0aGUgcGFnZS4gVGhlIHNjcm9sbGluZyBjb250YWluZXIgaXNcbiAqIGZvcmNlZCB0byB0aGUgaGVpZ2h0IGl0IHdvdWxkIGJlIGZvciB0aGUgZnVsbCB0YWJsZSBkaXNwbGF5IHVzaW5nIGFuIGV4dHJhXG4gKiBlbGVtZW50LlxuICpcbiAqIE5vdGUgdGhhdCByb3dzIGluIHRoZSB0YWJsZSBNVVNUIGFsbCBiZSB0aGUgc2FtZSBoZWlnaHQuIEluZm9ybWF0aW9uIGluIGEgY2VsbFxuICogd2hpY2ggZXhwYW5kcyBvbiB0byBtdWx0aXBsZSBsaW5lcyB3aWxsIGNhdXNlIHNvbWUgb2RkIGJlaGF2aW91ciBpbiB0aGUgc2Nyb2xsaW5nLlxuICpcbiAqIFNjcm9sbGVyIGlzIGluaXRpYWxpc2VkIGJ5IHNpbXBseSBpbmNsdWRpbmcgdGhlIGxldHRlciAnUycgaW4gdGhlIHNEb20gZm9yIHRoZVxuICogdGFibGUgeW91IHdhbnQgdG8gaGF2ZSB0aGlzIGZlYXR1cmUgZW5hYmxlZCBvbi4gTm90ZSB0aGF0IHRoZSAnUycgbXVzdCBjb21lXG4gKiBBRlRFUiB0aGUgJ3QnIHBhcmFtZXRlciBpbiBgZG9tYC5cbiAqXG4gKiBLZXkgZmVhdHVyZXMgaW5jbHVkZTpcbiAqICAgPHVsIGNsYXNzPVwibGltaXRfbGVuZ3RoXCI+XG4gKiAgICAgPGxpPlNwZWVkISBUaGUgYWltIG9mIFNjcm9sbGVyIGZvciBEYXRhVGFibGVzIGlzIHRvIG1ha2UgcmVuZGVyaW5nIGxhcmdlIGRhdGEgc2V0cyBmYXN0PC9saT5cbiAqICAgICA8bGk+RnVsbCBjb21wYXRpYmlsaXR5IHdpdGggZGVmZXJyZWQgcmVuZGVyaW5nIGluIERhdGFUYWJsZXMgZm9yIG1heGltdW0gc3BlZWQ8L2xpPlxuICogICAgIDxsaT5EaXNwbGF5IG1pbGxpb25zIG9mIHJvd3M8L2xpPlxuICogICAgIDxsaT5JbnRlZ3JhdGlvbiB3aXRoIHN0YXRlIHNhdmluZyBpbiBEYXRhVGFibGVzIChzY3JvbGxpbmcgcG9zaXRpb24gaXMgc2F2ZWQpPC9saT5cbiAqICAgICA8bGk+RWFzeSB0byB1c2U8L2xpPlxuICogICA8L3VsPlxuICpcbiAqICBAY2xhc3NcbiAqICBAY29uc3RydWN0b3JcbiAqICBAZ2xvYmFsXG4gKiAgQHBhcmFtIHtvYmplY3R9IGR0IERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IG9yIEFQSSBpbnN0YW5jZVxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0cz17fV0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFNjcm9sbGVyLiBPcHRpb25zIFxuICogICAgYXJlIGRlZmluZWQgYnkge0BsaW5rIFNjcm9sbGVyLmRlZmF1bHRzfVxuICpcbiAqICBAcmVxdWlyZXMgalF1ZXJ5IDEuNytcbiAqICBAcmVxdWlyZXMgRGF0YVRhYmxlcyAxLjEwLjArXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAqICAgICAgICAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgge1xuICogICAgICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuICogICAgICAgICAgICBcImFqYXhcIjogXCJtZWRpYS9kYXRhc2V0L2xhcmdlLnR4dFwiLFxuICogICAgICAgICAgICBcInNjcm9sbGVyXCI6IHRydWUsXG4gKiAgICAgICAgICAgIFwiZGVmZXJSZW5kZXJcIjogdHJ1ZVxuICogICAgICAgIH0gKTtcbiAqICAgIH0gKTtcbiAqL1xudmFyIFNjcm9sbGVyID0gZnVuY3Rpb24gKCBkdCwgb3B0cyApIHtcblx0LyogU2FuaXR5IGNoZWNrIC0geW91IGp1c3Qga25vdyBpdCB3aWxsIGhhcHBlbiAqL1xuXHRpZiAoICEgKHRoaXMgaW5zdGFuY2VvZiBTY3JvbGxlcikgKSB7XG5cdFx0YWxlcnQoIFwiU2Nyb2xsZXIgd2FybmluZzogU2Nyb2xsZXIgbXVzdCBiZSBpbml0aWFsaXNlZCB3aXRoIHRoZSAnbmV3JyBrZXl3b3JkLlwiICk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBvcHRzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cblx0dmFyIGR0QXBpID0gJC5mbi5kYXRhVGFibGUuQXBpKCBkdCApO1xuXG5cdC8qKlxuXHQgKiBTZXR0aW5ncyBvYmplY3Qgd2hpY2ggY29udGFpbnMgY3VzdG9taXNhYmxlIGluZm9ybWF0aW9uIGZvciB0aGUgU2Nyb2xsZXIgaW5zdGFuY2Vcblx0ICogQG5hbWVzcGFjZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAZXh0ZW5kcyBTY3JvbGxlci5kZWZhdWx0c1xuXHQgKi9cblx0dGhpcy5zID0ge1xuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEB0eXBlICAgICBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgIFBhc3NlZCBpbiBhcyBmaXJzdCBwYXJhbWV0ZXIgdG8gY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRkdDogZHRBcGkuc2V0dGluZ3MoKVswXSxcblxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlXG5cdFx0ICogIEB0eXBlICAgICBEYXRhVGFibGUuQXBpXG5cdFx0ICovXG5cdFx0ZHRBcGk6IGR0QXBpLFxuXG5cdFx0LyoqXG5cdFx0ICogUGl4ZWwgbG9jYXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgZHJhd24gdGFibGUgaW4gdGhlIHZpZXdwb3J0XG5cdFx0ICogIEB0eXBlICAgICBpbnRcblx0XHQgKiAgQGRlZmF1bHQgIDBcblx0XHQgKi9cblx0XHR0YWJsZVRvcDogMCxcblxuXHRcdC8qKlxuXHRcdCAqIFBpeGVsIGxvY2F0aW9uIG9mIHRoZSBib3R0b20gb2YgdGhlIGRyYXduIHRhYmxlIGluIHRoZSB2aWV3cG9ydFxuXHRcdCAqICBAdHlwZSAgICAgaW50XG5cdFx0ICogIEBkZWZhdWx0ICAwXG5cdFx0ICovXG5cdFx0dGFibGVCb3R0b206IDAsXG5cblx0XHQvKipcblx0XHQgKiBQaXhlbCBsb2NhdGlvbiBvZiB0aGUgYm91bmRhcnkgZm9yIHdoZW4gdGhlIG5leHQgZGF0YSBzZXQgc2hvdWxkIGJlIGxvYWRlZCBhbmQgZHJhd25cblx0XHQgKiB3aGVuIHNjcm9sbGluZyB1cCB0aGUgd2F5LlxuXHRcdCAqICBAdHlwZSAgICAgaW50XG5cdFx0ICogIEBkZWZhdWx0ICAwXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0cmVkcmF3VG9wOiAwLFxuXG5cdFx0LyoqXG5cdFx0ICogUGl4ZWwgbG9jYXRpb24gb2YgdGhlIGJvdW5kYXJ5IGZvciB3aGVuIHRoZSBuZXh0IGRhdGEgc2V0IHNob3VsZCBiZSBsb2FkZWQgYW5kIGRyYXduXG5cdFx0ICogd2hlbiBzY3JvbGxpbmcgZG93biB0aGUgd2F5LiBOb3RlIHRoYXQgdGhpcyBpcyBhY3R1YWxseSBjYWxjdWxhdGVkIGFzIHRoZSBvZmZzZXQgZnJvbVxuXHRcdCAqIHRoZSB0b3AuXG5cdFx0ICogIEB0eXBlICAgICBpbnRcblx0XHQgKiAgQGRlZmF1bHQgIDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRyZWRyYXdCb3R0b206IDAsXG5cblx0XHQvKipcblx0XHQgKiBBdXRvIHJvdyBoZWlnaHQgb3Igbm90IGluZGljYXRvclxuXHRcdCAqICBAdHlwZSAgICAgYm9vbFxuXHRcdCAqICBAZGVmYXVsdCAgMFxuXHRcdCAqL1xuXHRcdGF1dG9IZWlnaHQ6IHRydWUsXG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2Ygcm93cyBjYWxjdWxhdGVkIGFzIHZpc2libGUgaW4gdGhlIHZpc2libGUgdmlld3BvcnRcblx0XHQgKiAgQHR5cGUgICAgIGludFxuXHRcdCAqICBAZGVmYXVsdCAgMFxuXHRcdCAqL1xuXHRcdHZpZXdwb3J0Um93czogMCxcblxuXHRcdC8qKlxuXHRcdCAqIHNldFRpbWVvdXQgcmVmZXJlbmNlIGZvciBzdGF0ZSBzYXZpbmcsIHVzZWQgd2hlbiBzdGF0ZSBzYXZpbmcgaXMgZW5hYmxlZCBpbiB0aGUgRGF0YVRhYmxlXG5cdFx0ICogYW5kIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyB0aGUgdmlld3BvcnQgaW4gb3JkZXIgdG8gc3RvcCB0aGUgY29va2llIHNldCB0YWtpbmcgdG9vIG11Y2hcblx0XHQgKiBDUFUhXG5cdFx0ICogIEB0eXBlICAgICBpbnRcblx0XHQgKiAgQGRlZmF1bHQgIDBcblx0XHQgKi9cblx0XHRzdGF0ZVRPOiBudWxsLFxuXG5cdFx0c3RhdGVTYXZlVGhyb3R0bGU6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogc2V0VGltZW91dCByZWZlcmVuY2UgZm9yIHRoZSByZWRyYXcsIHVzZWQgd2hlbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGlzIGVuYWJsZWQgaW4gdGhlXG5cdFx0ICogRGF0YVRhYmxlcyBpbiBvcmRlciB0byBwcmV2ZW50IERvU2luZyB0aGUgc2VydmVyXG5cdFx0ICogIEB0eXBlICAgICBpbnRcblx0XHQgKiAgQGRlZmF1bHQgIG51bGxcblx0XHQgKi9cblx0XHRkcmF3VE86IG51bGwsXG5cblx0XHRoZWlnaHRzOiB7XG5cdFx0XHRqdW1wOiBudWxsLFxuXHRcdFx0cGFnZTogbnVsbCxcblx0XHRcdHZpcnR1YWw6IG51bGwsXG5cdFx0XHRzY3JvbGw6IG51bGwsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGVpZ2h0IG9mIHJvd3MgaW4gdGhlIHRhYmxlXG5cdFx0XHQgKiAgQHR5cGUgICAgIGludFxuXHRcdFx0ICogIEBkZWZhdWx0ICAwXG5cdFx0XHQgKi9cblx0XHRcdHJvdzogbnVsbCxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQaXhlbCBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG5cdFx0XHQgKiAgQHR5cGUgICAgIGludFxuXHRcdFx0ICogIEBkZWZhdWx0ICAwXG5cdFx0XHQgKi9cblx0XHRcdHZpZXdwb3J0OiBudWxsLFxuXHRcdFx0bGFiZWxIZWlnaHQ6IDAsXG5cdFx0XHR4YmFyOiAwXG5cdFx0fSxcblxuXHRcdHRvcFJvd0Zsb2F0OiAwLFxuXHRcdHNjcm9sbERyYXdEaWZmOiBudWxsLFxuXHRcdGxvYWRlclZpc2libGU6IGZhbHNlLFxuXHRcdGZvcmNlUmVwb3NpdGlvbjogZmFsc2UsXG5cdFx0YmFzZVJvd1RvcDogMCxcblx0XHRiYXNlU2Nyb2xsVG9wOiAwLFxuXHRcdG1vdXNlZG93bjogZmFsc2UsXG5cdFx0bGFzdFNjcm9sbFRvcDogMFxuXHR9O1xuXG5cdC8vIEB0b2RvIFRoZSBkZWZhdWx0cyBzaG91bGQgZXh0ZW5kIGEgYGNgIHByb3BlcnR5IGFuZCB0aGUgaW50ZXJuYWwgc2V0dGluZ3Ncblx0Ly8gb25seSBoZWxkIGluIHRoZSBgc2AgcHJvcGVydHkuIEF0IHRoZSBtb21lbnQgdGhleSBhcmUgbWl4ZWRcblx0dGhpcy5zID0gJC5leHRlbmQoIHRoaXMucywgU2Nyb2xsZXIub0RlZmF1bHRzLCBvcHRzICk7XG5cblx0Ly8gV29ya2Fyb3VuZCBmb3Igcm93IGhlaWdodCBiZWluZyByZWFkIGZyb20gaGVpZ2h0IG9iamVjdCAoc2VlIGFib3ZlIGNvbW1lbnQpXG5cdHRoaXMucy5oZWlnaHRzLnJvdyA9IHRoaXMucy5yb3dIZWlnaHQ7XG5cblx0LyoqXG5cdCAqIERPTSBlbGVtZW50cyB1c2VkIGJ5IHRoZSBjbGFzcyBpbnN0YW5jZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZXNwYWNlXG5cdCAqXG5cdCAqL1xuXHR0aGlzLmRvbSA9IHtcblx0XHRcImZvcmNlXCI6ICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdFwibGFiZWxcIjogICAgJCgnPGRpdiBjbGFzcz1cImR0c19sYWJlbFwiPjA8L2Rpdj4nKSxcblx0XHRcInNjcm9sbGVyXCI6IG51bGwsXG5cdFx0XCJ0YWJsZVwiOiAgICBudWxsLFxuXHRcdFwibG9hZGVyXCI6ICAgbnVsbFxuXHR9O1xuXG5cdC8vIEF0dGFjaCB0aGUgaW5zdGFuY2UgdG8gdGhlIERhdGFUYWJsZXMgaW5zdGFuY2Ugc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGluXG5cdC8vIGZ1dHVyZS4gRG9uJ3QgaW5pdGlhbGlzZSBTY3JvbGxlciB0d2ljZSBvbiB0aGUgc2FtZSB0YWJsZVxuXHRpZiAoIHRoaXMucy5kdC5vU2Nyb2xsZXIgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy5zLmR0Lm9TY3JvbGxlciA9IHRoaXM7XG5cblx0LyogTGV0J3MgZG8gaXQgKi9cblx0dGhpcy5jb25zdHJ1Y3QoKTtcbn07XG5cblxuXG4kLmV4dGVuZCggU2Nyb2xsZXIucHJvdG90eXBlLCB7XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogUHVibGljIG1ldGhvZHMgLSB0byBiZSBleHBvc2VkIHZpYSB0aGUgRGF0YVRhYmxlcyBBUElcblx0ICovXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBhbmQgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IG1hbnkgcm93cyBhcmUgdG8gYmUgZGlzcGxheWVkXG5cdCAqIGluIHRoZSBzY3JvbGxpbmcgdmlld3BvcnQsIGJhc2VkIG9uIGN1cnJlbnQgZGltZW5zaW9ucyBpbiB0aGUgYnJvd3NlcidzXG5cdCAqIHJlbmRlcmluZy4gVGhpcyBjYW4gYmUgcGFydGljdWxhcmx5IHVzZWZ1bCBpZiB0aGUgdGFibGUgaXMgaW5pdGlhbGx5XG5cdCAqIGRyYXduIGluIGEgaGlkZGVuIGVsZW1lbnQgLSBmb3IgZXhhbXBsZSBpbiBhIHRhYi5cblx0ICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgdGhlIHJlY2FsY3VsYXRpb24sIHdpdGhcblx0ICogICAgdGhlIG5ldyBkaW1lbnNpb25zIGZvcm1pbmcgdGhlIGJhc2lzIGZvciB0aGUgZHJhdy5cblx0ICogIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0bWVhc3VyZTogZnVuY3Rpb24gKCByZWRyYXcgKVxuXHR7XG5cdFx0aWYgKCB0aGlzLnMuYXV0b0hlaWdodCApXG5cdFx0e1xuXHRcdFx0dGhpcy5fY2FsY1Jvd0hlaWdodCgpO1xuXHRcdH1cblxuXHRcdHZhciBoZWlnaHRzID0gdGhpcy5zLmhlaWdodHM7XG5cblx0XHRpZiAoIGhlaWdodHMucm93ICkge1xuXHRcdFx0aGVpZ2h0cy52aWV3cG9ydCA9IHRoaXMuX3BhcnNlSGVpZ2h0KCQodGhpcy5kb20uc2Nyb2xsZXIpLmNzcygnbWF4LWhlaWdodCcpKTtcblxuXHRcdFx0dGhpcy5zLnZpZXdwb3J0Um93cyA9IHBhcnNlSW50KCBoZWlnaHRzLnZpZXdwb3J0IC8gaGVpZ2h0cy5yb3csIDEwICkrMTtcblx0XHRcdHRoaXMucy5kdC5faURpc3BsYXlMZW5ndGggPSB0aGlzLnMudmlld3BvcnRSb3dzICogdGhpcy5zLmRpc3BsYXlCdWZmZXI7XG5cdFx0fVxuXG5cdFx0dmFyIGxhYmVsID0gdGhpcy5kb20ubGFiZWwub3V0ZXJIZWlnaHQoKTtcblx0XHRcblx0XHRoZWlnaHRzLnhiYXIgPSB0aGlzLmRvbS5zY3JvbGxlci5vZmZzZXRIZWlnaHQgLSB0aGlzLmRvbS5zY3JvbGxlci5jbGllbnRIZWlnaHQ7XG5cdFx0aGVpZ2h0cy5sYWJlbEhlaWdodCA9IGxhYmVsO1xuXG5cdFx0aWYgKCByZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcgKVxuXHRcdHtcblx0XHRcdHRoaXMucy5kdC5vSW5zdGFuY2UuZm5EcmF3KCBmYWxzZSApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGN1cnJlbnQgZGlzcGxheWVkIHJlY29yZCByYW5nZS4gVGhpcyBjb3JyZXNwb25kcyB0b1xuXHQgKiB0aGUgaW5mb3JtYXRpb24gdXN1YWxseSBkaXNwbGF5ZWQgaW4gdGhlIFwiSW5mb1wiIGJsb2NrIG9mIHRoZSB0YWJsZS5cblx0ICpcblx0ICogQHJldHVybnMge29iamVjdH0gaW5mbyBhcyBhbiBvYmplY3Q6XG5cdCAqICB7XG5cdCAqICAgICAgc3RhcnQ6IHtpbnR9LCAvLyB0aGUgMC1pbmRleGVkIHJlY29yZCBhdCB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydFxuXHQgKiAgICAgIGVuZDogICB7aW50fSwgLy8gdGhlIDAtaW5kZXhlZCByZWNvcmQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgdmlld3BvcnRcblx0ICogIH1cblx0Ki9cblx0cGFnZUluZm86IGZ1bmN0aW9uKClcblx0e1xuXHRcdHZhciBcblx0XHRcdGR0ID0gdGhpcy5zLmR0LFxuXHRcdFx0aVNjcm9sbFRvcCA9IHRoaXMuZG9tLnNjcm9sbGVyLnNjcm9sbFRvcCxcblx0XHRcdGlUb3RhbCA9IGR0LmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGlQb3NzaWJsZUVuZCA9IE1hdGguY2VpbCh0aGlzLnBpeGVsc1RvUm93KGlTY3JvbGxUb3AgKyB0aGlzLnMuaGVpZ2h0cy52aWV3cG9ydCwgZmFsc2UsIHRoaXMucy5hbmkpKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogTWF0aC5mbG9vcih0aGlzLnBpeGVsc1RvUm93KGlTY3JvbGxUb3AsIGZhbHNlLCB0aGlzLnMuYW5pKSksXG5cdFx0XHRlbmQ6IGlUb3RhbCA8IGlQb3NzaWJsZUVuZCA/IGlUb3RhbC0xIDogaVBvc3NpYmxlRW5kLTFcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHJvdyBudW1iZXIgdGhhdCB3aWxsIGJlIGZvdW5kIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvblxuXHQgKiAoeS1zY3JvbGwpLlxuXHQgKlxuXHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHdoZW4gdGhlIGhlaWdodCBvZiB0aGUgZnVsbCB0YWJsZSBleGNlZWRzIDEgbWlsbGlvblxuXHQgKiBwaXhlbHMsIFNjcm9sbGVyIHN3aXRjaGVzIGludG8gYSBub24tbGluZWFyIG1vZGUgZm9yIHRoZSBzY3JvbGxiYXIgdG8gZml0XG5cdCAqIGFsbCBvZiB0aGUgcmVjb3JkcyBpbnRvIGEgZmluaXRlIGFyZWEsIGJ1dCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBsaW5lYXJcblx0ICogdmFsdWUgKHJlbGF0aXZlIHRvIHRoZSBsYXN0IG5vbi1saW5lYXIgcG9zaXRpb25pbmcpLlxuXHQgKiAgQHBhcmFtIHtpbnR9IHBpeGVscyBPZmZzZXQgZnJvbSB0b3AgdG8gY2FsY3VsYXRlIHRoZSByb3cgbnVtYmVyIG9mXG5cdCAqICBAcGFyYW0ge2ludH0gW2ludFBhcnNlPXRydWVdIElmIGFuIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICBAcGFyYW0ge2ludH0gW3ZpcnR1YWw9ZmFsc2VdIFBlcmZvcm0gdGhlIGNhbGN1bGF0aW9ucyBpbiB0aGUgdmlydHVhbCBkb21haW5cblx0ICogIEByZXR1cm5zIHtpbnR9IFJvdyBpbmRleFxuXHQgKi9cblx0cGl4ZWxzVG9Sb3c6IGZ1bmN0aW9uICggcGl4ZWxzLCBpbnRQYXJzZSwgdmlydHVhbCApXG5cdHtcblx0XHR2YXIgZGlmZiA9IHBpeGVscyAtIHRoaXMucy5iYXNlU2Nyb2xsVG9wO1xuXHRcdHZhciByb3cgPSB2aXJ0dWFsID9cblx0XHRcdCh0aGlzLl9kb21haW4oICdwaHlzaWNhbFRvVmlydHVhbCcsIHRoaXMucy5iYXNlU2Nyb2xsVG9wICkgKyBkaWZmKSAvIHRoaXMucy5oZWlnaHRzLnJvdyA6XG5cdFx0XHQoIGRpZmYgLyB0aGlzLnMuaGVpZ2h0cy5yb3cgKSArIHRoaXMucy5iYXNlUm93VG9wO1xuXG5cdFx0cmV0dXJuIGludFBhcnNlIHx8IGludFBhcnNlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0cGFyc2VJbnQoIHJvdywgMTAgKSA6XG5cdFx0XHRyb3c7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgcGl4ZWwgcG9zaXRpb24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGZvclxuXHQgKiBhIGdpdmVuIHJvd1xuXHQgKiAgQHBhcmFtIHtpbnR9IGlSb3cgUm93IG51bWJlciB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mXG5cdCAqICBAcmV0dXJucyB7aW50fSBQaXhlbHNcblx0ICovXG5cdHJvd1RvUGl4ZWxzOiBmdW5jdGlvbiAoIHJvd0lkeCwgaW50UGFyc2UsIHZpcnR1YWwgKVxuXHR7XG5cdFx0dmFyIHBpeGVscztcblx0XHR2YXIgZGlmZiA9IHJvd0lkeCAtIHRoaXMucy5iYXNlUm93VG9wO1xuXG5cdFx0aWYgKCB2aXJ0dWFsICkge1xuXHRcdFx0cGl4ZWxzID0gdGhpcy5fZG9tYWluKCAndmlydHVhbFRvUGh5c2ljYWwnLCB0aGlzLnMuYmFzZVNjcm9sbFRvcCApO1xuXHRcdFx0cGl4ZWxzICs9IGRpZmYgKiB0aGlzLnMuaGVpZ2h0cy5yb3c7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cGl4ZWxzID0gdGhpcy5zLmJhc2VTY3JvbGxUb3A7XG5cdFx0XHRwaXhlbHMgKz0gZGlmZiAqIHRoaXMucy5oZWlnaHRzLnJvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gaW50UGFyc2UgfHwgaW50UGFyc2UgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRwYXJzZUludCggcGl4ZWxzLCAxMCApIDpcblx0XHRcdHBpeGVscztcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHJvdyBudW1iZXIgdGhhdCB3aWxsIGJlIGZvdW5kIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiAoeS1zY3JvbGwpXG5cdCAqICBAcGFyYW0ge2ludH0gcm93IFJvdyBpbmRleCB0byBzY3JvbGwgdG9cblx0ICogIEBwYXJhbSB7Ym9vbH0gW2FuaW1hdGU9dHJ1ZV0gQW5pbWF0ZSB0aGUgdHJhbnNpdGlvbiBvciBub3Rcblx0ICogIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0c2Nyb2xsVG9Sb3c6IGZ1bmN0aW9uICggcm93LCBhbmltYXRlIClcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgYW5pID0gZmFsc2U7XG5cdFx0dmFyIHB4ID0gdGhpcy5yb3dUb1BpeGVscyggcm93ICk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGtub3cgaWYgdGhlIHRhYmxlIHdpbGwgcmVkcmF3IG9yIG5vdCBiZWZvcmUgZG9pbmcgdGhlXG5cdFx0Ly8gc2Nyb2xsLiBJZiBpdCB3aWxsIG5vdCByZWRyYXcsIHRoZW4gd2UgbmVlZCB0byB1c2UgdGhlIGN1cnJlbnRseVxuXHRcdC8vIGRpc3BsYXllZCB0YWJsZSwgYW5kIHNjcm9sbCB3aXRoIHRoZSBwaHlzaWNhbCBwaXhlbHMuIE90aGVyd2lzZSwgd2Vcblx0XHQvLyBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgdGFibGUncyBuZXcgcG9zaXRpb24gZnJvbSB0aGUgdmlydHVhbFxuXHRcdC8vIHRyYW5zZm9ybS5cblx0XHR2YXIgcHJlUm93cyA9ICgodGhpcy5zLmRpc3BsYXlCdWZmZXItMSkvMikgKiB0aGlzLnMudmlld3BvcnRSb3dzO1xuXHRcdHZhciBkcmF3Um93ID0gcm93IC0gcHJlUm93cztcblx0XHRpZiAoIGRyYXdSb3cgPCAwICkge1xuXHRcdFx0ZHJhd1JvdyA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCAocHggPiB0aGlzLnMucmVkcmF3Qm90dG9tIHx8IHB4IDwgdGhpcy5zLnJlZHJhd1RvcCkgJiYgdGhpcy5zLmR0Ll9pRGlzcGxheVN0YXJ0ICE9PSBkcmF3Um93ICkge1xuXHRcdFx0YW5pID0gdHJ1ZTtcblx0XHRcdHB4ID0gdGhpcy5fZG9tYWluKCAndmlydHVhbFRvUGh5c2ljYWwnLCByb3cgKiB0aGlzLnMuaGVpZ2h0cy5yb3cgKTtcblxuXHRcdFx0Ly8gSWYgd2UgbmVlZCByZWNvcmRzIG91dHNpZGUgdGhlIGN1cnJlbnQgZHJhdyByZWdpb24sIGJ1dCB0aGUgbmV3XG5cdFx0XHQvLyBzY3JvbGxpbmcgcG9zaXRpb24gaXMgaW5zaWRlIHRoYXQgKGR1ZSB0byB0aGUgbm9uLWxpbmVhciBuYXR1cmVcblx0XHRcdC8vIGZvciBsYXJnZXIgbnVtYmVycyBvZiByZWNvcmRzKSwgd2UgbmVlZCB0byBmb3JjZSBwb3NpdGlvbiB1cGRhdGUuXG5cdFx0XHRpZiAoIHRoaXMucy5yZWRyYXdUb3AgPCBweCAmJiBweCA8IHRoaXMucy5yZWRyYXdCb3R0b20gKSB7XG5cdFx0XHRcdHRoaXMucy5mb3JjZVJlcG9zaXRpb24gPSB0cnVlO1xuXHRcdFx0XHRhbmltYXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBhbmltYXRlID09PSB1bmRlZmluZWQgfHwgYW5pbWF0ZSApXG5cdFx0e1xuXHRcdFx0dGhpcy5zLmFuaSA9IGFuaTtcblx0XHRcdCQodGhpcy5kb20uc2Nyb2xsZXIpLmFuaW1hdGUoIHtcblx0XHRcdFx0XCJzY3JvbGxUb3BcIjogcHhcblx0XHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkIGFuZFxuXHRcdFx0XHQvLyB0aGUgZmluYWwgc2Nyb2xsIGV2ZW50IGZpcmVkXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGF0LnMuYW5pID0gZmFsc2U7XG5cdFx0XHRcdH0sIDI1MCApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0JCh0aGlzLmRvbS5zY3JvbGxlcikuc2Nyb2xsVG9wKCBweCApO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogQ29uc3RydWN0b3Jcblx0ICovXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpc2F0aW9uIGZvciBTY3JvbGxlclxuXHQgKiAgQHJldHVybnMge3ZvaWR9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0Y29uc3RydWN0OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdEFwaTtcblxuXHRcdC8qIFNhbml0eSBjaGVjayAqL1xuXHRcdGlmICggIXRoaXMucy5kdC5vRmVhdHVyZXMuYlBhZ2luYXRlICkge1xuXHRcdFx0dGhpcy5zLmR0Lm9BcGkuX2ZuTG9nKCB0aGlzLnMuZHQsIDAsICdQYWdpbmF0aW9uIG11c3QgYmUgZW5hYmxlZCBmb3IgU2Nyb2xsZXInICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogSW5zZXJ0IGEgZGl2IGVsZW1lbnQgdGhhdCB3ZSBjYW4gdXNlIHRvIGZvcmNlIHRoZSBEVCBzY3JvbGxpbmcgY29udGFpbmVyIHRvXG5cdFx0ICogdGhlIGhlaWdodCB0aGF0IHdvdWxkIGJlIHJlcXVpcmVkIGlmIHRoZSB3aG9sZSB0YWJsZSB3YXMgYmVpbmcgZGlzcGxheWVkXG5cdFx0ICovXG5cdFx0dGhpcy5kb20uZm9yY2Uuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0dGhpcy5kb20uZm9yY2Uuc3R5bGUudG9wID0gXCIwcHhcIjtcblx0XHR0aGlzLmRvbS5mb3JjZS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcblx0XHR0aGlzLmRvbS5mb3JjZS5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cblx0XHR0aGlzLmRvbS5zY3JvbGxlciA9ICQoJ2Rpdi4nK3RoaXMucy5kdC5vQ2xhc3Nlcy5zU2Nyb2xsQm9keSwgdGhpcy5zLmR0Lm5UYWJsZVdyYXBwZXIpWzBdO1xuXHRcdHRoaXMuZG9tLnNjcm9sbGVyLmFwcGVuZENoaWxkKCB0aGlzLmRvbS5mb3JjZSApO1xuXHRcdHRoaXMuZG9tLnNjcm9sbGVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXG5cdFx0dGhpcy5kb20udGFibGUgPSAkKCc+dGFibGUnLCB0aGlzLmRvbS5zY3JvbGxlcilbMF07XG5cdFx0dGhpcy5kb20udGFibGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0dGhpcy5kb20udGFibGUuc3R5bGUudG9wID0gXCIwcHhcIjtcblx0XHR0aGlzLmRvbS50YWJsZS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcblxuXHRcdC8vIEFkZCBjbGFzcyB0byAnYW5ub3VuY2UnIHRoYXQgd2UgYXJlIGEgU2Nyb2xsZXIgdGFibGVcblx0XHQkKGR0LnRhYmxlKCkuY29udGFpbmVyKCkpLmFkZENsYXNzKCdkdHMgRFRTJyk7XG5cblx0XHQvLyBBZGQgYSAnbG9hZGluZycgaW5kaWNhdG9yXG5cdFx0aWYgKCB0aGlzLnMubG9hZGluZ0luZGljYXRvciApXG5cdFx0e1xuXHRcdFx0dGhpcy5kb20ubG9hZGVyID0gJCgnPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfcHJvY2Vzc2luZyBkdHNfbG9hZGluZ1wiPicrdGhpcy5zLmR0Lm9MYW5ndWFnZS5zTG9hZGluZ1JlY29yZHMrJzwvZGl2PicpXG5cdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG5cdFx0XHQkKHRoaXMuZG9tLnNjcm9sbGVyLnBhcmVudE5vZGUpXG5cdFx0XHRcdC5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJylcblx0XHRcdFx0LmFwcGVuZCggdGhpcy5kb20ubG9hZGVyICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kb20ubGFiZWwuYXBwZW5kVG8odGhpcy5kb20uc2Nyb2xsZXIpO1xuXG5cdFx0LyogSW5pdGlhbCBzaXplIGNhbGN1bGF0aW9ucyAqL1xuXHRcdGlmICggdGhpcy5zLmhlaWdodHMucm93ICYmIHRoaXMucy5oZWlnaHRzLnJvdyAhPSAnYXV0bycgKVxuXHRcdHtcblx0XHRcdHRoaXMucy5hdXRvSGVpZ2h0ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gU2Nyb2xsaW5nIGNhbGxiYWNrIHRvIHNlZSBpZiBhIHBhZ2UgY2hhbmdlIGlzIG5lZWRlZFxuXHRcdHRoaXMucy5pbmdub3JlU2Nyb2xsID0gdHJ1ZTtcblx0XHQkKHRoaXMuZG9tLnNjcm9sbGVyKS5vbiggJ3Njcm9sbC5kdC1zY3JvbGxlcicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR0aGF0Ll9zY3JvbGwuY2FsbCggdGhhdCApO1xuXHRcdH0gKTtcblxuXHRcdC8vIEluIGlPUyB3ZSBjYXRjaCB0aGUgdG91Y2hzdGFydCBldmVudCBpbiBjYXNlIHRoZSB1c2VyIHRyaWVzIHRvIHNjcm9sbFxuXHRcdC8vIHdoaWxlIHRoZSBkaXNwbGF5IGlzIGFscmVhZHkgc2Nyb2xsaW5nXG5cdFx0JCh0aGlzLmRvbS5zY3JvbGxlcikub24oJ3RvdWNoc3RhcnQuZHQtc2Nyb2xsZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0Ll9zY3JvbGwuY2FsbCggdGhhdCApO1xuXHRcdH0gKTtcblxuXHRcdCQodGhpcy5kb20uc2Nyb2xsZXIpXG5cdFx0XHQub24oJ21vdXNlZG93bi5kdC1zY3JvbGxlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5zLm1vdXNlZG93biA9IHRydWU7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdtb3VzZXVwLmR0LXNjcm9sbGVyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0LnMubGFiZWxWaXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQucy5tb3VzZWRvd24gPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5kb20ubGFiZWwuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gT24gcmVzaXplLCB1cGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQsIHNpbmNlIHRoZSBudW1iZXIgb2Ygcm93cyBzaG93biBtaWdodCBjaGFuZ2Vcblx0XHQkKHdpbmRvdykub24oICdyZXNpemUuZHQtc2Nyb2xsZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0Lm1lYXN1cmUoIGZhbHNlICk7XG5cdFx0XHR0aGF0Ll9pbmZvKCk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gQWRkIGEgc3RhdGUgc2F2aW5nIHBhcmFtZXRlciB0byB0aGUgRFQgc3RhdGUgc2F2aW5nIHNvIHdlIGNhbiByZXN0b3JlIHRoZSBleGFjdFxuXHRcdC8vIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGxpbmcuXG5cdFx0dmFyIGluaXRpYWxTdGF0ZVNhdmUgPSB0cnVlO1xuXHRcdHZhciBsb2FkZWRTdGF0ZSA9IGR0LnN0YXRlLmxvYWRlZCgpO1xuXG5cdFx0ZHQub24oICdzdGF0ZVNhdmVQYXJhbXMuc2Nyb2xsZXInLCBmdW5jdGlvbiAoIGUsIHNldHRpbmdzLCBkYXRhICkge1xuXHRcdFx0aWYgKCBpbml0aWFsU3RhdGVTYXZlICYmIGxvYWRlZFN0YXRlICkge1xuXHRcdFx0XHRkYXRhLnNjcm9sbGVyID0gbG9hZGVkU3RhdGUuc2Nyb2xsZXI7XG5cdFx0XHRcdGluaXRpYWxTdGF0ZVNhdmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBOZWVkIHRvIHVzZWQgdGhlIHNhdmVkIHBvc2l0aW9uIG9uIGluaXRcblx0XHRcdFx0ZGF0YS5zY3JvbGxlciA9IHtcblx0XHRcdFx0XHR0b3BSb3c6IHRoYXQucy50b3BSb3dGbG9hdCxcblx0XHRcdFx0XHRiYXNlU2Nyb2xsVG9wOiB0aGF0LnMuYmFzZVNjcm9sbFRvcCxcblx0XHRcdFx0XHRiYXNlUm93VG9wOiB0aGF0LnMuYmFzZVJvd1RvcCxcblx0XHRcdFx0XHRzY3JvbGxUb3A6IHRoYXQucy5sYXN0U2Nyb2xsVG9wXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0aWYgKCBsb2FkZWRTdGF0ZSAmJiBsb2FkZWRTdGF0ZS5zY3JvbGxlciApIHtcblx0XHRcdHRoaXMucy50b3BSb3dGbG9hdCA9IGxvYWRlZFN0YXRlLnNjcm9sbGVyLnRvcFJvdztcblx0XHRcdHRoaXMucy5iYXNlU2Nyb2xsVG9wID0gbG9hZGVkU3RhdGUuc2Nyb2xsZXIuYmFzZVNjcm9sbFRvcDtcblx0XHRcdHRoaXMucy5iYXNlUm93VG9wID0gbG9hZGVkU3RhdGUuc2Nyb2xsZXIuYmFzZVJvd1RvcDtcblx0XHR9XG5cblx0XHR0aGlzLm1lYXN1cmUoIGZhbHNlICk7XG5cdFxuXHRcdHRoYXQucy5zdGF0ZVNhdmVUaHJvdHRsZSA9IHRoYXQucy5kdC5vQXBpLl9mblRocm90dGxlKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0LnMuZHRBcGkuc3RhdGUuc2F2ZSgpO1xuXHRcdH0sIDUwMCApO1xuXG5cdFx0ZHQub24oICdpbml0LnNjcm9sbGVyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5tZWFzdXJlKCBmYWxzZSApO1xuXG5cdFx0XHQvLyBTZXR0aW5nIHRvIGBqdW1wYCB3aWxsIGluc3RydWN0IF9kcmF3IHRvIGNhbGN1bGF0ZSB0aGUgc2Nyb2xsIHRvcFxuXHRcdFx0Ly8gcG9zaXRpb25cblx0XHRcdHRoYXQucy5zY3JvbGxUeXBlID0gJ2p1bXAnO1xuXHRcdFx0dGhhdC5fZHJhdygpO1xuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIHNjcm9sbGVyIHdoZW4gdGhlIERhdGFUYWJsZSBpcyByZWRyYXduXG5cdFx0XHRkdC5vbiggJ2RyYXcuc2Nyb2xsZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuX2RyYXcoKTtcblx0XHRcdH0pO1xuXHRcdH0gKTtcblxuXHRcdC8vIFNldCBoZWlnaHQgYmVmb3JlIHRoZSBkcmF3IGhhcHBlbnMsIGFsbG93aW5nIGV2ZXJ5dGhpbmcgZWxzZSB0byB1cGRhdGVcblx0XHQvLyBvbiBkcmF3IGNvbXBsZXRlIHdpdGhvdXQgd29ycnkgZm9yIHJvZGVyLlxuXHRcdGR0Lm9uKCAncHJlRHJhdy5kdC5zY3JvbGxlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuX3Njcm9sbEZvcmNlKCk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVzdHJ1Y3RvclxuXHRcdGR0Lm9uKCAnZGVzdHJveS5zY3JvbGxlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdCQod2luZG93KS5vZmYoICdyZXNpemUuZHQtc2Nyb2xsZXInICk7XG5cdFx0XHQkKHRoYXQuZG9tLnNjcm9sbGVyKS5vZmYoJy5kdC1zY3JvbGxlcicpO1xuXHRcdFx0JCh0aGF0LnMuZHQublRhYmxlKS5vZmYoICcuc2Nyb2xsZXInICk7XG5cblx0XHRcdCQodGhhdC5zLmR0Lm5UYWJsZVdyYXBwZXIpLnJlbW92ZUNsYXNzKCdEVFMnKTtcblx0XHRcdCQoJ2Rpdi5EVFNfTG9hZGluZycsIHRoYXQuZG9tLnNjcm9sbGVyLnBhcmVudE5vZGUpLnJlbW92ZSgpO1xuXG5cdFx0XHR0aGF0LmRvbS50YWJsZS5zdHlsZS5wb3NpdGlvbiA9IFwiXCI7XG5cdFx0XHR0aGF0LmRvbS50YWJsZS5zdHlsZS50b3AgPSBcIlwiO1xuXHRcdFx0dGhhdC5kb20udGFibGUuc3R5bGUubGVmdCA9IFwiXCI7XG5cdFx0fSApO1xuXHR9LFxuXG5cblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBQcml2YXRlIG1ldGhvZHNcblx0ICovXG5cblx0LyoqXG5cdCAqIEF1dG9tYXRpYyBjYWxjdWxhdGlvbiBvZiB0YWJsZSByb3cgaGVpZ2h0LiBUaGlzIGlzIGp1c3QgYSBsaXR0bGUgdHJpY2t5IGhlcmUgYXMgdXNpbmdcblx0ICogaW5pdGlhbGlzYXRpb24gRGF0YVRhYmxlcyBoYXMgdGFsZSB0aGUgdGFibGUgb3V0IG9mIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBjcmVhdGVcblx0ICogYSBuZXcgdGFibGUgYW5kIGluc2VydCBpdCBpbnRvIHRoZSBkb2N1bWVudCwgY2FsY3VsYXRlIHRoZSByb3cgaGVpZ2h0IGFuZCB0aGVuIHdoaXAgdGhlXG5cdCAqIHRhYmxlIG91dC5cblx0ICogIEByZXR1cm5zIHt2b2lkfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9jYWxjUm93SGVpZ2h0OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBvcmlnVGFibGUgPSBkdC5uVGFibGU7XG5cdFx0dmFyIG5UYWJsZSA9IG9yaWdUYWJsZS5jbG9uZU5vZGUoIGZhbHNlICk7XG5cdFx0dmFyIHRib2R5ID0gJCgnPHRib2R5Lz4nKS5hcHBlbmRUbyggblRhYmxlICk7XG5cdFx0dmFyIGNvbnRhaW5lciA9ICQoXG5cdFx0XHQnPGRpdiBjbGFzcz1cIicrZHQub0NsYXNzZXMuc1dyYXBwZXIrJyBEVFNcIj4nK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cIicrZHQub0NsYXNzZXMuc1Njcm9sbFdyYXBwZXIrJ1wiPicrXG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCInK2R0Lm9DbGFzc2VzLnNTY3JvbGxCb2R5KydcIj48L2Rpdj4nK1xuXHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdCc8L2Rpdj4nXG5cdFx0KTtcblxuXHRcdC8vIFdhbnQgMyByb3dzIGluIHRoZSBzaXppbmcgdGFibGUgc28gOmZpcnN0LWNoaWxkIGFuZCA6bGFzdC1jaGlsZFxuXHRcdC8vIENTUyBzdHlsZXMgZG9uJ3QgY29tZSBpbnRvIHBsYXkgLSB0YWtlIHRoZSBzaXplIG9mIHRoZSBtaWRkbGUgcm93XG5cdFx0JCgndGJvZHkgdHI6bHQoNCknLCBvcmlnVGFibGUpLmNsb25lKCkuYXBwZW5kVG8oIHRib2R5ICk7XG4gICAgICAgIHZhciByb3dzQ291bnQgPSAkKCd0cicsIHRib2R5KS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCByb3dzQ291bnQgPT09IDEgKSB7XG4gICAgICAgICAgICB0Ym9keS5wcmVwZW5kKCc8dHI+PHRkPiYjMTYwOzwvdGQ+PC90cj4nKTtcbiAgICAgICAgICAgIHRib2R5LmFwcGVuZCgnPHRyPjx0ZD4mIzE2MDs8L3RkPjwvdHI+Jyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IHJvd3NDb3VudCA8IDM7IHJvd3NDb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgdGJvZHkuYXBwZW5kKCc8dHI+PHRkPiYjMTYwOzwvdGQ+PC90cj4nKTtcbiAgICAgICAgICAgIH1cblx0XHR9XG5cdFxuXHRcdCQoJ2Rpdi4nK2R0Lm9DbGFzc2VzLnNTY3JvbGxCb2R5LCBjb250YWluZXIpLmFwcGVuZCggblRhYmxlICk7XG5cblx0XHQvLyBJZiBpbml0aWFsaXNlZCB1c2luZyBgZG9tYCwgdXNlIHRoZSBob2xkaW5nIGVsZW1lbnQgYXMgdGhlIGluc2VydCBwb2ludFxuXHRcdHZhciBpbnNlcnRFbCA9IHRoaXMucy5kdC5uSG9sZGluZyB8fCBvcmlnVGFibGUucGFyZW50Tm9kZTtcblxuXHRcdGlmICggISAkKGluc2VydEVsKS5pcygnOnZpc2libGUnKSApIHtcblx0XHRcdGluc2VydEVsID0gJ2JvZHknO1xuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBmb3JtIGVsZW1lbnQgbGlua3MgYXMgdGhleSBtaWdodCBzZWxlY3Qgb3ZlciBvdGhlcnMgKHBhcnRpY3VsYXJseSByYWRpbyBhbmQgY2hlY2tib3hlcylcblx0XHRjb250YWluZXIuZmluZChcImlucHV0XCIpLnJlbW92ZUF0dHIoXCJuYW1lXCIpO1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZFRvKCBpbnNlcnRFbCApO1xuXHRcdHRoaXMucy5oZWlnaHRzLnJvdyA9ICQoJ3RyJywgdGJvZHkpLmVxKDEpLm91dGVySGVpZ2h0KCk7XG5cblx0XHRjb250YWluZXIucmVtb3ZlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZmlyZWQgd2hlbiB0aGUgRGF0YVRhYmxlIGlzIHJlZHJhd24uIFRoZSBtYWluIGZ1bmN0aW9uIG9mXG5cdCAqIHRoaXMgbWV0aG9kIGlzIHRvIHBvc2l0aW9uIHRoZSBkcmF3biB0YWJsZSBjb3JyZWN0bHkgdGhlIHNjcm9sbGluZyBjb250YWluZXIgZm9yIHRoZSByb3dzXG5cdCAqIHRoYXQgaXMgZGlzcGxheXMgYXMgYSByZXN1bHQgb2YgdGhlIHNjcm9sbGluZyBwb3NpdGlvbi5cblx0ICogIEByZXR1cm5zIHt2b2lkfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9kcmF3OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGhlaWdodHMgPSB0aGlzLnMuaGVpZ2h0cyxcblx0XHRcdGlTY3JvbGxUb3AgPSB0aGlzLmRvbS5zY3JvbGxlci5zY3JvbGxUb3AsXG5cdFx0XHRpVGFibGVIZWlnaHQgPSAkKHRoaXMucy5kdC5uVGFibGUpLmhlaWdodCgpLFxuXHRcdFx0ZGlzcGxheVN0YXJ0ID0gdGhpcy5zLmR0Ll9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0ZGlzcGxheUxlbiA9IHRoaXMucy5kdC5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRkaXNwbGF5RW5kID0gdGhpcy5zLmR0LmZuUmVjb3Jkc0Rpc3BsYXkoKTtcblxuXHRcdC8vIERpc2FibGUgdGhlIHNjcm9sbCBldmVudCBsaXN0ZW5lciB3aGlsZSB3ZSBhcmUgdXBkYXRpbmcgdGhlIERPTVxuXHRcdHRoaXMucy5za2lwID0gdHJ1ZTtcblxuXHRcdC8vIElmIHBhZ2luZyBpcyByZXNldFxuXHRcdGlmICggKHRoaXMucy5kdC5iU29ydGVkIHx8IHRoaXMucy5kdC5iRmlsdGVyZWQpICYmIGRpc3BsYXlTdGFydCA9PT0gMCAmJiAhdGhpcy5zLmR0Ll9kcmF3SG9sZCApIHtcblx0XHRcdHRoaXMucy50b3BSb3dGbG9hdCA9IDA7XG5cdFx0fVxuXG5cdFx0aVNjcm9sbFRvcCA9IHRoaXMucy5zY3JvbGxUeXBlID09PSAnanVtcCcgP1xuXHRcdFx0dGhpcy5fZG9tYWluKCAndmlydHVhbFRvUGh5c2ljYWwnLCB0aGlzLnMudG9wUm93RmxvYXQgKiBoZWlnaHRzLnJvdyApIDpcblx0XHRcdGlTY3JvbGxUb3A7XG5cblx0XHQvLyBTdG9yZSBwb3NpdGlvbmFsIGluZm9ybWF0aW9uIHNvIHBvc2l0aW9uYWwgY2FsY3VsYXRpb25zIGNhbiBiZSBiYXNlZFxuXHRcdC8vIHVwb24gdGhlIGN1cnJlbnQgdGFibGUgZHJhdyBwb3NpdGlvblxuXHRcdHRoaXMucy5iYXNlU2Nyb2xsVG9wID0gaVNjcm9sbFRvcDtcblx0XHR0aGlzLnMuYmFzZVJvd1RvcCA9IHRoaXMucy50b3BSb3dGbG9hdDtcblxuXHRcdC8vIFBvc2l0aW9uIHRoZSB0YWJsZSBpbiB0aGUgdmlydHVhbCBzY3JvbGxlclxuXHRcdHZhciB0YWJsZVRvcCA9IGlTY3JvbGxUb3AgLSAoKHRoaXMucy50b3BSb3dGbG9hdCAtIGRpc3BsYXlTdGFydCkgKiBoZWlnaHRzLnJvdyk7XG5cdFx0aWYgKCBkaXNwbGF5U3RhcnQgPT09IDAgKSB7XG5cdFx0XHR0YWJsZVRvcCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBkaXNwbGF5U3RhcnQgKyBkaXNwbGF5TGVuID49IGRpc3BsYXlFbmQgKSB7XG5cdFx0XHR0YWJsZVRvcCA9IGhlaWdodHMuc2Nyb2xsIC0gaVRhYmxlSGVpZ2h0O1xuXHRcdH1cblxuXHRcdHRoaXMuZG9tLnRhYmxlLnN0eWxlLnRvcCA9IHRhYmxlVG9wKydweCc7XG5cblx0XHQvKiBDYWNoZSBzb21lIGluZm9ybWF0aW9uIGZvciB0aGUgc2Nyb2xsZXIgKi9cblx0XHR0aGlzLnMudGFibGVUb3AgPSB0YWJsZVRvcDtcblx0XHR0aGlzLnMudGFibGVCb3R0b20gPSBpVGFibGVIZWlnaHQgKyB0aGlzLnMudGFibGVUb3A7XG5cblx0XHQvLyBDYWxjdWxhdGUgdGhlIGJvdW5kYXJpZXMgZm9yIHdoZXJlIGEgcmVkcmF3IHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZVxuXHRcdC8vIHNjcm9sbCBldmVudCBsaXN0ZW5lclxuXHRcdHZhciBib3VuZGFyeVB4ID0gKGlTY3JvbGxUb3AgLSB0aGlzLnMudGFibGVUb3ApICogdGhpcy5zLmJvdW5kYXJ5U2NhbGU7XG5cdFx0dGhpcy5zLnJlZHJhd1RvcCA9IGlTY3JvbGxUb3AgLSBib3VuZGFyeVB4O1xuXHRcdHRoaXMucy5yZWRyYXdCb3R0b20gPSBpU2Nyb2xsVG9wICsgYm91bmRhcnlQeCA+IGhlaWdodHMuc2Nyb2xsIC0gaGVpZ2h0cy52aWV3cG9ydCAtIGhlaWdodHMucm93ID9cblx0XHRcdGhlaWdodHMuc2Nyb2xsIC0gaGVpZ2h0cy52aWV3cG9ydCAtIGhlaWdodHMucm93IDpcblx0XHRcdGlTY3JvbGxUb3AgKyBib3VuZGFyeVB4O1xuXG5cdFx0dGhpcy5zLnNraXAgPSBmYWxzZTtcblxuXHRcdC8vIFJlc3RvcmUgdGhlIHNjcm9sbGluZyBwb3NpdGlvbiB0aGF0IHdhcyBzYXZlZCBieSBEYXRhVGFibGUncyBzdGF0ZVxuXHRcdC8vIHNhdmluZyBOb3RlIHRoYXQgdGhpcyBpcyBkb25lIG9uIHRoZSBzZWNvbmQgZHJhdyB3aGVuIGRhdGEgaXMgQWpheFxuXHRcdC8vIHNvdXJjZWQsIGFuZCB0aGUgZmlyc3QgZHJhdyB3aGVuIERPTSBzb3VyZWRcblx0XHRpZiAoIHRoaXMucy5kdC5vRmVhdHVyZXMuYlN0YXRlU2F2ZSAmJiB0aGlzLnMuZHQub0xvYWRlZFN0YXRlICE9PSBudWxsICYmXG5cdFx0XHQgdHlwZW9mIHRoaXMucy5kdC5vTG9hZGVkU3RhdGUuc2Nyb2xsZXIgIT0gJ3VuZGVmaW5lZCcgKVxuXHRcdHtcblx0XHRcdC8vIEEgcXVpcmsgb2YgRGF0YVRhYmxlcyBpcyB0aGF0IHRoZSBkcmF3IGNhbGxiYWNrIHdpbGwgb2NjdXIgb24gYW5cblx0XHRcdC8vIGVtcHR5IHNldCBpZiBBamF4IHNvdXJjZWQsIGJ1dCBub3QgaWYgc2VydmVyLXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdHZhciBhamF4U291cmNlZCA9ICh0aGlzLnMuZHQuc0FqYXhTb3VyY2UgfHwgdGhhdC5zLmR0LmFqYXgpICYmICEgdGhpcy5zLmR0Lm9GZWF0dXJlcy5iU2VydmVyU2lkZSA/XG5cdFx0XHRcdHRydWUgOlxuXHRcdFx0XHRmYWxzZTtcblxuXHRcdFx0aWYgKCAoIGFqYXhTb3VyY2VkICYmIHRoaXMucy5kdC5pRHJhdyA9PSAyKSB8fFxuXHRcdFx0ICAgICAoIWFqYXhTb3VyY2VkICYmIHRoaXMucy5kdC5pRHJhdyA9PSAxKSApXG5cdFx0XHR7XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkKHRoYXQuZG9tLnNjcm9sbGVyKS5zY3JvbGxUb3AoIHRoYXQucy5kdC5vTG9hZGVkU3RhdGUuc2Nyb2xsZXIuc2Nyb2xsVG9wICk7XG5cblx0XHRcdFx0XHQvLyBJbiBvcmRlciB0byBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcgd2UgbmVlZCBhbm90aGVyXG5cdFx0XHRcdFx0Ly8gc21hbGwgZGVsYXlcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0aGF0LnMuaW5nbm9yZVNjcm9sbCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0sIDAgKTtcblx0XHRcdFx0fSwgMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoYXQucy5pbmdub3JlU2Nyb2xsID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQmVjYXVzZSBvZiB0aGUgb3JkZXIgb2YgdGhlIERUIGNhbGxiYWNrcywgdGhlIGluZm8gdXBkYXRlIHdpbGxcblx0XHQvLyB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUgb25lIHdlIHdhbnQgaGVyZS4gU28gYSAndGhyZWFkJyBicmVhayBpc1xuXHRcdC8vIG5lZWRlZC4gIE9ubHkgYWRkIHRoZSB0aHJlYWQgYnJlYWsgaWYgYkluZm8gaXMgc2V0XG5cdFx0aWYgKCB0aGlzLnMuZHQub0ZlYXR1cmVzLmJJbmZvICkge1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9pbmZvLmNhbGwoIHRoYXQgKTtcblx0XHRcdH0sIDAgKTtcblx0XHR9XG5cblx0XHQkKHRoaXMucy5kdC5uVGFibGUpLnRyaWdnZXJIYW5kbGVyKCdwb3NpdGlvbi5kdHMuZHQnLCB0YWJsZVRvcCk7XG5cblx0XHQvLyBIaWRlIHRoZSBsb2FkaW5nIGluZGljYXRvclxuXHRcdGlmICggdGhpcy5kb20ubG9hZGVyICYmIHRoaXMucy5sb2FkZXJWaXNpYmxlICkge1xuXHRcdFx0dGhpcy5kb20ubG9hZGVyLmNzcyggJ2Rpc3BsYXknLCAnbm9uZScgKTtcblx0XHRcdHRoaXMucy5sb2FkZXJWaXNpYmxlID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gb25lIGRvbWFpbiB0byBhbm90aGVyLiBUaGUgcGh5c2ljYWwgZG9tYWluIGlzIHRoZSBhY3R1YWxcblx0ICogcGl4ZWwgY291bnQgb24gdGhlIHNjcmVlbiwgd2hpbGUgdGhlIHZpcnR1YWwgaXMgaWYgd2UgaGFkIGJyb3dzZXJzIHdoaWNoXG5cdCAqIGhhZCBzY3JvbGxpbmcgY29udGFpbmVycyBvZiBpbmZpbml0ZSBoZWlnaHQgKGkuZS4gdGhlIGFic29sdXRlIHZhbHVlKVxuXHQgKlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGRpciBEb21haW4gdHJhbnNmb3JtIGRpcmVjdGlvbiwgYHZpcnR1YWxUb1BoeXNpY2FsYCBvclxuXHQgKiAgICBgcGh5c2ljYWxUb1ZpcnR1YWxgIFxuXHQgKiAgQHJldHVybnMge251bWJlcn0gQ2FsY3VsYXRlZCB0cmFuc2Zvcm1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRfZG9tYWluOiBmdW5jdGlvbiAoIGRpciwgdmFsIClcblx0e1xuXHRcdHZhciBoZWlnaHRzID0gdGhpcy5zLmhlaWdodHM7XG5cdFx0dmFyIGRpZmY7XG5cdFx0dmFyIG1hZ2ljID0gMTAwMDA7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgbm9uLWxpbmVhciBjYWxjdWxhdGlvbnMgc3RhcnQgdG8gaGFwcGVuXG5cblx0XHQvLyBJZiB0aGUgdmlydHVhbCBhbmQgcGh5c2ljYWwgaGVpZ2h0IG1hdGNoLCB0aGVuIHdlIHVzZSBhIGxpbmVhclxuXHRcdC8vIHRyYW5zZm9ybSBiZXR3ZWVuIHRoZSB0d28sIGFsbG93aW5nIHRoZSBzY3JvbGxiYXIgdG8gYmUgbGluZWFyXG5cdFx0aWYgKCBoZWlnaHRzLnZpcnR1YWwgPT09IGhlaWdodHMuc2Nyb2xsICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBJbiB0aGUgZmlyc3QgMTBrIHBpeGVscyBhbmQgdGhlIGxhc3QgMTBrIHBpeGVscywgd2Ugd2FudCB0aGUgc2Nyb2xsaW5nXG5cdFx0Ly8gdG8gYmUgbGluZWFyLiBBZnRlciB0aGF0IGl0IGNhbiBiZSBub24tbGluZWFyLiBJdCB3b3VsZCBiZSB1bnVzdWFsIGZvclxuXHRcdC8vIGFueW9uZSB0byBtb3VzZSB3aGVlbCB0aHJvdWdoIHRoYXQgbXVjaC5cblx0XHRpZiAoIHZhbCA8IG1hZ2ljICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRpciA9PT0gJ3ZpcnR1YWxUb1BoeXNpY2FsJyAmJiB2YWwgPj0gaGVpZ2h0cy52aXJ0dWFsIC0gbWFnaWMgKSB7XG5cdFx0XHRkaWZmID0gaGVpZ2h0cy52aXJ0dWFsIC0gdmFsO1xuXHRcdFx0cmV0dXJuIGhlaWdodHMuc2Nyb2xsIC0gZGlmZjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRpciA9PT0gJ3BoeXNpY2FsVG9WaXJ0dWFsJyAmJiB2YWwgPj0gaGVpZ2h0cy5zY3JvbGwgLSBtYWdpYyApIHtcblx0XHRcdGRpZmYgPSBoZWlnaHRzLnNjcm9sbCAtIHZhbDtcblx0XHRcdHJldHVybiBoZWlnaHRzLnZpcnR1YWwgLSBkaWZmO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgd2Ugd2FudCBhIG5vbi1saW5lYXIgc2Nyb2xsYmFyIHRvIHRha2UgYWNjb3VudCBvZiB0aGVcblx0XHQvLyByZWRyYXdpbmcgcmVnaW9ucyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgdGFibGUsIG90aGVyd2lzZSB0aGVzZVxuXHRcdC8vIGNhbiBzdHV0dGVyIGJhZGx5IC0gb24gbGFyZ2UgdGFibGVzIDMwcHggKGZvciBleGFtcGxlKSBzY3JvbGwgbWlnaHRcblx0XHQvLyBiZSBodW5kcmVkcyBvZiByb3dzLCBzbyB0aGUgdGFibGUgd291bGQgYmUgcmVkcmF3aW5nIGV2ZXJ5IGZldyBweCBhdFxuXHRcdC8vIHRoZSBzdGFydCBhbmQgZW5kLiBVc2UgYSBzaW1wbGUgbGluZWFyIGVxLiB0byBzdG9wIHRoaXMsIGVmZmVjdGl2ZWx5XG5cdFx0Ly8gY2F1c2luZyBhIGtpbmsgaW4gdGhlIHNjcm9sbGluZyByYXRpby4gSXQgZG9lcyBtZWFuIHRoZSBzY3JvbGxiYXIgaXNcblx0XHQvLyBub24tbGluZWFyLCBidXQgd2l0aCBzdWNoIG1hc3NpdmUgZGF0YSBzZXRzLCB0aGUgc2Nyb2xsYmFyIGlzIGdvaW5nXG5cdFx0Ly8gdG8gYmUgYSBiZXN0IGd1ZXNzIGFueXdheVxuXHRcdHZhciBtID0gKGhlaWdodHMudmlydHVhbCAtIG1hZ2ljIC0gbWFnaWMpIC8gKGhlaWdodHMuc2Nyb2xsIC0gbWFnaWMgLSBtYWdpYyk7XG5cdFx0dmFyIGMgPSBtYWdpYyAtIChtKm1hZ2ljKTtcblxuXHRcdHJldHVybiBkaXIgPT09ICd2aXJ0dWFsVG9QaHlzaWNhbCcgP1xuXHRcdFx0KHZhbC1jKSAvIG0gOlxuXHRcdFx0KG0qdmFsKSArIGM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBhbnkgaW5mb3JtYXRpb24gZWxlbWVudHMgdGhhdCBhcmUgY29udHJvbGxlZCBieSB0aGUgRGF0YVRhYmxlIGJhc2VkIG9uIHRoZSBzY3JvbGxpbmdcblx0ICogdmlld3BvcnQgYW5kIHdoYXQgcm93cyBhcmUgdmlzaWJsZSBpbiBpdC4gVGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgYWN0cyBpbiB0aGUgc2FtZSB3YXkgYXNcblx0ICogX2ZuVXBkYXRlSW5mbyBpbiBEYXRhVGFibGVzLCBhbmQgZWZmZWN0aXZlbHkgcmVwbGFjZXMgdGhhdCBmdW5jdGlvbi5cblx0ICogIEByZXR1cm5zIHt2b2lkfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9pbmZvOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0aWYgKCAhdGhpcy5zLmR0Lm9GZWF0dXJlcy5iSW5mbyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhclxuXHRcdFx0ZHQgPSB0aGlzLnMuZHQsXG5cdFx0XHRsYW5ndWFnZSA9IGR0Lm9MYW5ndWFnZSxcblx0XHRcdGlTY3JvbGxUb3AgPSB0aGlzLmRvbS5zY3JvbGxlci5zY3JvbGxUb3AsXG5cdFx0XHRpU3RhcnQgPSBNYXRoLmZsb29yKCB0aGlzLnBpeGVsc1RvUm93KGlTY3JvbGxUb3AsIGZhbHNlLCB0aGlzLnMuYW5pKSsxICksXG5cdFx0XHRpTWF4ID0gZHQuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcdGlUb3RhbCA9IGR0LmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGlQb3NzaWJsZUVuZCA9IE1hdGguY2VpbCggdGhpcy5waXhlbHNUb1JvdyhpU2Nyb2xsVG9wK3RoaXMucy5oZWlnaHRzLnZpZXdwb3J0LCBmYWxzZSwgdGhpcy5zLmFuaSkgKSxcblx0XHRcdGlFbmQgPSBpVG90YWwgPCBpUG9zc2libGVFbmQgPyBpVG90YWwgOiBpUG9zc2libGVFbmQsXG5cdFx0XHRzU3RhcnQgPSBkdC5mbkZvcm1hdE51bWJlciggaVN0YXJ0ICksXG5cdFx0XHRzRW5kID0gZHQuZm5Gb3JtYXROdW1iZXIoIGlFbmQgKSxcblx0XHRcdHNNYXggPSBkdC5mbkZvcm1hdE51bWJlciggaU1heCApLFxuXHRcdFx0c1RvdGFsID0gZHQuZm5Gb3JtYXROdW1iZXIoIGlUb3RhbCApLFxuXHRcdFx0c091dDtcblxuXHRcdGlmICggZHQuZm5SZWNvcmRzRGlzcGxheSgpID09PSAwICYmXG5cdFx0XHQgICBkdC5mblJlY29yZHNEaXNwbGF5KCkgPT0gZHQuZm5SZWNvcmRzVG90YWwoKSApXG5cdFx0e1xuXHRcdFx0LyogRW1wdHkgcmVjb3JkIHNldCAqL1xuXHRcdFx0c091dCA9IGxhbmd1YWdlLnNJbmZvRW1wdHkrIGxhbmd1YWdlLnNJbmZvUG9zdEZpeDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGR0LmZuUmVjb3Jkc0Rpc3BsYXkoKSA9PT0gMCApXG5cdFx0e1xuXHRcdFx0LyogRW1wdHkgcmVjb3JkIHNldCBhZnRlciBmaWx0ZXJpbmcgKi9cblx0XHRcdHNPdXQgPSBsYW5ndWFnZS5zSW5mb0VtcHR5ICsnICcrXG5cdFx0XHRcdGxhbmd1YWdlLnNJbmZvRmlsdGVyZWQucmVwbGFjZSgnX01BWF8nLCBzTWF4KStcblx0XHRcdFx0XHRsYW5ndWFnZS5zSW5mb1Bvc3RGaXg7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBkdC5mblJlY29yZHNEaXNwbGF5KCkgPT0gZHQuZm5SZWNvcmRzVG90YWwoKSApXG5cdFx0e1xuXHRcdFx0LyogTm9ybWFsIHJlY29yZCBzZXQgKi9cblx0XHRcdHNPdXQgPSBsYW5ndWFnZS5zSW5mby5cblx0XHRcdFx0XHRyZXBsYWNlKCdfU1RBUlRfJywgc1N0YXJ0KS5cblx0XHRcdFx0XHRyZXBsYWNlKCdfRU5EXycsICAgc0VuZCkuXG5cdFx0XHRcdFx0cmVwbGFjZSgnX01BWF8nLCAgIHNNYXgpLlxuXHRcdFx0XHRcdHJlcGxhY2UoJ19UT1RBTF8nLCBzVG90YWwpK1xuXHRcdFx0XHRsYW5ndWFnZS5zSW5mb1Bvc3RGaXg7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBSZWNvcmQgc2V0IGFmdGVyIGZpbHRlcmluZyAqL1xuXHRcdFx0c091dCA9IGxhbmd1YWdlLnNJbmZvLlxuXHRcdFx0XHRcdHJlcGxhY2UoJ19TVEFSVF8nLCBzU3RhcnQpLlxuXHRcdFx0XHRcdHJlcGxhY2UoJ19FTkRfJywgICBzRW5kKS5cblx0XHRcdFx0XHRyZXBsYWNlKCdfTUFYXycsICAgc01heCkuXG5cdFx0XHRcdFx0cmVwbGFjZSgnX1RPVEFMXycsIHNUb3RhbCkgKycgJytcblx0XHRcdFx0bGFuZ3VhZ2Uuc0luZm9GaWx0ZXJlZC5yZXBsYWNlKFxuXHRcdFx0XHRcdCdfTUFYXycsXG5cdFx0XHRcdFx0ZHQuZm5Gb3JtYXROdW1iZXIoZHQuZm5SZWNvcmRzVG90YWwoKSlcblx0XHRcdFx0KStcblx0XHRcdFx0bGFuZ3VhZ2Uuc0luZm9Qb3N0Rml4O1xuXHRcdH1cblxuXHRcdHZhciBjYWxsYmFjayA9IGxhbmd1YWdlLmZuSW5mb0NhbGxiYWNrO1xuXHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRzT3V0ID0gY2FsbGJhY2suY2FsbCggZHQub0luc3RhbmNlLFxuXHRcdFx0XHRkdCwgaVN0YXJ0LCBpRW5kLCBpTWF4LCBpVG90YWwsIHNPdXRcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIG4gPSBkdC5hYW5GZWF0dXJlcy5pO1xuXHRcdGlmICggdHlwZW9mIG4gIT0gJ3VuZGVmaW5lZCcgKVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49bi5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHQkKG5baV0pLmh0bWwoIHNPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEVCBkb2Vzbid0IGFjdHVhbGx5ICh5ZXQpIHRyaWdnZXIgdGhpcyBldmVudCwgYnV0IGl0IHdpbGwgaW4gZnV0dXJlXG5cdFx0JChkdC5uVGFibGUpLnRyaWdnZXJIYW5kbGVyKCAnaW5mby5kdCcgKTtcblx0fSxcblxuXHQvKipcblx0ICogUGFyc2UgQ1NTIGhlaWdodCBwcm9wZXJ0eSBzdHJpbmcgYXMgbnVtYmVyXG5cdCAqXG5cdCAqIEFuIGF0dGVtcHQgaXMgbWFkZSB0byBwYXJzZSB0aGUgc3RyaW5nIGFzIGEgbnVtYmVyLiBDdXJyZW50bHkgc3VwcG9ydGVkIHVuaXRzIGFyZSAncHgnLFxuXHQgKiAndmgnLCBhbmQgJ3JlbScuICdlbScgaXMgcGFydGlhbGx5IHN1cHBvcnRlZDsgaXQgd29ya3MgYXMgbG9uZyBhcyB0aGUgcGFyZW50IGVsZW1lbnQnc1xuXHQgKiBmb250IHNpemUgbWF0Y2hlcyB0aGUgYm9keSBlbGVtZW50LiBaZXJvIGlzIHJldHVybmVkIGZvciB1bnJlY29nbml6ZWQgc3RyaW5ncy5cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBjc3NIZWlnaHQgQ1NTIGhlaWdodCBwcm9wZXJ0eSBzdHJpbmdcblx0ICogIEByZXR1cm5zIHtudW1iZXJ9IGhlaWdodFxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9wYXJzZUhlaWdodDogZnVuY3Rpb24oY3NzSGVpZ2h0KSB7XG5cdFx0dmFyIGhlaWdodDtcblx0XHR2YXIgbWF0Y2hlcyA9IC9eKFsrLV0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKSkocHh8ZW18cmVtfHZoKSQvLmV4ZWMoY3NzSGVpZ2h0KTtcblxuXHRcdGlmIChtYXRjaGVzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuXHRcdHZhciB1bml0ID0gbWF0Y2hlc1syXTtcblxuXHRcdGlmICggdW5pdCA9PT0gJ3B4JyApIHtcblx0XHRcdGhlaWdodCA9IHZhbHVlO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdW5pdCA9PT0gJ3ZoJyApIHtcblx0XHRcdGhlaWdodCA9ICggdmFsdWUgLyAxMDAgKSAqICQod2luZG93KS5oZWlnaHQoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHVuaXQgPT09ICdyZW0nICkge1xuXHRcdFx0aGVpZ2h0ID0gdmFsdWUgKiBwYXJzZUZsb2F0KCQoJzpyb290JykuY3NzKCdmb250LXNpemUnKSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB1bml0ID09PSAnZW0nICkge1xuXHRcdFx0aGVpZ2h0ID0gdmFsdWUgKiBwYXJzZUZsb2F0KCQoJ2JvZHknKS5jc3MoJ2ZvbnQtc2l6ZScpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGVpZ2h0ID9cblx0XHRcdGhlaWdodCA6XG5cdFx0XHQwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTY3JvbGxpbmcgZnVuY3Rpb24gLSBmaXJlZCB3aGVuZXZlciB0aGUgc2Nyb2xsaW5nIHBvc2l0aW9uIGlzIGNoYW5nZWQuXG5cdCAqIFRoaXMgbWV0aG9kIG5lZWRzIHRvIHVzZSB0aGUgc3RvcmVkIHZhbHVlcyB0byBzZWUgaWYgdGhlIHRhYmxlIHNob3VsZCBiZVxuXHQgKiByZWRyYXduIGFzIHdlIGFyZSBtb3ZpbmcgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzXG5cdCAqIGN1cnJlbnRseSBkcmF3biBvciBub3QuIElmIG5lZWRlZCwgdGhlbiBpdCB3aWxsIHJlZHJhdyB0aGUgdGFibGUgYmFzZWQgb25cblx0ICogdGhlIG5ldyBwb3NpdGlvbi5cblx0ICogIEByZXR1cm5zIHt2b2lkfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9zY3JvbGw6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXJcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0aGVpZ2h0cyA9IHRoaXMucy5oZWlnaHRzLFxuXHRcdFx0aVNjcm9sbFRvcCA9IHRoaXMuZG9tLnNjcm9sbGVyLnNjcm9sbFRvcCxcblx0XHRcdGlUb3BSb3c7XG5cblx0XHRpZiAoIHRoaXMucy5za2lwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5zLmluZ25vcmVTY3JvbGwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBpU2Nyb2xsVG9wID09PSB0aGlzLnMubGFzdFNjcm9sbFRvcCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBJZiB0aGUgdGFibGUgaGFzIGJlZW4gc29ydGVkIG9yIGZpbHRlcmVkLCB0aGVuIHdlIHVzZSB0aGUgcmVkcmF3IHRoYXRcblx0XHQgKiBEYXRhVGFibGVzIGFzIGRvbmUsIHJhdGhlciB0aGFuIHBlcmZvcm1pbmcgb3VyIG93blxuXHRcdCAqL1xuXHRcdGlmICggdGhpcy5zLmR0LmJGaWx0ZXJlZCB8fCB0aGlzLnMuZHQuYlNvcnRlZCApIHtcblx0XHRcdHRoaXMucy5sYXN0U2Nyb2xsVG9wID0gMDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBVcGRhdGUgdGhlIHRhYmxlJ3MgaW5mb3JtYXRpb24gZGlzcGxheSBmb3Igd2hhdCBpcyBub3cgaW4gdGhlIHZpZXdwb3J0ICovXG5cdFx0dGhpcy5faW5mbygpO1xuXG5cdFx0LyogV2UgZG9uJ3Qgd2FudCB0byBzdGF0ZSBzYXZlIG9uIGV2ZXJ5IHNjcm9sbCBldmVudCAtIHRoYXQncyBoZWF2eVxuXHRcdCAqIGhhbmRlZCwgc28gdXNlIGEgdGltZW91dCB0byB1cGRhdGUgdGhlIHN0YXRlIHNhdmluZyBvbmx5IHdoZW4gdGhlXG5cdFx0ICogc2Nyb2xsaW5nIGhhcyBmaW5pc2hlZFxuXHRcdCAqL1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5zLnN0YXRlVE8gKTtcblx0XHR0aGlzLnMuc3RhdGVUTyA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQucy5kdEFwaS5zdGF0ZS5zYXZlKCk7XG5cdFx0fSwgMjUwICk7XG5cblx0XHR0aGlzLnMuc2Nyb2xsVHlwZSA9IE1hdGguYWJzKGlTY3JvbGxUb3AgLSB0aGlzLnMubGFzdFNjcm9sbFRvcCkgPiBoZWlnaHRzLnZpZXdwb3J0ID9cblx0XHRcdCdqdW1wJyA6XG5cdFx0XHQnY29udCc7XG5cblx0XHR0aGlzLnMudG9wUm93RmxvYXQgPSB0aGlzLnMuc2Nyb2xsVHlwZSA9PT0gJ2NvbnQnID9cblx0XHRcdHRoaXMucGl4ZWxzVG9Sb3coIGlTY3JvbGxUb3AsIGZhbHNlLCBmYWxzZSApIDpcblx0XHRcdHRoaXMuX2RvbWFpbiggJ3BoeXNpY2FsVG9WaXJ0dWFsJywgaVNjcm9sbFRvcCApIC8gaGVpZ2h0cy5yb3c7XG5cblx0XHRpZiAoIHRoaXMucy50b3BSb3dGbG9hdCA8IDAgKSB7XG5cdFx0XHR0aGlzLnMudG9wUm93RmxvYXQgPSAwO1xuXHRcdH1cblxuXHRcdC8qIENoZWNrIGlmIHRoZSBzY3JvbGwgcG9pbnQgaXMgb3V0c2lkZSB0aGUgdHJpZ2dlciBib3VuZGFyeSB3aGljaCB3b3VsZCByZXF1aXJlZFxuXHRcdCAqIGEgRGF0YVRhYmxlcyByZWRyYXdcblx0XHQgKi9cblx0XHRpZiAoIHRoaXMucy5mb3JjZVJlcG9zaXRpb24gfHwgaVNjcm9sbFRvcCA8IHRoaXMucy5yZWRyYXdUb3AgfHwgaVNjcm9sbFRvcCA+IHRoaXMucy5yZWRyYXdCb3R0b20gKSB7XG5cdFx0XHR2YXIgcHJlUm93cyA9IE1hdGguY2VpbCggKCh0aGlzLnMuZGlzcGxheUJ1ZmZlci0xKS8yKSAqIHRoaXMucy52aWV3cG9ydFJvd3MgKTtcblxuXHRcdFx0aVRvcFJvdyA9IHBhcnNlSW50KHRoaXMucy50b3BSb3dGbG9hdCwgMTApIC0gcHJlUm93cztcblx0XHRcdHRoaXMucy5mb3JjZVJlcG9zaXRpb24gPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBpVG9wUm93IDw9IDAgKSB7XG5cdFx0XHRcdC8qIEF0IHRoZSBzdGFydCBvZiB0aGUgdGFibGUgKi9cblx0XHRcdFx0aVRvcFJvdyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaVRvcFJvdyArIHRoaXMucy5kdC5faURpc3BsYXlMZW5ndGggPiB0aGlzLnMuZHQuZm5SZWNvcmRzRGlzcGxheSgpICkge1xuXHRcdFx0XHQvKiBBdCB0aGUgZW5kIG9mIHRoZSB0YWJsZSAqL1xuXHRcdFx0XHRpVG9wUm93ID0gdGhpcy5zLmR0LmZuUmVjb3Jkc0Rpc3BsYXkoKSAtIHRoaXMucy5kdC5faURpc3BsYXlMZW5ndGg7XG5cdFx0XHRcdGlmICggaVRvcFJvdyA8IDAgKSB7XG5cdFx0XHRcdFx0aVRvcFJvdyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBpVG9wUm93ICUgMiAhPT0gMCApIHtcblx0XHRcdFx0Ly8gRm9yIHRoZSByb3ctc3RyaXBpbmcgY2xhc3NlcyAob2RkL2V2ZW4pIHdlIHdhbnQgb25seSB0byBzdGFydFxuXHRcdFx0XHQvLyBvbiBldmVucyBvdGhlcndpc2UgdGhlIHN0cmlwZXMgd2lsbCBjaGFuZ2UgYmV0d2VlbiBkcmF3cyBhbmRcblx0XHRcdFx0Ly8gbG9vayBydWJiaXNoXG5cdFx0XHRcdGlUb3BSb3crKztcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgY2FsY3VhdGVkIHZhbHVlLCBpbiBjYXNlIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIGJ1dCBzb1xuXHRcdFx0Ly8gdGhhdCB0aGUgZHJhdyBmdW5jdGlvbiB3aWxsIHN0aWxsIHVzZSBpdC5cblx0XHRcdHRoaXMucy50YXJnZXRUb3AgPSBpVG9wUm93O1xuXG5cdFx0XHRpZiAoIGlUb3BSb3cgIT0gdGhpcy5zLmR0Ll9pRGlzcGxheVN0YXJ0ICkge1xuXHRcdFx0XHQvKiBDYWNoZSB0aGUgbmV3IHRhYmxlIHBvc2l0aW9uIGZvciBxdWljayBsb29rdXBzICovXG5cdFx0XHRcdHRoaXMucy50YWJsZVRvcCA9ICQodGhpcy5zLmR0Lm5UYWJsZSkub2Zmc2V0KCkudG9wO1xuXHRcdFx0XHR0aGlzLnMudGFibGVCb3R0b20gPSAkKHRoaXMucy5kdC5uVGFibGUpLmhlaWdodCgpICsgdGhpcy5zLnRhYmxlVG9wO1xuXG5cdFx0XHRcdHZhciBkcmF3ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoYXQucy5kdC5faURpc3BsYXlTdGFydCA9IHRoYXQucy50YXJnZXRUb3A7XG5cdFx0XHRcdFx0dGhhdC5zLmR0Lm9BcGkuX2ZuRHJhdyggdGhhdC5zLmR0ICk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0LyogRG8gdGhlIERhdGFUYWJsZXMgcmVkcmF3IGJhc2VkIG9uIHRoZSBjYWxjdWxhdGVkIHN0YXJ0IHBvaW50IC0gbm90ZSB0aGF0IHdoZW5cblx0XHRcdFx0ICogdXNpbmcgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB3ZSBpbnRyb2R1Y2UgYSBzbWFsbCBkZWxheSB0byBub3QgRG9TIHRoZSBzZXJ2ZXIuLi5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggdGhpcy5zLmR0Lm9GZWF0dXJlcy5iU2VydmVyU2lkZSApIHtcblx0XHRcdFx0XHR0aGlzLnMuZm9yY2VSZXBvc2l0aW9uID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5zLmRyYXdUTyApO1xuXHRcdFx0XHRcdHRoaXMucy5kcmF3VE8gPSBzZXRUaW1lb3V0KCBkcmF3LCB0aGlzLnMuc2VydmVyV2FpdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGRyYXcoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGhpcy5kb20ubG9hZGVyICYmICEgdGhpcy5zLmxvYWRlclZpc2libGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5kb20ubG9hZGVyLmNzcyggJ2Rpc3BsYXknLCAnYmxvY2snICk7XG5cdFx0XHRcdFx0dGhpcy5zLmxvYWRlclZpc2libGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5zLnRvcFJvd0Zsb2F0ID0gdGhpcy5waXhlbHNUb1JvdyggaVNjcm9sbFRvcCwgZmFsc2UsIHRydWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLnMubGFzdFNjcm9sbFRvcCA9IGlTY3JvbGxUb3A7XG5cdFx0dGhpcy5zLnN0YXRlU2F2ZVRocm90dGxlKCk7XG5cblx0XHRpZiAoIHRoaXMucy5zY3JvbGxUeXBlID09PSAnanVtcCcgJiYgdGhpcy5zLm1vdXNlZG93biApIHtcblx0XHRcdHRoaXMucy5sYWJlbFZpc2libGUgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5zLmxhYmVsVmlzaWJsZSkge1xuXHRcdFx0dmFyIGxhYmVsRmFjdG9yID0gKGhlaWdodHMudmlld3BvcnQtaGVpZ2h0cy5sYWJlbEhlaWdodCAtIGhlaWdodHMueGJhcikgLyBoZWlnaHRzLnNjcm9sbDtcblxuXHRcdFx0dGhpcy5kb20ubGFiZWxcblx0XHRcdFx0Lmh0bWwoIHRoaXMucy5kdC5mbkZvcm1hdE51bWJlciggcGFyc2VJbnQoIHRoaXMucy50b3BSb3dGbG9hdCwgMTAgKSsxICkgKVxuXHRcdFx0XHQuY3NzKCAndG9wJywgaVNjcm9sbFRvcCArIChpU2Nyb2xsVG9wICogbGFiZWxGYWN0b3IpIClcblx0XHRcdFx0LmNzcyggJ2Rpc3BsYXknLCAnYmxvY2snICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGb3JjZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciB0byBoYXZlIGhlaWdodCBiZXlvbmQgdGhhdCBvZiBqdXN0IHRoZVxuXHQgKiB0YWJsZSB0aGF0IGhhcyBiZWVuIGRyYXduIHNvIHRoZSB1c2VyIGNhbiBzY3JvbGwgdGhlIHdob2xlIGRhdGEgc2V0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgdGhlIGNhbGN1bGF0ZWQgcmVxdWlyZWQgc2Nyb2xsaW5nIGhlaWdodCBleGNlZWRzIGEgbWF4aW11bVxuXHQgKiB2YWx1ZSAoMSBtaWxsaW9uIHBpeGVscyAtIGhhcmQtY29kZWQpIHRoZSBmb3JjaW5nIGVsZW1lbnQgd2lsbCBiZSBzZXRcblx0ICogb25seSB0byB0aGF0IG1heGltdW0gdmFsdWUgYW5kIHZpcnR1YWwgLyBwaHlzaWNhbCBkb21haW4gdHJhbnNmb3JtcyB3aWxsXG5cdCAqIGJlIHVzZWQgdG8gYWxsb3cgU2Nyb2xsZXIgdG8gZGlzcGxheSB0YWJsZXMgb2YgYW55IG51bWJlciBvZiByZWNvcmRzLlxuXHQgKiAgQHJldHVybnMge3ZvaWR9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0X3Njcm9sbEZvcmNlOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGhlaWdodHMgPSB0aGlzLnMuaGVpZ2h0cztcblx0XHR2YXIgbWF4ID0gMTAwMDAwMDtcblxuXHRcdGhlaWdodHMudmlydHVhbCA9IGhlaWdodHMucm93ICogdGhpcy5zLmR0LmZuUmVjb3Jkc0Rpc3BsYXkoKTtcblx0XHRoZWlnaHRzLnNjcm9sbCA9IGhlaWdodHMudmlydHVhbDtcblxuXHRcdGlmICggaGVpZ2h0cy5zY3JvbGwgPiBtYXggKSB7XG5cdFx0XHRoZWlnaHRzLnNjcm9sbCA9IG1heDtcblx0XHR9XG5cblx0XHQvLyBNaW5pbXVtIGhlaWdodCBzbyB0aGVyZSBpcyBhbHdheXMgYSByb3cgdmlzaWJsZSAodGhlICdubyByb3dzIGZvdW5kJ1xuXHRcdC8vIGlmIHJlZHVjZWQgdG8gemVybyBmaWx0ZXJpbmcpXG5cdFx0dGhpcy5kb20uZm9yY2Uuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0cy5zY3JvbGwgPiB0aGlzLnMuaGVpZ2h0cy5yb3cgP1xuXHRcdFx0aGVpZ2h0cy5zY3JvbGwrJ3B4JyA6XG5cdFx0XHR0aGlzLnMuaGVpZ2h0cy5yb3crJ3B4Jztcblx0fVxufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBTdGF0aWNzXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cblxuLyoqXG4gKiBTY3JvbGxlciBkZWZhdWx0IHNldHRpbmdzIGZvciBpbml0aWFsaXNhdGlvblxuICogIEBuYW1lc3BhY2VcbiAqICBAbmFtZSBTY3JvbGxlci5kZWZhdWx0c1xuICogIEBzdGF0aWNcbiAqL1xuU2Nyb2xsZXIuZGVmYXVsdHMgPSB7XG5cdC8qKlxuXHQgKiBTY3JvbGxlciB1c2VzIHRoZSBib3VuZGFyeSBzY2FsaW5nIGZhY3RvciB0byBkZWNpZGUgd2hlbiB0byByZWRyYXcgdGhlIHRhYmxlIC0gd2hpY2ggaXRcblx0ICogdHlwaWNhbGx5IGRvZXMgYmVmb3JlIHlvdSByZWFjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIGRhdGEgc2V0IChpbiBvcmRlciB0b1xuXHQgKiBhbGxvdyB0aGUgZGF0YSB0byBsb29rIGNvbnRpbnVvdXMgdG8gYSB1c2VyIHNjcm9sbGluZyB0aHJvdWdoIHRoZSBkYXRhKS4gSWYgZ2l2ZW4gYXMgMFxuXHQgKiB0aGVuIHRoZSB0YWJsZSB3aWxsIGJlIHJlZHJhd24gd2hlbmV2ZXIgdGhlIHZpZXdwb3J0IGlzIHNjcm9sbGVkLCB3aGlsZSAxIHdvdWxkIG5vdFxuXHQgKiByZWRyYXcgdGhlIHRhYmxlIHVudGlsIHRoZSBjdXJyZW50bHkgbG9hZGVkIGRhdGEgaGFzIGFsbCBiZWVuIHNob3duLiBZb3Ugd2lsbCB3YW50XG5cdCAqIHNvbWV0aGluZyBpbiB0aGUgbWlkZGxlIC0gdGhlIGRlZmF1bHQgZmFjdG9yIG9mIDAuNSBpcyB1c3VhbGx5IHN1aXRhYmxlLlxuXHQgKiAgQHR5cGUgICAgIGZsb2F0XG5cdCAqICBAZGVmYXVsdCAgMC41XG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRib3VuZGFyeVNjYWxlOiAwLjUsXG5cblx0LyoqXG5cdCAqIFRoZSBkaXNwbGF5IGJ1ZmZlciBpcyB3aGF0IFNjcm9sbGVyIHVzZXMgdG8gY2FsY3VsYXRlIGhvdyBtYW55IHJvd3MgaXQgc2hvdWxkIHByZS1mZXRjaFxuXHQgKiBmb3Igc2Nyb2xsaW5nLiBTY3JvbGxlciBhdXRvbWF0aWNhbGx5IGFkanVzdHMgRGF0YVRhYmxlcycgZGlzcGxheSBsZW5ndGggdG8gcHJlLWZldGNoXG5cdCAqIHJvd3MgdGhhdCB3aWxsIGJlIHNob3duIGluIFwibmVhciBzY3JvbGxpbmdcIiAoaS5lLiBqdXN0IGJleW9uZCB0aGUgY3VycmVudCBkaXNwbGF5IGFyZWEpLlxuXHQgKiBUaGUgdmFsdWUgaXMgYmFzZWQgdXBvbiB0aGUgbnVtYmVyIG9mIHJvd3MgdGhhdCBjYW4gYmUgZGlzcGxheWVkIGluIHRoZSB2aWV3cG9ydCAoaS5lLlxuXHQgKiBhIHZhbHVlIG9mIDEpLCBhbmQgd2lsbCBhcHBseSB0aGUgZGlzcGxheSByYW5nZSB0byByZWNvcmRzIGJlZm9yZSBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuXHQgKiBjdXJyZW50IHZpZXdwb3J0IC0gaS5lLiBhIGZhY3RvciBvZiAzIHdpbGwgYWxsb3cgU2Nyb2xsZXIgdG8gcHJlLWZldGNoIDEgdmlld3BvcnQncyB3b3J0aFxuXHQgKiBvZiByb3dzIGJlZm9yZSB0aGUgY3VycmVudCB2aWV3cG9ydCwgdGhlIGN1cnJlbnQgdmlld3BvcnQncyByb3dzIGFuZCAxIHZpZXdwb3J0J3Mgd29ydGhcblx0ICogb2Ygcm93cyBhZnRlciB0aGUgY3VycmVudCB2aWV3cG9ydC4gQWRqdXN0aW5nIHRoaXMgdmFsdWUgY2FuIGJlIHVzZWZ1bCBmb3IgZW5zdXJpbmdcblx0ICogc21vb3RoIHNjcm9sbGluZyBiYXNlZCBvbiB5b3VyIGRhdGEgc2V0LlxuXHQgKiAgQHR5cGUgICAgIGludFxuXHQgKiAgQGRlZmF1bHQgIDdcblx0ICogIEBzdGF0aWNcblx0ICovXG5cdGRpc3BsYXlCdWZmZXI6IDksXG5cblx0LyoqXG5cdCAqIFNob3cgKG9yIG5vdCkgdGhlIGxvYWRpbmcgZWxlbWVudCBpbiB0aGUgYmFja2dyb3VuZCBvZiB0aGUgdGFibGUuIE5vdGUgdGhhdCB5b3Ugc2hvdWxkXG5cdCAqIGluY2x1ZGUgdGhlIGRhdGFUYWJsZXMuc2Nyb2xsZXIuY3NzIGZpbGUgZm9yIHRoaXMgdG8gYmUgZGlzcGxheWVkIGNvcnJlY3RseS5cblx0ICogIEB0eXBlICAgICBib29sZWFuXG5cdCAqICBAZGVmYXVsdCAgZmFsc2Vcblx0ICogIEBzdGF0aWNcblx0ICovXG5cdGxvYWRpbmdJbmRpY2F0b3I6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBTY3JvbGxlciB3aWxsIGF0dGVtcHQgdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiByb3dzIGZvciBpdCdzIGludGVybmFsXG5cdCAqIGNhbGN1bGF0aW9ucy4gSG93ZXZlciB0aGUgaGVpZ2h0IHRoYXQgaXMgdXNlZCBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGlzIHBhcmFtZXRlci5cblx0ICogIEB0eXBlICAgICBpbnR8c3RyaW5nXG5cdCAqICBAZGVmYXVsdCAgYXV0b1xuXHQgKiAgQHN0YXRpY1xuXHQgKi9cblx0cm93SGVpZ2h0OiBcImF1dG9cIixcblxuXHQvKipcblx0ICogV2hlbiB1c2luZyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCBTY3JvbGxlciB3aWxsIHdhaXQgYSBzbWFsbCBhbW91bnQgb2YgdGltZSB0byBhbGxvd1xuXHQgKiB0aGUgc2Nyb2xsaW5nIHRvIGZpbmlzaCBiZWZvcmUgcmVxdWVzdGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBUaGlzIHByZXZlbnRzXG5cdCAqIHlvdSBmcm9tIERvU2luZyB5b3VyIG93biBzZXJ2ZXIhIFRoZSB3YWl0IHRpbWUgY2FuIGJlIGNvbmZpZ3VyZWQgYnkgdGhpcyBwYXJhbWV0ZXIuXG5cdCAqICBAdHlwZSAgICAgaW50XG5cdCAqICBAZGVmYXVsdCAgMjAwXG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRzZXJ2ZXJXYWl0OiAyMDBcbn07XG5cblNjcm9sbGVyLm9EZWZhdWx0cyA9IFNjcm9sbGVyLmRlZmF1bHRzO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBDb25zdGFudHNcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuLyoqXG4gKiBTY3JvbGxlciB2ZXJzaW9uXG4gKiAgQHR5cGUgICAgICBTdHJpbmdcbiAqICBAZGVmYXVsdCAgIFNlZSBjb2RlXG4gKiAgQG5hbWUgICAgICBTY3JvbGxlci52ZXJzaW9uXG4gKiAgQHN0YXRpY1xuICovXG5TY3JvbGxlci52ZXJzaW9uID0gXCIyLjAuNVwiO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBJbml0aWFsaXNhdGlvblxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG4vLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgZG9jdW1lbnQgd2hpY2ggbGlzdGVucyBmb3IgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvblxuLy8gZXZlbnRzIHNvIHdlIGNhbiBhdXRvbWF0aWNhbGx5IGluaXRpYWxpc2VcbiQoZG9jdW1lbnQpLm9uKCAncHJlSW5pdC5kdC5kdHNjcm9sbGVyJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzKSB7XG5cdGlmICggZS5uYW1lc3BhY2UgIT09ICdkdCcgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGluaXQgPSBzZXR0aW5ncy5vSW5pdC5zY3JvbGxlcjtcblx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbGVyO1xuXG5cdGlmICggaW5pdCB8fCBkZWZhdWx0cyApIHtcblx0XHR2YXIgb3B0cyA9ICQuZXh0ZW5kKCB7fSwgaW5pdCwgZGVmYXVsdHMgKTtcblxuXHRcdGlmICggaW5pdCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRuZXcgU2Nyb2xsZXIoIHNldHRpbmdzLCBvcHRzICApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIEF0dGFjaCBTY3JvbGxlciB0byBEYXRhVGFibGVzIHNvIGl0IGNhbiBiZSBhY2Nlc3NlZCBhcyBhbiAnZXh0cmEnXG4kLmZuLmRhdGFUYWJsZS5TY3JvbGxlciA9IFNjcm9sbGVyO1xuJC5mbi5EYXRhVGFibGUuU2Nyb2xsZXIgPSBTY3JvbGxlcjtcblxuXG4vLyBEYXRhVGFibGVzIDEuMTAgQVBJIG1ldGhvZCBhbGlhc2VzXG52YXIgQXBpID0gJC5mbi5kYXRhVGFibGUuQXBpO1xuXG5BcGkucmVnaXN0ZXIoICdzY3JvbGxlcigpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuLy8gVW5kb2N1bWVudGVkIGFuZCBkZXByZWNhdGVkIC0gaXMgaXQgYWN0dWFsbHkgdXNlZnVsIGF0IGFsbD9cbkFwaS5yZWdpc3RlciggJ3Njcm9sbGVyKCkucm93VG9QaXhlbHMoKScsIGZ1bmN0aW9uICggcm93SWR4LCBpbnRQYXJzZSwgdmlydHVhbCApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggJiYgY3R4WzBdLm9TY3JvbGxlciApIHtcblx0XHRyZXR1cm4gY3R4WzBdLm9TY3JvbGxlci5yb3dUb1BpeGVscyggcm93SWR4LCBpbnRQYXJzZSwgdmlydHVhbCApO1xuXHR9XG5cdC8vIHVuZGVmaW5lZFxufSApO1xuXG4vLyBVbmRvY3VtZW50ZWQgYW5kIGRlcHJlY2F0ZWQgLSBpcyBpdCBhY3R1YWxseSB1c2VmdWwgYXQgYWxsP1xuQXBpLnJlZ2lzdGVyKCAnc2Nyb2xsZXIoKS5waXhlbHNUb1JvdygpJywgZnVuY3Rpb24gKCBwaXhlbHMsIGludFBhcnNlLCB2aXJ0dWFsICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCAmJiBjdHhbMF0ub1Njcm9sbGVyICkge1xuXHRcdHJldHVybiBjdHhbMF0ub1Njcm9sbGVyLnBpeGVsc1RvUm93KCBwaXhlbHMsIGludFBhcnNlLCB2aXJ0dWFsICk7XG5cdH1cblx0Ly8gdW5kZWZpbmVkXG59ICk7XG5cbi8vIGBzY3JvbGxlcigpLnNjcm9sbFRvUm93KClgIGlzIHVuZG9jdW1lbnRlZCBhbmQgZGVwcmVjYXRlZC4gVXNlIGBzY3JvbGxlci50b1Bvc2l0aW9uKClcbkFwaS5yZWdpc3RlciggWydzY3JvbGxlcigpLnNjcm9sbFRvUm93KCknLCAnc2Nyb2xsZXIudG9Qb3NpdGlvbigpJ10sIGZ1bmN0aW9uICggaWR4LCBhbmkgKSB7XG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGlmICggY3R4Lm9TY3JvbGxlciApIHtcblx0XHRcdGN0eC5vU2Nyb2xsZXIuc2Nyb2xsVG9Sb3coIGlkeCwgYW5pICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbkFwaS5yZWdpc3RlciggJ3JvdygpLnNjcm9sbFRvKCknLCBmdW5jdGlvbiAoIGFuaSApIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIGN0eCwgcm93SWR4ICkge1xuXHRcdGlmICggY3R4Lm9TY3JvbGxlciApIHtcblx0XHRcdHZhciBkaXNwbGF5SWR4ID0gdGhhdFxuXHRcdFx0XHQucm93cyggeyBvcmRlcjogJ2FwcGxpZWQnLCBzZWFyY2g6ICdhcHBsaWVkJyB9IClcblx0XHRcdFx0LmluZGV4ZXMoKVxuXHRcdFx0XHQuaW5kZXhPZiggcm93SWR4ICk7XG5cblx0XHRcdGN0eC5vU2Nyb2xsZXIuc2Nyb2xsVG9Sb3coIGRpc3BsYXlJZHgsIGFuaSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5BcGkucmVnaXN0ZXIoICdzY3JvbGxlci5tZWFzdXJlKCknLCBmdW5jdGlvbiAoIHJlZHJhdyApIHtcblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0aWYgKCBjdHgub1Njcm9sbGVyICkge1xuXHRcdFx0Y3R4Lm9TY3JvbGxlci5tZWFzdXJlKCByZWRyYXcgKTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuQXBpLnJlZ2lzdGVyKCAnc2Nyb2xsZXIucGFnZSgpJywgZnVuY3Rpb24oKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoICYmIGN0eFswXS5vU2Nyb2xsZXIgKSB7XG5cdFx0cmV0dXJuIGN0eFswXS5vU2Nyb2xsZXIucGFnZUluZm8oKTtcblx0fVxuXHQvLyB1bmRlZmluZWRcbn0gKTtcblxucmV0dXJuIFNjcm9sbGVyO1xufSkpO1xuIiwiLyohIEJvb3RzdHJhcCA1IHVpIGludGVncmF0aW9uIGZvciBEYXRhVGFibGVzJyBTZWFyY2hCdWlsZGVyXG4gKiDCqTIwMTYgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0LWJzNScsICdkYXRhdGFibGVzLm5ldC1zZWFyY2hidWlsZGVyJ10sIGZ1bmN0aW9uICgkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBDb21tb25KU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICByb290ID0gd2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEkIHx8ICEkLmZuLmRhdGFUYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgICAgICAgICAgJCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJzNScpKHJvb3QsICQpLiQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISQuZm4uZGF0YVRhYmxlLnNlYXJjaEJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LXNlYXJjaGJ1aWxkZXInKShyb290LCAkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlclxuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XG4gICAgJC5leHRlbmQodHJ1ZSwgZGF0YVRhYmxlLlNlYXJjaEJ1aWxkZXIuY2xhc3Nlcywge1xuICAgICAgICBjbGVhckFsbDogJ2J0biBidG4tbGlnaHQgZHRzYi1jbGVhckFsbCdcbiAgICB9KTtcbiAgICAkLmV4dGVuZCh0cnVlLCBkYXRhVGFibGUuR3JvdXAuY2xhc3Nlcywge1xuICAgICAgICBhZGQ6ICdidG4gYnRuLWxpZ2h0IGR0c2ItYWRkJyxcbiAgICAgICAgY2xlYXJHcm91cDogJ2J0biBidG4tbGlnaHQgZHRzYi1jbGVhckdyb3VwJyxcbiAgICAgICAgbG9naWM6ICdidG4gYnRuLWxpZ2h0IGR0c2ItbG9naWMnXG4gICAgfSk7XG4gICAgJC5leHRlbmQodHJ1ZSwgZGF0YVRhYmxlLkNyaXRlcmlhLmNsYXNzZXMsIHtcbiAgICAgICAgY29uZGl0aW9uOiAnZm9ybS1zZWxlY3QgZHRzYi1jb25kaXRpb24nLFxuICAgICAgICBkYXRhOiAnZHRzYi1kYXRhIGZvcm0tc2VsZWN0JyxcbiAgICAgICAgXCJkZWxldGVcIjogJ2J0biBidG4tbGlnaHQgZHRzYi1kZWxldGUnLFxuICAgICAgICBpbnB1dDogJ2Zvcm0tY29udHJvbCBkdHNiLWlucHV0JyxcbiAgICAgICAgbGVmdDogJ2J0biBidG4tbGlnaHQgZHRzYi1sZWZ0JyxcbiAgICAgICAgcmlnaHQ6ICdidG4gYnRuLWxpZ2h0IGR0c2ItcmlnaHQnLFxuICAgICAgICBzZWxlY3Q6ICdmb3JtLXNlbGVjdCcsXG4gICAgICAgIHZhbHVlOiAnZHRzYi12YWx1ZSdcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YVRhYmxlLnNlYXJjaFBhbmVzO1xufSkpO1xuIiwiLyohIFNlYXJjaEJ1aWxkZXIgMS4yLjFcbiAqIMKpU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2UvbWl0XG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyICQkMjtcbiAgICB2YXIgZGF0YVRhYmxlJDI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgIHZhciBtb21lbnQgPSB3aW5kb3cubW9tZW50O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICB2YXIgbHV4b24gPSB3aW5kb3cubHV4b247XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgalF1ZXJ5IGZvciB1c2UgaW4gdGhlIGZpbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBqcSB0aGUgaW5zdGFuY2Ugb2YgalF1ZXJ5IHRvIGJlIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEpRdWVyeSQyKGpxKSB7XG4gICAgICAgICQkMiA9IGpxO1xuICAgICAgICBkYXRhVGFibGUkMiA9IGpxLmZuLmRhdGFUYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIENyaXRlcmlhIGNsYXNzIGlzIHVzZWQgd2l0aGluIFNlYXJjaEJ1aWxkZXIgdG8gcmVwcmVzZW50IGEgc2VhcmNoIGNyaXRlcmlhXG4gICAgICovXG4gICAgdmFyIENyaXRlcmlhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDcml0ZXJpYSh0YWJsZSwgb3B0cywgdG9wR3JvdXAsIGluZGV4LCBkZXB0aCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxuICAgICAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHsgZGVwdGggPSAxOyB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZXF1aXJlZCB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgaW5jbHVkZWRcbiAgICAgICAgICAgIGlmICghZGF0YVRhYmxlJDIgfHwgIWRhdGFUYWJsZSQyLnZlcnNpb25DaGVjayB8fCAhZGF0YVRhYmxlJDIudmVyc2lvbkNoZWNrKCcxLjEwLjAnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoUGFuZSByZXF1aXJlcyBEYXRhVGFibGVzIDEuMTAgb3IgbmV3ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9ICQkMi5leHRlbmQodHJ1ZSwge30sIENyaXRlcmlhLmNsYXNzZXMpO1xuICAgICAgICAgICAgLy8gR2V0IG9wdGlvbnMgZnJvbSB1c2VyIGFuZCBhbnkgZXh0cmEgY29uZGl0aW9ucy9jb2x1bW4gdHlwZXMgZGVmaW5lZCBieSBwbHVnLWluc1xuICAgICAgICAgICAgdGhpcy5jID0gJCQyLmV4dGVuZCh0cnVlLCB7fSwgQ3JpdGVyaWEuZGVmYXVsdHMsICQkMi5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaEJ1aWxkZXIsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGkxOG4gPSB0aGlzLmMuaTE4bjtcbiAgICAgICAgICAgIHRoaXMucyA9IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZGF0YUlkeDogLTEsXG4gICAgICAgICAgICAgICAgZGF0YVBvaW50czogW10sXG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgIGR0OiB0YWJsZSxcbiAgICAgICAgICAgICAgICBmaWxsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBvcmlnRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRvcEdyb3VwOiB0b3BHcm91cCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRvbSA9IHtcbiAgICAgICAgICAgICAgICBidXR0b25zOiAkJDIoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYnV0dG9uQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246ICQkMignPHNlbGVjdCBkaXNhYmxlZC8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5jb25kaXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZHJvcERvd24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuaXRhbGljKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYXV0b2NvbXBsZXRlJywgJ2hhY2tpbmcnKSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25UaXRsZTogJCQyKCc8b3B0aW9uIHZhbHVlPVwiXCIgZGlzYWJsZWQgc2VsZWN0ZWQgaGlkZGVuLz4nKVxuICAgICAgICAgICAgICAgICAgICAudGV4dCh0aGlzLnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb24nLCBpMThuLmNvbmRpdGlvbikpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogJCQyKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmNvbnRhaW5lciksXG4gICAgICAgICAgICAgICAgZGF0YTogJCQyKCc8c2VsZWN0Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZHJvcERvd24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuaXRhbGljKSxcbiAgICAgICAgICAgICAgICBkYXRhVGl0bGU6ICQkMignPG9wdGlvbiB2YWx1ZT1cIlwiIGRpc2FibGVkIHNlbGVjdGVkIGhpZGRlbi8+JylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5zLmR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuZGF0YScsIGkxOG4uZGF0YSkpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJCQyKCc8c2VsZWN0IGRpc2FibGVkLz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRyb3BEb3duKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnNlbGVjdCksXG4gICAgICAgICAgICAgICAgXCJkZWxldGVcIjogJCQyKCc8YnV0dG9uPiZ0aW1lczwvYnV0dG9uPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXNbXCJkZWxldGVcIl0pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCB0aGlzLnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci5kZWxldGVUaXRsZScsIGkxOG4uZGVsZXRlVGl0bGUpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKSxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgICAgICAgICAgICBsZWZ0OiAkJDIoJzxidXR0b24+XFw8PC9idXR0b24+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5sZWZ0KVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmJ1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RpdGxlJywgdGhpcy5zLmR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIubGVmdFRpdGxlJywgaTE4bi5sZWZ0VGl0bGUpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKSxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgICAgICAgICAgICByaWdodDogJCQyKCc8YnV0dG9uPlxcPjwvYnV0dG9uPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCB0aGlzLnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci5yaWdodFRpdGxlJywgaTE4bi5yaWdodFRpdGxlKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJyksXG4gICAgICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJCQyKCc8c2VsZWN0IGRpc2FibGVkLz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZHJvcERvd24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLml0YWxpYylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuc2VsZWN0KVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdmFsdWVUaXRsZTogJCQyKCc8b3B0aW9uIHZhbHVlPVwiLS12YWx1ZVRpdGxlLS1cIiBzZWxlY3RlZC8+JylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5zLmR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIudmFsdWUnLCBpMThuLnZhbHVlKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBJZiB0aGUgZ3JleXNjYWxlIG9wdGlvbiBpcyBzZWxlY3RlZCB0aGVuIGFkZCB0aGUgY2xhc3MgdG8gYWRkIHRoZSBncmV5IGNvbG91ciB0byBTZWFyY2hCdWlsZGVyXG4gICAgICAgICAgICBpZiAodGhpcy5jLmdyZXlzY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmRhdGEuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmdyZXlzY2FsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmRlZmF1bHRWYWx1ZS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZ3JleXNjYWxlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kb20udmFsdWU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhbC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZ3JleXNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3IgcmVzcG9uc2l2ZSBkZXNpZ24sIGFkanVzdCB0aGUgY3JpdGVyaWFzIHByb3BlcnRpZXMgb24gdGhlIGZvbGxvd2luZyBldmVudHNcbiAgICAgICAgICAgIHRoaXMucy5kdC5vbignZHJhdy5kdHNwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hZGp1c3RDcml0ZXJpYSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnMuZHQub24oJ2J1dHRvbnMtYWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hZGp1c3RDcml0ZXJpYSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkJDIod2luZG93KS5vbigncmVzaXplLmR0c3AnLCBkYXRhVGFibGUkMi51dGlsLnRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRqdXN0Q3JpdGVyaWEoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkQ3JpdGVyaWEoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoZSBsZWZ0IGJ1dHRvbiB0byB0aGUgY3JpdGVyaWFcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS51cGRhdGVBcnJvd3MgPSBmdW5jdGlvbiAoaGFzU2libGluZ3MsIHJlZHJhdykge1xuICAgICAgICAgICAgaWYgKGhhc1NpYmxpbmdzID09PSB2b2lkIDApIHsgaGFzU2libGluZ3MgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHJlZHJhdyA9PT0gdm9pZCAwKSB7IHJlZHJhdyA9IHRydWU7IH1cbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBjb250YWluZXIgYW5kIGFwcGVuZCBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuY2hpbGRyZW4oKS5kZXRhY2goKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5kb20uZGF0YSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuZG9tLmNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuZG9tLnZhbHVlWzBdKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBpbnNlcnRlZCBldmVudHMgZm9yIHRoZSB2YWx1ZSBlbGVtZW50cyBhcyB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuZG9tLnZhbHVlWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS52YWx1ZVswXS50cmlnZ2VyKCdkdHNiLWluc2VydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuZG9tLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZCh0aGlzLmRvbS52YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20udmFsdWVbaV0udHJpZ2dlcignZHRzYi1pbnNlcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvcCBsZXZlbCBjcml0ZXJpYSB0aGVuIGRvbid0IGxldCBpdCBtb3ZlIGxlZnRcbiAgICAgICAgICAgIGlmICh0aGlzLnMuZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYnV0dG9ucy5hcHBlbmQodGhpcy5kb20ubGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVwdGhMaW1pdCBvZiB0aGUgcXVlcnkgaGFzIGJlZW4gaGl0IHRoZW4gZG9uJ3QgYWRkIHRoZSByaWdodCBidXR0b25cbiAgICAgICAgICAgIGlmICgodGhpcy5jLmRlcHRoTGltaXQgPT09IGZhbHNlIHx8IHRoaXMucy5kZXB0aCA8IHRoaXMuYy5kZXB0aExpbWl0KSAmJiBoYXNTaWJsaW5ncykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJ1dHRvbnMuYXBwZW5kKHRoaXMuZG9tLnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJpZ2h0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb20uYnV0dG9ucy5hcHBlbmQodGhpcy5kb21bXCJkZWxldGVcIl0pO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZCh0aGlzLmRvbS5idXR0b25zKTtcbiAgICAgICAgICAgIGlmIChyZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAvLyBBIGRpZmZlcmVudCBjb21iaW5hdGlvbiBvZiBhcnJvd3MgYW5kIHNlbGVjdG9ycyBtYXkgbGVhZCB0byBhIG5lZWQgZm9yIHJlc3BvbnNpdmUgdG8gYmUgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0Q3JpdGVyaWEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3lzIHRoZSBjcml0ZXJpYSwgcmVtb3ZpbmcgbGlzdGVuZXJzIGFuZCBjb250YWluZXIgZnJvbSB0aGUgZG9tXG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFR1cm4gb2ZmIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5kb20uZGF0YS5vZmYoJy5kdHNiJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb24ub2ZmKCcuZHRzYicpO1xuICAgICAgICAgICAgdGhpcy5kb21bXCJkZWxldGVcIl0ub2ZmKCcuZHRzYicpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZG9tLnZhbHVlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFsLm9mZignLmR0c2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb250YWluZXIgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzZXMgaW4gdGhlIGRhdGEgZm9yIHRoZSByb3cgYW5kIGNvbXBhcmVzIGl0IGFnYWluc3QgdGhpcyBzaW5nbGUgY3JpdGVyaWFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvd0RhdGEgVGhlIGRhdGEgZm9yIHRoZSByb3cgdG8gYmUgY29tcGFyZWRcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhbiBXaGV0aGVyIHRoZSBjcml0ZXJpYSBoYXMgcGFzc2VkXG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHJvd0RhdGEsIHJvd0lkeCkge1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMucy5jb25kaXRpb25zW3RoaXMucy5jb25kaXRpb25dO1xuICAgICAgICAgICAgaWYgKHRoaXMucy5jb25kaXRpb24gIT09IHVuZGVmaW5lZCAmJiBjb25kaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSByb3dEYXRhW3RoaXMucy5kYXRhSWR4XTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIGluIHBsYWNlIGZvciBpZiBhIGN1c3RvbSBkZWNpbWFsIGNoYXJhY3RlciBpcyBpbiBwbGFjZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnMudHlwZS5pbmNsdWRlcygnbnVtJykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zRGVjaW1hbCAhPT0gJycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zVGhvdXNhbmRzICE9PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0UkQgPSBbcm93RGF0YVt0aGlzLnMuZGF0YUlkeF1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNEZWNpbWFsICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRSRCA9IHJvd0RhdGFbdGhpcy5zLmRhdGFJZHhdLnNwbGl0KHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zRGVjaW1hbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zVGhvdXNhbmRzICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdFJELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRSRFtpXSA9IHNwbGl0UkRbaV0ucmVwbGFjZSh0aGlzLnMuZHQuc2V0dGluZ3MoKVswXS5vTGFuZ3VhZ2Uuc1Rob3VzYW5kcywgJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBzcGxpdFJELmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgb3J0aG9nb25hbCBkYXRhIGlzIGluIHBsYWNlIHdlIG5lZWQgdG8gZ2V0IGl0J3MgdmFsdWVzIGZvciBzZWFyY2hpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jLm9ydGhvZ29uYWwuc2VhcmNoICE9PSAnZmlsdGVyJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnMuZHQuc2V0dGluZ3MoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gc2V0dGluZ3Mub0FwaS5fZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93SWR4LCB0aGlzLnMuZGF0YUlkeCwgdHlwZW9mIHRoaXMuYy5vcnRob2dvbmFsID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmMub3J0aG9nb25hbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmMub3J0aG9nb25hbC5zZWFyY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSB3b3JraW5nIHdpdGggYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IFtmaWx0ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZmlsdGVyXzEgPSBmaWx0ZXI7IF9pIDwgZmlsdGVyXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdCA9IGZpbHRlcl8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdCA9IGZpbHQucmVwbGFjZSgvW1xcclxcblxcdTIwMjhdL2csICcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlci5yZXBsYWNlKC9bXFxyXFxuXFx1MjAyOF0vZywgJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucy50eXBlLmluY2x1ZGVzKCdodG1sJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdCBpZGVhbCwgYnV0IGpxdWVyaWVzIC52YWwoKSByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBldmVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgc2V0IGlzIG51bGwsIHNvIHdlIHNoYWxsIGFzc3VtZSB0aGUgdHdvIGFyZSBlcXVhbFxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24uc2VhcmNoKGZpbHRlciwgdGhpcy5zLnZhbHVlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRldGFpbHMgcmVxdWlyZWQgdG8gcmVidWlsZCB0aGUgY3JpdGVyaWFcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5nZXREZXRhaWxzID0gZnVuY3Rpb24gKGRlRm9ybWF0RGF0ZXMpIHtcbiAgICAgICAgICAgIGlmIChkZUZvcm1hdERhdGVzID09PSB2b2lkIDApIHsgZGVGb3JtYXREYXRlcyA9IGZhbHNlOyB9XG4gICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIGluIHBsYWNlIGZvciBpZiBhIGN1c3RvbSBkZWNpbWFsIGNoYXJhY3RlciBpcyBpbiBwbGFjZVxuICAgICAgICAgICAgaWYgKHRoaXMucy50eXBlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zLnR5cGUuaW5jbHVkZXMoJ251bScpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zRGVjaW1hbCAhPT0gJycgfHwgdGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNUaG91c2FuZHMgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdFJEID0gW3RoaXMucy52YWx1ZVtpXS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zRGVjaW1hbCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0UkQgPSB0aGlzLnMudmFsdWVbaV0uc3BsaXQodGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNEZWNpbWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNUaG91c2FuZHMgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwbGl0UkQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdFJEW2pdID0gc3BsaXRSRFtqXS5yZXBsYWNlKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zVGhvdXNhbmRzLCAnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy52YWx1ZVtpXSA9IHNwbGl0UkQuam9pbignLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucy50eXBlICE9PSBudWxsICYmIGRlRm9ybWF0RGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zLnR5cGUuaW5jbHVkZXMoJ2RhdGUnKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnMudHlwZS5pbmNsdWRlcygndGltZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zLnZhbHVlW2ldLm1hdGNoKC9eXFxkezR9LShbMF1cXGR8MVswLTJdKS0oWzAtMl1cXGR8M1swMV0pJC9nKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy52YWx1ZVtpXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucy50eXBlLmluY2x1ZGVzKCdtb21lbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnZhbHVlW2ldID0gbW9tZW50KHRoaXMucy52YWx1ZVtpXSwgdGhpcy5zLmRhdGVGb3JtYXQpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zLnR5cGUuaW5jbHVkZXMoJ2x1eG9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy52YWx1ZVtpXSA9IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQodGhpcy5zLnZhbHVlW2ldLCB0aGlzLnMuZGF0ZUZvcm1hdCkudG9JU08oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnMudHlwZS5pbmNsdWRlcygnbnVtJykgJiYgdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMudmFsdWVbaV0gPSB0aGlzLnMudmFsdWVbaV0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHRoaXMucy5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5zLmRhdGEsXG4gICAgICAgICAgICAgICAgb3JpZ0RhdGE6IHRoaXMucy5vcmlnRGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnMudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zLnZhbHVlLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50b1N0cmluZygpOyB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHRlciBmb3IgdGhlIG5vZGUgZm9yIHRoZSBjb250YWluZXIgb2YgdGhlIGNyaXRlcmlhXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEpRdWVyeTxIVE1MRWxlbWVudD4gdGhlIG5vZGUgZm9yIHRoZSBjb250YWluZXJcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvcHVsYXRlcyB0aGUgY3JpdGVyaWEgZGF0YSwgY29uZGl0aW9uIGFuZCB2YWx1ZShzKSBhcyBmYXIgYXMgaGFzIGJlZW4gc2VsZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlRGF0YSgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbHVtbiBpbmRleCBoYXMgYmVlbiBmb3VuZCBhdHRlbXB0IHRvIHNlbGVjdCBhIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMucy5kYXRhSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbmRpdHRpb24gaGFzIGJlZW4gZm91bmQgYXR0ZW1wdCB0byBzZWxlY3QgdGhlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnMuY29uZGl0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdWxhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYnVpbGRzIHRoZSBjcml0ZXJpYSBiYXNlZCB1cG9uIHRoZSBkZXRhaWxzIHBhc3NlZCBpblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVkQ3JpdGVyaWEgdGhlIGRldGFpbHMgcmVxdWlyZWQgdG8gcmVidWlsZCB0aGUgY3JpdGVyaWFcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5yZWJ1aWxkID0gZnVuY3Rpb24gKGxvYWRlZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgZGF0YSBleGlzdHMsIGlmIHNvIHNlbGVjdCBpdFxuICAgICAgICAgICAgdmFyIGZvdW5kRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGRhdGFJZHg7XG4gICAgICAgICAgICB0aGlzLl9wb3B1bGF0ZURhdGEoKTtcbiAgICAgICAgICAgIC8vIElmIGEgZGF0YSBzZWxlY3Rpb24gaGFzIHByZXZpb3VzbHkgYmVlbiBtYWRlIGF0dGVtcHQgdG8gZmluZCBhbmQgc2VsZWN0IGl0XG4gICAgICAgICAgICBpZiAobG9hZGVkQ3JpdGVyaWEuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0YWxpY18xID0gdGhpcy5jbGFzc2VzLml0YWxpYztcbiAgICAgICAgICAgICAgICB2YXIgZGF0YV8xID0gdGhpcy5kb20uZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5kYXRhLmNoaWxkcmVuKCdvcHRpb24nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQkMih0aGlzKS50ZXh0KCkgPT09IGxvYWRlZENyaXRlcmlhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQkMih0aGlzKS5wcm9wKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV8xLnJlbW92ZUNsYXNzKGl0YWxpY18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSWR4ID0gJCQyKHRoaXMpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCQyKHRoaXMpLnJlbW92ZVByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGhhcyBiZWVuIGZvdW5kIGFuZCBzZWxlY3RlZCB0aGVuIHRoZSBjb25kaXRpb24gY2FuIGJlIHBvcHVsYXRlZCBhbmQgc2VhcmNoZWRcbiAgICAgICAgICAgIGlmIChmb3VuZERhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMuZGF0YSA9IGxvYWRlZENyaXRlcmlhLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5zLm9yaWdEYXRhID0gbG9hZGVkQ3JpdGVyaWEub3JpZ0RhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5zLmRhdGFJZHggPSBkYXRhSWR4O1xuICAgICAgICAgICAgICAgIHRoaXMuYy5vcnRob2dvbmFsID0gdGhpcy5fZ2V0T3B0aW9ucygpLm9ydGhvZ29uYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZGF0YVRpdGxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uVGl0bGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgY29uZGl0aW9uIGV4aXN0cywgaWYgc28gc2VsZWN0IGl0XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmRvbS5jb25kaXRpb24uY2hpbGRyZW4oJ29wdGlvbicpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLWZvci1vZlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gJCQyKG9wdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkQ3JpdGVyaWEuY29uZGl0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi52YWwoKSA9PT0gbG9hZGVkQ3JpdGVyaWEuY29uZGl0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbG9hZGVkQ3JpdGVyaWEuY29uZGl0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSBvcHRpb24udmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24ucmVtb3ZlUHJvcCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb25kaXRpb24gaGFzIGJlZW4gZm91bmQgYW5kIHNlbGVjdGVkIHRoZW4gdGhlIHZhbHVlIGNhbiBiZSBwb3B1bGF0ZWQgYW5kIHNlYXJjaGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucy5jb25kaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb25UaXRsZS5yZW1vdmVQcm9wKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb25UaXRsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gJCQyKG9wdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi52YWwoKSAhPT0gdGhpcy5zLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5yZW1vdmVQcm9wKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlVmFsdWUobG9hZGVkQ3JpdGVyaWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uVGl0bGUucHJlcGVuZFRvKHRoaXMuZG9tLmNvbmRpdGlvbikucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBjcml0ZXJpYVxuICAgICAgICAgKi9cbiAgICAgICAgQ3JpdGVyaWEucHJvdG90eXBlLnNldExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRvbS5kYXRhXG4gICAgICAgICAgICAgICAgLnVuYmluZCgnY2hhbmdlJylcbiAgICAgICAgICAgICAgICAub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uZGF0YVRpdGxlLnJlbW92ZVByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBnbyBvdmVyIGV2ZXJ5IG9wdGlvbiB0byBpZGVudGlmeSB0aGUgY29ycmVjdCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLmRvbS5kYXRhLmNoaWxkcmVuKCdvcHRpb24uJyArIF90aGlzLmNsYXNzZXMub3B0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9ICQkMihvcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi52YWwoKSA9PT0gX3RoaXMuZG9tLmRhdGEudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5kYXRhLnJlbW92ZUNsYXNzKF90aGlzLmNsYXNzZXMuaXRhbGljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5wcm9wKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kYXRhSWR4ID0gK29wdGlvbi52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZGF0YSA9IG9wdGlvbi50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLm9yaWdEYXRhID0gb3B0aW9uLnByb3AoJ29yaWdEYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jLm9ydGhvZ29uYWwgPSBfdGhpcy5fZ2V0T3B0aW9ucygpLm9ydGhvZ29uYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBkYXRhIGlzIGNoYW5nZWQsIHRoZSB2YWx1ZXMgaW4gY29uZGl0aW9uIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgbWF5IGFsc28gY2hhbmdlIHNvIG5lZWQgdG8gcmVuZXcgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NsZWFyQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYXJWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3BvcHVsYXRlQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNyaXRlcmlhIHdhcyBwcmV2aW91c2x5IGFjdGl2ZSBpbiB0aGUgc2VhcmNoIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBzZWFyY2ggYW5kIHRyaWdnZXIgYSBuZXcgc2VhcmNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucy5maWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmZpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5zdGF0ZS5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24ucmVtb3ZlUHJvcCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgLnVuYmluZCgnY2hhbmdlJylcbiAgICAgICAgICAgICAgICAub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY29uZGl0aW9uVGl0bGUucmVtb3ZlUHJvcCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGdvIG92ZXIgZXZlcnkgb3B0aW9uIHRvIGlkZW50aWZ5IHRoZSBjb3JyZWN0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMuZG9tLmNvbmRpdGlvbi5jaGlsZHJlbignb3B0aW9uLicgKyBfdGhpcy5jbGFzc2VzLm9wdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSAkJDIob3B0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24udmFsKCkgPT09IF90aGlzLmRvbS5jb25kaXRpb24udmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jb25kaXRpb24ucmVtb3ZlQ2xhc3MoX3RoaXMuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZERpc3AgPSBvcHRpb24udmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBjb25kaXRpb24gdGhhdCBoYXMgYmVlbiBzZWxlY3RlZCBhbmQgc3RvcmUgaXQgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKF90aGlzLnMuY29uZGl0aW9ucyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmQgPT09IGNvbmREaXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuY29uZGl0aW9uID0gY29uZERpc3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbmRpdGlvbiBpcyBjaGFuZ2VkLCB0aGUgdmFsdWUgc2VsZWN0b3IgbWF5IHN3aXRjaCBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHNlbGVjdCBlbGVtZW50IGFuZCBhbiBpbnB1dCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYXJWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3BvcHVsYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBfdGhpcy5kb20udmFsdWU7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNyaXRlcmlhIHdhcyBwcmV2aW91c2x5IGFjdGl2ZSBpbiB0aGUgc2VhcmNoIHRoZW4gcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgc2VhcmNoIGFuZCB0cmlnZ2VyIGEgbmV3IHNlYXJjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zLmZpbGxlZCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiBfdGhpcy5kb20uY29udGFpbmVyLmhhcyh2YWxbMF0pLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmZpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmR0LmRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRvbS52YWx1ZS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20udmFsdWUubGVuZ3RoID09PSAxICYmIF90aGlzLmRvbS52YWx1ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24ucmVtb3ZlUHJvcCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRqdXN0cyB0aGUgY3JpdGVyaWEgdG8gbWFrZSBTZWFyY2hCdWlsZGVyIHJlc3BvbnNpdmVcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5fYWRqdXN0Q3JpdGVyaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGNyaXRlcmlhIGlzIG5vdCBwcmVzZW50IHRoZW4gZG9uJ3QgYm90aGVyIGFkanVzdGluZyBpdFxuICAgICAgICAgICAgaWYgKCQkMihkb2N1bWVudCkuaGFzKHRoaXMuZG9tLmNvbnRhaW5lcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbFJpZ2h0O1xuICAgICAgICAgICAgdmFyIHZhbFdpZHRoO1xuICAgICAgICAgICAgdmFyIG91dG1vc3R2YWwgPSB0aGlzLmRvbS52YWx1ZVt0aGlzLmRvbS52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgd2lkdGggYW5kIHJpZ2h0IHZhbHVlIG9mIHRoZSBvdXRtb3N0IHZhbHVlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChvdXRtb3N0dmFsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5kb20uY29udGFpbmVyLmhhcyhvdXRtb3N0dmFsWzBdKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWxXaWR0aCA9IG91dG1vc3R2YWwub3V0ZXJXaWR0aCh0cnVlKTtcbiAgICAgICAgICAgICAgICB2YWxSaWdodCA9IG91dG1vc3R2YWwub2Zmc2V0KCkubGVmdCArIHZhbFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSB0aGlzLmRvbS5sZWZ0Lm9mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0T2Zmc2V0ID0gdGhpcy5kb20ucmlnaHQub2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgY2xlYXJPZmZzZXQgPSB0aGlzLmRvbVtcImRlbGV0ZVwiXS5vZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBoYXNMZWZ0ID0gdGhpcy5kb20uY29udGFpbmVyLmhhcyh0aGlzLmRvbS5sZWZ0WzBdKS5sZW5ndGggIT09IDA7XG4gICAgICAgICAgICB2YXIgaGFzUmlnaHQgPSB0aGlzLmRvbS5jb250YWluZXIuaGFzKHRoaXMuZG9tLnJpZ2h0WzBdKS5sZW5ndGggIT09IDA7XG4gICAgICAgICAgICB2YXIgYnV0dG9uc0xlZnQgPSBoYXNMZWZ0ID9cbiAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0LmxlZnQgOlxuICAgICAgICAgICAgICAgIGhhc1JpZ2h0ID9cbiAgICAgICAgICAgICAgICAgICAgcmlnaHRPZmZzZXQubGVmdCA6XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSByZXNwb25zaXZlIGNhbGN1bGF0aW9ucyBhbmQgcmVkcmF3IHdoZXJlIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKChidXR0b25zTGVmdCAtIHZhbFJpZ2h0IDwgMTUgfHxcbiAgICAgICAgICAgICAgICBoYXNMZWZ0ICYmIGxlZnRPZmZzZXQudG9wICE9PSBjbGVhck9mZnNldC50b3AgfHxcbiAgICAgICAgICAgICAgICBoYXNSaWdodCAmJiByaWdodE9mZnNldC50b3AgIT09IGNsZWFyT2Zmc2V0LnRvcCkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5kb20uY29udGFpbmVyLnBhcmVudCgpLmhhc0NsYXNzKHRoaXMuY2xhc3Nlcy52ZXJ0aWNhbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIucGFyZW50KCkuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdDb250ZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnV0dG9uc0xlZnQgLVxuICAgICAgICAgICAgICAgICh0aGlzLmRvbS5kYXRhLm9mZnNldCgpLmxlZnQgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5kYXRhLm91dGVyV2lkdGgodHJ1ZSkgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb24ub3V0ZXJXaWR0aCh0cnVlKSArXG4gICAgICAgICAgICAgICAgICAgIHZhbFdpZHRoKSA+IDE1XG4gICAgICAgICAgICAgICAgJiYgdGhpcy5kb20uY29udGFpbmVyLnBhcmVudCgpLmhhc0NsYXNzKHRoaXMuY2xhc3Nlcy52ZXJ0aWNhbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIucGFyZW50KCkucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdDb250ZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGRzIHRoZSBlbGVtZW50cyBvZiB0aGUgZG9tIHRvZ2V0aGVyXG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5wcm90b3R5cGUuX2J1aWxkQ3JpdGVyaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBBcHBlbmQgVGl0bGVzIGZvciBzZWxlY3QgZWxlbWVudHNcbiAgICAgICAgICAgIHRoaXMuZG9tLmRhdGEuYXBwZW5kKHRoaXMuZG9tLmRhdGFUaXRsZSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb24uYXBwZW5kKHRoaXMuZG9tLmNvbmRpdGlvblRpdGxlKTtcbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5kb20uZGF0YSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuZG9tLmNvbmRpdGlvbik7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kb20udmFsdWU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB2YWwuYXBwZW5kKHRoaXMuZG9tLnZhbHVlVGl0bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5hcHBlbmQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBidXR0b25zIHRvIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLmRvbVtcImRlbGV0ZVwiXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuZG9tLnJpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgdGhlIGNvbmRpdGlvbiBzZWxlY3QgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgQ3JpdGVyaWEucHJvdG90eXBlLl9jbGVhckNvbmRpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbmRpdGlvbi5lbXB0eSgpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uVGl0bGUucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKS5hdHRyKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb24ucHJlcGVuZCh0aGlzLmRvbS5jb25kaXRpb25UaXRsZSkucHJvcCgnc2VsZWN0ZWRJbmRleCcsIDApO1xuICAgICAgICAgICAgdGhpcy5zLmNvbmRpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucy5jb25kaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgdGhlIHZhbHVlIGVsZW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5wcm90b3R5cGUuX2NsZWFyVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zLmNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5kb20udmFsdWVbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpbWVvdXQgaXMgYW5ub3lpbmcgYnV0IGJlY2F1c2Ugb2YgSU9TXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgb2YgdGhlIHZhbHVlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmRvbS52YWx1ZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgaW5pdCBmdW5jdGlvbiB0byBnZXQgdGhlIHZhbHVlIGVsZW1lbnRzIGZvciB0aGlzIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnZhbHVlID0gW10uY29uY2F0KHRoaXMucy5jb25kaXRpb25zW3RoaXMucy5jb25kaXRpb25dLmluaXQodGhpcywgQ3JpdGVyaWEudXBkYXRlTGlzdGVuZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20udmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLmRvbS52YWx1ZVswXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLnZhbHVlWzBdLmluc2VydEFmdGVyKHRoaXMuZG9tLmNvbmRpdGlvbikudHJpZ2dlcignZHRzYi1pbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYWxsIG9mIHRoZSB2YWx1ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuZG9tLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS52YWx1ZVtpXS5pbnNlcnRBZnRlcih0aGlzLmRvbS52YWx1ZVtpIC0gMV0pLnRyaWdnZXIoJ2R0c2ItaW5zZXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpbWVvdXQgaXMgYW5ub3lpbmcgYnV0IGJlY2F1c2Ugb2YgSU9TXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgb2YgdGhlIHZhbHVlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuZG9tLnZhbHVlOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZGVmYXVsdCB2YWx1ZVRpdGxlIHRvIHRoZSBkZWZhdWx0IHNlbGVjdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5kb20udmFsdWVUaXRsZVxuICAgICAgICAgICAgICAgICAgICAucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLmRvbS52YWx1ZVRpdGxlKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWZ0ZXIodGhpcy5kb20uY29uZGl0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kb20udmFsdWUgPSBbXG4gICAgICAgICAgICAgICAgJCQyKCc8c2VsZWN0IGRpc2FibGVkLz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRyb3BEb3duKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLml0YWxpYylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5zZWxlY3QpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5kb20udmFsdWVUaXRsZS5jbG9uZSgpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjb2x1bW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gVGhlIG9wdGlvbnMgZm9yIHRoZSBjb2x1bW5cbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5fZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMucy5kdDtcbiAgICAgICAgICAgIHJldHVybiAkJDIuZXh0ZW5kKHRydWUsIHt9LCBDcml0ZXJpYS5kZWZhdWx0cywgdGFibGUuc2V0dGluZ3MoKVswXS5hb0NvbHVtbnNbdGhpcy5zLmRhdGFJZHhdLnNlYXJjaEJ1aWxkZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9wdWxhdGVzIHRoZSBjb25kaXRpb24gZHJvcGRvd25cbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5fcG9wdWxhdGVDb25kaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uT3B0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbnNMZW5ndGggPSBPYmplY3Qua2V5cyh0aGlzLnMuY29uZGl0aW9ucykubGVuZ3RoO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNvbmRpdGlvbnMgc3RvcmVkIHRoZW4gd2UgbmVlZCB0byBnZXQgdGhlbSBmcm9tIHRoZSBhcHByb3ByaWF0ZSB0eXBlXG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSArdGhpcy5kb20uZGF0YS5jaGlsZHJlbignb3B0aW9uOnNlbGVjdGVkJykudmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnR5cGUgPSB0aGlzLnMuZHQuY29sdW1ucygpLnR5cGUoKS50b0FycmF5KClbY29sdW1uXTtcbiAgICAgICAgICAgICAgICB2YXIgY29sSW5pdHMgPSB0aGlzLnMuZHQuc2V0dGluZ3MoKVswXS5hb0NvbHVtbnM7XG4gICAgICAgICAgICAgICAgaWYgKGNvbEluaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbEluaXQgPSBjb2xJbml0c1tjb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sSW5pdC5zZWFyY2hCdWlsZGVyVHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbEluaXQuc2VhcmNoQnVpbGRlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy50eXBlID0gY29sSW5pdC5zZWFyY2hCdWlsZGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnMudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucy50eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMudHlwZSA9IGNvbEluaXQuc1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbHVtbiB0eXBlIGlzIHN0aWxsIHVua25vd24sIGNhbGwgYSBkcmF3IHRvIHRyeSByZWFkaW5nIGl0IGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucy50eXBlID09PSBudWxsIHx8IHRoaXMucy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCQyLmZuLmRhdGFUYWJsZS5leHQub0FwaS5fZm5Db2x1bW5UeXBlcyh0aGlzLnMuZHQuc2V0dGluZ3MoKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy50eXBlID0gdGhpcy5zLmR0LmNvbHVtbnMoKS50eXBlKCkudG9BcnJheSgpW2NvbHVtbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSB0aGUgY29uZGl0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgLmVtcHR5KClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLmRvbS5jb25kaXRpb25UaXRsZSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbmRpdGlvblRpdGxlXG4gICAgICAgICAgICAgICAgICAgIC5wcm9wKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gdGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNEZWNpbWFsO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgaW4gcGxhY2UgZm9yIGlmIGEgY3VzdG9tIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGluIHBsYWNlXG4gICAgICAgICAgICAgICAgaWYgKGRlY2ltYWwgIT09ICcnICYmIHRoaXMucy50eXBlLmluZGV4T2YoZGVjaW1hbCkgPT09IHRoaXMucy50eXBlLmxlbmd0aCAtIGRlY2ltYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnMudHlwZS5pbmNsdWRlcygnbnVtLWZtdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMudHlwZSA9IHRoaXMucy50eXBlLnJlcGxhY2UoZGVjaW1hbCwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucy50eXBlLmluY2x1ZGVzKCdudW0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnR5cGUgPSB0aGlzLnMudHlwZS5yZXBsYWNlKGRlY2ltYWwsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWxlY3Qgd2hpY2ggY29uZGl0aW9ucyBhcmUgZ29pbmcgdG8gYmUgdXNlZCBiYXNlZCBvbiB0aGUgY29sdW1uIHR5cGVcbiAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uT2JqID0gdGhpcy5jLmNvbmRpdGlvbnNbdGhpcy5zLnR5cGVdICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmMuY29uZGl0aW9uc1t0aGlzLnMudHlwZV0gOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnMudHlwZS5pbmNsdWRlcygnbW9tZW50JykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jLmNvbmRpdGlvbnMubW9tZW50IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy50eXBlLmluY2x1ZGVzKCdsdXhvbicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmMuY29uZGl0aW9ucy5sdXhvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jLmNvbmRpdGlvbnMuc3RyaW5nO1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgbW9tZW50IGZvcm1hdCB0aGVuIGV4dHJhY3QgdGhlIGRhdGUgZm9ybWF0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucy50eXBlLmluY2x1ZGVzKCdtb21lbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuZGF0ZUZvcm1hdCA9IHRoaXMucy50eXBlLnJlcGxhY2UoL21vbWVudC0vZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnMudHlwZS5pbmNsdWRlcygnbHV4b24nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuZGF0ZUZvcm1hdCA9IHRoaXMucy50eXBlLnJlcGxhY2UoL2x1eG9uLS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIGNvbmRpdGlvbnMgdG8gdGhlIHNlbGVjdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKGNvbmRpdGlvbk9iaik7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25PYmpbY29uZGl0aW9uXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VydmVyc2lkZSBwcm9jZXNzaW5nIGRvZXMgbm90IHN1cHBseSB0aGUgb3B0aW9ucyBmb3IgdGhlIHNlbGVjdCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBpbnB1dCBlbGVtZW50cyBuZWVkIHRvIGJlIHVzZWQgZm9yIHRoZXNlIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSAmJiBjb25kaXRpb25PYmpbY29uZGl0aW9uXS5pbml0ID09PSBDcml0ZXJpYS5pbml0U2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uT2JqW2NvbmRpdGlvbl0uaW5pdCA9IENyaXRlcmlhLmluaXRJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25PYmpbY29uZGl0aW9uXS5pbnB1dFZhbHVlID0gQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbk9ialtjb25kaXRpb25dLmlzSW5wdXRWYWxpZCA9IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmNvbmRpdGlvbnNbY29uZGl0aW9uXSA9IGNvbmRpdGlvbk9ialtjb25kaXRpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmROYW1lID0gY29uZGl0aW9uT2JqW2NvbmRpdGlvbl0uY29uZGl0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kTmFtZSA9IGNvbmROYW1lKHRoaXMucy5kdCwgdGhpcy5jLmkxOG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uT3B0cy5wdXNoKCQkMignPG9wdGlvbj4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29uZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLm9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLm5vdEl0YWxpYykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiBqdXN0IGxvYWQgdGhlbSBpblxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZGl0aW9uc0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb25kaXRpb24uZW1wdHkoKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyh0aGlzLnMuY29uZGl0aW9ucyk7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kTmFtZSA9IHRoaXMucy5jb25kaXRpb25zW2NvbmRpdGlvbl0uY29uZGl0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25kTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZE5hbWUgPSBjb25kTmFtZSh0aGlzLnMuZHQsIHRoaXMuYy5pMThuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3T3B0ID0gJCQyKCc8b3B0aW9uPicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbmROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5vcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLm5vdEl0YWxpYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnMuY29uZGl0aW9uICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zLmNvbmRpdGlvbiA9PT0gY29uZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09wdC5wcm9wKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29uZGl0aW9uLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbk9wdHMucHVzaChuZXdPcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuaXRhbGljKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIGNvbmRpdGlvbk9wdHNfMSA9IGNvbmRpdGlvbk9wdHM7IF9kIDwgY29uZGl0aW9uT3B0c18xLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgICAgIHZhciBvcHQgPSBjb25kaXRpb25PcHRzXzFbX2RdO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbmRpdGlvbi5hcHBlbmQob3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbmRpdGlvbi5wcm9wKCdzZWxlY3RlZEluZGV4JywgMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3B1bGF0ZXMgdGhlIGRhdGEgc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnByb3RvdHlwZS5fcG9wdWxhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmRhdGEuZW1wdHkoKS5hcHBlbmQodGhpcy5kb20uZGF0YVRpdGxlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkYXRhcyBzdG9yZWQgdGhlbiB3ZSBuZWVkIHRvIGdldCB0aGVtIGZyb20gdGhlIHRhYmxlXG4gICAgICAgICAgICBpZiAodGhpcy5zLmRhdGFQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zLmR0LmNvbHVtbnMoKS5ldmVyeShmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayB0aGF0IHRoZSBjb2x1bW4gY2FuIGJlIGZpbHRlcmVkIG9uIGJlZm9yZSBhZGRpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmMuY29sdW1ucyA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5jb2x1bW5zKF90aGlzLmMuY29sdW1ucykuaW5kZXhlcygpLnRvQXJyYXkoKS5pbmNsdWRlcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLnMuZGF0YVBvaW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfdGhpcy5zLmR0LnNldHRpbmdzKClbMF0uYW9Db2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdEYXRhOiBjb2wuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogKGNvbC5zZWFyY2hCdWlsZGVyVGl0bGUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wuc1RpdGxlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5zZWFyY2hCdWlsZGVyVGl0bGUpLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZGF0YVBvaW50cy5wdXNoKG9wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9tLmRhdGEuYXBwZW5kKCQkMignPG9wdGlvbj4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG9wdC50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0LmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKF90aGlzLmNsYXNzZXMub3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoX3RoaXMuY2xhc3Nlcy5ub3RJdGFsaWMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdvcmlnRGF0YScsIGNvbC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnc2VsZWN0ZWQnLCBfdGhpcy5zLmRhdGFJZHggPT09IG9wdC5pbmRleCA/IHRydWUgOiBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zLmRhdGFJZHggPT09IG9wdC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20uZGF0YVRpdGxlLnJlbW92ZVByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2FuIGp1c3QgbG9hZCB0aGVtIGluXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5zLmR0LmNvbHVtbnMoKS5ldmVyeShmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfdGhpcy5zLmR0LnNldHRpbmdzKClbMF0uYW9Db2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29sLnNlYXJjaEJ1aWxkZXJUaXRsZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wuc1RpdGxlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wuc2VhcmNoQnVpbGRlclRpdGxlKS5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpID09PSBkYXRhLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vcmlnRGF0YSA9IGNvbC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld09wdCA9ICQkMignPG9wdGlvbj4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBkYXRhLnRleHQucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLmluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpc18xLmNsYXNzZXMub3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXNfMS5jbGFzc2VzLm5vdEl0YWxpYylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdvcmlnRGF0YScsIGRhdGEub3JpZ0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc18xLnMuZGF0YSA9PT0gZGF0YS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEucy5kYXRhSWR4ID0gZGF0YS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5kb20uZGF0YVRpdGxlLnJlbW92ZVByb3AoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPcHQucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5kb20uZGF0YS5yZW1vdmVDbGFzcyh0aGlzXzEuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5kb20uZGF0YS5hcHBlbmQobmV3T3B0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMuZGF0YVBvaW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9wdWxhdGVzIHRoZSBWYWx1ZSBzZWxlY3QgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVkQ3JpdGVyaWEgb3B0aW9uYWwsIHVzZWQgdG8gcmVsb2FkIGNyaXRlcmlhIGZyb20gcHJlZGVmaW5lZCBmaWx0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5wcm90b3R5cGUuX3BvcHVsYXRlVmFsdWUgPSBmdW5jdGlvbiAobG9hZGVkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcHJldkZpbGxlZCA9IHRoaXMucy5maWxsZWQ7XG4gICAgICAgICAgICB0aGlzLnMuZmlsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IHByZXZpb3VzIHZhbHVlIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBUaW1lb3V0IGlzIGFubm95aW5nIGJ1dCBiZWNhdXNlIG9mIElPU1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmRlZmF1bHRWYWx1ZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIHZhciBfbG9vcF80ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXQgaXMgYW5ub3lpbmcgYnV0IGJlY2F1c2Ugb2YgSU9TXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmRvbS52YWx1ZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIF9sb29wXzQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZG9tLmNvbnRhaW5lci5jaGlsZHJlbigpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAkJDIoY2hpbGRyZW5baV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvbHVtbiB3aXRoIHRoZSB0aXRsZSBtYXRjaGluZyB0aGUgZGF0YSBmb3IgdGhlIGNyaXRlcmlhIGFuZCB0YWtlIG5vdGUgb2YgdGhlIGluZGV4XG4gICAgICAgICAgICBpZiAobG9hZGVkQ3JpdGVyaWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucy5kdC5jb2x1bW5zKCkuZXZlcnkoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zLmR0LnNldHRpbmdzKClbMF0uYW9Db2x1bW5zW2luZGV4XS5zVGl0bGUgPT09IGxvYWRlZENyaXRlcmlhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZGF0YUlkeCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSB2YWx1ZSBlbGVtZW50cyBiYXNlZCBvbiB0aGUgY29uZGl0aW9uXG4gICAgICAgICAgICB0aGlzLmRvbS52YWx1ZSA9IFtdLmNvbmNhdCh0aGlzLnMuY29uZGl0aW9uc1t0aGlzLnMuY29uZGl0aW9uXS5pbml0KHRoaXMsIENyaXRlcmlhLnVwZGF0ZUxpc3RlbmVyLCBsb2FkZWRDcml0ZXJpYSAhPT0gdW5kZWZpbmVkID8gbG9hZGVkQ3JpdGVyaWEudmFsdWUgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmIChsb2FkZWRDcml0ZXJpYSAhPT0gdW5kZWZpbmVkICYmIGxvYWRlZENyaXRlcmlhLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMudmFsdWUgPSBsb2FkZWRDcml0ZXJpYS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB2YWx1ZSBlbGVtZW50cyBhbmQgdHJpZ2dlciB0aGUgaW5zZXJ0ZWQgZXZlbnRcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbS52YWx1ZVswXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20udmFsdWVbMF1cbiAgICAgICAgICAgICAgICAgICAgLmluc2VydEFmdGVyKHRoaXMuZG9tLmNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLnRyaWdnZXIoJ2R0c2ItaW5zZXJ0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5kb20udmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS52YWx1ZVtpXVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWZ0ZXIodGhpcy5kb20udmFsdWVbaSAtIDFdKVxuICAgICAgICAgICAgICAgICAgICAudHJpZ2dlcignZHRzYi1pbnNlcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNyaXRlcmlhIGNhbiBiZSB1c2VkIGluIGEgc2VhcmNoXG4gICAgICAgICAgICB0aGlzLnMuZmlsbGVkID0gdGhpcy5zLmNvbmRpdGlvbnNbdGhpcy5zLmNvbmRpdGlvbl0uaXNJbnB1dFZhbGlkKHRoaXMuZG9tLnZhbHVlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAvLyBJZiBpdCBjYW4gYW5kIHRoaXMgaXMgZGlmZmVyZW50IHRvIGJlZm9yZSB0aGVuIHRyaWdnZXIgYSBkcmF3XG4gICAgICAgICAgICBpZiAocHJldkZpbGxlZCAhPT0gdGhpcy5zLmZpbGxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucy5kdC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIHRocm90dGxpbmcgY2FwYWJpbGl0aWVzIHRvIFNlYXJjaEJ1aWxkZXIgd2l0aG91dCBoYXZpbmcgdG8gdXNlIGR0J3MgX2ZuVGhyb3R0bGUgZnVuY3Rpb25cbiAgICAgICAgICogVGhpcyBpcyBiZWNhdXNlIHRoYXQgZnVuY3Rpb24gaXMgbm90IHF1aXRlIHN1aXRhYmxlIGZvciBvdXIgbmVlZHMgYXMgaXQgcnVucyBpbml0aWFsbHkgcmF0aGVyIHRoYW4gd2FpdGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYXJncyBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHRocm90dGxlIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRoYXQgaXMgdG8gYmUgcnVuIHRoYXQgaW1wbGVtZW50cyB0aGUgdGhyb3R0bGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ3JpdGVyaWEucHJvdG90eXBlLl90aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICBpZiAoZnJlcXVlbmN5ID09PSB2b2lkIDApIHsgZnJlcXVlbmN5ID0gMjAwOyB9XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGZyZXF1ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSA9IDIwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAhPT0gbnVsbCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSwgZnJlcXVlbmN5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIENyaXRlcmlhLnZlcnNpb24gPSAnMS4xLjAnO1xuICAgICAgICBDcml0ZXJpYS5jbGFzc2VzID0ge1xuICAgICAgICAgICAgYnV0dG9uOiAnZHRzYi1idXR0b24nLFxuICAgICAgICAgICAgYnV0dG9uQ29udGFpbmVyOiAnZHRzYi1idXR0b25Db250YWluZXInLFxuICAgICAgICAgICAgY29uZGl0aW9uOiAnZHRzYi1jb25kaXRpb24nLFxuICAgICAgICAgICAgY29udGFpbmVyOiAnZHRzYi1jcml0ZXJpYScsXG4gICAgICAgICAgICBkYXRhOiAnZHRzYi1kYXRhJyxcbiAgICAgICAgICAgIFwiZGVsZXRlXCI6ICdkdHNiLWRlbGV0ZScsXG4gICAgICAgICAgICBkcm9wRG93bjogJ2R0c2ItZHJvcERvd24nLFxuICAgICAgICAgICAgZ3JleXNjYWxlOiAnZHRzYi1ncmV5c2NhbGUnLFxuICAgICAgICAgICAgaW5wdXQ6ICdkdHNiLWlucHV0JyxcbiAgICAgICAgICAgIGl0YWxpYzogJ2R0c2ItaXRhbGljJyxcbiAgICAgICAgICAgIGpvaW5lcjogJ2R0c3Atam9pbmVyJyxcbiAgICAgICAgICAgIGxlZnQ6ICdkdHNiLWxlZnQnLFxuICAgICAgICAgICAgbm90SXRhbGljOiAnZHRzYi1ub3RJdGFsaWMnLFxuICAgICAgICAgICAgb3B0aW9uOiAnZHRzYi1vcHRpb24nLFxuICAgICAgICAgICAgcmlnaHQ6ICdkdHNiLXJpZ2h0JyxcbiAgICAgICAgICAgIHNlbGVjdDogJ2R0c2Itc2VsZWN0JyxcbiAgICAgICAgICAgIHZhbHVlOiAnZHRzYi12YWx1ZScsXG4gICAgICAgICAgICB2ZXJ0aWNhbDogJ2R0c2ItdmVydGljYWwnXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGluaXRpYWxpc2F0aW9uIGZ1bmN0aW9uIGZvciBzZWxlY3QgY29uZGl0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQ3JpdGVyaWEuaW5pdFNlbGVjdCA9IGZ1bmN0aW9uICh0aGF0LCBmbiwgcHJlRGVmaW5lZCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChwcmVEZWZpbmVkID09PSB2b2lkIDApIHsgcHJlRGVmaW5lZCA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhcnJheSA9PT0gdm9pZCAwKSB7IGFycmF5ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGF0LmRvbS5kYXRhLmNoaWxkcmVuKCdvcHRpb246c2VsZWN0ZWQnKS52YWwoKTtcbiAgICAgICAgICAgIHZhciBpbmRleEFycmF5ID0gdGhhdC5zLmR0LnJvd3MoKS5pbmRleGVzKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gdGhhdC5zLmR0LnNldHRpbmdzKClbMF07XG4gICAgICAgICAgICAvLyBEZWNsYXJlIHNlbGVjdCBlbGVtZW50IHRvIGJlIHVzZWQgd2l0aCBhbGwgb2YgdGhlIGRlZmF1bHQgY2xhc3NlcyBhbmQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgdmFyIGVsID0gJCQyKCc8c2VsZWN0Lz4nKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLnZhbHVlKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLmRyb3BEb3duKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLml0YWxpYylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5zZWxlY3QpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGF0LmRvbS52YWx1ZVRpdGxlKVxuICAgICAgICAgICAgICAgIC5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQkMih0aGlzKS5yZW1vdmVDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLml0YWxpYyk7XG4gICAgICAgICAgICAgICAgZm4odGhhdCwgdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGF0LmMuZ3JleXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZGVkID0gW107XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IFtdO1xuICAgICAgICAgICAgLy8gQWRkIGFsbCBvZiB0aGUgb3B0aW9ucyBmcm9tIHRoZSB0YWJsZSB0byB0aGUgc2VsZWN0IGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBPbmx5IGFkZCBvbmUgb3B0aW9uIGZvciBlYWNoIHBvc3NpYmxlIHZhbHVlXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGluZGV4QXJyYXlfMSA9IGluZGV4QXJyYXk7IF9pIDwgaW5kZXhBcnJheV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluZGV4QXJyYXlfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHNldHRpbmdzLm9BcGkuX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGluZGV4LCBjb2x1bW4sIHR5cGVvZiB0aGF0LmMub3J0aG9nb25hbCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmMub3J0aG9nb25hbCA6XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYy5vcnRob2dvbmFsLnNlYXJjaCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5yZXBsYWNlKC9bXFxyXFxuXFx1MjAyOF0vZywgJyAnKSA6IC8vIE5lZWQgdG8gcmVwbGFjZSBjZXJ0YWluIGNoYXJhY3RlcnMgdG8gbWF0Y2ggc2VhcmNoIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHNldHRpbmdzLm9BcGkuX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGluZGV4LCBjb2x1bW4sIHR5cGVvZiB0aGF0LmMub3J0aG9nb25hbCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jLm9ydGhvZ29uYWwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jLm9ydGhvZ29uYWwuZGlzcGxheSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXkgdHlwZSwgZWl0aGVyIG1ha2Ugc3VyZSB3ZSBhcmUgd29ya2luZyB3aXRoIGFycmF5cywgb3Igc29ydCB0aGVtXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQucy50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlciA9ICFBcnJheS5pc0FycmF5KHZhbHVlLmZpbHRlcikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlLmZpbHRlcl0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyID0gdmFsdWUuZmlsdGVyLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudGV4dCA9ICFBcnJheS5pc0FycmF5KHZhbHVlLnRleHQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZS50ZXh0XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50ZXh0ID0gdmFsdWUudGV4dC5zb3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIHRvIGFkZCBhbiBvcHRpb24gdG8gdGhlIHNlbGVjdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIGFkZE9wdGlvbiA9IGZ1bmN0aW9uIChmaWx0LCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0ZXh0IGFuZCB2YWx1ZSwgc3RyaXBwaW5nIG91dCBhbnkgaHRtbCBpZiB0aGF0IGlzIHRoZSBjb2x1bW4gdHlwZVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gJCQyKCc8b3B0aW9uPicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycmF5LmlzQXJyYXkoZmlsdCkgPyAnQXJyYXknIDogJ1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhhdC5zLnR5cGUuaW5jbHVkZXMoJ2h0bWwnKSAmJiBmaWx0ICE9PSBudWxsICYmIHR5cGVvZiBmaWx0ID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdC5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhhdC5jbGFzc2VzLm9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGF0LmNsYXNzZXMubm90SXRhbGljKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGF2ZSB0byBhZGQgdGhlIHRleHQgdGhpcyB3YXkgc28gdGhhdCBzcGVjaWFsIGh0bWwgY2hhcmFjdGVycyBhcmUgbm90IGVzY2FwZWQgLSAmYW1wOyBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaHRtbCh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gb3B0LnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgdmFsdWUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZURlZmluZWQgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShwcmVEZWZpbmVkWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZURlZmluZWRbMF0gPSBwcmVEZWZpbmVkWzBdLnNvcnQoKS5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHZhbHVlIHdhcyBwcmV2aW91c2x5IHNlbGVjdGVkIGFzIGluZGljYXRlZCBieSBwcmVEZWZpbmVkLCB0aGVuIHNlbGVjdCBpdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZURlZmluZWQgIT09IG51bGwgJiYgb3B0LnZhbCgpID09PSBwcmVEZWZpbmVkWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0LnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRvIGFkZCB0aGUgaW5kaXZpZHVhbCB2YWx1ZXMgd2l0aGluIHRoZSBhcnJheSB3ZSBuZWVkIHRvIGxvb3Agb3ZlciB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5maWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGlvbih2YWx1ZS5maWx0ZXJbaV0sIHZhbHVlLnRleHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgdmFsdWUgdGhhdCBpcyBpbiB0aGUgY2VsbCBpcyB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcHRpb24odmFsdWUuZmlsdGVyLCB2YWx1ZS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5zLnR5cGUgPT09ICdhcnJheScgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zLnR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucy50eXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEudmFsKCkgPCBiLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYS52YWwoKSA+IGIudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhhdC5zLnR5cGUgPT09ICdudW0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucy50eXBlID09PSAnaHRtbC1udW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrYS52YWwoKS5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpIDwgK2IudmFsKCkucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCthLnZhbCgpLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJykgPiArYi52YWwoKS5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoYXQucy50eXBlID09PSAnbnVtLWZtdCcgfHwgdGhhdC5zLnR5cGUgPT09ICdodG1sLW51bS1mbXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrYS52YWwoKS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSA8ICtiLnZhbCgpLnJlcGxhY2UoL1teMC05Ll0vZywgJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoK2EudmFsKCkucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgPiArYi52YWwoKS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBvcHRpb25zXzEgPSBvcHRpb25zOyBfYSA8IG9wdGlvbnNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9uc18xW19hXTtcbiAgICAgICAgICAgICAgICBlbC5hcHBlbmQob3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgaW5pdGlhbGlzYXRpb24gZnVuY3Rpb24gZm9yIHNlbGVjdCBhcnJheSBjb25kaXRpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZXhpc3RzIGJlY2F1c2UgdGhlcmUgbmVlZHMgdG8gYmUgZGlmZmVyZW50IHNlbGVjdCBmdW5jdGlvbmFsaXR5IGZvciBjb250YWlucy93aXRob3V0IGFuZCBlcXVhbHMvbm90XG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5pbml0U2VsZWN0QXJyYXkgPSBmdW5jdGlvbiAodGhhdCwgZm4sIHByZURlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChwcmVEZWZpbmVkID09PSB2b2lkIDApIHsgcHJlRGVmaW5lZCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBDcml0ZXJpYS5pbml0U2VsZWN0KHRoYXQsIGZuLCBwcmVEZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgaW5pdGlhbGlzYXRpb24gZnVuY3Rpb24gZm9yIGlucHV0IGNvbmRpdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLmluaXRJbnB1dCA9IGZ1bmN0aW9uICh0aGF0LCBmbiwgcHJlRGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHByZURlZmluZWQgPT09IHZvaWQgMCkgeyBwcmVEZWZpbmVkID0gbnVsbDsgfVxuICAgICAgICAgICAgLy8gRGVjbGFyZSB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgICAgdmFyIHNlYXJjaERlbGF5ID0gdGhhdC5zLmR0LnNldHRpbmdzKClbMF0uc2VhcmNoRGVsYXk7XG4gICAgICAgICAgICB2YXIgZWwgPSAkJDIoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5pbnB1dClcbiAgICAgICAgICAgICAgICAub24oJ2lucHV0IGtleXByZXNzJywgdGhhdC5fdGhyb3R0bGUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGUua2V5Q29kZSB8fCBlLndoaWNoO1xuICAgICAgICAgICAgICAgIGlmICghdGhhdC5jLmVudGVyU2VhcmNoICYmXG4gICAgICAgICAgICAgICAgICAgICEodGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0luaXQuc2VhcmNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9Jbml0LnNlYXJjaFtcInJldHVyblwiXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlYXJjaERlbGF5ID09PSBudWxsID8gMTAwIDogc2VhcmNoRGVsYXkpKTtcbiAgICAgICAgICAgIGlmICh0aGF0LmMuZ3JleXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwcmVEZWZpbmVkIHZhbHVlIHRoZW4gYWRkIGl0XG4gICAgICAgICAgICBpZiAocHJlRGVmaW5lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsLnZhbChwcmVEZWZpbmVkWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkIHJlc3BvbnNpdmUgZnVuY3Rpb25hbGl0eSB0byB0aGUgbG9naWMgYnV0dG9uIHdpdGhvdXQgcmVkcmF3aW5nIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgdGhhdC5zLmR0Lm9uZSgnZHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdMb2dpYycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGluaXRpYWxpc2F0aW9uIGZ1bmN0aW9uIGZvciBjb25kaXRpb25zIHJlcXVpcmluZyAyIGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgQ3JpdGVyaWEuaW5pdDJJbnB1dCA9IGZ1bmN0aW9uICh0aGF0LCBmbiwgcHJlRGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHByZURlZmluZWQgPT09IHZvaWQgMCkgeyBwcmVEZWZpbmVkID0gbnVsbDsgfVxuICAgICAgICAgICAgLy8gRGVjbGFyZSBhbGwgb2YgdGhlIG5lY2Vzc2FyeSBqUXVlcnkgZWxlbWVudHNcbiAgICAgICAgICAgIHZhciBzZWFyY2hEZWxheSA9IHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLnNlYXJjaERlbGF5O1xuICAgICAgICAgICAgdmFyIGVscyA9IFtcbiAgICAgICAgICAgICAgICAkJDIoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKENyaXRlcmlhLmNsYXNzZXMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLmlucHV0KVxuICAgICAgICAgICAgICAgICAgICAub24oJ2lucHV0IGtleXByZXNzJywgdGhhdC5fdGhyb3R0bGUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBlLmtleUNvZGUgfHwgZS53aGljaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0LmMuZW50ZXJTZWFyY2ggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEodGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0luaXQuc2VhcmNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vSW5pdC5zZWFyY2hbXCJyZXR1cm5cIl0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc2VhcmNoRGVsYXkgPT09IG51bGwgPyAxMDAgOiBzZWFyY2hEZWxheSkpLFxuICAgICAgICAgICAgICAgICQkMignPHNwYW4+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoYXQuY2xhc3Nlcy5qb2luZXIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoYXQucy5kdC5pMThuKCdzZWFyY2hCdWlsZGVyLnZhbHVlSm9pbmVyJywgdGhhdC5jLmkxOG4udmFsdWVKb2luZXIpKSxcbiAgICAgICAgICAgICAgICAkJDIoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKENyaXRlcmlhLmNsYXNzZXMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLmlucHV0KVxuICAgICAgICAgICAgICAgICAgICAub24oJ2lucHV0IGtleXByZXNzJywgdGhhdC5fdGhyb3R0bGUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBlLmtleUNvZGUgfHwgZS53aGljaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0LmMuZW50ZXJTZWFyY2ggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEodGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0luaXQuc2VhcmNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vSW5pdC5zZWFyY2hbXCJyZXR1cm5cIl0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc2VhcmNoRGVsYXkgPT09IG51bGwgPyAxMDAgOiBzZWFyY2hEZWxheSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKHRoYXQuYy5ncmV5c2NhbGUpIHtcbiAgICAgICAgICAgICAgICBlbHNbMF0uYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgICAgIGVsc1syXS5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLmdyZXlzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHByZURlZmluZWQgdmFsdWUgdGhlbiBhZGQgaXRcbiAgICAgICAgICAgIGlmIChwcmVEZWZpbmVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxzWzBdLnZhbChwcmVEZWZpbmVkWzBdKTtcbiAgICAgICAgICAgICAgICBlbHNbMl0udmFsKHByZURlZmluZWRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhZGQgcmVzcG9uc2l2ZSBmdW5jdGlvbmFsaXR5IHRvIHRoZSBsb2dpYyBidXR0b24gd2l0aG91dCByZWRyYXdpbmcgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICB0aGF0LnMuZHQub25lKCdkcmF3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQucy50b3BHcm91cC50cmlnZ2VyKCdkdHNiLXJlZHJhd0xvZ2ljJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbHM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGluaXRpYWxpc2F0aW9uIGZ1bmN0aW9uIGZvciBkYXRlIGNvbmRpdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLmluaXREYXRlID0gZnVuY3Rpb24gKHRoYXQsIGZuLCBwcmVEZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocHJlRGVmaW5lZCA9PT0gdm9pZCAwKSB7IHByZURlZmluZWQgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgc2VhcmNoRGVsYXkgPSB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5zZWFyY2hEZWxheTtcbiAgICAgICAgICAgIC8vIERlY2xhcmUgZGF0ZSBlbGVtZW50IHVzaW5nIERhdGFUYWJsZXMgZGF0ZVRpbWUgcGx1Z2luXG4gICAgICAgICAgICB2YXIgZWwgPSAkJDIoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5pbnB1dClcbiAgICAgICAgICAgICAgICAuZHREYXRlVGltZSh7XG4gICAgICAgICAgICAgICAgYXR0YWNoVG86ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGF0LnMuZGF0ZUZvcm1hdCA/IHRoYXQucy5kYXRlRm9ybWF0IDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2hhbmdlJywgdGhhdC5fdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbih0aGF0LCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHNlYXJjaERlbGF5ID09PSBudWxsID8gMTAwIDogc2VhcmNoRGVsYXkpKVxuICAgICAgICAgICAgICAgIC5vbignaW5wdXQga2V5cHJlc3MnLCB0aGF0LmMuZW50ZXJTZWFyY2ggfHxcbiAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vSW5pdC5zZWFyY2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vSW5pdC5zZWFyY2hbXCJyZXR1cm5cIl0gP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3Rocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZS5rZXlDb2RlIHx8IGUud2hpY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4odGhhdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlYXJjaERlbGF5ID09PSBudWxsID8gMTAwIDogc2VhcmNoRGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHRoYXQuX3Rocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sIHNlYXJjaERlbGF5ID09PSBudWxsID8gMTAwIDogc2VhcmNoRGVsYXkpKTtcbiAgICAgICAgICAgIGlmICh0aGF0LmMuZ3JleXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwcmVEZWZpbmVkIHZhbHVlIHRoZW4gYWRkIGl0XG4gICAgICAgICAgICBpZiAocHJlRGVmaW5lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsLnZhbChwcmVEZWZpbmVkWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkIHJlc3BvbnNpdmUgZnVuY3Rpb25hbGl0eSB0byB0aGUgbG9naWMgYnV0dG9uIHdpdGhvdXQgcmVkcmF3aW5nIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgdGhhdC5zLmR0Lm9uZSgnZHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdMb2dpYycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIENyaXRlcmlhLmluaXROb1ZhbHVlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkIHJlc3BvbnNpdmUgZnVuY3Rpb25hbGl0eSB0byB0aGUgbG9naWMgYnV0dG9uIHdpdGhvdXQgcmVkcmF3aW5nIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgdGhhdC5zLmR0Lm9uZSgnZHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdMb2dpYycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENyaXRlcmlhLmluaXQyRGF0ZSA9IGZ1bmN0aW9uICh0aGF0LCBmbiwgcHJlRGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChwcmVEZWZpbmVkID09PSB2b2lkIDApIHsgcHJlRGVmaW5lZCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBzZWFyY2hEZWxheSA9IHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLnNlYXJjaERlbGF5O1xuICAgICAgICAgICAgLy8gRGVjbGFyZSBhbGwgb2YgdGhlIGRhdGUgZWxlbWVudHMgdGhhdCBhcmUgcmVxdWlyZWQgdXNpbmcgRGF0YVRhYmxlcyBkYXRlVGltZSBwbHVnaW5cbiAgICAgICAgICAgIHZhciBlbHMgPSBbXG4gICAgICAgICAgICAgICAgJCQyKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5pbnB1dClcbiAgICAgICAgICAgICAgICAgICAgLmR0RGF0ZVRpbWUoe1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2hUbzogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGF0LnMuZGF0ZUZvcm1hdCA/IHRoYXQucy5kYXRlRm9ybWF0IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdjaGFuZ2UnLCBzZWFyY2hEZWxheSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9BcGkuX2ZuVGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBzZWFyY2hEZWxheSkgOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbih0aGF0LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbignaW5wdXQga2V5cHJlc3MnLCAhdGhhdC5jLmVudGVyU2VhcmNoICYmXG4gICAgICAgICAgICAgICAgICAgICEodGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0luaXQuc2VhcmNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9Jbml0LnNlYXJjaFtcInJldHVyblwiXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vQXBpLl9mblRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbih0aGF0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VhcmNoRGVsYXkpIDpcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jLmVudGVyU2VhcmNoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vSW5pdC5zZWFyY2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9Jbml0LnNlYXJjaFtcInJldHVyblwiXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZS5rZXlDb2RlIHx8IGUud2hpY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKHRoYXQsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbih0aGF0LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAkJDIoJzxzcGFuPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGF0LmNsYXNzZXMuam9pbmVyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dCh0aGF0LnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci52YWx1ZUpvaW5lcicsIHRoYXQuYy5pMThuLnZhbHVlSm9pbmVyKSksXG4gICAgICAgICAgICAgICAgJCQyKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhDcml0ZXJpYS5jbGFzc2VzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5pbnB1dClcbiAgICAgICAgICAgICAgICAgICAgLmR0RGF0ZVRpbWUoe1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2hUbzogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGF0LnMuZGF0ZUZvcm1hdCA/IHRoYXQucy5kYXRlRm9ybWF0IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdjaGFuZ2UnLCBzZWFyY2hEZWxheSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9BcGkuX2ZuVGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBzZWFyY2hEZWxheSkgOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbih0aGF0LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbignaW5wdXQga2V5cHJlc3MnLCAhdGhhdC5jLmVudGVyU2VhcmNoICYmXG4gICAgICAgICAgICAgICAgICAgICEodGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0luaXQuc2VhcmNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9Jbml0LnNlYXJjaFtcInJldHVyblwiXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vQXBpLl9mblRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbih0aGF0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VhcmNoRGVsYXkpIDpcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jLmVudGVyU2VhcmNoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vSW5pdC5zZWFyY2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9Jbml0LnNlYXJjaFtcInJldHVyblwiXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZS5rZXlDb2RlIHx8IGUud2hpY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKHRoYXQsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbih0aGF0LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICh0aGF0LmMuZ3JleXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgZWxzWzBdLmFkZENsYXNzKENyaXRlcmlhLmNsYXNzZXMuZ3JleXNjYWxlKTtcbiAgICAgICAgICAgICAgICBlbHNbMl0uYWRkQ2xhc3MoQ3JpdGVyaWEuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFuZCBwcmVEZWZpbmVkIHZhbHVlcyB0aGVuIGFkZCB0aGVtXG4gICAgICAgICAgICBpZiAocHJlRGVmaW5lZCAhPT0gbnVsbCAmJiBwcmVEZWZpbmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlbHNbMF0udmFsKHByZURlZmluZWRbMF0pO1xuICAgICAgICAgICAgICAgIGVsc1syXS52YWwocHJlRGVmaW5lZFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFkZCByZXNwb25zaXZlIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGxvZ2ljIGJ1dHRvbiB3aXRob3V0IHJlZHJhd2luZyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIHRoYXQucy5kdC5vbmUoJ2RyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zLnRvcEdyb3VwLnRyaWdnZXIoJ2R0c2ItcmVkcmF3TG9naWMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVscztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgZnVuY3Rpb24gZm9yIHNlbGVjdCBlbGVtZW50cyB0byB2YWxpZGF0ZSBjb25kaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGFsbEZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBDaGVjayBlYWNoIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIHZhbGlkXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVsXzEgPSBlbDsgX2kgPCBlbF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxfMVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4oJ29wdGlvbjpzZWxlY3RlZCcpLmxlbmd0aCA9PT1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbignb3B0aW9uJykubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4oJ29wdGlvbi4nICsgQ3JpdGVyaWEuY2xhc3Nlcy5ub3RJdGFsaWMpLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuKCdvcHRpb246c2VsZWN0ZWQnKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbignb3B0aW9uOnNlbGVjdGVkJylbMF0gPT09IGVsZW1lbnQuY2hpbGRyZW4oJ29wdGlvbjpoaWRkZW4nKVswXSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxGaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsRmlsbGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBmdW5jdGlvbiBmb3IgaW5wdXQgYW5kIGRhdGUgZWxlbWVudHMgdG8gdmFsaWRhdGUgY29uZGl0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGFsbEZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBDaGVjayBlYWNoIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGlucHV0cyBhcmUgdmFsaWRcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZWxfMiA9IGVsOyBfaSA8IGVsXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbF8yW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pcygnaW5wdXQnKSAmJiBlbGVtZW50LnZhbCgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxGaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsRmlsbGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBmdW5jdGlvbiBmb3IgZ2V0dGluZyBzZWxlY3QgY29uZGl0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgc2VsZWN0IGVsZW1lbnRzIGFuZCBwdXNoIGVhY2ggc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZWxfMyA9IGVsOyBfaSA8IGVsXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbF8zW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pcygnc2VsZWN0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW1lbnQuY2hpbGRyZW4oJ29wdGlvbjpzZWxlY3RlZCcpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZSBvZiB0aGUgb3B0aW9uIGlzIGFuIGFycmF5IHdlIG5lZWQgdG8gc3BsaXQgaXQgdXAgYW5kIHNvcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZWxlbWVudC5jaGlsZHJlbignb3B0aW9uOnNlbGVjdGVkJykuYXR0cigndHlwZScpID09PSAnQXJyYXknID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5zcGxpdCgnLCcpLnNvcnQoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGZ1bmN0aW9uIGZvciBnZXR0aW5nIGlucHV0IGNvbmRpdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgaW5wdXQgZWxlbWVudHMgYW5kIHB1c2ggZWFjaCB2YWx1ZSB0byB0aGUgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVsXzQgPSBlbDsgX2kgPCBlbF80Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxfNFtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaXMoJ2lucHV0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZWxlbWVudC52YWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgcnVuIG9uIGVhY2ggZWxlbWVudCBhcyBhIGNhbGwgYmFjayB3aGVuIGEgc2VhcmNoIHNob3VsZCBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICovXG4gICAgICAgIENyaXRlcmlhLnVwZGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gKHRoYXQsIGVsKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIHRoZSBjcml0ZXJpYSBpcyBub3cgY29tcGxldGUgc28gY2FuIGJlIGluY2x1ZGVkIGluIHNlYXJjaGVzXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbmRpdGlvbiBmcm9tIHRoZSBtYXAgYmFzZWQgb24gdGhlIGtleSB0aGF0IGhhcyBiZWVuIHNlbGVjdGVkIGZvciB0aGUgY29uZGl0aW9uXG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhhdC5zLmNvbmRpdGlvbnNbdGhhdC5zLmNvbmRpdGlvbl07XG4gICAgICAgICAgICB0aGF0LnMuZmlsbGVkID0gY29uZGl0aW9uLmlzSW5wdXRWYWxpZCh0aGF0LmRvbS52YWx1ZSwgdGhhdCk7XG4gICAgICAgICAgICB0aGF0LnMudmFsdWUgPSBjb25kaXRpb24uaW5wdXRWYWx1ZSh0aGF0LmRvbS52YWx1ZSwgdGhhdCk7XG4gICAgICAgICAgICBpZiAoIXRoYXQucy5maWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnMuZHQuZHJhdygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGF0LnMudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zLnZhbHVlID0gW3RoYXQucy52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQucy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSB3ZSBuZWVkIHRvIHNvcnQgaXRcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGF0LnMudmFsdWVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucy52YWx1ZVtpXS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXBsYWNlIHRoZSBkZWNpbWFsIHBsYWNlIGNoYXJhY3RlciBmb3IgaTE4blxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoYXQucy50eXBlLmluY2x1ZGVzKCdudW0nKSAmJlxuICAgICAgICAgICAgICAgICAgICAodGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNEZWNpbWFsICE9PSAnJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLnNUaG91c2FuZHMgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRSRCA9IFt0aGF0LnMudmFsdWVbaV0udG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vTGFuZ3VhZ2Uuc0RlY2ltYWwgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdFJEID0gdGhhdC5zLnZhbHVlW2ldLnNwbGl0KHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zRGVjaW1hbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucy5kdC5zZXR0aW5ncygpWzBdLm9MYW5ndWFnZS5zVGhvdXNhbmRzICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcGxpdFJELmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRSRFtqXSA9IHNwbGl0UkRbal0ucmVwbGFjZSh0aGF0LnMuZHQuc2V0dGluZ3MoKVswXS5vTGFuZ3VhZ2Uuc1Rob3VzYW5kcywgJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGF0LnMudmFsdWVbaV0gPSBzcGxpdFJELmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUYWtlIG5vdGUgb2YgdGhlIGN1cnNvciBwb3NpdGlvbiBzbyB0aGF0IHdlIGNhbiByZWZvY3VzIHRoZXJlIGxhdGVyXG4gICAgICAgICAgICB2YXIgaWR4ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjdXJzb3JQb3MgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmRvbS52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gdGhhdC5kb20udmFsdWVbaV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGlvblN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvclBvcyA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIHNlYXJjaFxuICAgICAgICAgICAgdGhhdC5zLmR0LmRyYXcoKTtcbiAgICAgICAgICAgIC8vIFJlZm9jdXMgdGhlIGVsZW1lbnQgYW5kIHNldCB0aGUgY29ycmVjdCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChpZHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmRvbS52YWx1ZVtpZHhdLnJlbW92ZUNsYXNzKHRoYXQuY2xhc3Nlcy5pdGFsaWMpO1xuICAgICAgICAgICAgICAgIHRoYXQuZG9tLnZhbHVlW2lkeF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yUG9zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZG9tLnZhbHVlW2lkeF1bMF0uc2V0U2VsZWN0aW9uUmFuZ2UoY3Vyc29yUG9zLCBjdXJzb3JQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHRoZSBjb25kaXRpb25zIHdpbGwgbWFrZSBlc2xpbnQgc2FkIDooXG4gICAgICAgIC8vIEhhcyB0byBiZSBpbiB0aGlzIG9yZGVyIHNvIHRoYXQgdGhleSBhcmUgZGlzcGxheWVkIGNvcnJlY3RseSBpbiBzZWxlY3QgZWxlbWVudHNcbiAgICAgICAgLy8gQWxzbyBoYXZlIHRvIGRpc2FibGUgbWVtYmVyIG9yZGVyaW5nIGZvciB0aGlzIGFzIHRoZSBwcml2YXRlIG1ldGhvZHMgdXNlZCBhcmUgbm90IHlldCBkZWNsYXJlZCBvdGhlcndpc2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICAgICAgQ3JpdGVyaWEuZGF0ZUNvbmRpdGlvbnMgPSB7XG4gICAgICAgICAgICAnPSc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLmVxdWFscycsIGkxOG4uY29uZGl0aW9ucy5kYXRlLmVxdWFscyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0RGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC98LXwsKS9nLCAnLScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGNvbXBhcmlzb25bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICchPSc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLm5vdCcsIGkxOG4uY29uZGl0aW9ucy5kYXRlLm5vdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0RGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC98LXwsKS9nLCAnLScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGNvbXBhcmlzb25bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICc8Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUuYmVmb3JlJywgaTE4bi5jb25kaXRpb25zLmRhdGUuYmVmb3JlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXREYXRlLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcL3wtfCwpL2csICctJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IGNvbXBhcmlzb25bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICc+Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUuYWZ0ZXInLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5hZnRlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0RGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC98LXwsKS9nLCAnLScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiBjb21wYXJpc29uWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYmV0d2Vlbic6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLmJldHdlZW4nLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5iZXR3ZWVuKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXQyRGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC98LXwsKS9nLCAnLScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvblswXSA8IGNvbXBhcmlzb25bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uWzBdIDw9IHZhbHVlICYmIHZhbHVlIDw9IGNvbXBhcmlzb25bMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvblsxXSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBjb21wYXJpc29uWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICchYmV0d2Vlbic6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLm5vdEJldHdlZW4nLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5ub3RCZXR3ZWVuKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXQyRGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC98LXwsKS9nLCAnLScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvblswXSA8IGNvbXBhcmlzb25bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKGNvbXBhcmlzb25bMF0gPD0gdmFsdWUgJiYgdmFsdWUgPD0gY29tcGFyaXNvblsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShjb21wYXJpc29uWzFdIDw9IHZhbHVlICYmIHZhbHVlIDw9IGNvbXBhcmlzb25bMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUuZW1wdHknLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5lbXB0eSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0Tm9WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyFudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUubm90RW1wdHknLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5ub3RFbXB0eSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0Tm9WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgY29uZGl0aW9ucyB3aWxsIG1ha2UgZXNsaW50IHNhZCA6KFxuICAgICAgICAvLyBIYXMgdG8gYmUgaW4gdGhpcyBvcmRlciBzbyB0aGF0IHRoZXkgYXJlIGRpc3BsYXllZCBjb3JyZWN0bHkgaW4gc2VsZWN0IGVsZW1lbnRzXG4gICAgICAgIC8vIEFsc28gaGF2ZSB0byBkaXNhYmxlIG1lbWJlciBvcmRlcmluZyBmb3IgdGhpcyBhcyB0aGUgcHJpdmF0ZSBtZXRob2RzIHVzZWQgYXJlIG5vdCB5ZXQgZGVjbGFyZWQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgICAgIENyaXRlcmlhLm1vbWVudERhdGVDb25kaXRpb25zID0ge1xuICAgICAgICAgICAgJz0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuZGF0ZS5lcXVhbHMnLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5lcXVhbHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdERhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSwgdGhhdC5zLmRhdGVGb3JtYXQpLnZhbHVlT2YoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudChjb21wYXJpc29uWzBdLCB0aGF0LnMuZGF0ZUZvcm1hdCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIT0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuZGF0ZS5ub3QnLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5ub3QpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdERhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSwgdGhhdC5zLmRhdGVGb3JtYXQpLnZhbHVlT2YoKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudChjb21wYXJpc29uWzBdLCB0aGF0LnMuZGF0ZUZvcm1hdCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLmJlZm9yZScsIGkxOG4uY29uZGl0aW9ucy5kYXRlLmJlZm9yZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0RGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbiwgdGhhdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KHZhbHVlLCB0aGF0LnMuZGF0ZUZvcm1hdCkudmFsdWVPZigpIDwgbW9tZW50KGNvbXBhcmlzb25bMF0sIHRoYXQucy5kYXRlRm9ybWF0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICc+Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUuYWZ0ZXInLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5hZnRlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0RGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbiwgdGhhdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KHZhbHVlLCB0aGF0LnMuZGF0ZUZvcm1hdCkudmFsdWVPZigpID4gbW9tZW50KGNvbXBhcmlzb25bMF0sIHRoYXQucy5kYXRlRm9ybWF0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdiZXR3ZWVuJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUuYmV0d2VlbicsIGkxOG4uY29uZGl0aW9ucy5kYXRlLmJldHdlZW4pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdDJEYXRlLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uLCB0aGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtb21lbnQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wMCA9IG1vbWVudChjb21wYXJpc29uWzBdLCB0aGF0LnMuZGF0ZUZvcm1hdCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcDEgPSBtb21lbnQoY29tcGFyaXNvblsxXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAwIDwgY29tcDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wMCA8PSB2YWwgJiYgdmFsIDw9IGNvbXAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAxIDw9IHZhbCAmJiB2YWwgPD0gY29tcDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyFiZXR3ZWVuJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUubm90QmV0d2VlbicsIGkxOG4uY29uZGl0aW9ucy5kYXRlLm5vdEJldHdlZW4pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdDJEYXRlLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uLCB0aGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtb21lbnQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wMCA9IG1vbWVudChjb21wYXJpc29uWzBdLCB0aGF0LnMuZGF0ZUZvcm1hdCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcDEgPSBtb21lbnQoY29tcGFyaXNvblsxXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAwIDwgY29tcDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCtjb21wMCA8PSArdmFsICYmICt2YWwgPD0gK2NvbXAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCtjb21wMSA8PSArdmFsICYmICt2YWwgPD0gK2NvbXAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbnVsbCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLmVtcHR5JywgaTE4bi5jb25kaXRpb25zLmRhdGUuZW1wdHkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdE5vVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICchbnVsbCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLm5vdEVtcHR5JywgaTE4bi5jb25kaXRpb25zLmRhdGUubm90RW1wdHkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdE5vVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGNvbmRpdGlvbnMgd2lsbCBtYWtlIGVzbGludCBzYWQgOihcbiAgICAgICAgLy8gSGFzIHRvIGJlIGluIHRoaXMgb3JkZXIgc28gdGhhdCB0aGV5IGFyZSBkaXNwbGF5ZWQgY29ycmVjdGx5IGluIHNlbGVjdCBlbGVtZW50c1xuICAgICAgICAvLyBBbHNvIGhhdmUgdG8gZGlzYWJsZSBtZW1iZXIgb3JkZXJpbmcgZm9yIHRoaXMgYXMgdGhlIHByaXZhdGUgbWV0aG9kcyB1c2VkIGFyZSBub3QgeWV0IGRlY2xhcmVkIG90aGVyd2lzZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgICAgICBDcml0ZXJpYS5sdXhvbkRhdGVDb25kaXRpb25zID0ge1xuICAgICAgICAgICAgJz0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuZGF0ZS5lcXVhbHMnLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5lcXVhbHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdERhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS50c1xuICAgICAgICAgICAgICAgICAgICAgICAgPT09IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoY29tcGFyaXNvblswXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIT0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuZGF0ZS5ub3QnLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5ub3QpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdERhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS50c1xuICAgICAgICAgICAgICAgICAgICAgICAgIT09IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoY29tcGFyaXNvblswXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLmJlZm9yZScsIGkxOG4uY29uZGl0aW9ucy5kYXRlLmJlZm9yZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0RGF0ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbiwgdGhhdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbHV4b24uRGF0ZVRpbWUuZnJvbUZvcm1hdCh2YWx1ZSwgdGhhdC5zLmRhdGVGb3JtYXQpLnRzXG4gICAgICAgICAgICAgICAgICAgICAgICA8IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoY29tcGFyaXNvblswXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPic6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5kYXRlLmFmdGVyJywgaTE4bi5jb25kaXRpb25zLmRhdGUuYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdERhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS50c1xuICAgICAgICAgICAgICAgICAgICAgICAgPiBsdXhvbi5EYXRlVGltZS5mcm9tRm9ybWF0KGNvbXBhcmlzb25bMF0sIHRoYXQucy5kYXRlRm9ybWF0KS50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2JldHdlZW4nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuZGF0ZS5iZXR3ZWVuJywgaTE4bi5jb25kaXRpb25zLmRhdGUuYmV0d2Vlbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0MkRhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAwID0gbHV4b24uRGF0ZVRpbWUuZnJvbUZvcm1hdChjb21wYXJpc29uWzBdLCB0aGF0LnMuZGF0ZUZvcm1hdCkudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wMSA9IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoY29tcGFyaXNvblsxXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcDAgPCBjb21wMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAwIDw9IHZhbCAmJiB2YWwgPD0gY29tcDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDEgPD0gdmFsICYmIHZhbCA8PSBjb21wMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIWJldHdlZW4nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuZGF0ZS5ub3RCZXR3ZWVuJywgaTE4bi5jb25kaXRpb25zLmRhdGUubm90QmV0d2Vlbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0MkRhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24sIHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQodmFsdWUsIHRoYXQucy5kYXRlRm9ybWF0KS50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAwID0gbHV4b24uRGF0ZVRpbWUuZnJvbUZvcm1hdChjb21wYXJpc29uWzBdLCB0aGF0LnMuZGF0ZUZvcm1hdCkudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wMSA9IGx1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoY29tcGFyaXNvblsxXSwgdGhhdC5zLmRhdGVGb3JtYXQpLnRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcDAgPCBjb21wMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoK2NvbXAwIDw9ICt2YWwgJiYgK3ZhbCA8PSArY29tcDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoK2NvbXAxIDw9ICt2YWwgJiYgK3ZhbCA8PSArY29tcDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUuZW1wdHknLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5lbXB0eSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0Tm9WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyFudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmRhdGUubm90RW1wdHknLCBpMThuLmNvbmRpdGlvbnMuZGF0ZS5ub3RFbXB0eSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0Tm9WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgY29uZGl0aW9ucyB3aWxsIG1ha2UgZXNsaW50IHNhZCA6KFxuICAgICAgICAvLyBIYXMgdG8gYmUgaW4gdGhpcyBvcmRlciBzbyB0aGF0IHRoZXkgYXJlIGRpc3BsYXllZCBjb3JyZWN0bHkgaW4gc2VsZWN0IGVsZW1lbnRzXG4gICAgICAgIC8vIEFsc28gaGF2ZSB0byBkaXNhYmxlIG1lbWJlciBvcmRlcmluZyBmb3IgdGhpcyBhcyB0aGUgcHJpdmF0ZSBtZXRob2RzIHVzZWQgYXJlIG5vdCB5ZXQgZGVjbGFyZWQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgICAgIENyaXRlcmlhLm51bUNvbmRpdGlvbnMgPSB7XG4gICAgICAgICAgICAnPSc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5udW1iZXIuZXF1YWxzJywgaTE4bi5jb25kaXRpb25zLm51bWJlci5lcXVhbHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdFNlbGVjdCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlU2VsZWN0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkU2VsZWN0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArdmFsdWUgPT09ICtjb21wYXJpc29uWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIT0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLm5vdCcsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIubm90KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRTZWxlY3QsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlICE9PSArY29tcGFyaXNvblswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJzwnOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLmx0JywgaTE4bi5jb25kaXRpb25zLm51bWJlci5sdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0SW5wdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICt2YWx1ZSA8ICtjb21wYXJpc29uWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPD0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLmx0ZScsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIubHRlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlIDw9ICtjb21wYXJpc29uWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPj0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLmd0ZScsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIuZ3RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlID49ICtjb21wYXJpc29uWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnPic6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5udW1iZXIuZ3QnLCBpMThuLmNvbmRpdGlvbnMubnVtYmVyLmd0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlID4gK2NvbXBhcmlzb25bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdiZXR3ZWVuJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLm51bWJlci5iZXR3ZWVuJywgaTE4bi5jb25kaXRpb25zLm51bWJlci5iZXR3ZWVuKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXQySW5wdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjb21wYXJpc29uWzBdIDwgK2NvbXBhcmlzb25bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArY29tcGFyaXNvblswXSA8PSArdmFsdWUgJiYgK3ZhbHVlIDw9ICtjb21wYXJpc29uWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtjb21wYXJpc29uWzFdIDw9ICt2YWx1ZSAmJiArdmFsdWUgPD0gK2NvbXBhcmlzb25bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyFiZXR3ZWVuJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLm51bWJlci5ub3RCZXR3ZWVuJywgaTE4bi5jb25kaXRpb25zLm51bWJlci5ub3RCZXR3ZWVuKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXQySW5wdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjb21wYXJpc29uWzBdIDwgK2NvbXBhcmlzb25bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCtjb21wYXJpc29uWzBdIDw9ICt2YWx1ZSAmJiArdmFsdWUgPD0gK2NvbXBhcmlzb25bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoK2NvbXBhcmlzb25bMV0gPD0gK3ZhbHVlICYmICt2YWx1ZSA8PSArY29tcGFyaXNvblswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ251bGwnOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLmVtcHR5JywgaTE4bi5jb25kaXRpb25zLm51bWJlci5lbXB0eSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0Tm9WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyFudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLm51bWJlci5ub3RFbXB0eScsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIubm90RW1wdHkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdE5vVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGNvbmRpdGlvbnMgd2lsbCBtYWtlIGVzbGludCBzYWQgOihcbiAgICAgICAgLy8gSGFzIHRvIGJlIGluIHRoaXMgb3JkZXIgc28gdGhhdCB0aGV5IGFyZSBkaXNwbGF5ZWQgY29ycmVjdGx5IGluIHNlbGVjdCBlbGVtZW50c1xuICAgICAgICAvLyBBbHNvIGhhdmUgdG8gZGlzYWJsZSBtZW1iZXIgb3JkZXJpbmcgZm9yIHRoaXMgYXMgdGhlIHByaXZhdGUgbWV0aG9kcyB1c2VkIGFyZSBub3QgeWV0IGRlY2xhcmVkIG90aGVyd2lzZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgICAgICBDcml0ZXJpYS5udW1GbXRDb25kaXRpb25zID0ge1xuICAgICAgICAgICAgJz0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLmVxdWFscycsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIuZXF1YWxzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRTZWxlY3QsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWUuaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmlzb25bMF0uaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIGNvbXBhcmlzb25bMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICt2YWwgPT09ICtjb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIT0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLm5vdCcsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIubm90KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRTZWxlY3QsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWUuaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmlzb25bMF0uaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIGNvbXBhcmlzb25bMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICt2YWwgIT09ICtjb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5udW1iZXIubHQnLCBpMThuLmNvbmRpdGlvbnMubnVtYmVyLmx0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWUuaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmlzb25bMF0uaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIGNvbXBhcmlzb25bMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICt2YWwgPCArY29tcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJzw9Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLm51bWJlci5sdGUnLCBpMThuLmNvbmRpdGlvbnMubnVtYmVyLmx0ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0SW5wdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHZhbHVlLmluZGV4T2YoJy0nKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnLScgKyB2YWx1ZS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAgPSBjb21wYXJpc29uWzBdLmluZGV4T2YoJy0nKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnLScgKyBjb21wYXJpc29uWzBdLnJlcGxhY2UoL1teMC05Ll0vZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmlzb25bMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArdmFsIDw9ICtjb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPj0nOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLmd0ZScsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIuZ3RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRJbnB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlSW5wdXQsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWUuaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmlzb25bMF0uaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIGNvbXBhcmlzb25bMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICt2YWwgPj0gK2NvbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICc+Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLm51bWJlci5ndCcsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIuZ3QpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdElucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB2YWx1ZS5pbmRleE9mKCctJykgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJy0nICsgdmFsdWUucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wID0gY29tcGFyaXNvblswXS5pbmRleE9mKCctJykgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJy0nICsgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uWzBdLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbCA+ICtjb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYmV0d2Vlbic6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5udW1iZXIuYmV0d2VlbicsIGkxOG4uY29uZGl0aW9ucy5udW1iZXIuYmV0d2Vlbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0MklucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB2YWx1ZS5pbmRleE9mKCctJykgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJy0nICsgdmFsdWUucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wMCA9IGNvbXBhcmlzb25bMF0uaW5kZXhPZignLScpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICctJyArIGNvbXBhcmlzb25bMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAxID0gY29tcGFyaXNvblsxXS5pbmRleE9mKCctJykgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJy0nICsgY29tcGFyaXNvblsxXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uWzFdLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoK2NvbXAwIDwgK2NvbXAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK2NvbXAwIDw9ICt2YWwgJiYgK3ZhbCA8PSArY29tcDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK2NvbXAxIDw9ICt2YWwgJiYgK3ZhbCA8PSArY29tcDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyFiZXR3ZWVuJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLm51bWJlci5ub3RCZXR3ZWVuJywgaTE4bi5jb25kaXRpb25zLm51bWJlci5ub3RCZXR3ZWVuKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXQySW5wdXQsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZUlucHV0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkSW5wdXQsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUsIGNvbXBhcmlzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHZhbHVlLmluZGV4T2YoJy0nKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnLScgKyB2YWx1ZS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAwID0gY29tcGFyaXNvblswXS5pbmRleE9mKCctJykgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJy0nICsgY29tcGFyaXNvblswXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uWzBdLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcDEgPSBjb21wYXJpc29uWzFdLmluZGV4T2YoJy0nKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnLScgKyBjb21wYXJpc29uWzFdLnJlcGxhY2UoL1teMC05Ll0vZywgJycpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmlzb25bMV0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrY29tcDAgPCArY29tcDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCtjb21wMCA8PSArdmFsICYmICt2YWwgPD0gK2NvbXAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCtjb21wMSA8PSArdmFsICYmICt2YWwgPD0gK2NvbXAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbnVsbCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5udW1iZXIuZW1wdHknLCBpMThuLmNvbmRpdGlvbnMubnVtYmVyLmVtcHR5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXROb1ZhbHVlLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIW51bGwnOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMubnVtYmVyLm5vdEVtcHR5JywgaTE4bi5jb25kaXRpb25zLm51bWJlci5ub3RFbXB0eSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0Tm9WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgY29uZGl0aW9ucyB3aWxsIG1ha2UgZXNsaW50IHNhZCA6KFxuICAgICAgICAvLyBIYXMgdG8gYmUgaW4gdGhpcyBvcmRlciBzbyB0aGF0IHRoZXkgYXJlIGRpc3BsYXllZCBjb3JyZWN0bHkgaW4gc2VsZWN0IGVsZW1lbnRzXG4gICAgICAgIC8vIEFsc28gaGF2ZSB0byBkaXNhYmxlIG1lbWJlciBvcmRlcmluZyBmb3IgdGhpcyBhcyB0aGUgcHJpdmF0ZSBtZXRob2RzIHVzZWQgYXJlIG5vdCB5ZXQgZGVjbGFyZWQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgICAgIENyaXRlcmlhLnN0cmluZ0NvbmRpdGlvbnMgPSB7XG4gICAgICAgICAgICAnPSc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5zdHJpbmcuZXF1YWxzJywgaTE4bi5jb25kaXRpb25zLnN0cmluZy5lcXVhbHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdFNlbGVjdCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlU2VsZWN0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkU2VsZWN0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gY29tcGFyaXNvblswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJyE9Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLnN0cmluZy5ub3QnLCBpMThuLmNvbmRpdGlvbnMuc3RyaW5nLm5vdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0U2VsZWN0LFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVTZWxlY3QsXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBDcml0ZXJpYS5pc0lucHV0VmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGNvbXBhcmlzb25bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzdGFydHMnOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuc3RyaW5nLnN0YXJ0c1dpdGgnLCBpMThuLmNvbmRpdGlvbnMuc3RyaW5nLnN0YXJ0c1dpdGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdElucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoY29tcGFyaXNvblswXS50b0xvd2VyQ2FzZSgpKSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvcnQta2V5c1xuICAgICAgICAgICAgJ2NvbnRhaW5zJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLnN0cmluZy5jb250YWlucycsIGkxOG4uY29uZGl0aW9ucy5zdHJpbmcuY29udGFpbnMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdElucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGNvbXBhcmlzb25bMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdlbmRzJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLnN0cmluZy5lbmRzV2l0aCcsIGkxOG4uY29uZGl0aW9ucy5zdHJpbmcuZW5kc1dpdGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdElucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IENyaXRlcmlhLmlucHV0VmFsdWVJbnB1dCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZElucHV0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGNvbXBhcmlzb25bMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLnN0cmluZy5lbXB0eScsIGkxOG4uY29uZGl0aW9ucy5zdHJpbmcuZW1wdHkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdE5vVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICchbnVsbCc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5zdHJpbmcubm90RW1wdHknLCBpMThuLmNvbmRpdGlvbnMuc3RyaW5nLm5vdEVtcHR5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXROb1ZhbHVlLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPT09IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHRoZSBjb25kaXRpb25zIHdpbGwgbWFrZSBlc2xpbnQgc2FkIDooXG4gICAgICAgIC8vIEFsc28gaGF2ZSB0byBkaXNhYmxlIG1lbWJlciBvcmRlcmluZyBmb3IgdGhpcyBhcyB0aGUgcHJpdmF0ZSBtZXRob2RzIHVzZWQgYXJlIG5vdCB5ZXQgZGVjbGFyZWQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgICAgIENyaXRlcmlhLmFycmF5Q29uZGl0aW9ucyA9IHtcbiAgICAgICAgICAgICdjb250YWlucyc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5hcnJheS5jb250YWlucycsIGkxOG4uY29uZGl0aW9ucy5hcnJheS5jb250YWlucyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0U2VsZWN0QXJyYXksXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5jbHVkZXMoY29tcGFyaXNvblswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd3aXRob3V0Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmFycmF5LndpdGhvdXQnLCBpMThuLmNvbmRpdGlvbnMuYXJyYXkud2l0aG91dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbml0OiBDcml0ZXJpYS5pbml0U2VsZWN0QXJyYXksXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihjb21wYXJpc29uWzBdKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICc9Jzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmFycmF5LmVxdWFscycsIGkxOG4uY29uZGl0aW9ucy5hcnJheS5lcXVhbHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdFNlbGVjdCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBDcml0ZXJpYS5pbnB1dFZhbHVlU2VsZWN0LFxuICAgICAgICAgICAgICAgIGlzSW5wdXRWYWxpZDogQ3JpdGVyaWEuaXNJbnB1dFZhbGlkU2VsZWN0LFxuICAgICAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJpc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IGNvbXBhcmlzb25bMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldICE9PSBjb21wYXJpc29uWzBdW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWtleXNcbiAgICAgICAgICAgICchPSc6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25OYW1lOiBmdW5jdGlvbiAoZHQsIGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY29uZGl0aW9ucy5hcnJheS5ub3QnLCBpMThuLmNvbmRpdGlvbnMuYXJyYXkubm90KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXRTZWxlY3QsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogQ3JpdGVyaWEuaW5wdXRWYWx1ZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IENyaXRlcmlhLmlzSW5wdXRWYWxpZFNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29tcGFyaXNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBjb21wYXJpc29uWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSAhPT0gY29tcGFyaXNvblswXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdudWxsJzoge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbk5hbWU6IGZ1bmN0aW9uIChkdCwgaTE4bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHQuaTE4bignc2VhcmNoQnVpbGRlci5jb25kaXRpb25zLmFycmF5LmVtcHR5JywgaTE4bi5jb25kaXRpb25zLmFycmF5LmVtcHR5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IENyaXRlcmlhLmluaXROb1ZhbHVlLFxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNJbnB1dFZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC1rZXlzXG4gICAgICAgICAgICAnIW51bGwnOiB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uTmFtZTogZnVuY3Rpb24gKGR0LCBpMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmNvbmRpdGlvbnMuYXJyYXkubm90RW1wdHknLCBpMThuLmNvbmRpdGlvbnMuYXJyYXkubm90RW1wdHkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogQ3JpdGVyaWEuaW5pdE5vVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0lucHV0VmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggIT09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQgd2lsbCBiZSBzYWQgYmVjYXVzZSB3ZSBoYXZlIHRvIGRpc2FibGUgbWVtYmVyIG9yZGVyaW5nIGZvciB0aGlzIGFzIHRoZVxuICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzIHVzZWQgYXJlIG5vdCB5ZXQgZGVjbGFyZWQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgICAgIENyaXRlcmlhLmRlZmF1bHRzID0ge1xuICAgICAgICAgICAgY29sdW1uczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmRpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnYXJyYXknOiBDcml0ZXJpYS5hcnJheUNvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ2RhdGUnOiBDcml0ZXJpYS5kYXRlQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnaHRtbCc6IENyaXRlcmlhLnN0cmluZ0NvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ2h0bWwtbnVtJzogQ3JpdGVyaWEubnVtQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnaHRtbC1udW0tZm10JzogQ3JpdGVyaWEubnVtRm10Q29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbHV4b24nOiBDcml0ZXJpYS5sdXhvbkRhdGVDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICdtb21lbnQnOiBDcml0ZXJpYS5tb21lbnREYXRlQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbnVtJzogQ3JpdGVyaWEubnVtQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbnVtLWZtdCc6IENyaXRlcmlhLm51bUZtdENvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ3N0cmluZyc6IENyaXRlcmlhLnN0cmluZ0NvbmRpdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXB0aExpbWl0OiBmYWxzZSxcbiAgICAgICAgICAgIGVudGVyU2VhcmNoOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbHRlckNoYW5nZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGdyZXlzY2FsZTogZmFsc2UsXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgICAgYWRkOiAnQWRkIENvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIDA6ICdTZWFyY2ggQnVpbGRlcicsXG4gICAgICAgICAgICAgICAgICAgIF86ICdTZWFyY2ggQnVpbGRlciAoJWQpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xlYXJBbGw6ICdDbGVhciBBbGwnLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogJ0NvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgZGF0YTogJ0RhdGEnLFxuICAgICAgICAgICAgICAgIGRlbGV0ZVRpdGxlOiAnRGVsZXRlIGZpbHRlcmluZyBydWxlJyxcbiAgICAgICAgICAgICAgICBsZWZ0VGl0bGU6ICdPdXRkZW50IGNyaXRlcmlhJyxcbiAgICAgICAgICAgICAgICBsb2dpY0FuZDogJ0FuZCcsXG4gICAgICAgICAgICAgICAgbG9naWNPcjogJ09yJyxcbiAgICAgICAgICAgICAgICByaWdodFRpdGxlOiAnSW5kZW50IGNyaXRlcmlhJyxcbiAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICAwOiAnQ3VzdG9tIFNlYXJjaCBCdWlsZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXzogJ0N1c3RvbSBTZWFyY2ggQnVpbGRlciAoJWQpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdWYWx1ZScsXG4gICAgICAgICAgICAgICAgdmFsdWVKb2luZXI6ICdhbmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9naWM6ICdBTkQnLFxuICAgICAgICAgICAgb3J0aG9nb25hbDoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgICAgICAgICAgICAgICBzZWFyY2g6ICdmaWx0ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlRGVmaW5lZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENyaXRlcmlhO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgJCQxO1xuICAgIHZhciBkYXRhVGFibGUkMTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBqUXVlcnkgZm9yIHVzZSBpbiB0aGUgZmlsZVxuICAgICAqXG4gICAgICogQHBhcmFtIGpxIHRoZSBpbnN0YW5jZSBvZiBqUXVlcnkgdG8gYmUgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0SlF1ZXJ5JDEoanEpIHtcbiAgICAgICAgJCQxID0ganE7XG4gICAgICAgIGRhdGFUYWJsZSQxID0ganEuZm4uZGF0YVRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgR3JvdXAgY2xhc3MgaXMgdXNlZCB3aXRoaW4gU2VhcmNoQnVpbGRlciB0byByZXByZXNlbnQgYSBncm91cCBvZiBjcml0ZXJpYVxuICAgICAqL1xuICAgIHZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAodGFibGUsIG9wdHMsIHRvcEdyb3VwLCBpbmRleCwgaXNDaGlsZCwgZGVwdGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxuICAgICAgICAgICAgaWYgKGlzQ2hpbGQgPT09IHZvaWQgMCkgeyBpc0NoaWxkID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7IGRlcHRoID0gMTsgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVxdWlyZWQgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGluY2x1ZGVkXG4gICAgICAgICAgICBpZiAoIWRhdGFUYWJsZSQxIHx8ICFkYXRhVGFibGUkMS52ZXJzaW9uQ2hlY2sgfHwgIWRhdGFUYWJsZSQxLnZlcnNpb25DaGVjaygnMS4xMC4wJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlYXJjaEJ1aWxkZXIgcmVxdWlyZXMgRGF0YVRhYmxlcyAxLjEwIG9yIG5ld2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSAkJDEuZXh0ZW5kKHRydWUsIHt9LCBHcm91cC5jbGFzc2VzKTtcbiAgICAgICAgICAgIC8vIEdldCBvcHRpb25zIGZyb20gdXNlclxuICAgICAgICAgICAgdGhpcy5jID0gJCQxLmV4dGVuZCh0cnVlLCB7fSwgR3JvdXAuZGVmYXVsdHMsIG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5zID0ge1xuICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBbXSxcbiAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICAgICAgZHQ6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBpc0NoaWxkOiBpc0NoaWxkLFxuICAgICAgICAgICAgICAgIGxvZ2ljOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgICAgICAgICBwcmV2ZW50UmVkcmF3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b0Ryb3A6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0b3BHcm91cDogdG9wR3JvdXBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRvbSA9IHtcbiAgICAgICAgICAgICAgICBhZGQ6ICQkMSgnPGJ1dHRvbi8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5hZGQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKSxcbiAgICAgICAgICAgICAgICBjbGVhcjogJCQxKCc8YnV0dG9uPiZ0aW1lczwvYnV0dG9uPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmNsZWFyR3JvdXApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogJCQxKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmdyb3VwKSxcbiAgICAgICAgICAgICAgICBsb2dpYzogJCQxKCc8YnV0dG9uPjxkaXYvPjwvYnV0dG9uPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMubG9naWMpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKSxcbiAgICAgICAgICAgICAgICBsb2dpY0NvbnRhaW5lcjogJCQxKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmxvZ2ljQ29udGFpbmVyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSB0b3AgbGV2ZWwgZ3JvdXAgaXMgbWFpbnRhaW5lZCB0aHJvdWdob3V0IGFueSBzdWJncm91cHMgYW5kIGNyaXRlcmlhIHRoYXQgbWF5IGJlIGNyZWF0ZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnMudG9wR3JvdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucy50b3BHcm91cCA9IHRoaXMuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIGdyb3VwcyBidXR0b25zLCBjbGVhcnMgdGhlIGludGVybmFsIGNyaXRlcmlhIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGRvbVxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUdXJuIG9mZiBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZC5vZmYoJy5kdHNiJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5sb2dpYy5vZmYoJy5kdHNiJyk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGV2ZW50IGZvciBncm91cHMgYXQgYSBoaWdoZXIgbGV2ZWwgdG8gcGljayB1cCBvblxuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoJ2R0c2ItZGVzdHJveScpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZXRhaWxzIHJlcXVpcmVkIHRvIHJlYnVpbGQgdGhlIGdyb3VwXG4gICAgICAgICAqL1xuICAgICAgICAvLyBFc2xpbnQgdXBzZXQgYXQgZW1wdHkgb2JqZWN0IGJ1dCBuZWVkcyB0byBiZSBkb25lXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5nZXREZXRhaWxzID0gZnVuY3Rpb24gKGRlRm9ybWF0RGF0ZXMpIHtcbiAgICAgICAgICAgIGlmIChkZUZvcm1hdERhdGVzID09PSB2b2lkIDApIHsgZGVGb3JtYXREYXRlcyA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5zLmNyaXRlcmlhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBbXSxcbiAgICAgICAgICAgICAgICBsb2dpYzogdGhpcy5zLmxvZ2ljXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTk9URSBoZXJlIGNyaXQgY291bGQgYmUgZWl0aGVyIGEgc3ViZ3JvdXAgb3IgYSBjcml0ZXJpYVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5jcml0ZXJpYTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLmNyaXRlcmlhLnB1c2goY3JpdC5jcml0ZXJpYS5nZXREZXRhaWxzKGRlRm9ybWF0RGF0ZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgbm9kZSBmb3IgdGhlIGNvbnRhaW5lciBvZiB0aGUgZ3JvdXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgTm9kZSBmb3IgdGhlIGNvbnRhaW5lciBvZiB0aGUgZ3JvdXBcbiAgICAgICAgICovXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYnVpbGRzIHRoZSBncm91cCBiYXNlZCB1cG9uIHRoZSBkZXRhaWxzIHBhc3NlZCBpblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVkRGV0YWlscyB0aGUgZGV0YWlscyByZXF1aXJlZCB0byByZWJ1aWxkIHRoZSBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnJlYnVpbGQgPSBmdW5jdGlvbiAobG9hZGVkRGV0YWlscykge1xuICAgICAgICAgICAgLy8gSWYgbm8gY3JpdGVyaWEgYXJlIHN0b3JlZCB0aGVuIGp1c3QgcmV0dXJuXG4gICAgICAgICAgICBpZiAobG9hZGVkRGV0YWlscy5jcml0ZXJpYSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgbG9hZGVkRGV0YWlscy5jcml0ZXJpYSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobG9hZGVkRGV0YWlscy5jcml0ZXJpYSkgJiYgbG9hZGVkRGV0YWlscy5jcml0ZXJpYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnMubG9naWMgPSBsb2FkZWREZXRhaWxzLmxvZ2ljO1xuICAgICAgICAgICAgdGhpcy5kb20ubG9naWMuY2hpbGRyZW4oKS5maXJzdCgpLnRleHQodGhpcy5zLmxvZ2ljID09PSAnT1InXG4gICAgICAgICAgICAgICAgPyB0aGlzLnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci5sb2dpY09yJywgdGhpcy5jLmkxOG4ubG9naWNPcilcbiAgICAgICAgICAgICAgICA6IHRoaXMucy5kdC5pMThuKCdzZWFyY2hCdWlsZGVyLmxvZ2ljQW5kJywgdGhpcy5jLmkxOG4ubG9naWNBbmQpKTtcbiAgICAgICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIGNyaXRlcmlhLCBiZSBpdCBhIHN1YiBncm91cCBvciBhIGNyaXRlcmlhXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsb2FkZWREZXRhaWxzLmNyaXRlcmlhKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBsb2FkZWREZXRhaWxzLmNyaXRlcmlhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyaXQubG9naWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUHJldkdyb3VwKGNyaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyaXQubG9naWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUHJldkNyaXRlcmlhKGNyaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIGFsbCBvZiB0aGUgY3JpdGVyaWEgY2hpbGRyZW4sIHVwZGF0ZSB0aGUgYXJyb3dzIGluY2FzZSB0aGV5IHJlcXVpcmUgY2hhbmdpbmcgYW5kIHNldCB0aGUgbGlzdGVuZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5zLmNyaXRlcmlhOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBjcml0ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChjcml0LmNyaXRlcmlhIGluc3RhbmNlb2YgQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JpdC5jcml0ZXJpYS51cGRhdGVBcnJvd3ModGhpcy5zLmNyaXRlcmlhLmxlbmd0aCA+IDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3JpdGVyaWFMaXN0ZW5lcnMoY3JpdC5jcml0ZXJpYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVkcmF3cyB0aGUgQ29udGVudHMgb2YgdGhlIHNlYXJjaEJ1aWxkZXIgR3JvdXBzIGFuZCBDcml0ZXJpYVxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnJlZHJhd0NvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucy5wcmV2ZW50UmVkcmF3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbnRhaW5lciBvdXQgYW5kIGFkZCB0aGUgYmFzaWMgZWxlbWVudHNcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5jaGlsZHJlbigpLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLmRvbS5sb2dpY0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuZG9tLmFkZCk7XG4gICAgICAgICAgICAvLyBTb3J0IHRoZSBjcml0ZXJpYSBieSBpbmRleCBzbyB0aGF0IHRoZXkgYXBwZWFyIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhLmNyaXRlcmlhLnMuaW5kZXggPCBiLmNyaXRlcmlhLnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhLmNyaXRlcmlhLnMuaW5kZXggPiBiLmNyaXRlcmlhLnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldExpc3RlbmVycygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnMuY3JpdGVyaWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IHRoaXMucy5jcml0ZXJpYVtpXS5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICBpZiAoY3JpdCBpbnN0YW5jZW9mIENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBpbmRleCB0byB0aGUgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5jcml0ZXJpYVtpXS5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5jcml0ZXJpYVtpXS5jcml0ZXJpYS5zLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBncm91cFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWFbaV0uY3JpdGVyaWEuZG9tLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5kb20uYWRkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxpc3RlbmVycyBmb3IgdmFyaW91cyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3JpdGVyaWFMaXN0ZW5lcnMoY3JpdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5jcml0ZXJpYVtpXS5jcml0ZXJpYS5yZWJ1aWxkKHRoaXMucy5jcml0ZXJpYVtpXS5jcml0ZXJpYS5nZXREZXRhaWxzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjcml0IGluc3RhbmNlb2YgR3JvdXAgJiYgY3JpdC5zLmNyaXRlcmlhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IHRvIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhW2ldLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhW2ldLmNyaXRlcmlhLnMuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHN1YiBncm91cCB0byB0aGUgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhW2ldLmNyaXRlcmlhLmRvbS5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLmFkZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZHJhdyB0aGUgY29udGVudHMgb2YgdGhlIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGNyaXQucmVkcmF3Q29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0R3JvdXBMaXN0ZW5lcnMoY3JpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ3JvdXAgaXMgZW1wdHkgc28gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5jcml0ZXJpYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHVwTG9naWMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZXMgdGhlIGxvZ2ljIGJ1dHRvbiBvbmx5IHJhdGhlciB0aGFuIHRoZSBlbnRpcmUgZG9tLlxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnJlZHJhd0xvZ2ljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5jcml0ZXJpYTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoY3JpdCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXQucmVkcmF3TG9naWMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHVwTG9naWMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaCBtZXRob2QsIGNoZWNraW5nIHRoZSByb3cgZGF0YSBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBpbiB0aGUgZ3JvdXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvd0RhdGEgVGhlIHJvdyBkYXRhIHRvIGJlIGNvbXBhcmVkXG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW4gVGhlIHJlc3VsdCBvZiB0aGUgc2VhcmNoXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHJvd0RhdGEsIHJvd0lkeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucy5sb2dpYyA9PT0gJ0FORCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5kU2VhcmNoKHJvd0RhdGEsIHJvd0lkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnMubG9naWMgPT09ICdPUicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JTZWFyY2gocm93RGF0YSwgcm93SWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyB0aGUgZ3JvdXBzIGxvZ2ljIGJ1dHRvbiB0byB0aGUgY29ycmVjdCBsb2NhdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnNldHVwTG9naWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgbG9naWMgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLmRvbS5sb2dpY0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyLnJlbW92ZSgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNyaXRlcmlhIGluIHRoZSBncm91cCB0aGVuIGtlZXAgdGhlIGxvZ2ljIHJlbW92ZWQgYW5kIHJldHVyblxuICAgICAgICAgICAgaWYgKHRoaXMucy5jcml0ZXJpYS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnMuaXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIudHJpZ2dlcignZHRzYi1kZXN0cm95Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBjcml0ZXJpYSBsZWZ0IG1hcmdpblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuY3NzKCdtYXJnaW4tbGVmdCcsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgd2lkdGgsIHRha2UgMiBmb3IgdGhlIGJvcmRlclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZG9tLmNvbnRhaW5lci5oZWlnaHQoKSAtIDE7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGVhci5oZWlnaHQoJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5kb20ubG9naWNDb250YWluZXIuYXBwZW5kKHRoaXMuZG9tLmNsZWFyKS53aWR0aChoZWlnaHQpO1xuICAgICAgICAgICAgLy8gUHJlcGVuZCBsb2dpYyBidXR0b25cbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5wcmVwZW5kKHRoaXMuZG9tLmxvZ2ljQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3NldExvZ2ljTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIC8vIFNldCBjcml0ZXJpYSBsZWZ0IG1hcmdpblxuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmNzcygnbWFyZ2luLWxlZnQnLCB0aGlzLmRvbS5sb2dpY0NvbnRhaW5lci5vdXRlckhlaWdodCh0cnVlKSk7XG4gICAgICAgICAgICB2YXIgbG9naWNPZmZzZXQgPSB0aGlzLmRvbS5sb2dpY0NvbnRhaW5lci5vZmZzZXQoKTtcbiAgICAgICAgICAgIC8vIFNldCBob3Jpem9udGFsIGFsaWdubWVudFxuICAgICAgICAgICAgdmFyIGN1cnJlbnRMZWZ0ID0gbG9naWNPZmZzZXQubGVmdDtcbiAgICAgICAgICAgIHZhciBncm91cExlZnQgPSB0aGlzLmRvbS5jb250YWluZXIub2Zmc2V0KCkubGVmdDtcbiAgICAgICAgICAgIHZhciBzaHVmZmxlTGVmdCA9IGN1cnJlbnRMZWZ0IC0gZ3JvdXBMZWZ0O1xuICAgICAgICAgICAgdmFyIG5ld1BvcyA9IGN1cnJlbnRMZWZ0IC0gc2h1ZmZsZUxlZnQgLSB0aGlzLmRvbS5sb2dpY0NvbnRhaW5lci5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmxvZ2ljQ29udGFpbmVyLm9mZnNldCh7IGxlZnQ6IG5ld1BvcyB9KTtcbiAgICAgICAgICAgIC8vIFNldCB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAgICAgICAgICAgIHZhciBmaXJzdENyaXQgPSB0aGlzLmRvbS5sb2dpY0NvbnRhaW5lci5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRvcCA9IGxvZ2ljT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIHZhciBmaXJzdFRvcCA9ICQkMShmaXJzdENyaXQpLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgIHZhciBzaHVmZmxlVG9wID0gY3VycmVudFRvcCAtIGZpcnN0VG9wO1xuICAgICAgICAgICAgdmFyIG5ld1RvcCA9IGN1cnJlbnRUb3AgLSBzaHVmZmxlVG9wO1xuICAgICAgICAgICAgdGhpcy5kb20ubG9naWNDb250YWluZXIub2Zmc2V0KHsgdG9wOiBuZXdUb3AgfSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGVhci5vdXRlckhlaWdodCh0aGlzLmRvbS5sb2dpY0NvbnRhaW5lci5oZWlnaHQoKSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDbGVhckxpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGxpc3RlbmVycyBvbiB0aGUgZ3JvdXBzIGVsZW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZC51bmJpbmQoJ2NsaWNrJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIHBhcmVudCBncm91cCB0aGVuIHRoZSBsb2dpYyBidXR0b24gaGFzIG5vdCBiZWVuIGFkZGVkIHlldFxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucy5pc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jb250YWluZXIucHJlcGVuZChfdGhpcy5kb20ubG9naWNDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRDcml0ZXJpYSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jb250YWluZXIudHJpZ2dlcignZHRzYi1hZGQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zLmR0LnN0YXRlLnNhdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMuY3JpdGVyaWE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNyaXQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgY3JpdC5jcml0ZXJpYS5zZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldENsZWFyTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldExvZ2ljTGlzdGVuZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjcml0ZXJpYSB0byB0aGUgZ3JvdXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNyaXQgSW5zdGFuY2Ugb2YgQ3JpdGVyaWEgdG8gYmUgYWRkZWQgdG8gdGhlIGdyb3VwXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuYWRkQ3JpdGVyaWEgPSBmdW5jdGlvbiAoY3JpdCwgcmVkcmF3KSB7XG4gICAgICAgICAgICBpZiAoY3JpdCA9PT0gdm9pZCAwKSB7IGNyaXQgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAocmVkcmF3ID09PSB2b2lkIDApIHsgcmVkcmF3ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gY3JpdCA9PT0gbnVsbCA/IHRoaXMucy5jcml0ZXJpYS5sZW5ndGggOiBjcml0LnMuaW5kZXg7XG4gICAgICAgICAgICB2YXIgY3JpdGVyaWEgPSBuZXcgQ3JpdGVyaWEodGhpcy5zLmR0LCB0aGlzLnMub3B0cywgdGhpcy5zLnRvcEdyb3VwLCBpbmRleCwgdGhpcy5zLmRlcHRoKTtcbiAgICAgICAgICAgIC8vIElmIGEgQ3JpdGVyaWEgaGFzIGJlZW4gcGFzc2VkIGluIHRoZW4gc2V0IHRoZSB2YWx1ZXMgdG8gY29udGludWUgdGhhdFxuICAgICAgICAgICAgaWYgKGNyaXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYS5jID0gY3JpdC5jO1xuICAgICAgICAgICAgICAgIGNyaXRlcmlhLnMgPSBjcml0LnM7XG4gICAgICAgICAgICAgICAgY3JpdGVyaWEucy5kZXB0aCA9IHRoaXMucy5kZXB0aDtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYS5jbGFzc2VzID0gY3JpdC5jbGFzc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JpdGVyaWEucG9wdWxhdGUoKTtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnMuY3JpdGVyaWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLnMuY3JpdGVyaWFbaV0uY3JpdGVyaWEucy5pbmRleCA+IGNyaXRlcmlhLnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBub2RlIGZvciB0aGUgY3JpdGVyaWEgYXQgdGhlIHN0YXJ0IG9mIHRoZSBncm91cFxuICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYS5nZXROb2RlKCkuaW5zZXJ0QmVmb3JlKHRoaXMucy5jcml0ZXJpYVtpXS5jcml0ZXJpYS5kb20uY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgdGhpcy5zLmNyaXRlcmlhLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhW2ldLmNyaXRlcmlhLnMuaW5kZXggPCBjcml0ZXJpYS5zLmluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5jcml0ZXJpYVtpICsgMV0uY3JpdGVyaWEucy5pbmRleCA+IGNyaXRlcmlhLnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBub2RlIGZvciB0aGUgY3JpdGVyaWEgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWEuZ2V0Tm9kZSgpLmluc2VydEFmdGVyKHRoaXMucy5jcml0ZXJpYVtpXS5jcml0ZXJpYS5kb20uY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYS5nZXROb2RlKCkuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLmFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGRldGFpbHMgZm9yIHRoaXMgY3JpdGVyaWEgdG8gdGhlIGFycmF5XG4gICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWEucHVzaCh7XG4gICAgICAgICAgICAgICAgY3JpdGVyaWE6IGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWEgPSB0aGlzLnMuY3JpdGVyaWEuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jcml0ZXJpYS5zLmluZGV4IC0gYi5jcml0ZXJpYS5zLmluZGV4OyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMuY3JpdGVyaWE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmNyaXRlcmlhIGluc3RhbmNlb2YgQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LmNyaXRlcmlhLnVwZGF0ZUFycm93cyh0aGlzLnMuY3JpdGVyaWEubGVuZ3RoID4gMSwgcmVkcmF3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRDcml0ZXJpYUxpc3RlbmVycyhjcml0ZXJpYSk7XG4gICAgICAgICAgICBjcml0ZXJpYS5zZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBMb2dpYygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHRoZSBncm91cCB0byBzZWUgaWYgaXQgaGFzIGFueSBmaWxsZWQgY3JpdGVyaWFcbiAgICAgICAgICovXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5jaGVja0ZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMuY3JpdGVyaWE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNyaXQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGNyaXQuY3JpdGVyaWEgaW5zdGFuY2VvZiBDcml0ZXJpYSAmJiBjcml0LmNyaXRlcmlhLnMuZmlsbGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNyaXQuY3JpdGVyaWEgaW5zdGFuY2VvZiBHcm91cCAmJiBjcml0LmNyaXRlcmlhLmNoZWNrRmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY291bnQgZm9yIHRoZSBudW1iZXIgb2YgY3JpdGVyaWEgaW4gdGhpcyBncm91cCBhbmQgYW55IHN1YiBncm91cHNcbiAgICAgICAgICovXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLmNyaXRlcmlhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjcml0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChjcml0LmNyaXRlcmlhIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gY3JpdC5jcml0ZXJpYS5jb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkcyBhIHN1YiBncm91cCB0aGF0IHByZXZpb3VzbHkgZXhpc3RlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVkR3JvdXAgVGhlIGRldGFpbHMgb2YgYSBncm91cCB3aXRoaW4gdGhpcyBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLl9hZGRQcmV2R3JvdXAgPSBmdW5jdGlvbiAobG9hZGVkR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLnMuY3JpdGVyaWEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IEdyb3VwKHRoaXMucy5kdCwgdGhpcy5jLCB0aGlzLnMudG9wR3JvdXAsIGlkeCwgdHJ1ZSwgdGhpcy5zLmRlcHRoICsgMSk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBncm91cCB0byB0aGUgY3JpdGVyaWEgYXJyYXlcbiAgICAgICAgICAgIHRoaXMucy5jcml0ZXJpYS5wdXNoKHtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYTogZ3JvdXAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgICAgICAgICBsb2dpYzogZ3JvdXAucy5sb2dpY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZWJ1aWxkIGl0IHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgZm9yIHRoYXQgZ3JvdXBcbiAgICAgICAgICAgIGdyb3VwLnJlYnVpbGQobG9hZGVkR3JvdXApO1xuICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhW2lkeF0uY3JpdGVyaWEgPSBncm91cDtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC50cmlnZ2VyKCdkdHNiLXJlZHJhd0NvbnRlbnRzJyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRHcm91cExpc3RlbmVycyhncm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkcyBhIGNyaXRlcmlhIG9mIHRoaXMgZ3JvdXAgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxvYWRlZENyaXRlcmlhIFRoZSBkZXRhaWxzIG9mIGEgY3JpdGVyaWEgd2l0aGluIHRoZSBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLl9hZGRQcmV2Q3JpdGVyaWEgPSBmdW5jdGlvbiAobG9hZGVkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLnMuY3JpdGVyaWEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNyaXRlcmlhID0gbmV3IENyaXRlcmlhKHRoaXMucy5kdCwgdGhpcy5zLm9wdHMsIHRoaXMucy50b3BHcm91cCwgaWR4LCB0aGlzLnMuZGVwdGgpO1xuICAgICAgICAgICAgY3JpdGVyaWEucG9wdWxhdGUoKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IGNyaXRlcmlhIHRvIHRoZSBjcml0ZXJpYSBhcnJheVxuICAgICAgICAgICAgdGhpcy5zLmNyaXRlcmlhLnB1c2goe1xuICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICBpbmRleDogaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgaXQgd2l0aCB0aGUgcHJldmlvdXMgY29uZGl0aW9ucyBmb3IgdGhhdCBjcml0ZXJpYVxuICAgICAgICAgICAgY3JpdGVyaWEucmVidWlsZChsb2FkZWRDcml0ZXJpYSk7XG4gICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWFbaWR4XS5jcml0ZXJpYSA9IGNyaXRlcmlhO1xuICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwLnRyaWdnZXIoJ2R0c2ItcmVkcmF3Q29udGVudHMnKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBBbmQgdGhlIGNyaXRlcmlhIHVzaW5nIEFORCBsb2dpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93RGF0YSBUaGUgcm93IGRhdGEgdG8gYmUgY2hlY2tlZCBhZ2FpbnN0IHRoZSBzZWFyY2ggY3JpdGVyaWFcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhbiBUaGUgcmVzdWx0IG9mIHRoZSBBTkQgc2VhcmNoXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuX2FuZFNlYXJjaCA9IGZ1bmN0aW9uIChyb3dEYXRhLCByb3dJZHgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjcml0ZXJpYSB0aGVuIHJldHVybiB0cnVlIGZvciB0aGlzIGdyb3VwXG4gICAgICAgICAgICBpZiAodGhpcy5zLmNyaXRlcmlhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5jcml0ZXJpYTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3JpdGVyaWEgaXMgbm90IGNvbXBsZXRlIHRoZW4gc2tpcCBpdFxuICAgICAgICAgICAgICAgIGlmIChjcml0LmNyaXRlcmlhIGluc3RhbmNlb2YgQ3JpdGVyaWEgJiYgIWNyaXQuY3JpdGVyaWEucy5maWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiBhIHNpbmdsZSBvbmUgZmFpbHMgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNyaXQuY3JpdGVyaWEuc2VhcmNoKHJvd0RhdGEsIHJvd0lkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGdldCB0byBoZXJlIHRoZW4gZXZlcnl0aGluZyBoYXMgcGFzc2VkLCBzbyByZXR1cm4gdHJ1ZSBmb3IgdGhlIGdyb3VwXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBBbmQgdGhlIGNyaXRlcmlhIHVzaW5nIE9SIGxvZ2ljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3dEYXRhIFRoZSByb3cgZGF0YSB0byBiZSBjaGVja2VkIGFnYWluc3QgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuIFRoZSByZXN1bHQgb2YgdGhlIE9SIHNlYXJjaFxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLl9vclNlYXJjaCA9IGZ1bmN0aW9uIChyb3dEYXRhLCByb3dJZHgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjcml0ZXJpYSBpbiB0aGUgZ3JvdXAgdGhlbiByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgaWYgKHRoaXMucy5jcml0ZXJpYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBhdCBsZWFzdCBvbmUgY3JpdGVyaWEgaW4gdGhlIGdyb3VwIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICB2YXIgZmlsbGVkZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMuY3JpdGVyaWE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNyaXQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGNyaXQuY3JpdGVyaWEgaW5zdGFuY2VvZiBDcml0ZXJpYSAmJiBjcml0LmNyaXRlcmlhLnMuZmlsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY29tcGxldGVkIGNyaXRlcmlhIGhhcyBiZWVuIGZvdW5kIHNvIHNldCB0aGUgZmxhZ1xuICAgICAgICAgICAgICAgICAgICBmaWxsZWRmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzZWFyY2ggcGFzc2VzIHRoZW4gcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyaXQuY3JpdGVyaWEuc2VhcmNoKHJvd0RhdGEsIHJvd0lkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyaXQuY3JpdGVyaWEgaW5zdGFuY2VvZiBHcm91cCAmJiBjcml0LmNyaXRlcmlhLmNoZWNrRmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3JpdC5jcml0ZXJpYS5zZWFyY2gocm93RGF0YSwgcm93SWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3ZSBuZWVkIHRvIHJldHVybiB0aGUgaW52ZXJzZSBvZiBmaWxsZWRmb3VuZCxcbiAgICAgICAgICAgIC8vICBhcyBpZiBhbnkgaGF2ZSBiZWVuIGZvdW5kIGFuZCB3ZSBhcmUgaGVyZSB0aGVuIG5vbmUgaGF2ZSBwYXNzZWRcbiAgICAgICAgICAgIHJldHVybiAhZmlsbGVkZm91bmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgY3JpdGVyaWEgZnJvbSB0aGUgZ3JvdXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNyaXRlcmlhIFRoZSBjcml0ZXJpYSBpbnN0YW5jZSB0byBiZSByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuX3JlbW92ZUNyaXRlcmlhID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBncm91cCkge1xuICAgICAgICAgICAgaWYgKGdyb3VwID09PSB2b2lkIDApIHsgZ3JvdXAgPSBmYWxzZTsgfVxuICAgICAgICAgICAgLy8gSWYgcmVtb3ZpbmcgYSBjcml0ZXJpYSBhbmQgdGhlcmUgaXMgb25seSB0aGVuIHRoZW4ganVzdCBkZXN0cm95IHRoZSBncm91cFxuICAgICAgICAgICAgaWYgKHRoaXMucy5jcml0ZXJpYS5sZW5ndGggPD0gMSAmJiB0aGlzLnMuaXNDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNwbGljZSB0aGUgZ2l2ZW4gY3JpdGVyaWEgb3V0IGFuZCByZWRvIHRoZSBpbmRleGVzXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnMuY3JpdGVyaWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5jcml0ZXJpYVtpXS5pbmRleCA9PT0gY3JpdGVyaWEucy5pbmRleCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFncm91cCB8fCB0aGlzLnMuY3JpdGVyaWFbaV0uY3JpdGVyaWEgaW5zdGFuY2VvZiBHcm91cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgd2l0aCB0aGUgZGVzaXJlZCBpbmRleCwgYXMgaXRzIHJlcGxhY2VtZW50IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWEuc3BsaWNlKGxhc3QsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucy5jcml0ZXJpYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWFbaV0uaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuY3JpdGVyaWFbaV0uY3JpdGVyaWEucy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbGlzdGVuZXJzIGluIGdyb3VwIGZvciBhIGNyaXRlcmlhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjcml0ZXJpYSBUaGUgY3JpdGVyaWEgZm9yIHRoZSBsaXN0ZW5lcnMgdG8gYmUgc2V0IG9uXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuX3NldENyaXRlcmlhTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgY3JpdGVyaWEuZG9tW1wiZGVsZXRlXCJdXG4gICAgICAgICAgICAgICAgLnVuYmluZCgnY2xpY2snKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNyaXRlcmlhKGNyaXRlcmlhKTtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYS5kb20uY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5zLmNyaXRlcmlhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyaXQuY3JpdGVyaWEgaW5zdGFuY2VvZiBDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JpdC5jcml0ZXJpYS51cGRhdGVBcnJvd3MoX3RoaXMucy5jcml0ZXJpYS5sZW5ndGggPiAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjcml0ZXJpYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy5kdC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b3BHcm91cC50cmlnZ2VyKCdkdHNiLXJlZHJhd0NvbnRlbnRzJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b3BHcm91cC50cmlnZ2VyKCdkdHNiLXVwZGF0ZVRpdGxlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjcml0ZXJpYS5kb20ucmlnaHRcbiAgICAgICAgICAgICAgICAudW5iaW5kKCdjbGljaycpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gY3JpdGVyaWEucy5pbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoX3RoaXMucy5kdCwgX3RoaXMucy5vcHRzLCBfdGhpcy5zLnRvcEdyb3VwLCBjcml0ZXJpYS5zLmluZGV4LCB0cnVlLCBfdGhpcy5zLmRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjcml0ZXJpYSB0aGF0IGlzIHRvIGJlIG1vdmVkIHRvIHRoZSBuZXcgZ3JvdXBcbiAgICAgICAgICAgICAgICBncm91cC5hZGRDcml0ZXJpYShjcml0ZXJpYSk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBkZXRhaWxzIGluIHRoZSBjdXJyZW50IGdyb3VwcyBjcml0ZXJpYSBhcnJheVxuICAgICAgICAgICAgICAgIF90aGlzLnMuY3JpdGVyaWFbaWR4XS5jcml0ZXJpYSA9IGdyb3VwO1xuICAgICAgICAgICAgICAgIF90aGlzLnMuY3JpdGVyaWFbaWR4XS5sb2dpYyA9ICdBTkQnO1xuICAgICAgICAgICAgICAgIF90aGlzLnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdDb250ZW50cycpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRHcm91cExpc3RlbmVycyhncm91cCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjcml0ZXJpYS5kb20ubGVmdFxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ2NsaWNrJylcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnMudG9Ecm9wID0gbmV3IENyaXRlcmlhKF90aGlzLnMuZHQsIF90aGlzLnMub3B0cywgX3RoaXMucy50b3BHcm91cCwgY3JpdGVyaWEucy5pbmRleCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b0Ryb3AucyA9IGNyaXRlcmlhLnM7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b0Ryb3AuYyA9IGNyaXRlcmlhLmM7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b0Ryb3AuY2xhc3NlcyA9IGNyaXRlcmlhLmNsYXNzZXM7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b0Ryb3AucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZHJvcENyaXRlcmlhIGV2ZW50IG11dGF0ZXMgdGhlIHJlZmVyZW5jZSB0byB0aGUgaW5kZXggc28gbmVlZCB0byBzdG9yZSBpdFxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLnMudG9Ecm9wLnMuaW5kZXg7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNvbnRhaW5lci50cmlnZ2VyKCdkdHNiLWRyb3BDcml0ZXJpYScpO1xuICAgICAgICAgICAgICAgIGNyaXRlcmlhLnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ3JpdGVyaWEoY3JpdGVyaWEpO1xuICAgICAgICAgICAgICAgIC8vIEJ5IHRyYWNraW5nIHRoZSB0b3AgbGV2ZWwgZ3JvdXAgd2UgY2FuIGRpcmVjdGx5IHRyaWdnZXIgYSByZWRyYXcgb24gaXQsXG4gICAgICAgICAgICAgICAgLy8gIGJ1YmJsaW5nIGlzIGFsc28gcG9zc2libGUsIGJ1dCB0aGF0IGlzIHNsb3cgd2l0aCBkZWVwIGxldmVsbGVkIGdyb3Vwc1xuICAgICAgICAgICAgICAgIF90aGlzLnMudG9wR3JvdXAudHJpZ2dlcignZHRzYi1yZWRyYXdDb250ZW50cycpO1xuICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuZHJhdygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0J3MgdGhlIGxpc3RlbmVycyBmb3IgdGhlIGdyb3VwIGNsZWFyIGJ1dHRvblxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLl9zZXRDbGVhckxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyXG4gICAgICAgICAgICAgICAgLnVuYmluZCgnY2xpY2snKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zLmlzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNvbnRhaW5lci50cmlnZ2VyKCdkdHNiLWNsZWFyQ29udGVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b3BHcm91cC50cmlnZ2VyKCdkdHNiLXVwZGF0ZVRpdGxlJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b3BHcm91cC50cmlnZ2VyKCdkdHNiLXJlZHJhd0NvbnRlbnRzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGxpc3RlbmVycyBmb3Igc3ViIGdyb3VwcyBvZiB0aGlzIGdyb3VwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBncm91cCBUaGUgc3ViIGdyb3VwIHRoYXQgdGhlIGxpc3RlbmVycyBhcmUgdG8gYmUgc2V0IG9uXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuX3NldEdyb3VwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gU2V0IGxpc3RlbmVycyBmb3IgdGhlIG5ldyBncm91cFxuICAgICAgICAgICAgZ3JvdXAuZG9tLmFkZFxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ2NsaWNrJylcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldHVwTG9naWMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY29udGFpbmVyLnRyaWdnZXIoJ2R0c2ItYWRkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cC5kb20uY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLnVuYmluZCgnZHRzYi1hZGQnKVxuICAgICAgICAgICAgICAgIC5vbignZHRzYi1hZGQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0dXBMb2dpYygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jb250YWluZXIudHJpZ2dlcignZHRzYi1hZGQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3VwLmRvbS5jb250YWluZXJcbiAgICAgICAgICAgICAgICAudW5iaW5kKCdkdHNiLWRlc3Ryb3knKVxuICAgICAgICAgICAgICAgIC5vbignZHRzYi1kZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDcml0ZXJpYShncm91cCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZG9tLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXR1cExvZ2ljKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cC5kb20uY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLnVuYmluZCgnZHRzYi1kcm9wQ3JpdGVyaWEnKVxuICAgICAgICAgICAgICAgIC5vbignZHRzYi1kcm9wQ3JpdGVyaWEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvRHJvcCA9IGdyb3VwLnMudG9Ecm9wO1xuICAgICAgICAgICAgICAgIHRvRHJvcC5zLmluZGV4ID0gZ3JvdXAucy5pbmRleDtcbiAgICAgICAgICAgICAgICB0b0Ryb3AudXBkYXRlQXJyb3dzKF90aGlzLnMuY3JpdGVyaWEubGVuZ3RoID4gMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZENyaXRlcmlhKHRvRHJvcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXAuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIHRoZSBHcm91cCBpbnN0YW5jZSwgc2V0dGluZyBsaXN0ZW5lcnMgYW5kIGFwcGVuZGluZyBlbGVtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXAucHJvdG90eXBlLl9zZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGQudGV4dCh0aGlzLnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci5hZGQnLCB0aGlzLmMuaTE4bi5hZGQpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmxvZ2ljLmNoaWxkcmVuKCkuZmlyc3QoKS50ZXh0KHRoaXMuYy5sb2dpYyA9PT0gJ09SJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5zLmR0LmkxOG4oJ3NlYXJjaEJ1aWxkZXIubG9naWNPcicsIHRoaXMuYy5pMThuLmxvZ2ljT3IpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnMuZHQuaTE4bignc2VhcmNoQnVpbGRlci5sb2dpY0FuZCcsIHRoaXMuYy5pMThuLmxvZ2ljQW5kKSk7XG4gICAgICAgICAgICB0aGlzLnMubG9naWMgPSB0aGlzLmMubG9naWMgPT09ICdPUicgPyAnT1InIDogJ0FORCc7XG4gICAgICAgICAgICBpZiAodGhpcy5jLmdyZXlzY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmxvZ2ljLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5ncmV5c2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb20ubG9naWNDb250YWluZXIuYXBwZW5kKHRoaXMuZG9tLmxvZ2ljKS5hcHBlbmQodGhpcy5kb20uY2xlYXIpO1xuICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGxvZ2ljIGJ1dHRvbiBpbW1lZGlhdGVseSBpZiB0aGlzIGlzIGEgc3ViIGdyb3VwLFxuICAgICAgICAgICAgLy8gIG90aGVyd2lzZSBpdCB3aWxsIGJlIHByZXBlbmRlZCBsYXRlciB3aGVuIGFkZGluZyBhIGNyaXRlcmlhXG4gICAgICAgICAgICBpZiAodGhpcy5zLmlzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuYXBwZW5kKHRoaXMuZG9tLmxvZ2ljQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5hcHBlbmQodGhpcy5kb20uYWRkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGxpc3RlbmVyIGZvciB0aGUgbG9naWMgYnV0dG9uXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuX3NldExvZ2ljTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kb20ubG9naWNcbiAgICAgICAgICAgICAgICAudW5iaW5kKCdjbGljaycpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlTG9naWMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zLmR0LmRyYXcoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMucy5jcml0ZXJpYTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNyaXQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGNyaXQuY3JpdGVyaWEuc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGVzIHRoZSBsb2dpYyBmb3IgdGhlIGdyb3VwXG4gICAgICAgICAqL1xuICAgICAgICBHcm91cC5wcm90b3R5cGUuX3RvZ2dsZUxvZ2ljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucy5sb2dpYyA9PT0gJ09SJykge1xuICAgICAgICAgICAgICAgIHRoaXMucy5sb2dpYyA9ICdBTkQnO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmxvZ2ljLmNoaWxkcmVuKCkuZmlyc3QoKS50ZXh0KHRoaXMucy5kdC5pMThuKCdzZWFyY2hCdWlsZGVyLmxvZ2ljQW5kJywgdGhpcy5jLmkxOG4ubG9naWNBbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucy5sb2dpYyA9PT0gJ0FORCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMubG9naWMgPSAnT1InO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmxvZ2ljLmNoaWxkcmVuKCkuZmlyc3QoKS50ZXh0KHRoaXMucy5kdC5pMThuKCdzZWFyY2hCdWlsZGVyLmxvZ2ljT3InLCB0aGlzLmMuaTE4bi5sb2dpY09yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEdyb3VwLnZlcnNpb24gPSAnMS4xLjAnO1xuICAgICAgICBHcm91cC5jbGFzc2VzID0ge1xuICAgICAgICAgICAgYWRkOiAnZHRzYi1hZGQnLFxuICAgICAgICAgICAgYnV0dG9uOiAnZHRzYi1idXR0b24nLFxuICAgICAgICAgICAgY2xlYXJHcm91cDogJ2R0c2ItY2xlYXJHcm91cCcsXG4gICAgICAgICAgICBncmV5c2NhbGU6ICdkdHNiLWdyZXlzY2FsZScsXG4gICAgICAgICAgICBncm91cDogJ2R0c2ItZ3JvdXAnLFxuICAgICAgICAgICAgaW5wdXRCdXR0b246ICdkdHNiLWlwdGJ0bicsXG4gICAgICAgICAgICBsb2dpYzogJ2R0c2ItbG9naWMnLFxuICAgICAgICAgICAgbG9naWNDb250YWluZXI6ICdkdHNiLWxvZ2ljQ29udGFpbmVyJ1xuICAgICAgICB9O1xuICAgICAgICBHcm91cC5kZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHRydWUsXG4gICAgICAgICAgICBjb25kaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgJ2RhdGUnOiBDcml0ZXJpYS5kYXRlQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnaHRtbCc6IENyaXRlcmlhLnN0cmluZ0NvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ2h0bWwtbnVtJzogQ3JpdGVyaWEubnVtQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnaHRtbC1udW0tZm10JzogQ3JpdGVyaWEubnVtRm10Q29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbHV4b24nOiBDcml0ZXJpYS5sdXhvbkRhdGVDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICdtb21lbnQnOiBDcml0ZXJpYS5tb21lbnREYXRlQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbnVtJzogQ3JpdGVyaWEubnVtQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbnVtLWZtdCc6IENyaXRlcmlhLm51bUZtdENvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ3N0cmluZyc6IENyaXRlcmlhLnN0cmluZ0NvbmRpdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXB0aExpbWl0OiBmYWxzZSxcbiAgICAgICAgICAgIGVudGVyU2VhcmNoOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbHRlckNoYW5nZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGdyZXlzY2FsZTogZmFsc2UsXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgICAgYWRkOiAnQWRkIENvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIDA6ICdTZWFyY2ggQnVpbGRlcicsXG4gICAgICAgICAgICAgICAgICAgIF86ICdTZWFyY2ggQnVpbGRlciAoJWQpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xlYXJBbGw6ICdDbGVhciBBbGwnLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogJ0NvbmRpdGlvbicsXG4gICAgICAgICAgICAgICAgZGF0YTogJ0RhdGEnLFxuICAgICAgICAgICAgICAgIGRlbGV0ZVRpdGxlOiAnRGVsZXRlIGZpbHRlcmluZyBydWxlJyxcbiAgICAgICAgICAgICAgICBsZWZ0VGl0bGU6ICdPdXRkZW50IGNyaXRlcmlhJyxcbiAgICAgICAgICAgICAgICBsb2dpY0FuZDogJ0FuZCcsXG4gICAgICAgICAgICAgICAgbG9naWNPcjogJ09yJyxcbiAgICAgICAgICAgICAgICByaWdodFRpdGxlOiAnSW5kZW50IGNyaXRlcmlhJyxcbiAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICAwOiAnQ3VzdG9tIFNlYXJjaCBCdWlsZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXzogJ0N1c3RvbSBTZWFyY2ggQnVpbGRlciAoJWQpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdWYWx1ZScsXG4gICAgICAgICAgICAgICAgdmFsdWVKb2luZXI6ICdhbmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9naWM6ICdBTkQnLFxuICAgICAgICAgICAgb3J0aG9nb25hbDoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgICAgICAgICAgICAgICBzZWFyY2g6ICdmaWx0ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlRGVmaW5lZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEdyb3VwO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgJDtcbiAgICB2YXIgZGF0YVRhYmxlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGpRdWVyeSBmb3IgdXNlIGluIHRoZSBmaWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganEgdGhlIGluc3RhbmNlIG9mIGpRdWVyeSB0byBiZSBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRKUXVlcnkoanEpIHtcbiAgICAgICAgJCA9IGpxO1xuICAgICAgICBkYXRhVGFibGUgPSBqcS5mbi5EYXRhVGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaEJ1aWxkZXIgY2xhc3MgZm9yIERhdGFUYWJsZXMuXG4gICAgICogQWxsb3dzIGZvciBjb21wbGV4IHNlYXJjaCBxdWVyaWVzIHRvIGJlIGNvbnN0cnVjdGVkIGFuZCBpbXBsZW1lbnRlZCBvbiBhIERhdGFUYWJsZVxuICAgICAqL1xuICAgIHZhciBTZWFyY2hCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZWFyY2hCdWlsZGVyKGJ1aWxkZXJTZXR0aW5ncywgb3B0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHJlcXVpcmVkIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBpbmNsdWRlZFxuICAgICAgICAgICAgaWYgKCFkYXRhVGFibGUgfHwgIWRhdGFUYWJsZS52ZXJzaW9uQ2hlY2sgfHwgIWRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soJzEuMTAuMCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWFyY2hCdWlsZGVyIHJlcXVpcmVzIERhdGFUYWJsZXMgMS4xMCBvciBuZXdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhYmxlID0gbmV3IGRhdGFUYWJsZS5BcGkoYnVpbGRlclNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBTZWFyY2hCdWlsZGVyLmNsYXNzZXMpO1xuICAgICAgICAgICAgLy8gR2V0IG9wdGlvbnMgZnJvbSB1c2VyXG4gICAgICAgICAgICB0aGlzLmMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgU2VhcmNoQnVpbGRlci5kZWZhdWx0cywgb3B0cyk7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IHtcbiAgICAgICAgICAgICAgICBjbGVhckFsbDogJCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCI+JyArIHRhYmxlLmkxOG4oJ3NlYXJjaEJ1aWxkZXIuY2xlYXJBbGwnLCB0aGlzLmMuaTE4bi5jbGVhckFsbCkgKyAnPC9idXR0b24+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5jbGVhckFsbClcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5idXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5jb250YWluZXIpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnRpdGxlKSxcbiAgICAgICAgICAgICAgICB0aXRsZVJvdzogJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy50aXRsZVJvdyksXG4gICAgICAgICAgICAgICAgdG9wR3JvdXA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucyA9IHtcbiAgICAgICAgICAgICAgICBkdDogdGFibGUsXG4gICAgICAgICAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0b3BHcm91cDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSWYgc2VhcmNoYnVpbGRlciBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIHRoaXMgdGFibGUgdGhlbiByZXR1cm5cbiAgICAgICAgICAgIGlmICh0YWJsZS5zZXR0aW5ncygpWzBdLl9zZWFyY2hCdWlsZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXR0aW5ncygpWzBdLl9zZWFyY2hCdWlsZGVyID0gdGhpcztcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgcmVtYWluaW5nIHNldHVwIHdoZW4gdGhlIHRhYmxlIGlzIGluaXRpYWxpc2VkXG4gICAgICAgICAgICBpZiAodGhpcy5zLmR0LnNldHRpbmdzKClbMF0uX2JJbml0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFibGUub25lKCdpbml0LmR0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VXAoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZXRhaWxzIHJlcXVpcmVkIHRvIHJlYnVpbGQgdGhlIFNlYXJjaEJ1aWxkZXIgYXMgaXQgY3VycmVudGx5IGlzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQgdXBzZXQgYXQgZW1wdHkgb2JqZWN0IGJ1dCB0aGF0IGlzIHdoYXQgaXQgaXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICAgICAgU2VhcmNoQnVpbGRlci5wcm90b3R5cGUuZ2V0RGV0YWlscyA9IGZ1bmN0aW9uIChkZUZvcm1hdERhdGVzKSB7XG4gICAgICAgICAgICBpZiAoZGVGb3JtYXREYXRlcyA9PT0gdm9pZCAwKSB7IGRlRm9ybWF0RGF0ZXMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucy50b3BHcm91cC5nZXREZXRhaWxzKGRlRm9ybWF0RGF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgbm9kZSBvZiB0aGUgY29udGFpbmVyIGZvciB0aGUgc2VhcmNoQnVpbGRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBKUXVlcnk8SFRNTEVsZW1lbnQ+IHRoZSBub2RlIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaEJ1aWxkZXIucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb20uY29udGFpbmVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVidWlsZHMgdGhlIFNlYXJjaEJ1aWxkZXIgdG8gYSBzdGF0ZSB0aGF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXRhaWxzIFRoZSBkZXRhaWxzIHJlcXVpcmVkIHRvIHBlcmZvcm0gYSByZWJ1aWxkXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hCdWlsZGVyLnByb3RvdHlwZS5yZWJ1aWxkID0gZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLmNsaWNrKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGV0YWlscyB0byByZWJ1aWxkIHRoZW4gcmV0dXJuXG4gICAgICAgICAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5zLnByZXZlbnRSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwLnJlYnVpbGQoZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAucy5wcmV2ZW50UmVkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAucmVkcmF3Q29udGVudHMoKTtcbiAgICAgICAgICAgIHRoaXMucy5kdC5kcmF3KGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5zZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgZGVmYXVsdHMgdG8gcHJlRGVmaW5lZCBjcml0ZXJpYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcHJlRGVmIHRoZSBhcnJheSBvZiBjcml0ZXJpYSB0byBiZSBwcm9jZXNzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hCdWlsZGVyLnByb3RvdHlwZS5fYXBwbHlQcmVEZWZEZWZhdWx0cyA9IGZ1bmN0aW9uIChwcmVEZWYpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocHJlRGVmLmNyaXRlcmlhICE9PSB1bmRlZmluZWQgJiYgcHJlRGVmLmxvZ2ljID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVEZWYubG9naWMgPSAnQU5EJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGNyaXQpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgZGVmYXVsdHMgdG8gYW55IGZ1cnRoZXIgY3JpdGVyaWFcbiAgICAgICAgICAgICAgICBpZiAoY3JpdC5jcml0ZXJpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXQgPSB0aGlzXzEuX2FwcGx5UHJlRGVmRGVmYXVsdHMoY3JpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEucy5kdC5jb2x1bW5zKCkuZXZlcnkoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucy5kdC5zZXR0aW5ncygpWzBdLmFvQ29sdW1uc1tpbmRleF0uc1RpdGxlID09PSBjcml0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0LmRhdGFJZHggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHByZURlZi5jcml0ZXJpYTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3JpdCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGNyaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZURlZjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCdzIHVwIHRoZSBTZWFyY2hCdWlsZGVyXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hCdWlsZGVyLnByb3RvdHlwZS5fc2V0VXAgPSBmdW5jdGlvbiAobG9hZFN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGxvYWRTdGF0ZSA9PT0gdm9pZCAwKSB7IGxvYWRTdGF0ZSA9IHRydWU7IH1cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGFuIEFwaSBtZXRob2QgZm9yIGdldHRpbmcgdGhlIGNvbHVtbiB0eXBlXG4gICAgICAgICAgICAkLmZuLkRhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS50eXBlKCknLCAnY29sdW1uKCkudHlwZSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0uc1R5cGU7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgRGF0ZVRpbWUgaXMgaW5jbHVkZWQsIElmIG5vdCBuZWVkIHRvIGNoZWNrIGlmIGl0IGNvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgICAgIGlmICghZGF0YVRhYmxlLkRhdGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVzID0gdGhpcy5zLmR0LmNvbHVtbnMoKS50eXBlKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlcyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVzLmluY2x1ZGVzKHVuZGVmaW5lZCkgfHwgdHlwZXMuaW5jbHVkZXMobnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLmFvQ29sdW1uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xJbml0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaChjb2xJbml0LnNlYXJjaEJ1aWxkZXJUeXBlICE9PSB1bmRlZmluZWQgPyBjb2xJbml0LnNlYXJjaEJ1aWxkZXJUeXBlIDogY29sSW5pdC5zVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbklkeHMgPSB0aGlzLnMuZHQuY29sdW1ucygpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZXMgYXJlIG5vdCB5ZXQgc2V0IHRoZW4gZHJhdyB0byBzZWUgaWYgdGhleSBjYW4gYmUgcmV0cmlldmVkIHRoZW5cbiAgICAgICAgICAgICAgICBpZiAodHlwZXMgPT09IHVuZGVmaW5lZCB8fCB0eXBlcy5pbmNsdWRlcyh1bmRlZmluZWQpIHx8IHR5cGVzLmluY2x1ZGVzKG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlLmV4dC5vQXBpLl9mbkNvbHVtblR5cGVzKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSB0aGlzLnMuZHQuY29sdW1ucygpLnR5cGUoKS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uSWR4c1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gY29sdW1uSWR4c1swXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tjb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY29sdW1uIGNhbiBiZSBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5jLmNvbHVtbnMgPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5jLmNvbHVtbnMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jLmNvbHVtbnMuaW5jbHVkZXMoaSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHlwZSBpcyBvbmUgb2YgdGhlIHJlc3RyaWN0ZWQgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlLmluY2x1ZGVzKCdkYXRlJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmluY2x1ZGVzKCdtb21lbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuaW5jbHVkZXMoJ2x1eG9uJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydCgnU2VhcmNoQnVpbGRlciBSZXF1aXJlcyBEYXRlVGltZSB3aGVuIHVzZWQgd2l0aCBkYXRlcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoQnVpbGRlciByZXF1aXJlcyBEYXRlVGltZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwID0gbmV3IEdyb3VwKHRoaXMucy5kdCwgdGhpcy5jLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5fc2V0Q2xlYXJMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdGhpcy5zLmR0Lm9uKCdzdGF0ZVNhdmVQYXJhbXMnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNlYXJjaEJ1aWxkZXIgPSBfdGhpcy5nZXREZXRhaWxzKCk7XG4gICAgICAgICAgICAgICAgZGF0YS5wYWdlID0gX3RoaXMucy5kdC5wYWdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkKCk7XG4gICAgICAgICAgICB0aGlzLnMuZHQub24oJ3ByZVhocicsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hCdWlsZGVyID0gX3RoaXMuX2NvbGxhcHNlQXJyYXkoX3RoaXMuZ2V0RGV0YWlscyh0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobG9hZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZFN0YXRlID0gdGhpcy5zLmR0LnN0YXRlLmxvYWRlZCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsb2FkZWQgU3RhdGUgaXMgbm90IG51bGwgcmVidWlsZCBiYXNlZCBvbiBpdCBmb3Igc3RhdGVzYXZlXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZFN0YXRlICE9PSBudWxsICYmIGxvYWRlZFN0YXRlLnNlYXJjaEJ1aWxkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAucmVidWlsZChsb2FkZWRTdGF0ZS5zZWFyY2hCdWlsZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwLmRvbS5jb250YWluZXIudHJpZ2dlcignZHRzYi1yZWRyYXdDb250ZW50cycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuZHQucGFnZShsb2FkZWRTdGF0ZS5wYWdlKS5kcmF3KCdwYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5zZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGxvYWQgYW55IHByZWRlZmluZWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYy5wcmVEZWZpbmVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmMucHJlRGVmaW5lZCA9IHRoaXMuX2FwcGx5UHJlRGVmRGVmYXVsdHModGhpcy5jLnByZURlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGQodGhpcy5jLnByZURlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEVtcHR5TGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMucy5kdC5zdGF0ZS5zYXZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIFNlYXJjaEJ1aWxkZXIucHJvdG90eXBlLl9jb2xsYXBzZUFycmF5ID0gZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICBpZiAoY3JpdGVyaWEubG9naWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChjcml0ZXJpYS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLnZhbHVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oK2EpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9ICthO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSArYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIgPCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLnZhbHVlMSA9IGNyaXRlcmlhLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYS52YWx1ZTIgPSBjcml0ZXJpYS52YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNyaXRlcmlhLmNyaXRlcmlhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLmNyaXRlcmlhW2ldID0gdGhpcy5fY29sbGFwc2VBcnJheShjcml0ZXJpYS5jcml0ZXJpYVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyaXRlcmlhO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb2YgdGhlIFNlYXJjaEJ1aWxkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZmlsdGVycyBpbiB0aGUgU2VhcmNoQnVpbGRlclxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoQnVpbGRlci5wcm90b3R5cGUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmRvbS50aXRsZS5odG1sKHRoaXMucy5kdC5pMThuKCdzZWFyY2hCdWlsZGVyLnRpdGxlJywgdGhpcy5jLmkxOG4udGl0bGUsIGNvdW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZHMgYWxsIG9mIHRoZSBkb20gZWxlbWVudHMgdG9nZXRoZXJcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaEJ1aWxkZXIucHJvdG90eXBlLl9idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBFbXB0eSBhbmQgc2V0dXAgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5kb20uY2xlYXJBbGwucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMucy50b3BHcm91cC5jb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGl0bGUoY291bnQpO1xuICAgICAgICAgICAgdGhpcy5kb20udGl0bGVSb3cuYXBwZW5kKHRoaXMuZG9tLnRpdGxlKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5hcHBlbmQodGhpcy5kb20udGl0bGVSb3cpO1xuICAgICAgICAgICAgdGhpcy5kb20udG9wR3JvdXAgPSB0aGlzLnMudG9wR3JvdXAuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZCh0aGlzLmRvbS50b3BHcm91cCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRSZWRyYXdMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdmFyIHRhYmxlTm9kZSA9IHRoaXMucy5kdC50YWJsZSgwKS5ub2RlKCk7XG4gICAgICAgICAgICBpZiAoISQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2guaW5jbHVkZXModGhpcy5zLnNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gc2VhcmNoIGZ1bmN0aW9uIGZvciBTZWFyY2hCdWlsZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5zLnNlYXJjaCA9IGZ1bmN0aW9uIChzZXR0aW5ncywgc2VhcmNoRGF0YSwgZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uVGFibGUgIT09IHRhYmxlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnMudG9wR3JvdXAuc2VhcmNoKHNlYXJjaERhdGEsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgU2VhcmNoQnVpbGRlciBzZWFyY2ggZnVuY3Rpb24gdG8gdGhlIGRhdGFUYWJsZXMgc2VhcmNoIGFycmF5XG4gICAgICAgICAgICAgICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKHRoaXMucy5zZWFyY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zLmR0Lm9uKCdkZXN0cm95LmR0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNsZWFyQWxsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hJZHggPSAkLmZuLmRhdGFUYWJsZS5leHQuc2VhcmNoLmluZGV4T2YoX3RoaXMucy5zZWFyY2gpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZWFyY2hJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2guc3BsaWNlKHNlYXJjaElkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaElkeCA9ICQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2guaW5kZXhPZihfdGhpcy5zLnNlYXJjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGNsZWFyQWxsIGJ1dHRvbiBzaG91bGQgYmUgYWRkZWQgb3Igbm90XG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hCdWlsZGVyLnByb3RvdHlwZS5fY2hlY2tDbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnMudG9wR3JvdXAucy5jcml0ZXJpYS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xlYXJBbGwuaW5zZXJ0QWZ0ZXIodGhpcy5kb20udGl0bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENsZWFyTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBjb3VudCBpbiB0aGUgdGl0bGUvYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgZmlsdGVycyBhcHBsaWVkXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hCdWlsZGVyLnByb3RvdHlwZS5fZmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgICAgdmFyIGZuID0gdGhpcy5jLmZpbHRlckNoYW5nZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZm4oY291bnQsIHRoaXMucy5kdC5pMThuKCdzZWFyY2hCdWlsZGVyLmJ1dHRvbicsIHRoaXMuYy5pMThuLmJ1dHRvbiwgY291bnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbGlzdGVuZXIgZm9yIHRoZSBjbGVhciBidXR0b25cbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaEJ1aWxkZXIucHJvdG90eXBlLl9zZXRDbGVhckxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLnVuYmluZCgnY2xpY2snKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zLnRvcEdyb3VwID0gbmV3IEdyb3VwKF90aGlzLnMuZHQsIF90aGlzLmMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2J1aWxkKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy5kdC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b3BHcm91cC5zZXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXJBbGwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldEVtcHR5TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZmlsdGVyQ2hhbmdlZCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbGlzdGVuZXIgZm9yIHRoZSBSZWRyYXcgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaEJ1aWxkZXIucHJvdG90eXBlLl9zZXRSZWRyYXdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAuZG9tLmNvbnRhaW5lci51bmJpbmQoJ2R0c2ItcmVkcmF3Q29udGVudHMnKTtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5kb20uY29udGFpbmVyLm9uKCdkdHNiLXJlZHJhd0NvbnRlbnRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja0NsZWFyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy50b3BHcm91cC5yZWRyYXdDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnMudG9wR3JvdXAuc2V0dXBMb2dpYygpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRFbXB0eUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gX3RoaXMucy50b3BHcm91cC5jb3VudCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVUaXRsZShjb3VudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2ZpbHRlckNoYW5nZWQoY291bnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuZHJhdygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuc3RhdGUuc2F2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAuZG9tLmNvbnRhaW5lci51bmJpbmQoJ2R0c2ItcmVkcmF3TG9naWMnKTtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5kb20uY29udGFpbmVyLm9uKCdkdHNiLXJlZHJhd0xvZ2ljJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnMudG9wR3JvdXAucmVkcmF3TG9naWMoKTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBfdGhpcy5zLnRvcEdyb3VwLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVRpdGxlKGNvdW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZmlsdGVyQ2hhbmdlZChjb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5kb20uY29udGFpbmVyLnVuYmluZCgnZHRzYi1hZGQnKTtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5kb20uY29udGFpbmVyLm9uKCdkdHNiLWFkZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBfdGhpcy5zLnRvcEdyb3VwLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVRpdGxlKGNvdW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZmlsdGVyQ2hhbmdlZChjb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucy5kdC5vbigncG9zdEVkaXQgcG9zdENyZWF0ZSBwb3N0UmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnMudG9wR3JvdXAucmVkcmF3Q29udGVudHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwLmRvbS5jb250YWluZXIudW5iaW5kKCdkdHNiLWNsZWFyQ29udGVudHMnKTtcbiAgICAgICAgICAgIHRoaXMucy50b3BHcm91cC5kb20uY29udGFpbmVyLm9uKCdkdHNiLWNsZWFyQ29udGVudHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFVwKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZmlsdGVyQ2hhbmdlZCgwKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zLmR0LmRyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwLmRvbS5jb250YWluZXIub24oJ2R0c2ItdXBkYXRlVGl0bGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gX3RoaXMucy50b3BHcm91cC5jb3VudCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVUaXRsZShjb3VudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2ZpbHRlckNoYW5nZWQoY291bnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGxpc3RlbmVycyB0byBjaGVjayB3aGV0aGVyIGNsZWFyQWxsIHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hCdWlsZGVyLnByb3RvdHlwZS5fc2V0RW1wdHlMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnMudG9wR3JvdXAuZG9tLmFkZC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrQ2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zLnRvcEdyb3VwLmRvbS5jb250YWluZXIub24oJ2R0c2ItZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXJBbGwucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VhcmNoQnVpbGRlci52ZXJzaW9uID0gJzEuMi4xJztcbiAgICAgICAgU2VhcmNoQnVpbGRlci5jbGFzc2VzID0ge1xuICAgICAgICAgICAgYnV0dG9uOiAnZHRzYi1idXR0b24nLFxuICAgICAgICAgICAgY2xlYXJBbGw6ICdkdHNiLWNsZWFyQWxsJyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogJ2R0c2Itc2VhcmNoQnVpbGRlcicsXG4gICAgICAgICAgICBpbnB1dEJ1dHRvbjogJ2R0c2ItaXB0YnRuJyxcbiAgICAgICAgICAgIHRpdGxlOiAnZHRzYi10aXRsZScsXG4gICAgICAgICAgICB0aXRsZVJvdzogJ2R0c2ItdGl0bGVSb3cnXG4gICAgICAgIH07XG4gICAgICAgIFNlYXJjaEJ1aWxkZXIuZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjb2x1bW5zOiB0cnVlLFxuICAgICAgICAgICAgY29uZGl0aW9uczoge1xuICAgICAgICAgICAgICAgICdkYXRlJzogQ3JpdGVyaWEuZGF0ZUNvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ2h0bWwnOiBDcml0ZXJpYS5zdHJpbmdDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICdodG1sLW51bSc6IENyaXRlcmlhLm51bUNvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ2h0bWwtbnVtLWZtdCc6IENyaXRlcmlhLm51bUZtdENvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ2x1eG9uJzogQ3JpdGVyaWEubHV4b25EYXRlQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAnbW9tZW50JzogQ3JpdGVyaWEubW9tZW50RGF0ZUNvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ251bSc6IENyaXRlcmlhLm51bUNvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgJ251bS1mbXQnOiBDcml0ZXJpYS5udW1GbXRDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICdzdHJpbmcnOiBDcml0ZXJpYS5zdHJpbmdDb25kaXRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVwdGhMaW1pdDogZmFsc2UsXG4gICAgICAgICAgICBlbnRlclNlYXJjaDogZmFsc2UsXG4gICAgICAgICAgICBmaWx0ZXJDaGFuZ2VkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBncmV5c2NhbGU6IGZhbHNlLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICAgIGFkZDogJ0FkZCBDb25kaXRpb24nLFxuICAgICAgICAgICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgICAgICAgICAwOiAnU2VhcmNoIEJ1aWxkZXInLFxuICAgICAgICAgICAgICAgICAgICBfOiAnU2VhcmNoIEJ1aWxkZXIgKCVkKSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsZWFyQWxsOiAnQ2xlYXIgQWxsJyxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246ICdDb25kaXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiAnQ29udGFpbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHk6ICdFbXB0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcXVhbHM6ICdFcXVhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90OiAnTm90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEVtcHR5OiAnTm90IEVtcHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQ6ICdXaXRob3V0J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlcjogJ0FmdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogJ0JlZm9yZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXR3ZWVuOiAnQmV0d2VlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eTogJ0VtcHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsczogJ0VxdWFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3Q6ICdOb3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90QmV0d2VlbjogJ05vdCBCZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEVtcHR5OiAnTm90IEVtcHR5J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaWQtYmxhY2tsaXN0XG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmV0d2VlbjogJ0JldHdlZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHk6ICdFbXB0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcXVhbHM6ICdFcXVhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3Q6ICdHcmVhdGVyIFRoYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3RlOiAnR3JlYXRlciBUaGFuIEVxdWFsIFRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0OiAnTGVzcyBUaGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0ZTogJ0xlc3MgVGhhbiBFcXVhbCBUbycsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3Q6ICdOb3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90QmV0d2VlbjogJ05vdCBCZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEVtcHR5OiAnTm90IEVtcHR5J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaWQtYmxhY2tsaXN0XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6ICdDb250YWlucycsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eTogJ0VtcHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHNXaXRoOiAnRW5kcyBXaXRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsczogJ0VxdWFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3Q6ICdOb3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90RW1wdHk6ICdOb3QgRW1wdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRzV2l0aDogJ1N0YXJ0cyBXaXRoJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhOiAnRGF0YScsXG4gICAgICAgICAgICAgICAgZGVsZXRlVGl0bGU6ICdEZWxldGUgZmlsdGVyaW5nIHJ1bGUnLFxuICAgICAgICAgICAgICAgIGxlZnRUaXRsZTogJ091dGRlbnQgY3JpdGVyaWEnLFxuICAgICAgICAgICAgICAgIGxvZ2ljQW5kOiAnQW5kJyxcbiAgICAgICAgICAgICAgICBsb2dpY09yOiAnT3InLFxuICAgICAgICAgICAgICAgIHJpZ2h0VGl0bGU6ICdJbmRlbnQgY3JpdGVyaWEnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgIDA6ICdDdXN0b20gU2VhcmNoIEJ1aWxkZXInLFxuICAgICAgICAgICAgICAgICAgICBfOiAnQ3VzdG9tIFNlYXJjaCBCdWlsZGVyICglZCknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZUpvaW5lcjogJ2FuZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2dpYzogJ0FORCcsXG4gICAgICAgICAgICBvcnRob2dvbmFsOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogJ2ZpbHRlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVEZWZpbmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2VhcmNoQnVpbGRlcjtcbiAgICB9KCkpO1xuXG4gICAgLyohIFNlYXJjaEJ1aWxkZXIgMS4yLjFcbiAgICAgKiDCqVNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICAgICAqL1xuICAgIC8vIERhdGFUYWJsZXMgZXh0ZW5zaW9ucyBjb21tb24gVU1ELiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgZm9yIEFNRCwgQ29tbW9uSlNcbiAgICAvLyAod2l0aCB3aW5kb3cgYW5kIGpRdWVyeSBiZWluZyBhbGxvd2VkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIHJldHVybmVkXG4gICAgLy8gZnVuY3Rpb24pIG9yIGp1c3QgZGVmYXVsdCBicm93c2VyIGxvYWRpbmcuXG4gICAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIC8vIEFNRFxuICAgICAgICAgICAgZGVmaW5lKFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0J10sIGZ1bmN0aW9uICgkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoJCwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIENvbW1vbkpTXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghJCB8fCAhJC5mbi5kYXRhVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgICAgICAgICAgICAgICAgJCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jykocm9vdCwgJCkuJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoJCwgcm9vdCwgcm9vdC5kb2N1bWVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQnJvd3NlciAtIGFzc3VtZSBqUXVlcnkgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICB9KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50KSB7XG4gICAgICAgIHNldEpRdWVyeSgkKTtcbiAgICAgICAgc2V0SlF1ZXJ5JDEoJCk7XG4gICAgICAgIHNldEpRdWVyeSQyKCQpO1xuICAgICAgICB2YXIgZGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgJC5mbi5kYXRhVGFibGUuU2VhcmNoQnVpbGRlciA9IFNlYXJjaEJ1aWxkZXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgJC5mbi5EYXRhVGFibGUuU2VhcmNoQnVpbGRlciA9IFNlYXJjaEJ1aWxkZXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgJC5mbi5kYXRhVGFibGUuR3JvdXAgPSBHcm91cDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAkLmZuLkRhdGFUYWJsZS5Hcm91cCA9IEdyb3VwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgICQuZm4uZGF0YVRhYmxlLkNyaXRlcmlhID0gQ3JpdGVyaWE7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgJC5mbi5EYXRhVGFibGUuQ3JpdGVyaWEgPSBDcml0ZXJpYTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICB2YXIgYXBpUmVnaXN0ZXIgPSAkLmZuLmRhdGFUYWJsZS5BcGkucmVnaXN0ZXI7XG4gICAgICAgIC8vIFNldCB1cCBvYmplY3QgZm9yIHBsdWdpbnNcbiAgICAgICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaEJ1aWxkZXIgPSB7XG4gICAgICAgICAgICBjb25kaXRpb25zOiB7fVxuICAgICAgICB9O1xuICAgICAgICAkLmZuLmRhdGFUYWJsZS5leHQuYnV0dG9ucy5zZWFyY2hCdWlsZGVyID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoZSwgZHQsIG5vZGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlcihjb25maWcuX3NlYXJjaEJ1aWxkZXIuZ2V0Tm9kZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiAnZHQtY29udGFpbmVyJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVkcmF3IHRoZSBjb250ZW50cyB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgcG9zaXRpb25zIGZvciB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLl9zZWFyY2hCdWlsZGVyLnMudG9wR3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3NlYXJjaEJ1aWxkZXIucy50b3BHcm91cC5kb20uY29udGFpbmVyLnRyaWdnZXIoJ2R0c2ItcmVkcmF3Q29udGVudHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChkdCwgbm9kZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNiID0gbmV3ICQuZm4uZGF0YVRhYmxlLlNlYXJjaEJ1aWxkZXIoZHQsICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ2hhbmdlZDogZnVuY3Rpb24gKGNvdW50LCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdC5idXR0b24obm9kZSkudGV4dCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5jb25maWcpKTtcbiAgICAgICAgICAgICAgICBkdC5idXR0b24obm9kZSkudGV4dChjb25maWcudGV4dCB8fCBkdC5pMThuKCdzZWFyY2hCdWlsZGVyLmJ1dHRvbicsIHNiLmMuaTE4bi5idXR0b24sIDApKTtcbiAgICAgICAgICAgICAgICBjb25maWcuX3NlYXJjaEJ1aWxkZXIgPSBzYjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGFwaVJlZ2lzdGVyKCdzZWFyY2hCdWlsZGVyLmdldERldGFpbHMoKScsIGZ1bmN0aW9uIChkZUZvcm1hdERhdGVzKSB7XG4gICAgICAgICAgICBpZiAoZGVGb3JtYXREYXRlcyA9PT0gdm9pZCAwKSB7IGRlRm9ybWF0RGF0ZXMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcbiAgICAgICAgICAgIC8vIElmIFNlYXJjaEJ1aWxkZXIgaGFzIG5vdCBiZWVuIGluaXRpYWxpc2VkIG9uIHRoaXMgaW5zdGFuY2UgdGhlbiByZXR1cm5cbiAgICAgICAgICAgIHJldHVybiBjdHguX3NlYXJjaEJ1aWxkZXIgP1xuICAgICAgICAgICAgICAgIGN0eC5fc2VhcmNoQnVpbGRlci5nZXREZXRhaWxzKGRlRm9ybWF0RGF0ZXMpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgYXBpUmVnaXN0ZXIoJ3NlYXJjaEJ1aWxkZXIucmVidWlsZCgpJywgZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG4gICAgICAgICAgICAvLyBJZiBTZWFyY2hCdWlsZGVyIGhhcyBub3QgYmVlbiBpbml0aWFsaXNlZCBvbiB0aGlzIGluc3RhbmNlIHRoZW4gcmV0dXJuXG4gICAgICAgICAgICBpZiAoY3R4Ll9zZWFyY2hCdWlsZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5fc2VhcmNoQnVpbGRlci5yZWJ1aWxkKGRldGFpbHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgICAgICBhcGlSZWdpc3Rlcignc2VhcmNoQnVpbGRlci5jb250YWluZXIoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG4gICAgICAgICAgICAvLyBJZiBTZWFyY2hCdWlsZGVyIGhhcyBub3QgYmVlbiBpbml0aWFsaXNlZCBvbiB0aGlzIGluc3RhbmNlIHRoZW4gcmV0dXJuXG4gICAgICAgICAgICByZXR1cm4gY3R4Ll9zZWFyY2hCdWlsZGVyID9cbiAgICAgICAgICAgICAgICBjdHguX3NlYXJjaEJ1aWxkZXIuZ2V0Tm9kZSgpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgZnVuY3Rpb24gZm9yIFNlYXJjaEJ1aWxkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNldHRpbmdzIHRoZSBzZXR0aW5ncyB0byBiZSBhcHBsaWVkXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIGZvciBTZWFyY2hCdWlsZGVyXG4gICAgICAgICAqIEByZXR1cm5zIEpRVUVSWTxIVE1MRWxlbWVudD4gUmV0dXJucyB0aGUgbm9kZSBvZiB0aGUgU2VhcmNoQnVpbGRlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2luaXQoc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhcGkgPSBuZXcgZGF0YVRhYmxlLkFwaShzZXR0aW5ncyk7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IG9wdGlvbnNcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnNcbiAgICAgICAgICAgICAgICA6IGFwaS5pbml0KCkuc2VhcmNoQnVpbGRlciB8fCBkYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBzZWFyY2hCdWlsZGVyID0gbmV3IFNlYXJjaEJ1aWxkZXIoYXBpLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2VhcmNoQnVpbGRlci5nZXROb2RlKCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgZG9jdW1lbnQgd2hpY2ggbGlzdGVucyBmb3IgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvblxuICAgICAgICAvLyBldmVudHMgc28gd2UgY2FuIGF1dG9tYXRpY2FsbHkgaW5pdGlhbGlzZVxuICAgICAgICAkKGRvY3VtZW50KS5vbigncHJlSW5pdC5kdC5kdHNwJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoZS5uYW1lc3BhY2UgIT09ICdkdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0luaXQuc2VhcmNoQnVpbGRlciB8fFxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hCdWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5fc2VhcmNoQnVpbGRlcikge1xuICAgICAgICAgICAgICAgICAgICBfaW5pdChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGF0YVRhYmxlcyBgZG9tYCBmZWF0dXJlIG9wdGlvblxuICAgICAgICBkYXRhVGFibGUuZXh0LmZlYXR1cmUucHVzaCh7XG4gICAgICAgICAgICBjRmVhdHVyZTogJ1EnLFxuICAgICAgICAgICAgZm5Jbml0OiBfaW5pdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGF0YVRhYmxlcyAyIGxheW91dCBmZWF0dXJlXG4gICAgICAgIGlmIChkYXRhVGFibGUuZXh0LmZlYXR1cmVzKSB7XG4gICAgICAgICAgICBkYXRhVGFibGUuZXh0LmZlYXR1cmVzLnJlZ2lzdGVyKCdzZWFyY2hCdWlsZGVyJywgX2luaXQpO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG59KCkpO1xuIiwiLyohIEJvb3RzdHJhcCA1IGludGVncmF0aW9uIGZvciBEYXRhVGFibGVzJyBTZWFyY2hQYW5lc1xuICogwqkyMDE2IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1EXG4gICAgICAgIGRlZmluZShbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldC1iczUnLCAnZGF0YXRhYmxlcy5uZXQtc2VhcmNocGFuZXMnXSwgZnVuY3Rpb24gKCQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCQsIHdpbmRvdywgZG9jdW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIENvbW1vbkpTXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgIHJvb3QgPSB3aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISQgfHwgISQuZm4uZGF0YVRhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgICAgICAgICAgICAkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnM1Jykocm9vdCwgJCkuJDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghJC5mbi5kYXRhVGFibGUuU2VhcmNoUGFuZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LXNlYXJjaHBhbmVzJykocm9vdCwgJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCByb290LCByb290LmRvY3VtZW50KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXJcbiAgICAgICAgZmFjdG9yeShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuICAgIH1cbn0oZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xuICAgICQuZXh0ZW5kKHRydWUsIGRhdGFUYWJsZS5TZWFyY2hQYW5lLmNsYXNzZXMsIHtcbiAgICAgICAgYnV0dG9uR3JvdXA6ICdidG4tZ3JvdXAnLFxuICAgICAgICBkaXNhYmxlZEJ1dHRvbjogJ2Rpc2FibGVkJyxcbiAgICAgICAgbmFycm93OiAnY29sJyxcbiAgICAgICAgcGFuZToge1xuICAgICAgICAgICAgY29udGFpbmVyOiAndGFibGUnXG4gICAgICAgIH0sXG4gICAgICAgIHBhbmVCdXR0b246ICdidG4gYnRuLWxpZ2h0JyxcbiAgICAgICAgcGlsbDogJ2JhZGdlIHJvdW5kZWQtcGlsbCBiZy1zZWNvbmRhcnknLFxuICAgICAgICBzZWFyY2g6ICdmb3JtLWNvbnRyb2wgc2VhcmNoJyxcbiAgICAgICAgdGFibGU6ICd0YWJsZSB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzJyxcbiAgICAgICAgdG9wUm93OiAnZHRzcC10b3BSb3cnXG4gICAgfSk7XG4gICAgJC5leHRlbmQodHJ1ZSwgZGF0YVRhYmxlLlNlYXJjaFBhbmVzLmNsYXNzZXMsIHtcbiAgICAgICAgY2xlYXJBbGw6ICdkdHNwLWNsZWFyQWxsIGJ0biBidG4tbGlnaHQnLFxuICAgICAgICBjb2xsYXBzZUFsbDogJ2R0c3AtY29sbGFwc2VBbGwgYnRuIGJ0bi1saWdodCcsXG4gICAgICAgIGNvbnRhaW5lcjogJ2R0c3Atc2VhcmNoUGFuZXMnLFxuICAgICAgICBkaXNhYmxlZEJ1dHRvbjogJ2Rpc2FibGVkJyxcbiAgICAgICAgcGFuZXM6ICdkdHNwLXBhbmVzIGR0c3AtcGFuZXNDb250YWluZXInLFxuICAgICAgICBzaG93QWxsOiAnZHRzcC1zaG93QWxsIGJ0biBidG4tbGlnaHQnLFxuICAgICAgICB0aXRsZTogJ2R0c3AtdGl0bGUnLFxuICAgICAgICB0aXRsZVJvdzogJ2R0c3AtdGl0bGVSb3cnXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGFUYWJsZS5zZWFyY2hQYW5lcztcbn0pKTtcbiIsIi8qISBTZWFyY2hQYW5lcyAxLjQuMFxuICogMjAxOS0yMDIwIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyICQ7XG4gICAgdmFyIGRhdGFUYWJsZTtcbiAgICBmdW5jdGlvbiBzZXRKUXVlcnkoanEpIHtcbiAgICAgICAgJCA9IGpxO1xuICAgICAgICBkYXRhVGFibGUgPSBqcS5mbi5kYXRhVGFibGU7XG4gICAgfVxuICAgIHZhciBTZWFyY2hQYW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgcGFuZXMsIHNldHMgdXAgdGhlIHNlYXJjaCBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFuZVNldHRpbmdzIFRoZSBzZXR0aW5ncyBmb3IgdGhlIHNlYXJjaFBhbmVzXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIGZvciB0aGUgZGVmYXVsdCBmZWF0dXJlc1xuICAgICAgICAgKiBAcGFyYW0gaWR4IHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGZvciB0aGlzIHBhbmVcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gdGhlIHBhbmUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkLCBpbmNsdWRpbmcgdGhlIHRhYmxlIGFuZCB0aGUgaW5kZXggb2YgdGhlIHBhbmVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFNlYXJjaFBhbmUocGFuZVNldHRpbmdzLCBvcHRzLCBpZHgsIGxheW91dCwgcGFuZXNDb250YWluZXIsIHBhbmVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBhbmVzID09PSB2b2lkIDApIHsgcGFuZXMgPSBudWxsOyB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZXF1aXJlZCB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgaW5jbHVkZWRcbiAgICAgICAgICAgIGlmICghZGF0YVRhYmxlIHx8ICFkYXRhVGFibGUudmVyc2lvbkNoZWNrIHx8ICFkYXRhVGFibGUudmVyc2lvbkNoZWNrKCcxLjEwLjAnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoUGFuZSByZXF1aXJlcyBEYXRhVGFibGVzIDEuMTAgb3IgbmV3ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgU2VsZWN0IGlzIGluY2x1ZGVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgICAgICBpZiAoIWRhdGFUYWJsZS5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlYXJjaFBhbmUgcmVxdWlyZXMgU2VsZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFibGUgPSBuZXcgZGF0YVRhYmxlLkFwaShwYW5lU2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gJC5leHRlbmQodHJ1ZSwge30sIFNlYXJjaFBhbmUuY2xhc3Nlcyk7XG4gICAgICAgICAgICAvLyBHZXQgb3B0aW9ucyBmcm9tIHVzZXJcbiAgICAgICAgICAgIHRoaXMuYyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBTZWFyY2hQYW5lLmRlZmF1bHRzLCBvcHRzKTtcbiAgICAgICAgICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgb3B0cy5oaWRlQ291bnQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnZpZXdDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jLnZpZXdDb3VudCA9ICF0aGlzLmMuaGlkZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MgPSBwYW5lcztcbiAgICAgICAgICAgIHRoaXMucyA9IHtcbiAgICAgICAgICAgICAgICBjYXNjYWRlUmVnZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsZWFyaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb2xPcHRzOiBbXSxcbiAgICAgICAgICAgICAgICBkZXNlbGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlzcGxheWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkdDogdGFibGUsXG4gICAgICAgICAgICAgICAgZHRQYW5lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmlsdGVyaW5nQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaXJzdFNldDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb3JjZVZpZXdUb3RhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgICAgICAgICBpbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICBsYXN0Q2FzY2FkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGlzdFNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlZHJhdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcm93RGF0YToge1xuICAgICAgICAgICAgICAgICAgICBhcnJheUZpbHRlcjogW10sXG4gICAgICAgICAgICAgICAgICAgIGFycmF5T3JpZ2luYWw6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcnJheVRvdGFsczogW10sXG4gICAgICAgICAgICAgICAgICAgIGJpbnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBiaW5zT3JpZ2luYWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICBiaW5zVG90YWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxPcHRpb25zOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgICAgICAgICAgc2VhcmNoRnVuY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RQcmVzZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTZWxlY3Q6IFtdLFxuICAgICAgICAgICAgICAgIHNlcnZlclNlbGVjdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0ZpbHRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWJsZUxlbmd0aDogbnVsbCxcbiAgICAgICAgICAgICAgICB1cGRhdGluZzogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcm93TGVuZ3RoID0gdGFibGUuY29sdW1ucygpLmVxKDApLnRvQXJyYXkoKS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNvbEV4aXN0cyA9IHRoaXMucy5pbmRleCA8IHJvd0xlbmd0aDtcbiAgICAgICAgICAgIC8vIEFkZCBleHRyYSBlbGVtZW50cyB0byBET00gb2JqZWN0IGluY2x1ZGluZyBjbGVhciBhbmQgaGlkZSBidXR0b25zXG4gICAgICAgICAgICB0aGlzLmMubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICAgICAgdmFyIGxheVZhbCA9IHBhcnNlSW50KGxheW91dC5zcGxpdCgnLScpWzFdLCAxMCk7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IHtcbiAgICAgICAgICAgICAgICBidXR0b25Hcm91cDogJCgnPGRpdi8+JykuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmJ1dHRvbkdyb3VwKSxcbiAgICAgICAgICAgICAgICBjbGVhcjogJCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCI+JiMyMTU7PC9idXR0b24+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgJ3RydWUnKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnBhbmVCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuY2xlYXJCdXR0b24pLFxuICAgICAgICAgICAgICAgIGNvbGxhcHNlQnV0dG9uOiAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj48c3BhbiBjbGFzcz1cImR0c3AtY2FyZXRcIj4mI3g1ZTs8L3NwYW4+PC9idXR0b24+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5wYW5lQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmNvbGxhcHNlQnV0dG9uKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmxheW91dCArXG4gICAgICAgICAgICAgICAgICAgIChsYXlWYWwgPCAxMCA/IGxheW91dCA6IGxheW91dC5zcGxpdCgnLScpWzBdICsgJy05JykpLFxuICAgICAgICAgICAgICAgIGNvdW50QnV0dG9uOiAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnBhbmVCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuY291bnRCdXR0b24pLFxuICAgICAgICAgICAgICAgIGR0UDogJCgnPHRhYmxlPjx0aGVhZD48dHI+PHRoPicgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5jb2xFeGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJCh0YWJsZS5jb2x1bW4odGhpcy5jb2xFeGlzdHMgPyB0aGlzLnMuaW5kZXggOiAwKS5oZWFkZXIoKSkudGV4dCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLmhlYWRlciB8fCAnQ3VzdG9tIFBhbmUnKSArICc8L3RoPjx0aC8+PC90cj48L3RoZWFkPjwvdGFibGU+JyksXG4gICAgICAgICAgICAgICAgbG93ZXI6ICQoJzxkaXYvPicpLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5zdWJSb3cyKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMubmFycm93QnV0dG9uKSxcbiAgICAgICAgICAgICAgICBuYW1lQnV0dG9uOiAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnBhbmVCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMubmFtZUJ1dHRvbiksXG4gICAgICAgICAgICAgICAgcGFuZXNDb250YWluZXI6IHBhbmVzQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHNlYXJjaEJveDogJCgnPGlucHV0Lz4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMucGFuZUlucHV0QnV0dG9uKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuc2VhcmNoKSxcbiAgICAgICAgICAgICAgICBzZWFyY2hCdXR0b246ICQoJzxidXR0b24gdHlwZSA9IFwiYnV0dG9uXCIgY2xhc3M9XCInICsgdGhpcy5jbGFzc2VzLnNlYXJjaEljb24gKyAnXCI+PC9idXR0b24+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5wYW5lQnV0dG9uKSxcbiAgICAgICAgICAgICAgICBzZWFyY2hDb250OiAkKCc8ZGl2Lz4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuc2VhcmNoQ29udCksXG4gICAgICAgICAgICAgICAgc2VhcmNoTGFiZWxDb250OiAkKCc8ZGl2Lz4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuc2VhcmNoTGFiZWxDb250KSxcbiAgICAgICAgICAgICAgICB0b3BSb3c6ICQoJzxkaXYvPicpLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy50b3BSb3cpLFxuICAgICAgICAgICAgICAgIHVwcGVyOiAkKCc8ZGl2Lz4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuc3ViUm93MSkuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLm5hcnJvd1NlYXJjaClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnMuZGlzcGxheWVkID0gZmFsc2U7XG4gICAgICAgICAgICB0YWJsZSA9IHRoaXMucy5kdDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zLmNvbE9wdHMgPSB0aGlzLmNvbEV4aXN0cyA/IHRoaXMuX2dldE9wdGlvbnMoKSA6IHRoaXMuX2dldEJvbnVzT3B0aW9ucygpO1xuICAgICAgICAgICAgdmFyIGNvbE9wdHMgPSB0aGlzLnMuY29sT3B0cztcbiAgICAgICAgICAgIHZhciBjbGVhciA9ICQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPlg8L2J1dHRvbj4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMucGFuZUJ1dHRvbik7XG4gICAgICAgICAgICBjbGVhci50ZXh0KHRhYmxlLmkxOG4oJ3NlYXJjaFBhbmVzLmNsZWFyUGFuZScsIHRoaXMuYy5pMThuLmNsZWFyUGFuZSkpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFkZENsYXNzKGNvbE9wdHMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAhPT0gbnVsbCAmJiB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgOiAnJyk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIG9mIG5hbWUgaW5jYXNlIG9yZGVyaW5nIGlzIGRlc2lyZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnMuY29sT3B0cy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMubmFtZSA9IHRoaXMucy5jb2xPcHRzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAhPT0gbnVsbCAmJiB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMubmFtZSA9IHRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMubmFtZSA9IHRoaXMuY29sRXhpc3RzID9cbiAgICAgICAgICAgICAgICAgICAgJCh0YWJsZS5jb2x1bW4odGhpcy5zLmluZGV4KS5oZWFkZXIoKSkudGV4dCgpIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MuaGVhZGVyIHx8ICdDdXN0b20gUGFuZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHBhbmVzQ29udGFpbmVyKS5hcHBlbmQodGhpcy5kb20uY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciB0YWJsZU5vZGUgPSB0YWJsZS50YWJsZSgwKS5ub2RlKCk7XG4gICAgICAgICAgICAvLyBDdXN0b20gc2VhcmNoIGZ1bmN0aW9uIGZvciB0YWJsZVxuICAgICAgICAgICAgdGhpcy5zLnNlYXJjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWFyY2hEYXRhLCBkYXRhSW5kZXgsIG9yaWdEYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZGF0YSBoYXMgYmVlbiBzZWxlY3RlZCB0aGVuIHNob3cgYWxsXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MublRhYmxlICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb2xFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGZpbHRlcmVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gc2VhcmNoRGF0YVtfdGhpcy5zLmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbE9wdHMub3J0aG9nb25hbC5maWx0ZXIgIT09ICdmaWx0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGZpbHRlciB2YWx1ZSBmcm9tIHRoZSBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IF90aGlzLnMucm93RGF0YS5maWx0ZXJNYXAuZ2V0KGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgJC5mbi5kYXRhVGFibGUuQXBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlci50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZWFyY2goZmlsdGVyLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2gucHVzaCh0aGlzLnMuc2VhcmNoRnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNsZWFyIGJ1dHRvbiBmb3IgdGhpcyBwYW5lIGlzIGNsaWNrZWQgY2xlYXIgdGhlIHNlbGVjdGlvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLmMuY2xlYXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhci5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hlcyA9IF90aGlzLmRvbS5jb250YWluZXIuZmluZCgnLicgKyBfdGhpcy5jbGFzc2VzLnNlYXJjaC5yZXBsYWNlKC9cXHMrL2csICcuJykpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyUGFuZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB0b3Agcm93IG9mIHRoZSBwYW5lcyBjb250YWluaW5nIHRoZSBzZWFyY2ggYm94IGFuZCBvcmRlcmluZyBidXR0b25zIGFwcGVhcnNcbiAgICAgICAgICAgIC8vICB3ZWlyZCBpZiB0aGUgd2lkdGggb2YgdGhlIHBhbmVzIGlzIGxvd2VyIHRoYW4gZXhwZWN0ZWQsIHRoaXMgZml4ZXMgdGhlIGRlc2lnbi5cbiAgICAgICAgICAgIC8vIEVxdWFsbHkgdGhpcyBtYXkgb2NjdXIgd2hlbiB0aGUgdGFibGUgaXMgcmVzaXplZC5cbiAgICAgICAgICAgIHRhYmxlLm9uKCdkcmF3LmR0c3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRqdXN0VG9wUm93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhYmxlLm9uKCdidXR0b25zLWFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGp1c3RUb3BSb3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2hlbiBjb2x1bW4tcmVvcmRlciBpcyBwcmVzZW50IGFuZCB0aGUgY29sdW1ucyBhcmUgbW92ZWQsIGl0IGlzIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgICAgLy8gIHJlYXNzaWduIGFsbCBvZiB0aGUgcGFuZXMgaW5kZXhlcyB0byB0aGUgbmV3IGluZGV4IG9mIHRoZSBjb2x1bW4uXG4gICAgICAgICAgICB0YWJsZS5vbignY29sdW1uLXJlb3JkZXIuZHRzcCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGV0YWlscykge1xuICAgICAgICAgICAgICAgIF90aGlzLnMuaW5kZXggPSBkZXRhaWxzLm1hcHBpbmdbX3RoaXMucy5pbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgcm93IHRvIHRoZSBwYW5lcyB0YWJsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGlzcGxheSB0aGUgdmFsdWUgdG8gYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyXG4gICAgICAgICAqIEBwYXJhbSBmaWx0ZXIgdGhlIHZhbHVlIHRvIGJlIGZpbHRlcmVkIG9uIHdoZW4gc2VhcmNocGFuZXMgaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICogQHBhcmFtIHNob3duIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGFibGUgdGhhdCBhcmUgY3VycmVudGx5IHZpc2libGUgbWF0Y2hpbmcgdGhpcyBjcml0ZXJpYVxuICAgICAgICAgKiBAcGFyYW0gdG90YWwgdGhlIHRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSB0YWJsZSB0aGF0IG1hdGNoIHRoaXMgY3JpdGVyaWFcbiAgICAgICAgICogQHBhcmFtIHNvcnQgdGhlIHZhbHVlIHRvIGJlIHNvcnRlZCBpbiB0aGUgcGFuZSB0YWJsZVxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdmFsdWUgb2Ygd2hpY2ggdGhlIHR5cGUgaXMgdG8gYmUgZGVyaXZlZCBmcm9tXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5hZGRSb3cgPSBmdW5jdGlvbiAoZGlzcGxheSwgZmlsdGVyLCBzaG93biwgdG90YWwsIHNvcnQsIHR5cGUsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5pbmRleGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZmlsdGVyID09PSBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbnRyeS5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMucy5pbmRleGVzLnB1c2goeyBmaWx0ZXI6IGZpbHRlciwgaW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucy5kdFBhbmUucm93LmFkZCh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogZGlzcGxheSAhPT0gJycgP1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5IDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eU1lc3NhZ2UoKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgc2hvd246IHNob3duLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRqdXN0cyB0aGUgbGF5b3V0IG9mIHRoZSB0b3Agcm93IHdoZW4gdGhlIHNjcmVlbiBpcyByZXNpemVkXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5hZGp1c3RUb3BSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3ViQ29udGFpbmVycyA9IHRoaXMuZG9tLmNvbnRhaW5lci5maW5kKCcuJyArIHRoaXMuY2xhc3Nlcy5zdWJSb3dzQ29udGFpbmVyLnJlcGxhY2UoL1xccysvZywgJy4nKSk7XG4gICAgICAgICAgICB2YXIgc3ViUm93MSA9IHRoaXMuZG9tLmNvbnRhaW5lci5maW5kKCcuJyArIHRoaXMuY2xhc3Nlcy5zdWJSb3cxLnJlcGxhY2UoL1xccysvZywgJy4nKSk7XG4gICAgICAgICAgICB2YXIgc3ViUm93MiA9IHRoaXMuZG9tLmNvbnRhaW5lci5maW5kKCcuJyArIHRoaXMuY2xhc3Nlcy5zdWJSb3cyLnJlcGxhY2UoL1xccysvZywgJy4nKSk7XG4gICAgICAgICAgICB2YXIgdG9wUm93ID0gdGhpcy5kb20uY29udGFpbmVyLmZpbmQoJy4nICsgdGhpcy5jbGFzc2VzLnRvcFJvdy5yZXBsYWNlKC9cXHMrL2csICcuJykpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHdpZHRoIGlzIDAgdGhlbiBpdCBpcyBzYWZlIHRvIGFzc3VtZSB0aGF0IHRoZSBwYW5lIGhhcyBub3QgeWV0IGJlZW4gZGlzcGxheWVkLlxuICAgICAgICAgICAgLy8gIEV2ZW4gaWYgaXQgaGFzLCBpZiB0aGUgd2lkdGggaXMgMCBpdCB3b24ndCBtYWtlIGEgZGlmZmVyZW5jZSBpZiBpdCBoYXMgdGhlIG5hcnJvdyBjbGFzcyBvciBub3RcbiAgICAgICAgICAgIGlmICgoJChzdWJDb250YWluZXJzWzBdKS53aWR0aCgpIDwgMjUyIHx8ICQodG9wUm93WzBdKS53aWR0aCgpIDwgMjUyKSAmJiAkKHN1YkNvbnRhaW5lcnNbMF0pLndpZHRoKCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAkKHN1YkNvbnRhaW5lcnNbMF0pLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5uYXJyb3cpO1xuICAgICAgICAgICAgICAgICQoc3ViUm93MVswXSkuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLm5hcnJvd1N1YikucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLm5hcnJvd1NlYXJjaCk7XG4gICAgICAgICAgICAgICAgJChzdWJSb3cyWzBdKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMubmFycm93U3ViKS5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMubmFycm93QnV0dG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQoc3ViQ29udGFpbmVyc1swXSkucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLm5hcnJvdyk7XG4gICAgICAgICAgICAgICAgJChzdWJSb3cxWzBdKS5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMubmFycm93U3ViKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMubmFycm93U2VhcmNoKTtcbiAgICAgICAgICAgICAgICAkKHN1YlJvdzJbMF0pLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5uYXJyb3dTdWIpLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5uYXJyb3dCdXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gdGhlIGNhc2Ugb2YgYSByZWJ1aWxkIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgbmV3IGRhdGEgdG8gaGF2ZSBiZWVuIGluY2x1ZGVkIG9yIHJlbW92ZWRcbiAgICAgICAgICogc28gYWxsIG9mIHRoZSByb3dEYXRhIG11c3QgYmUgcmVzZXQgYXMgYSBwcmVjYXV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuY2xlYXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zLnJvd0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgYXJyYXlGaWx0ZXI6IFtdLFxuICAgICAgICAgICAgICAgIGFycmF5T3JpZ2luYWw6IFtdLFxuICAgICAgICAgICAgICAgIGFycmF5VG90YWxzOiBbXSxcbiAgICAgICAgICAgICAgICBiaW5zOiB7fSxcbiAgICAgICAgICAgICAgICBiaW5zT3JpZ2luYWw6IHt9LFxuICAgICAgICAgICAgICAgIGJpbnNUb3RhbDoge30sXG4gICAgICAgICAgICAgICAgZmlsdGVyTWFwOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgdG90YWxPcHRpb25zOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgdGhlIHNlbGVjdGlvbnMgaW4gdGhlIHBhbmVcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLmNsZWFyUGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERlc2VsZWN0IGFsbCByb3dzIHdoaWNoIGFyZSBzZWxlY3RlZCBhbmQgdXBkYXRlIHRoZSB0YWJsZSBhbmQgZmlsdGVyIGNvdW50LlxuICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGVzZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGFibGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGFwc2VzIHRoZSBwYW5lIHNvIHRoYXQgb25seSB0aGUgaGVhZGVyIGlzIGRpc3BsYXllZFxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuY29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnMuZGlzcGxheWVkIHx8XG4gICAgICAgICAgICAgICAgKCF0aGlzLmMuY29sbGFwc2UgJiYgdGhpcy5zLmNvbE9wdHMuY29sbGFwc2UgIT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmNvbE9wdHMuY29sbGFwc2UgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbGxhcHNlQnV0dG9uLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5yb3RhdGVkKTtcbiAgICAgICAgICAgICQodGhpcy5zLmR0UGFuZS50YWJsZSgpLmNvbnRhaW5lcigpKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZGVuKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRvcFJvdy5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYm9yZGVyZWQpO1xuICAgICAgICAgICAgdGhpcy5kb20uY291bnRCdXR0b24uYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5hbWVCdXR0b24uYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNlYXJjaEJ1dHRvbi5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pO1xuICAgICAgICAgICAgdGhpcy5kb20udG9wUm93Lm9uZSgnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpcHMgYWxsIG9mIHRoZSBTZWFyY2hQYW5lcyBlbGVtZW50cyBmcm9tIHRoZSBkb2N1bWVudCBhbmQgdHVybnMgYWxsIG9mIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBidXR0b25zIG9mZlxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLm9mZignLmR0c3AnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLm5hbWVCdXR0b24ub2ZmKCcuZHRzcCcpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29sbGFwc2VCdXR0b24ub2ZmKCcuZHRzcCcpO1xuICAgICAgICAgICAgdGhpcy5kb20uY291bnRCdXR0b24ub2ZmKCcuZHRzcCcpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xlYXIub2ZmKCcuZHRzcCcpO1xuICAgICAgICAgICAgdGhpcy5kb20uc2VhcmNoQnV0dG9uLm9mZignLmR0c3AnKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHZhciBzZWFyY2hJZHggPSAkLmZuLmRhdGFUYWJsZS5leHQuc2VhcmNoLmluZGV4T2YodGhpcy5zLnNlYXJjaEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChzZWFyY2hJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5zcGxpY2Uoc2VhcmNoSWR4LCAxKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hJZHggPSAkLmZuLmRhdGFUYWJsZS5leHQuc2VhcmNoLmluZGV4T2YodGhpcy5zLnNlYXJjaEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhdGFibGVzIGhhdmUgYmVlbiBkZWZpbmVkIGZvciB0aGUgcGFuZXMgdGhlbiBhbHNvIGRlc3Ryb3kgdGhlc2VcbiAgICAgICAgICAgIGlmICh0aGlzLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucy5saXN0U2V0ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXR0aW5nIHRoZSBsZWdhY3kgbWVzc2FnZSBpcyBhIGxpdHRsZSBjb21wbGV4IGR1ZSBhIGxlZ2FjeSBwYXJhbWV0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLmVtcHR5TWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLmMuaTE4bi5lbXB0eU1lc3NhZ2U7XG4gICAgICAgICAgICAvLyBMZWdhY3kgcGFyYW1ldGVyIHN1cHBvcnRcbiAgICAgICAgICAgIGlmICh0aGlzLmMuZW1wdHlNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGVmID0gdGhpcy5jLmVtcHR5TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHBlciBjb2x1bW5cbiAgICAgICAgICAgIGlmICh0aGlzLnMuY29sT3B0cy5lbXB0eU1lc3NhZ2UgIT09IGZhbHNlICYmIHRoaXMucy5jb2xPcHRzLmVtcHR5TWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZiA9IHRoaXMucy5jb2xPcHRzLmVtcHR5TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnMuZHQuaTE4bignc2VhcmNoUGFuZXMuZW1wdHlNZXNzYWdlJywgZGVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIG51bWJlciBvZiBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGFwcGxpZWQgaW4gdGhlIHRpdGxlXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5nZXRQYW5lQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYnVpbGRzIHRoZSBwYW5lcyBmcm9tIHRoZSBzdGFydCBoYXZpbmcgZGVsZXRlZCB0aGUgb2xkIG9uZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtPyBsYXN0IGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhpcyBpcyB0aGUgbGFzdCBwYW5lIGEgc2VsZWN0aW9uIHdhcyBtYWRlIGluXG4gICAgICAgICAqIEBwYXJhbT8gZGF0YUluIGRhdGEgdG8gYmUgdXNlZCBpbiBidWlsZFBhbmVcbiAgICAgICAgICogQHBhcmFtPyBpbml0IFdoZXRoZXIgdGhpcyBpcyB0aGUgaW5pdGlhbCBkcmF3IG9yIG5vdFxuICAgICAgICAgKiBAcGFyYW0/IG1haW50YWluU2VsZWN0aW9uIFdoZXRoZXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9ucyBhcmUgdG8gYmUgbWFpbnRhaW5lZCBvdmVyIHJlYnVpbGRcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLnJlYnVpbGRQYW5lID0gZnVuY3Rpb24gKGxhc3QsIGRhdGFJbiwgaW5pdCwgbWFpbnRhaW5TZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSB2b2lkIDApIHsgbGFzdCA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoZGF0YUluID09PSB2b2lkIDApIHsgZGF0YUluID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGluaXQgPT09IHZvaWQgMCkgeyBpbml0ID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKG1haW50YWluU2VsZWN0aW9uID09PSB2b2lkIDApIHsgbWFpbnRhaW5TZWxlY3Rpb24gPSBmYWxzZTsgfVxuICAgICAgICAgICAgdGhpcy5jbGVhckRhdGEoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucy5zZXJ2ZXJTZWxlY3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBwcmV2RWwgPSBudWxsO1xuICAgICAgICAgICAgLy8gV2hlbiByZWJ1aWxkaW5nIHN0cmlwIGFsbCBvZiB0aGUgSFRNTCBFbGVtZW50cyBvdXQgb2YgdGhlIGNvbnRhaW5lciBhbmQgc3RhcnQgZnJvbSBzY3JhdGNoXG4gICAgICAgICAgICBpZiAodGhpcy5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1haW50YWluU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cyA9IHRoaXMucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VydmVyU2VsZWN0ID0gdGhpcy5zLmR0UGFuZS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGF0YSgpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLmNsZWFyKCkuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHByZXZFbCA9IHRoaXMuZG9tLmNvbnRhaW5lci5wcmV2KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zLmR0UGFuZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAkLmZuLmRhdGFUYWJsZS5leHQuc2VhcmNoLnB1c2godGhpcy5zLnNlYXJjaEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZGVuKTtcbiAgICAgICAgICAgIHRoaXMucy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkUGFuZSghdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUgP1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cyA6XG4gICAgICAgICAgICAgICAgdGhpcy5zLnNlcnZlclNlbGVjdCwgbGFzdCwgZGF0YUluLCBpbml0LCBwcmV2RWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVzIHRoZSBwYW5lIGZyb20gdGhlIHBhZ2UgYW5kIHNldHMgdGhlIGRpc3BsYXllZCBwcm9wZXJ0eSB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLnJlbW92ZVBhbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnMuZGlzcGxheWVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplcyB0aGUgcGFuZSBiYXNlZCBvbiB0aGUgbGF5b3V0IHRoYXQgaXMgcGFzc2VkIGluXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBsYXlvdXQgdGhlIGxheW91dCB0byBiZSBhcHBsaWVkIHRvIHRoaXMgcGFuZVxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5jLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgICAgIHZhciBsYXlWYWwgPSBwYXJzZUludChsYXlvdXQuc3BsaXQoJy0nKVsxXSwgMTApO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmxheW91dCArXG4gICAgICAgICAgICAgICAgKGxheVZhbCA8IDEwID8gbGF5b3V0IDogbGF5b3V0LnNwbGl0KCctJylbMF0gKyAnLTknKSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5zLmNvbE9wdHMuY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAhPT0gbnVsbCAmJiB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgOiAnJylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnNob3cpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUb3BSb3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGNhc2NhZGVSZWdlbiBwcm9wZXJ0eSBvZiB0aGUgcGFuZS4gQWNjZXNzaWJsZSBmcm9tIGFib3ZlIGJlY2F1c2UgYXMgU2VhcmNoUGFuZXMudHNcbiAgICAgICAgICogZGVhbHMgd2l0aCB0aGUgcmVidWlsZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2YWwgdGhlIGJvb2xlYW4gdmFsdWUgdGhhdCB0aGUgY2FzY2FkZVJlZ2VuIHByb3BlcnR5IGlzIHRvIGJlIHNldCB0b1xuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuc2V0Q2FzY2FkZVJlZ2VuID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5zLmNhc2NhZGVSZWdlbiA9IHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHRoZSBjbGVhcmluZyBwcm9wZXJ0eSB0byBiZSBhc3NpZ25lZC4gVGhpcyBpcyB1c2VkIHdoZW4gaW1wbGVtZW50aW5nIGNhc2NhZGVQYW5lLlxuICAgICAgICAgKiBJbiBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSBmb3IgdGhlIGNsZWFyaW5nIG9mIHRoZSBwYW5lcyBzZWxlY3Rpb24gb24gdGhlIGRlc2VsZWN0cyBpdCBmb3JjZXMgdGhlIHBhbmUgdG9cbiAgICAgICAgICogcmVwb3B1bGF0ZSBmcm9tIHRoZSBlbnRpcmUgZGF0YXNldCBub3QganVzdCB0aGUgZGlzcGxheWVkIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZhbCB0aGUgYm9vbGVhbiB2YWx1ZSB3aGljaCB0aGUgY2xlYXJpbmcgcHJvcGVydHkgaXMgdG8gYmUgYXNzaWduZWRcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLnNldENsZWFyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5zLmNsZWFyaW5nID0gdmFsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwYW5kcyB0aGUgcGFuZSBmcm9tIHRoZSBjb2xsYXBzZWQgc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucy5kaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbS5jb2xsYXBzZUJ1dHRvbi5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMucm90YXRlZCk7XG4gICAgICAgICAgICAkKHRoaXMucy5kdFBhbmUudGFibGUoKS5jb250YWluZXIoKSkucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmhpZGRlbik7XG4gICAgICAgICAgICB0aGlzLmRvbS50b3BSb3cucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmJvcmRlcmVkKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvdW50QnV0dG9uLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbik7XG4gICAgICAgICAgICB0aGlzLmRvbS5uYW1lQnV0dG9uLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbik7XG4gICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hCdXR0b24ucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiBhbGwgb2YgdGhlIHBhbmVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkcmF3IHdoZXRoZXIgdGhpcyBoYXMgYmVlbiB0cmlnZ2VyZWQgYnkgYSBkcmF3IGV2ZW50IG9yIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUudXBkYXRlUGFuZSA9IGZ1bmN0aW9uIChkcmF3KSB7XG4gICAgICAgICAgICBpZiAoZHJhdyA9PT0gdm9pZCAwKSB7IGRyYXcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdGhpcy5zLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbW1vbihkcmF3KTtcbiAgICAgICAgICAgIHRoaXMucy51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcGFuZXMgaWYgb25lIG9mIHRoZSBvcHRpb25zIHRvIGRvIHNvIGhhcyBiZWVuIHNldCB0byB0cnVlXG4gICAgICAgICAqIHJhdGhlciB0aGFuIHRoZSBmaWx0ZXJlZCBtZXNzYWdlIHdoZW4gdXNpbmcgdmlld1RvdGFsLlxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUudXBkYXRlVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5zLmR0UGFuZS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGF0YSgpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IHNlbGVjdGVkUm93cztcbiAgICAgICAgICAgIHRoaXMuX3NlYXJjaEV4dHJhcygpO1xuICAgICAgICAgICAgLy8gSWYgZWl0aGVyIG9mIHRoZSBvcHRpb25zIHRoYXQgZWZmZWN0IGhvdyB0aGUgcGFuZXMgYXJlIGRpc3BsYXllZCBhcmUgc2VsZWN0ZWQgdGhlbiB1cGRhdGUgdGhlIFBhbmVzXG4gICAgICAgICAgICBpZiAodGhpcy5jLmNhc2NhZGVQYW5lcyB8fCB0aGlzLmMudmlld1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBwYW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBIYXZpbmcgaXQgaW4gaXQncyBvd24gZnVuY3Rpb24gbWFrZXMgaXQgZWFzaWVyIHRvIG9ubHkgc2V0IHRoZW0gb25jZVxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuX3NldExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcm93RGF0YSA9IHRoaXMucy5yb3dEYXRhO1xuICAgICAgICAgICAgdmFyIHQwO1xuICAgICAgICAgICAgLy8gV2hlbiBhbiBpdGVtIGlzIHNlbGVjdGVkIG9uIHRoZSBwYW5lLCBhZGQgdGhlc2UgdG8gdGhlIGFycmF5IHdoaWNoIGhvbGRzIHNlbGVjdGVkIGl0ZW1zLlxuICAgICAgICAgICAgLy8gQ3VzdG9tIHNlYXJjaCB3aWxsIHBlcmZvcm0uXG4gICAgICAgICAgICB0aGlzLnMuZHRQYW5lLm9mZignc2VsZWN0LmR0c3AnKTtcbiAgICAgICAgICAgIHRoaXMucy5kdFBhbmUub24oJ3NlbGVjdC5kdHNwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0MCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSAmJiAhX3RoaXMucy51cGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnMuc2VydmVyU2VsZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLnNlcnZlclNlbGVjdCA9IF90aGlzLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5zY3JvbGxUb3AgPSAkKF90aGlzLnMuZHRQYW5lLnRhYmxlKCkubm9kZSgpKS5wYXJlbnQoKVswXS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLnNlbGVjdFByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5kcmF3KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghX3RoaXMucy51cGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLnNlbGVjdFByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbWFrZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLnNlbGVjdFByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNsZWFyLnJlbW92ZUNsYXNzKF90aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdoZW4gYW4gaXRlbSBpcyBkZXNlbGVjdGVkIG9uIHRoZSBwYW5lLCByZSBhZGQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcyB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIC8vIHdoaWNoIGhvbGRzIHNlbGVjdGVkIGl0ZW1zLiBDdXN0b20gc2VhcmNoIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS5vZmYoJ2Rlc2VsZWN0LmR0c3AnKTtcbiAgICAgICAgICAgIHRoaXMucy5kdFBhbmUub24oJ2Rlc2VsZWN0LmR0c3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdDAgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5zY3JvbGxUb3AgPSAkKF90aGlzLnMuZHRQYW5lLnRhYmxlKCkubm9kZSgpKS5wYXJlbnQoKVswXS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUgJiYgIV90aGlzLnMudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucy5zZXJ2ZXJTZWxlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLnNlcnZlclNlbGVjdCA9IF90aGlzLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZGVzZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuZHJhdyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmRlc2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYWtlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmRlc2VsZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNsZWFyLmFkZENsYXNzKF90aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pLmF0dHIoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgd2UgYXR0ZW1wdHkgdG8gdHVybiBvZmYgdGhpcyBldmVudCB0aGVuIGl0IHdpbGwgcnVpbiBiZWhhdmlvdXIgaW4gb3RoZXIgcGFuZXNcbiAgICAgICAgICAgIC8vICBzbyBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIG9ubHkgZG9uZSBvbmNlXG4gICAgICAgICAgICBpZiAodGhpcy5zLmZpcnN0U2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zLmZpcnN0U2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzYXZpbmcgdGhlIHN0YXRlIHN0b3JlIGFsbCBvZiB0aGUgc2VsZWN0ZWQgcm93cyBmb3IgcHJlc2VsZWN0aW9uIG5leHQgdGltZSBhcm91bmRcbiAgICAgICAgICAgICAgICB0aGlzLnMuZHQub24oJ3N0YXRlU2F2ZVBhcmFtcy5kdHNwJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGJlaW5nIHBhc3NlZCBpbiBpcyBlbXB0eSB0aGVuIHN0YXRlIGNsZWFyIG11c3QgaGF2ZSBvY2N1cmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGNsZWFyIHRoZSBwYW5lcyBzdGF0ZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmlzRW1wdHlPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZHRQYW5lLnN0YXRlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hUZXJtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlGaWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgc3RhdGUgc2F2ZSBmcm9tIHRoZSBwYW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IF90aGlzLnMuZHRQYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmZpbHRlci50b1N0cmluZygpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hUZXJtID0gX3RoaXMuZG9tLnNlYXJjaEJveC52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyID0gX3RoaXMucy5kdFBhbmUub3JkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbnMgPSByb3dEYXRhLmJpbnNPcmlnaW5hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5RmlsdGVyID0gcm93RGF0YS5hcnJheU9yaWdpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkID0gX3RoaXMuZG9tLmNvbGxhcHNlQnV0dG9uLmhhc0NsYXNzKF90aGlzLmNsYXNzZXMucm90YXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2VhcmNoUGFuZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlYXJjaFBhbmVzLnBhbmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXMucGFuZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VhcmNoUGFuZXMucGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlYXJjaFBhbmVzLnBhbmVzW2ldLmlkID09PSBfdGhpcy5zLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lcy5wYW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGFuZXMgZGF0YSB0byB0aGUgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXMucGFuZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheUZpbHRlcjogYXJyYXlGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5zOiBiaW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkOiBjb2xsYXBzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX3RoaXMucy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiBvcmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm06IHNlYXJjaFRlcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnMuZHRQYW5lLm9mZigndXNlci1zZWxlY3QuZHRzcCcpO1xuICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS5vbigndXNlci1zZWxlY3QuZHRzcCcsIGZ1bmN0aW9uIChlLCBfZHQsIHR5cGUsIGNlbGwsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnMuZHRQYW5lLm9mZignZHJhdy5kdHNwJyk7XG4gICAgICAgICAgICB0aGlzLnMuZHRQYW5lLm9uKCdkcmF3LmR0c3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRqdXN0VG9wUm93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGJ1dHRvbiB0byBvcmRlciBieSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9ucyBpcyBjbGlja2VkIHRoZW5cbiAgICAgICAgICAgIC8vICBjaGFuZ2UgdGhlIG9yZGVyaW5nIHRvIHdoYXRldmVyIGl0IGlzbid0IGN1cnJlbnRseVxuICAgICAgICAgICAgdGhpcy5kb20ubmFtZUJ1dHRvbi5vZmYoJ2NsaWNrLmR0c3AnKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5hbWVCdXR0b24ub24oJ2NsaWNrLmR0c3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRPcmRlciA9IF90aGlzLnMuZHRQYW5lLm9yZGVyKClbMF1bMV07XG4gICAgICAgICAgICAgICAgX3RoaXMucy5kdFBhbmUub3JkZXIoWzAsIGN1cnJlbnRPcmRlciA9PT0gJ2FzYycgPyAnZGVzYycgOiAnYXNjJ10pLmRyYXcoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQgc28gdGhhdCB0aGUgb3JkZXJpbmcgb2YgdGhlIHBhbmVzIGlzIG1haW50YWluZWRcbiAgICAgICAgICAgICAgICBfdGhpcy5zLmR0LnN0YXRlLnNhdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgYnV0dG9uIHRvIG9yZGVyIGJ5IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY29sdW1uIGlzIGNsaWNrZWQgdGhlblxuICAgICAgICAgICAgLy8gIGNoYW5nZSB0aGUgb3JkZXJpbmcgdG8gd2hhdGV2ZXIgaXQgaXNuJ3QgY3VycmVudGx5XG4gICAgICAgICAgICB0aGlzLmRvbS5jb3VudEJ1dHRvbi5vZmYoJ2NsaWNrLmR0c3AnKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvdW50QnV0dG9uLm9uKCdjbGljay5kdHNwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50T3JkZXIgPSBfdGhpcy5zLmR0UGFuZS5vcmRlcigpWzBdWzFdO1xuICAgICAgICAgICAgICAgIF90aGlzLnMuZHRQYW5lLm9yZGVyKFsxLCBjdXJyZW50T3JkZXIgPT09ICdhc2MnID8gJ2Rlc2MnIDogJ2FzYyddKS5kcmF3KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzdGF0ZSBzYXZlIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIG9yZGVyaW5nIG9mIHRoZSBwYW5lcyBpcyBtYWludGFpbmVkXG4gICAgICAgICAgICAgICAgX3RoaXMucy5kdC5zdGF0ZS5zYXZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGJ1dHRvbiB0byBvcmRlciBieSB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNvbHVtbiBpcyBjbGlja2VkIHRoZW5cbiAgICAgICAgICAgIC8vICBjaGFuZ2UgdGhlIG9yZGVyaW5nIHRvIHdoYXRldmVyIGl0IGlzbid0IGN1cnJlbnRseVxuICAgICAgICAgICAgdGhpcy5kb20uY29sbGFwc2VCdXR0b24ub2ZmKCdjbGljay5kdHNwJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb2xsYXBzZUJ1dHRvbi5vbignY2xpY2suZHRzcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gJChfdGhpcy5zLmR0UGFuZS50YWJsZSgpLmNvbnRhaW5lcigpKTtcbiAgICAgICAgICAgICAgICAvLyBUb2dnbGUgdGhlIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY29sbGFwc2VCdXR0b24udG9nZ2xlQ2xhc3MoX3RoaXMuY2xhc3Nlcy5yb3RhdGVkKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudG9nZ2xlQ2xhc3MoX3RoaXMuY2xhc3Nlcy5oaWRkZW4pO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS50b3BSb3cudG9nZ2xlQ2xhc3MoX3RoaXMuY2xhc3Nlcy5ib3JkZXJlZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNvdW50QnV0dG9uLnRvZ2dsZUNsYXNzKF90aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5uYW1lQnV0dG9uLnRvZ2dsZUNsYXNzKF90aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5zZWFyY2hCdXR0b24udG9nZ2xlQ2xhc3MoX3RoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5oYXNDbGFzcyhfdGhpcy5jbGFzc2VzLmhpZGRlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9tLnRvcFJvdy5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kb20uY29sbGFwc2VCdXR0b24uY2xpY2soKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20udG9wUm93Lm9mZignY2xpY2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucy5kdC5zdGF0ZS5zYXZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBjbGVhciBidXR0b24gaXMgY2xpY2tlZCByZXNldCB0aGUgcGFuZVxuICAgICAgICAgICAgdGhpcy5kb20uY2xlYXIub2ZmKCdjbGljay5kdHNwJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGVhci5vbignY2xpY2suZHRzcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoZXMgPSBfdGhpcy5kb20uY29udGFpbmVyLmZpbmQoJy4nICsgX3RoaXMuY2xhc3Nlcy5zZWFyY2gucmVwbGFjZSgvIC9nLCAnLicpKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgc2VhcmNoIGJveCB0byBiZSBhbiBlbXB0eSBzdHJpbmcgYW5kIHRoZW4gc2VhcmNoIG9uIHRoYXQsIGVmZmVjdGl2ZWx5IHJlc2V0aW5nXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyUGFuZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBzZWFyY2ggYnV0dG9uIGlzIGNsaWNrZWQgdGhlbiBkcmF3IGZvY3VzIHRvIHRoZSBzZWFyY2ggYm94XG4gICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hCdXR0b24ub2ZmKCdjbGljay5kdHNwJyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hCdXR0b24ub24oJ2NsaWNrLmR0c3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLnNlYXJjaEJveC5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXaGVuIGEgY2hhcmFjdGVyIGlzIGlucHV0dGVkIGludG8gdGhlIHNlYXJjaGJveCBzZWFyY2ggdGhlIHBhbmUgZm9yIG1hdGNoaW5nIHZhbHVlcy5cbiAgICAgICAgICAgIC8vIERvaW5nIGl0IHRoaXMgd2F5IG1lYW5zIHRoYXQgbm8gYnV0dG9uIGhhcyB0byBiZSBjbGlja2VkIHRvIHRyaWdnZXIgYSBzZWFyY2gsIGl0IGlzIGRvbmUgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHRoaXMuZG9tLnNlYXJjaEJveC5vZmYoJ2NsaWNrLmR0c3AnKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNlYXJjaEJveC5vbignaW5wdXQuZHRzcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNodmFsID0gX3RoaXMuZG9tLnNlYXJjaEJveC52YWwoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zLmR0UGFuZS5zZWFyY2goc2VhcmNodmFsKS5kcmF3KCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2h2YWwgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWFyY2h2YWwubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNodmFsLmxlbmd0aCA9PT0gMCAmJiBfdGhpcy5zLmR0UGFuZS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGF0YSgpLnRvQXJyYXkoKS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXIucmVtb3ZlQ2xhc3MoX3RoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbikucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jbGVhci5hZGRDbGFzcyhfdGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKS5hdHRyKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZCBzbyB0aGF0IHRoZSBzZWFyY2hpbmcgb24gdGhlIHBhbmVzIGlzIG1haW50YWluZWRcbiAgICAgICAgICAgICAgICBfdGhpcy5zLmR0LnN0YXRlLnNhdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBpbiBwb3RlbnRpYWxseSB1bmRldGVjdGVkIHJvd3MgYW5kIGFkZHMgdGhlbSB0byB0aGUgYXJyYXkgaWYgdGhleSBhcmUgbm90IHlldCBmZWF0dXJlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZmlsdGVyIHRoZSBmaWx0ZXIgdmFsdWUgb2YgdGhlIHBvdGVudGlhbCByb3dcbiAgICAgICAgICogQHBhcmFtIGRpc3BsYXkgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIHBvdGVudGlhbCByb3dcbiAgICAgICAgICogQHBhcmFtIHNvcnQgdGhlIHNvcnQgdmFsdWUgb2YgdGhlIHBvdGVudGlhbCByb3dcbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgdmFsdWUgb2YgdGhlIHBvdGVudGlhbCByb3dcbiAgICAgICAgICogQHBhcmFtIGFycmF5RmlsdGVyIHRoZSBhcnJheSB0byBiZSBwb3B1bGF0ZWRcbiAgICAgICAgICogQHBhcmFtIGJpbnMgdGhlIGJpbnMgdG8gYmUgcG9wdWxhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5fYWRkT3B0aW9uID0gZnVuY3Rpb24gKGZpbHRlciwgZGlzcGxheSwgc29ydCwgdHlwZSwgYXJyYXlGaWx0ZXIsIGJpbnMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWx0ZXIgaXMgYW4gYXJyYXkgdGhlbiB0YWtlIGEgbm90ZSBvZiB0aGlzLCBhbmQgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgYXJyYXlGaWx0ZXIgYXJyYXlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikgfHwgZmlsdGVyIGluc3RhbmNlb2YgZGF0YVRhYmxlLkFwaSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gYW4gYXJyYXkgc28gdGhhdCB3ZSBjYW4gd29yayB3aXRoIGl0XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIGRhdGFUYWJsZS5BcGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9IGRpc3BsYXkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmxlbmd0aCA9PT0gZGlzcGxheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIHJvdyBiZWZvcmUgYWRkIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJpbnNbZmlsdGVyW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbnNbZmlsdGVyW2ldXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlGaWx0ZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGRpc3BsYXlbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0OiBzb3J0W2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBpbmNyZW1lbnQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5zW2ZpbHRlcltpXV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheSBhbmQgZmlsdGVyIG5vdCB0aGUgc2FtZSBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWVzIHdlcmUgYWZmZWN0ZWQgYnkgb3Rob2dvbmFsIGRhdGEgYW5kIGFyZSBub3QgYW4gYXJyYXkgdGhlbiBjaGVjayBpZiBpdCBpcyBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnMuY29sT3B0cy5vcnRob2dvbmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghYmluc1tmaWx0ZXJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbnNbZmlsdGVyXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5RmlsdGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZGlzcGxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmluc1tmaWx0ZXJdKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QganVzdCBiZSBhZGRpbmcgYW4gb3B0aW9uXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheUZpbHRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZGlzcGxheSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjb25zdHJ1Y3QgdGhlIGFjdHVhbCBwYW5lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRSb3dzIHByZXZpb3VzbHkgc2VsZWN0ZWQgUm93cyB0byBiZSByZXNlbGVjdGVkXG4gICAgICAgICAqIEBsYXN0IGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIHBhbmUgd2FzIHRoZSBsYXN0IG9uZSB0byBoYXZlIGEgc2VsZWN0aW9uIG1hZGVcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9idWlsZFBhbmUgPSBmdW5jdGlvbiAoc2VsZWN0ZWRSb3dzLCBsYXN0LCBkYXRhSW4sIGluaXQsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFJvd3MgPT09IHZvaWQgMCkgeyBzZWxlY3RlZFJvd3MgPSBbXTsgfVxuICAgICAgICAgICAgaWYgKGxhc3QgPT09IHZvaWQgMCkgeyBsYXN0ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChkYXRhSW4gPT09IHZvaWQgMCkgeyBkYXRhSW4gPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7IGluaXQgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAocHJldkVsID09PSB2b2lkIDApIHsgcHJldkVsID0gbnVsbDsgfVxuICAgICAgICAgICAgLy8gQWxpYXNlc1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG4gICAgICAgICAgICB2YXIgdGFibGUgPSB0aGlzLnMuZHQ7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGFibGUuY29sdW1uKHRoaXMuY29sRXhpc3RzID8gdGhpcy5zLmluZGV4IDogMCk7XG4gICAgICAgICAgICB2YXIgY29sT3B0cyA9IHRoaXMucy5jb2xPcHRzO1xuICAgICAgICAgICAgdmFyIHJvd0RhdGEgPSB0aGlzLnMucm93RGF0YTtcbiAgICAgICAgICAgIC8vIE90aGVyIFZhcmlhYmxlc1xuICAgICAgICAgICAgdmFyIGNvdW50TWVzc2FnZSA9IHRhYmxlLmkxOG4oJ3NlYXJjaFBhbmVzLmNvdW50JywgdGhpcy5jLmkxOG4uY291bnQpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkTWVzc2FnZSA9IHRhYmxlLmkxOG4oJ3NlYXJjaFBhbmVzLmNvdW50RmlsdGVyZWQnLCB0aGlzLmMuaTE4bi5jb3VudEZpbHRlcmVkKTtcbiAgICAgICAgICAgIHZhciBsb2FkZWRGaWx0ZXIgPSB0YWJsZS5zdGF0ZS5sb2FkZWQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaXN0ZW5lcnMgaGF2ZSBub3QgYmVlbiBzZXQgeWV0IHRoZW4gdXNpbmcgdGhlIGxhdGVzdCBzdGF0ZSBtYXkgcmVzdWx0IGluIGZ1bm55IGVycm9yc1xuICAgICAgICAgICAgaWYgKHRoaXMucy5saXN0U2V0KSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkRmlsdGVyID0gdGFibGUuc3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCBhIGN1c3RvbSBwYW5lIGluIHBsYWNlXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZEZpbHRlciAmJiBsb2FkZWRGaWx0ZXIuc2VhcmNoUGFuZXMgJiYgbG9hZGVkRmlsdGVyLnNlYXJjaFBhbmVzLnBhbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9hZGVkRmlsdGVyLnNlYXJjaFBhbmVzLnBhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkRmlsdGVyLnNlYXJjaFBhbmVzLnBhbmVzW2ldLmlkID09PSB0aGlzLnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY2hlY2tzIHRoYXQgZG8gbm90IHJlcXVpcmUgcG9wdWxhdGUgcGFuZSB0byBydW5cbiAgICAgICAgICAgICAgICBpZiAoKGNvbE9wdHMuc2hvdyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgY29sT3B0cy5zaG93ICE9PSB1bmRlZmluZWQgJiYgY29sT3B0cy5zaG93ICE9PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgICBpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbE9wdHMuc2hvdyA9PT0gdHJ1ZSB8fCBpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5kaXNwbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgIChkYXRhSW4gPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbi5zZWFyY2hQYW5lcyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUluLnNlYXJjaFBhbmVzLm9wdGlvbnMgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHBvcHVsYXRlUGFuZSBpZiB0aGUgZGF0YSBoYXMgbm90IGJlZW4gY29sbGVjdGVkIHlldFxuICAgICAgICAgICAgICAgICAgICBpZiAocm93RGF0YS5hcnJheUZpbHRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlUGFuZShsYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXRhaWxzUGFuZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YS5hcnJheU9yaWdpbmFsID0gcm93RGF0YS5hcnJheVRvdGFscztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0RhdGEuYmluc09yaWdpbmFsID0gcm93RGF0YS5iaW5zVG90YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbkxlbmd0aCA9IE9iamVjdC5rZXlzKHJvd0RhdGEuYmluc09yaWdpbmFsKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlxdWVSYXRpbyA9IHRoaXMuX3VuaXF1ZVJhdGlvKGJpbkxlbmd0aCwgdGFibGUucm93cygpWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgdGhlIHBhbmUgaWYgdGhlcmUgaXNuJ3QgZW5vdWdoIHZhcmlhbmNlIGluIHRoZSBkYXRhLCBvciB0aGVyZSBpcyBvbmx5IDEgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgLy8gIGZvciB0aGF0IHBhbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5kaXNwbGF5ZWQgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGNvbE9wdHMuc2hvdyA9PT0gdW5kZWZpbmVkICYmIGNvbE9wdHMudGhyZXNob2xkID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVSYXRpbyA+IHRoaXMuYy50aHJlc2hvbGQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVJhdGlvID4gY29sT3B0cy50aHJlc2hvbGQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sT3B0cy5zaG93ICE9PSB0cnVlICYmIGJpbkxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5oaWRkZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gdmlld1RvdGFsIGlzIHRydWUgdGhlbiBmaW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0b3RhbCBjb3VudCBmb3IgdGhlIHdob2xlIHRhYmxlIHRvIGRpc3BsYXkgYWxvbmdzaWRlIHRoZSBkaXNwbGF5ZWQgY291bnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYy52aWV3VG90YWwgJiYgcm93RGF0YS5hcnJheVRvdGFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXRhaWxzUGFuZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YS5iaW5zVG90YWwgPSByb3dEYXRhLmJpbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5zaG93KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmRpc3BsYXllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFJbiAhPT0gbnVsbCAmJiBkYXRhSW4uc2VhcmNoUGFuZXMgIT09IG51bGwgJiYgZGF0YUluLnNlYXJjaFBhbmVzLm9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFJbi50YWJsZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMudGFibGVMZW5ndGggPSBkYXRhSW4udGFibGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMucm93RGF0YS50b3RhbE9wdGlvbnMgPSB0aGlzLnMudGFibGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zLnRhYmxlTGVuZ3RoID09PSBudWxsIHx8IHRhYmxlLnJvd3MoKVswXS5sZW5ndGggPiB0aGlzLnMudGFibGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy50YWJsZUxlbmd0aCA9IHRhYmxlLnJvd3MoKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMucm93RGF0YS50b3RhbE9wdGlvbnMgPSB0aGlzLnMudGFibGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbFRpdGxlID0gdGFibGUuY29sdW1uKHRoaXMucy5pbmRleCkuZGF0YVNyYygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUluLnNlYXJjaFBhbmVzLm9wdGlvbnNbY29sVGl0bGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkYXRhSW4uc2VhcmNoUGFuZXMub3B0aW9uc1tjb2xUaXRsZV07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFQb2ludCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMucm93RGF0YS5hcnJheUZpbHRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZGF0YVBvaW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGRhdGFQb2ludC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydDogZGF0YVBvaW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBkYXRhUG9pbnQubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMucm93RGF0YS5iaW5zW2RhdGFQb2ludC52YWx1ZV0gPSB0aGlzLmMudmlld1RvdGFsIHx8IHRoaXMuYy5jYXNjYWRlUGFuZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUG9pbnQuY291bnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUG9pbnQudG90YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnJvd0RhdGEuYmluc1RvdGFsW2RhdGFQb2ludC52YWx1ZV0gPSBkYXRhUG9pbnQudG90YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbkxlbmd0aCA9IE9iamVjdC5rZXlzKHJvd0RhdGEuYmluc1RvdGFsKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlxdWVSYXRpbyA9IHRoaXMuX3VuaXF1ZVJhdGlvKGJpbkxlbmd0aCwgdGhpcy5zLnRhYmxlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2hvdyB0aGUgcGFuZSBpZiB0aGVyZSBpc250IGVub3VnaCB2YXJpYW5jZSBpbiB0aGUgZGF0YSwgb3IgdGhlcmUgaXMgb25seSAxIGVudHJ5IGZvciB0aGF0IHBhbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5kaXNwbGF5ZWQgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGNvbE9wdHMuc2hvdyA9PT0gdW5kZWZpbmVkICYmIGNvbE9wdHMudGhyZXNob2xkID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVSYXRpbyA+IHRoaXMuYy50aHJlc2hvbGQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVJhdGlvID4gY29sT3B0cy50aHJlc2hvbGQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sT3B0cy5zaG93ICE9PSB0cnVlICYmIGJpbkxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5oaWRkZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLmFycmF5T3JpZ2luYWwgPSB0aGlzLnMucm93RGF0YS5hcnJheUZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnJvd0RhdGEuYmluc09yaWdpbmFsID0gdGhpcy5zLnJvd0RhdGEuYmlucztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmRpc3BsYXllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zLmRpc3BsYXllZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFyaWFuY2UgaXMgYWNjY2VwdGFibGUgdGhlbiBkaXNwbGF5IHRoZSBzZWFyY2ggcGFuZVxuICAgICAgICAgICAgdGhpcy5fZGlzcGxheVBhbmUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zLmxpc3RTZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBIZXJlLCB3aGVuIHRoZSBzdGF0ZSBpcyBsb2FkZWQgaWYgdGhlIGRhdGEgb2JqZWN0IG9uIHRoZSBvcmlnaW5hbCB0YWJsZSBpcyBlbXB0eSxcbiAgICAgICAgICAgICAgICAvLyAgdGhlbiBhIHN0YXRlLmNsZWFyKCkgbXVzdCBoYXZlIG9jY3VycmVkLCBzbyBkZWxldGUgYWxsIG9mIHRoZSBwYW5lcyB0YWJsZXMgc3RhdGUgb2JqZWN0cyB0b28uXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZHRQLm9uKCdzdGF0ZUxvYWRQYXJhbXMuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNFbXB0eU9iamVjdCh0YWJsZS5zdGF0ZS5sb2FkZWQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY29udGFpbmVyIHRvIHRoZSBkb2N1bWVudCBpbiBpdHMgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIGlmIChwcmV2RWwgIT09IG51bGwgJiYgdGhpcy5kb20ucGFuZXNDb250YWluZXIuaGFzKHByZXZFbCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5pbnNlcnRBZnRlcihwcmV2RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucGFuZXNDb250YWluZXIucHJlcGVuZCh0aGlzLmRvbS5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjbGFyZSB0aGUgZGF0YXRhYmxlIGZvciB0aGUgcGFuZVxuICAgICAgICAgICAgdmFyIGVyck1vZGUgPSAkLmZuLmRhdGFUYWJsZS5leHQuZXJyTW9kZTtcbiAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlLmV4dC5lcnJNb2RlID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAgICAgdmFyIGhhdmVTY3JvbGxlciA9IGRhdGFUYWJsZS5TY3JvbGxlcjtcbiAgICAgICAgICAgIHRoaXMucy5kdFBhbmUgPSB0aGlzLmRvbS5kdFAuRGF0YVRhYmxlKCQuZXh0ZW5kKHRydWUsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWZzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0c3AtbmFtZUNvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAnZGlzcGxheScsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NvcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cuc29ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfdGhpcy5zLmZpbHRlcmluZ0FjdGl2ZSB8fCBfdGhpcy5zLnNob3dGaWx0ZXJlZCkgJiYgX3RoaXMuYy52aWV3VG90YWwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmMudmlld1RvdGFsICYmIF90aGlzLnMuZm9yY2VWaWV3VG90YWwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRNZXNzYWdlLnJlcGxhY2UoL3t0b3RhbH0vLCByb3cudG90YWwpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50TWVzc2FnZS5yZXBsYWNlKC97dG90YWx9Lywgcm93LnRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC97c2hvd259Lywgcm93LnNob3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWVzc2FnZS5pbmNsdWRlcygne3RvdGFsfScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL3t0b3RhbH0vLCByb3cudG90YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWVzc2FnZS5pbmNsdWRlcygne3Nob3dufScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL3tzaG93bn0vLCByb3cuc2hvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZGlzcGxheWluZyB0aGUgY291bnQgaW4gdGhlIHNhbWUgY29sdW1uZSBhcyB0aGUgbmFtZSBvZiB0aGUgc2VhcmNoIG9wdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHNvIHRoYXQgdGhlcmUgaXMgbm90IG5lZWQgdG8gY2FsbCBjb2x1bW5zLmFkanVzdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdoaWNoIGluIHR1cm4gc3BlZWRzIHVwIHRoZSBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpbGwgPSAnPHNwYW4gY2xhc3M9XCInICsgX3RoaXMuY2xhc3Nlcy5waWxsICsgJ1wiPicgKyBtZXNzYWdlICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuYy52aWV3Q291bnQgfHwgIWNvbE9wdHMudmlld0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmaWx0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5tYXRjaCgvPFtePl0qPi8pICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVwbGFjZSgvPFtePl0qPi9nLCAnJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiJyArIF90aGlzLmNsYXNzZXMubmFtZUNvbnQgKyAnXCI+PHNwYW4gdGl0bGU9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLm1hdGNoKC88W14+XSo+LykgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZXBsYWNlKC88W14+XSo+L2csICcnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIiBjbGFzcz1cIicgKyBfdGhpcy5jbGFzc2VzLm5hbWUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgKyAnPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWxsICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGUgcHJpdmF0ZSBkYXRhdGFibGVzIHByb3BlcnR5IHRvIHNldCB0eXBlIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCB0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbnVsbCBpZiBub3QgZGVmaW5lZCBieSB0aGUgdXNlciwgbWVhbmluZyB0aGF0IGF1dG9tYXRpYyB0eXBlIGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdvdWxkIHRha2UgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRhYmxlLnNldHRpbmdzKClbMF0uYW9Db2x1bW5zW3RoaXMucy5pbmRleF0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc2V0dGluZ3MoKVswXS5hb0NvbHVtbnNbdGhpcy5zLmluZGV4XS5fc01hbnVhbFR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHRzcC1jb3VudENvbHVtbiAnICsgdGhpcy5jbGFzc2VzLmJhZGdlUGlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICdzaG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckRhdGE6IFsxLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICd0b3RhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWZlclJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkb206ICd0JyxcbiAgICAgICAgICAgICAgICBpbmZvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5zLmR0LnNldHRpbmdzKClbMF0ub0xhbmd1YWdlLFxuICAgICAgICAgICAgICAgIHBhZ2luZzogaGF2ZVNjcm9sbGVyID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjcm9sbFg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjcm9sbFk6ICcyMDBweCcsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXI6IGhhdmVTY3JvbGxlciA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhdGVTYXZlOiB0YWJsZS5zZXR0aW5ncygpWzBdLm9GZWF0dXJlcy5iU3RhdGVTYXZlID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgICAgICB9LCB0aGlzLmMuZHRPcHRzLCBjb2xPcHRzICE9PSB1bmRlZmluZWQgPyBjb2xPcHRzLmR0T3B0cyA6IHt9LCB0aGlzLnMuY29sT3B0cy5vcHRpb25zICE9PSB1bmRlZmluZWQgfHwgIXRoaXMuY29sRXhpc3RzID9cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRSb3c6IGZ1bmN0aW9uIChyb3csIGRhdGEsIGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChyb3cpLmFkZENsYXNzKGRhdGEuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MgIT09IG51bGwgJiYgdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MuZHRPcHRzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLmR0T3B0cyA6XG4gICAgICAgICAgICAgICAge30sICQuZm4uZGF0YVRhYmxlLnZlcnNpb25DaGVjaygnMicpXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tTGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcFJpZ2h0OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICAgICAgdGhpcy5kb20uZHRQLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy50YWJsZSk7XG4gICAgICAgICAgICAvLyBHZXR0aW5nIGNvbHVtbiB0aXRsZXMgaXMgYSBsaXR0bGUgbWVzc3lcbiAgICAgICAgICAgIHZhciBoZWFkZXJUZXh0ID0gJ0N1c3RvbSBQYW5lJztcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAmJiB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJUZXh0ID0gdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MuaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sT3B0cy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJUZXh0ID0gY29sT3B0cy5oZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbEV4aXN0cykge1xuICAgICAgICAgICAgICAgIGhlYWRlclRleHQgPSAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soJzInKVxuICAgICAgICAgICAgICAgICAgICA/IHRhYmxlLmNvbHVtbih0aGlzLnMuaW5kZXgpLnRpdGxlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0YWJsZS5zZXR0aW5ncygpWzBdLmFvQ29sdW1uc1t0aGlzLnMuaW5kZXhdLnNUaXRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLnNlYXJjaEJveC5hdHRyKCdwbGFjZWhvbGRlcicsIGhlYWRlclRleHQpO1xuICAgICAgICAgICAgLy8gQXMgdGhlIHBhbmUgdGFibGUgaXMgbm90IGluIHRoZSBkb2N1bWVudCB5ZXQgd2UgbXVzdCBpbml0aWFsaXNlIHNlbGVjdCBvdXJzZWx2ZXNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlLnNlbGVjdC5pbml0KHRoaXMucy5kdFBhbmUpO1xuICAgICAgICAgICAgJC5mbi5kYXRhVGFibGUuZXh0LmVyck1vZGUgPSBlcnJNb2RlO1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGEgY3VzdG9tIHBhbmVcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbEV4aXN0cykge1xuICAgICAgICAgICAgICAgIC8vIE9uIGluaXRpYWxpc2F0aW9uLCBkbyB3ZSBuZWVkIHRvIHNldCBhIGZpbHRlcmluZyB2YWx1ZSBmcm9tIGFcbiAgICAgICAgICAgICAgICAvLyBzYXZlZCBzdGF0ZSBvciBpbml0IG9wdGlvbj9cbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoID0gY29sdW1uLnNlYXJjaCgpO1xuICAgICAgICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaCA/IHNlYXJjaC5zdWJzdHIoMSwgc2VhcmNoLmxlbmd0aCAtIDIpLnNwbGl0KCd8JykgOiBbXTtcbiAgICAgICAgICAgICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGVtcHR5IGNlbGxzXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgIHJvd0RhdGEuYXJyYXlGaWx0ZXIuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5maWx0ZXIgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudF8xKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIG9mIHRoZSBzZWFyY2ggb3B0aW9ucyB0byB0aGUgcGFuZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSByb3dEYXRhLmFycmF5RmlsdGVyLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5zLnNlcnZlclNlbGVjdDsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmZpbHRlciA9PT0gcm93RGF0YS5hcnJheUZpbHRlcltpXS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXRoaXMuYy5jYXNjYWRlUGFuZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmMuY2FzY2FkZVBhbmVzICYmIHJvd0RhdGEuYmluc1tyb3dEYXRhLmFycmF5RmlsdGVyW2ldLmZpbHRlcl0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmMuY2FzY2FkZVBhbmVzICYmIGluaXQgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmFkZFJvdyhyb3dEYXRhLmFycmF5RmlsdGVyW2ldLmRpc3BsYXksIHJvd0RhdGEuYXJyYXlGaWx0ZXJbaV0uZmlsdGVyLCBpbml0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhLmJpbnNUb3RhbFtyb3dEYXRhLmFycmF5RmlsdGVyW2ldLmZpbHRlcl0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0RhdGEuYmluc1tyb3dEYXRhLmFycmF5RmlsdGVyW2ldLmZpbHRlcl0sIHRoaXMuYy52aWV3VG90YWwgfHwgaW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKHJvd0RhdGEuYmluc1RvdGFsW3Jvd0RhdGEuYXJyYXlGaWx0ZXJbaV0uZmlsdGVyXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJvd0RhdGEuYmluc1tyb3dEYXRhLmFycmF5RmlsdGVyW2ldLmZpbHRlcl0sIHJvd0RhdGEuYXJyYXlGaWx0ZXJbaV0uc29ydCwgcm93RGF0YS5hcnJheUZpbHRlcltpXS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSB0aGlzLnMuc2VydmVyU2VsZWN0OyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5maWx0ZXIgPT09IHJvd0RhdGEuYXJyYXlGaWx0ZXJbaV0uZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5zZXJ2ZXJTZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5zZXJ2ZXJTZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhLmFycmF5RmlsdGVyW2ldICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocm93RGF0YS5iaW5zW3Jvd0RhdGEuYXJyYXlGaWx0ZXJbaV0uZmlsdGVyXSAhPT0gdW5kZWZpbmVkIHx8ICF0aGlzLmMuY2FzY2FkZVBhbmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSb3cocm93RGF0YS5hcnJheUZpbHRlcltpXS5kaXNwbGF5LCByb3dEYXRhLmFycmF5RmlsdGVyW2ldLmZpbHRlciwgcm93RGF0YS5iaW5zW3Jvd0RhdGEuYXJyYXlGaWx0ZXJbaV0uZmlsdGVyXSwgcm93RGF0YS5iaW5zVG90YWxbcm93RGF0YS5hcnJheUZpbHRlcltpXS5maWx0ZXJdLCByb3dEYXRhLmFycmF5RmlsdGVyW2ldLnNvcnQsIHJvd0RhdGEuYXJyYXlGaWx0ZXJbaV0udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHBhc3MgYW4gZW1wdHkgc3RyaW5nIGFzIHRoZSBtZXNzYWdlIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGF0IGluIGFkZFJvdygpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFJvdygnJywgY291bnRfMSwgY291bnRfMSwgJycsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgICAgICBkYXRhVGFibGUuc2VsZWN0LmluaXQodGhpcy5zLmR0UGFuZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgY3VzdG9tIG9wdGlvbnMgc2V0IG9yIGl0IGlzIGEgY3VzdG9tIHBhbmUgdGhlbiBnZXQgdGhlbVxuICAgICAgICAgICAgaWYgKGNvbE9wdHMub3B0aW9ucyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21QYW5lU2V0dGluZ3MgIT09IG51bGwgJiYgdGhpcy5jdXN0b21QYW5lU2V0dGluZ3Mub3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Q29tcGFyaXNvblJvd3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIHBhbmVcbiAgICAgICAgICAgIHRoaXMucy5kdFBhbmUuZHJhdygpO1xuICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS50YWJsZSgpLm5vZGUoKS5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IHRoaXMucy5zY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvcFJvdygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnMubGlzdFNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMucy5saXN0U2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9mID0gMCwgc2VsZWN0ZWRSb3dzXzEgPSBzZWxlY3RlZFJvd3M7IF9mIDwgc2VsZWN0ZWRSb3dzXzEubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGVkUm93c18xW19mXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2cgPSAwLCBfaCA9IHRoaXMucy5kdFBhbmUucm93cygpLmluZGV4ZXMoKS50b0FycmF5KCk7IF9nIDwgX2gubGVuZ3RoOyBfZysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gX2hbX2ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucy5kdFBhbmUucm93KHJvdykuZGF0YSgpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZmlsdGVyID09PSB0aGlzLnMuZHRQYW5lLnJvdyhyb3cpLmRhdGEoKS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGhhcHBlbmluZyB3aGVuIHNlcnZlclNpZGUgcHJvY2Vzc2luZyBpcyBoYXBwZW5pbmcgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBkaWZmZXJlbnQgYmVoYXZpb3VyIGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VydmVyU2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS5yb3cocm93KS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnNlcnZlclNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS5yb3cocm93KS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAgSWYgU1NQIGFuZCB0aGUgdGFibGUgaXMgcmVhZHksIGFwcGx5IHRoZSBzZWFyY2ggZm9yIHRoZSBwYW5lXG4gICAgICAgICAgICBpZiAodGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLnNlYXJjaCh0aGlzLmRvbS5zZWFyY2hCb3gudmFsKCkpLmRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5jLmluaXRDb2xsYXBzZWQgJiYgdGhpcy5zLmNvbE9wdHMuaW5pdENvbGxhcHNlZCAhPT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnMuY29sT3B0cy5pbml0Q29sbGFwc2VkKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmMuY29sbGFwc2UgJiYgdGhpcy5zLmNvbE9wdHMuY29sbGFwc2UgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5jb2xPcHRzLmNvbGxhcHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbG9hZCB0aGUgc2VsZWN0aW9uLCBzZWFyY2hib3ggZW50cnkgYW5kIG9yZGVyaW5nIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGhlcmUgaWYgU1NQIHRoYXQgdGhpcyBpcyB0aGUgZmlyc3QgZHJhdywgb3RoZXJ3aXNlIGl0IHdpbGwgaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgaWYgKGxvYWRlZEZpbHRlciAmJlxuICAgICAgICAgICAgICAgIGxvYWRlZEZpbHRlci5zZWFyY2hQYW5lcyAmJlxuICAgICAgICAgICAgICAgIGxvYWRlZEZpbHRlci5zZWFyY2hQYW5lcy5wYW5lcyAmJlxuICAgICAgICAgICAgICAgIChkYXRhSW4gPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUluLmRyYXcgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmMuY2FzY2FkZVBhbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbG9hZFNlbGVjdChsb2FkZWRGaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gbG9hZGVkRmlsdGVyLnNlYXJjaFBhbmVzLnBhbmVzOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9rW19qXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUuaWQgPT09IHRoaXMucy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBzb21lIHRpbWUgYnkgb25seSB0cmlnZ2VyaW5nIGFuIGlucHV0IGlmIHRoZXJlIGlzIGEgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLnNlYXJjaFRlcm0gJiYgcGFuZS5zZWFyY2hUZXJtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hCb3gudmFsKHBhbmUuc2VhcmNoVGVybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uc2VhcmNoQm94LnRyaWdnZXIoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLm9yZGVyKHBhbmUub3JkZXIpLmRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSBwYW5lIHRvIGJlIGhpZGRlbiBvciBzaG93bj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGFycmF5IHdoaWNoIGhvbGRzIHRoZSBkaXNwbGF5IGFuZCBmaWx0ZXIgdmFsdWVzIGZvciB0aGUgdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9kZXRhaWxzUGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMucy5kdDtcbiAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLmFycmF5VG90YWxzID0gW107XG4gICAgICAgICAgICB0aGlzLnMucm93RGF0YS5iaW5zVG90YWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMucy5kdC5zZXR0aW5ncygpWzBdO1xuICAgICAgICAgICAgdmFyIGluZGV4QXJyYXkgPSB0YWJsZS5yb3dzKCkuaW5kZXhlcygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5kZXhBcnJheV8xID0gaW5kZXhBcnJheTsgX2kgPCBpbmRleEFycmF5XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dJZHggPSBpbmRleEFycmF5XzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3B1bGF0ZVBhbmVBcnJheShyb3dJZHgsIHRoaXMucy5yb3dEYXRhLmFycmF5VG90YWxzLCBzZXR0aW5ncywgdGhpcy5zLnJvd0RhdGEuYmluc1RvdGFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIGFsbCBvZiB0aGUgSFRNTCBlbGVtZW50cyB0byB0aGVpciByZWxldmFudCBwYXJlbnQgRWxlbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9kaXNwbGF5UGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRvbS5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgY29sT3B0cyA9IHRoaXMucy5jb2xPcHRzO1xuICAgICAgICAgICAgdmFyIGxheVZhbCA9IHBhcnNlSW50KHRoaXMuYy5sYXlvdXQuc3BsaXQoJy0nKVsxXSwgMTApO1xuICAgICAgICAgICAgLy8gRW1wdHkgZXZlcnl0aGluZyB0byBzdGFydCBhZ2FpblxuICAgICAgICAgICAgdGhpcy5kb20udG9wUm93LmVtcHR5KCk7XG4gICAgICAgICAgICB0aGlzLmRvbS5kdFAuZW1wdHkoKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRvcFJvdy5hZGRDbGFzcyh0aGlzLmNsYXNzZXMudG9wUm93KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gMyBjb2x1bW5zIGRlZmluZWQgdGhlbiBtYWtlIHRoZXJlIGJlIGEgc21hbGxlciBnYXAgYmV0d2VlbiB0aGUgcGFuZXNcbiAgICAgICAgICAgIGlmIChsYXlWYWwgPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5zbWFsbEdhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbS50b3BSb3cuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnN1YlJvd3NDb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5kb20udXBwZXIuYXBwZW5kVG8odGhpcy5kb20udG9wUm93KTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmxvd2VyLmFwcGVuZFRvKHRoaXMuZG9tLnRvcFJvdyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hDb250LmFwcGVuZFRvKHRoaXMuZG9tLnVwcGVyKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmJ1dHRvbkdyb3VwLmFwcGVuZFRvKHRoaXMuZG9tLmxvd2VyKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHNlbGVjdGlvbnMgaGF2ZSBiZWVuIG1hZGUgaW4gdGhlIHBhbmUgdGhlbiBkaXNhYmxlIHRoZSBjbGVhciBidXR0b25cbiAgICAgICAgICAgIGlmICh0aGlzLmMuZHRPcHRzLnNlYXJjaGluZyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICBjb2xPcHRzLmR0T3B0cyAhPT0gdW5kZWZpbmVkICYmIGNvbE9wdHMuZHRPcHRzLnNlYXJjaGluZyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAoIXRoaXMuYy5jb250cm9scyB8fCAhY29sT3B0cy5jb250cm9scykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5kdE9wdHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5kdE9wdHMuc2VhcmNoaW5nICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLmR0T3B0cy5zZWFyY2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hCb3hcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5wYW5lSW5wdXRCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbS5zZWFyY2hCb3guYXBwZW5kVG8odGhpcy5kb20uc2VhcmNoQ29udCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBzZWFyY2hDb250IGRpdi4gV29ydGggbm90aW5nIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGNoYW5nZSB3aGVuIHVzaW5nIHNlbWFudGljIHVpXG4gICAgICAgICAgICB0aGlzLl9zZWFyY2hDb250U2V0dXAoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjbGVhciBidXR0b24gaXMgYWxsb3dlZCB0byBzaG93IHRoZW4gZGlzcGxheSBpdFxuICAgICAgICAgICAgaWYgKHRoaXMuYy5jbGVhciAmJiB0aGlzLmMuY29udHJvbHMgJiYgY29sT3B0cy5jb250cm9scykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyLmFwcGVuZFRvKHRoaXMuZG9tLmJ1dHRvbkdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmMub3JkZXJhYmxlICYmIGNvbE9wdHMub3JkZXJhYmxlICYmIHRoaXMuYy5jb250cm9scyAmJiBjb2xPcHRzLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ubmFtZUJ1dHRvbi5hcHBlbmRUbyh0aGlzLmRvbS5idXR0b25Hcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY291bnQgY29sdW1uIGlzIGhpZGRlbiB0aGVuIGRvbid0IGRpc3BsYXkgdGhlIG9yZGVyaW5nIGJ1dHRvbiBmb3IgaXRcbiAgICAgICAgICAgIGlmICh0aGlzLmMudmlld0NvdW50ICYmXG4gICAgICAgICAgICAgICAgY29sT3B0cy52aWV3Q291bnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmMub3JkZXJhYmxlICYmXG4gICAgICAgICAgICAgICAgY29sT3B0cy5vcmRlcmFibGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmMuY29udHJvbHMgJiZcbiAgICAgICAgICAgICAgICBjb2xPcHRzLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY291bnRCdXR0b24uYXBwZW5kVG8odGhpcy5kb20uYnV0dG9uR3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmMuY29sbGFwc2UgJiYgdGhpcy5zLmNvbE9wdHMuY29sbGFwc2UgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zLmNvbE9wdHMuY29sbGFwc2UpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jLmNvbnRyb2xzICYmIGNvbE9wdHMuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb2xsYXBzZUJ1dHRvbi5hcHBlbmRUbyh0aGlzLmRvbS5idXR0b25Hcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbS50b3BSb3cucHJlcGVuZFRvKHRoaXMuZG9tLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKHRoaXMuZG9tLmR0UCk7XG4gICAgICAgICAgICBjb250YWluZXIuc2hvdygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIHJvdyBmb3IgdGhlIGN1c3RvbVBhbmVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBvcHRpb25zIGZvciB0aGUgcm93IGV4dGVuZGVkIHRvIGluY2x1ZGUgdGhlIG9wdGlvbnMgZnJvbSB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9nZXRCb251c09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlc2V0IHRoZSB0aHJlc2hvbGRzIGFzIGlmIHRoZXkgaGF2ZSBhIHZhbHVlIGluIGNvbE9wdHMgdGhlbiB0aGF0IHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgdmFyIGRlZmF1bHRNdXRhdG9yID0ge1xuICAgICAgICAgICAgICAgIG9ydGhvZ29uYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIFNlYXJjaFBhbmUuZGVmYXVsdHMsIGRlZmF1bHRNdXRhdG9yLCB0aGlzLmMgIT09IHVuZGVmaW5lZCA/IHRoaXMuYyA6IHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgdGhlIGN1c3RvbSBvcHRpb25zIHRvIHRoZSBwYW5lXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygcm93cyB3aGljaCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIHBhbmVcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9nZXRDb21wYXJpc29uUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb2xPcHRzID0gdGhpcy5zLmNvbE9wdHM7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBhcHByb3ByaWF0ZSBvcHRpb25zIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoaXMgaXMgYSBwYW5lIGZvciBhIHNwZWNpZmljIGNvbHVtbiBvciBhIGN1c3RvbSBwYW5lXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbE9wdHMub3B0aW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjb2xPcHRzLm9wdGlvbnNcbiAgICAgICAgICAgICAgICA6IHRoaXMuY3VzdG9tUGFuZVNldHRpbmdzICE9PSBudWxsICYmIHRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLm9wdGlvbnMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLm9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhYmxlVmFscyA9IHRoaXMucy5kdC5yb3dzKHsgc2VhcmNoOiAnYXBwbGllZCcgfSkuZGF0YSgpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHZhciBhcHBSb3dzID0gdGhpcy5zLmR0LnJvd3MoeyBzZWFyY2g6ICdhcHBsaWVkJyB9KTtcbiAgICAgICAgICAgIHZhciB0YWJsZVZhbHNUb3RhbCA9IHRoaXMucy5kdC5yb3dzKCkuZGF0YSgpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHZhciBhbGxSb3dzID0gdGhpcy5zLmR0LnJvd3MoKTtcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgb2YgdGhlIG90aGVyIHJvd3MgZnJvbSB0aGUgcGFuZSwgb25seSBjdXN0b20gb3B0aW9ucyBhcmUgdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhleSBhcmUgZGVmaW5lZFxuICAgICAgICAgICAgdGhpcy5zLmR0UGFuZS5jbGVhcigpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvcHRpb25zXzEgPSBvcHRpb25zOyBfaSA8IG9wdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IG9wdGlvbnNfMVtfaV07XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgb2JqZWN0IHdoaWNoIGlzIHRvIGJlIHBsYWNlZCBpbiB0aGUgcm93XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGNvbXAubGFiZWwgIT09ICcnID9cbiAgICAgICAgICAgICAgICAgICAgY29tcC5sYWJlbCA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHlNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmlzb25PYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY29tcC5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGluc2VydCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB0eXBlb2YgY29tcC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbXAudmFsdWUgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd246IDAsXG4gICAgICAgICAgICAgICAgICAgIHNvcnQ6IGluc2VydCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc2VydFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gZnVuY3Rpb24gaXMgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXAudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUgZm9yIHRoZSBkYXRhIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdFZhbCA9IDA7IHRWYWwgPCB0YWJsZVZhbHMubGVuZ3RoOyB0VmFsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wLnZhbHVlLmNhbGwodGhpcy5zLmR0LCB0YWJsZVZhbHNbdFZhbF0sIGFwcFJvd3NbMF1bdFZhbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvbk9iai5zaG93bisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlIGZvciB0aGUgb3JpZ2luYWwgZGF0YSBpbiB0aGUgVGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZVZhbHNUb3RhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAudmFsdWUuY2FsbCh0aGlzLnMuZHQsIHRhYmxlVmFsc1RvdGFsW2ldLCBhbGxSb3dzWzBdW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmlzb25PYmoudG90YWwrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbXBhcmlzb25PYmpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJpc29uT2JqLmZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvbk9iai5maWx0ZXIucHVzaChjb21wLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgY2FzY2FkZVBhbmVzIGlzIG5vdCBhY3RpdmUgb3IgaWYgaXQgaXMgYW5kIHRoZSBjb21wYXJpc29uT2JqIHNob3VsZCBiZSBzaG93biB0aGVuIGFkZCBpdCB0byB0aGUgcGFuZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jLmNhc2NhZGVQYW5lcyB8fCB0aGlzLmMuY2FzY2FkZVBhbmVzICYmIGNvbXBhcmlzb25PYmouc2hvd24gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHRoaXMuYWRkUm93KGNvbXBhcmlzb25PYmouZGlzcGxheSwgY29tcGFyaXNvbk9iai5maWx0ZXIsIGNvbXBhcmlzb25PYmouc2hvd24sIGNvbXBhcmlzb25PYmoudG90YWwsIGNvbXBhcmlzb25PYmouc29ydCwgY29tcGFyaXNvbk9iai50eXBlLCBjb21wYXJpc29uT2JqLmNsYXNzTmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIHJvdyBmb3IgdGhlIGN1c3RvbVBhbmVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBvcHRpb25zIGZvciB0aGUgcm93IGV4dGVuZGVkIHRvIGluY2x1ZGUgdGhlIG9wdGlvbnMgZnJvbSB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9nZXRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5zLmR0O1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZXNldCB0aGUgdGhyZXNob2xkcyBhcyBpZiB0aGV5IGhhdmUgYSB2YWx1ZSBpbiBjb2xPcHRzIHRoZW4gdGhhdCB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TXV0YXRvciA9IHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZTogbnVsbCxcbiAgICAgICAgICAgICAgICBlbXB0eU1lc3NhZ2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluaXRDb2xsYXBzZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgb3J0aG9nb25hbDoge1xuICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5PcHRpb25zID0gdGFibGUuc2V0dGluZ3MoKVswXS5hb0NvbHVtbnNbdGhpcy5zLmluZGV4XS5zZWFyY2hQYW5lcztcbiAgICAgICAgICAgIHZhciBjb2xPcHRzID0gJC5leHRlbmQodHJ1ZSwge30sIFNlYXJjaFBhbmUuZGVmYXVsdHMsIGRlZmF1bHRNdXRhdG9yLCBjb2x1bW5PcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5PcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBjb2x1bW5PcHRpb25zLmhpZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgY29sdW1uT3B0aW9ucy52aWV3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbE9wdHMudmlld0NvdW50ID0gIWNvbHVtbk9wdGlvbnMuaGlkZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbE9wdHM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIGNoYW5nZXMgdG8gdGhlIHBhbmVzIGFuZCB0YWJsZSB0byBiZSBtYWRlIHdoZW4gYSBzZWxlY3Rpb24gb3IgYSBkZXNlbGVjdGlvbiBvY2N1cnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlbGVjdCBEZW5vdGVzIHdoZXRoZXIgYSBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZSBvciBub3RcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmUucHJvdG90eXBlLl9tYWtlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUYWJsZSgpO1xuICAgICAgICAgICAgdGhpcy5zLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucy5kdC5kcmF3KCk7XG4gICAgICAgICAgICB0aGlzLnMudXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbGwgdGhlIGFycmF5IHdpdGggdGhlIHZhbHVlcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgZGlzcGxheWVkIGluIHRoZSB0YWJsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGFzdCBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyB3YXMgdGhlIGxhc3QgcGFuZSBhIHNlbGVjdGlvbiB3YXMgbWFkZSBpblxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuX3BvcHVsYXRlUGFuZSA9IGZ1bmN0aW9uIChsYXN0KSB7XG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gdm9pZCAwKSB7IGxhc3QgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5zLmR0O1xuICAgICAgICAgICAgdGhpcy5zLnJvd0RhdGEuYXJyYXlGaWx0ZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLmJpbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMucy5kdC5zZXR0aW5ncygpWzBdO1xuICAgICAgICAgICAgLy8gSWYgY2FzY2FkZVBhbmVzIG9yIHZpZXdUb3RhbCBhcmUgYWN0aXZlIGl0IGlzIG5lY2Vzc2FyeSB0byBnZXQgdGhlIGRhdGEgd2hpY2ggaXMgY3VycmVudGx5XG4gICAgICAgICAgICAvLyBiZWluZyBkaXNwbGF5ZWQgZm9yIHRoZWlyIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgICAgICAvLyBBbHNvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgd2FzIG5vdCB0aGUgbGFzdCBwYW5lIHRvIGhhdmUgYSBzZWxlY3Rpb24gbWFkZVxuICAgICAgICAgICAgaWYgKCF0aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEFycmF5ID0gKHRoaXMuYy5jYXNjYWRlUGFuZXMgfHwgdGhpcy5jLnZpZXdUb3RhbCkgJiYgKCF0aGlzLnMuY2xlYXJpbmcgJiYgIWxhc3QpID9cbiAgICAgICAgICAgICAgICAgICAgdGFibGUucm93cyh7IHNlYXJjaDogJ2FwcGxpZWQnIH0pLmluZGV4ZXMoKSA6XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLnJvd3MoKS5pbmRleGVzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGluZGV4QXJyYXkudG9BcnJheSgpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlUGFuZUFycmF5KGluZGV4LCB0aGlzLnMucm93RGF0YS5hcnJheUZpbHRlciwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvcHVsYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBvZiB0aGUgZGF0YSBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3dJZHggVGhlIGN1cnJlbnQgcm93IGluZGV4IHRvIGJlIGNvbXBhcmVkXG4gICAgICAgICAqIEBwYXJhbSBhcnJheUZpbHRlciBUaGUgYXJyYXkgdGhhdCBpcyB0byBiZSBwb3B1bGF0ZWQgd2l0aCByb3cgRGV0YWlsc1xuICAgICAgICAgKiBAcGFyYW0gYmlucyBUaGUgYmlucyBvYmplY3QgdGhhdCBpcyB0byBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgcm93IGNvdW50c1xuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuX3BvcHVsYXRlUGFuZUFycmF5ID0gZnVuY3Rpb24gKHJvd0lkeCwgYXJyYXlGaWx0ZXIsIHNldHRpbmdzLCBiaW5zKSB7XG4gICAgICAgICAgICBpZiAoYmlucyA9PT0gdm9pZCAwKSB7IGJpbnMgPSB0aGlzLnMucm93RGF0YS5iaW5zOyB9XG4gICAgICAgICAgICB2YXIgY29sT3B0cyA9IHRoaXMucy5jb2xPcHRzO1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlbmRlcmVkIGRhdGEgZnJvbSB0aGUgY2VsbCB1c2luZyB0aGUgZm5HZXRDZWxsRGF0YSBmdW5jdGlvblxuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gdGhlIGNlbGwoKS5yZW5kZXIgQVBJIG1ldGhvZCBmb3Igb3B0aW1pc2F0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbE9wdHMub3J0aG9nb25hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWQgPSBzZXR0aW5ncy5vQXBpLl9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIHRoaXMucy5pbmRleCwgY29sT3B0cy5vcnRob2dvbmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMucm93RGF0YS5maWx0ZXJNYXAuc2V0KHJvd0lkeCwgcmVuZGVyZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE9wdGlvbihyZW5kZXJlZCwgcmVuZGVyZWQsIHJlbmRlcmVkLCByZW5kZXJlZCwgYXJyYXlGaWx0ZXIsIGJpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHNldHRpbmdzLm9BcGkuX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd0lkeCwgdGhpcy5zLmluZGV4LCBjb2xPcHRzLm9ydGhvZ29uYWwuc2VhcmNoKTtcbiAgICAgICAgICAgICAgICAvLyBOdWxsIGFuZCBlbXB0eSBzdHJpbmcgYXJlIHRvIGJlIGNvbnNpZGVyZWQgdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnMucm93RGF0YS5maWx0ZXJNYXAuc2V0KHJvd0lkeCwgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJpbnNbZmlsdGVyXSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5zW2ZpbHRlcl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRPcHRpb24oZmlsdGVyLCBzZXR0aW5ncy5vQXBpLl9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIHRoaXMucy5pbmRleCwgY29sT3B0cy5vcnRob2dvbmFsLmRpc3BsYXkpLCBzZXR0aW5ncy5vQXBpLl9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIHRoaXMucy5pbmRleCwgY29sT3B0cy5vcnRob2dvbmFsLnNvcnQpLCBzZXR0aW5ncy5vQXBpLl9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIHRoaXMucy5pbmRleCwgY29sT3B0cy5vcnRob2dvbmFsLnR5cGUpLCBhcnJheUZpbHRlciwgYmlucyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmluc1tmaWx0ZXJdKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVsb2FkcyBhbGwgb2YgdGhlIHByZXZpb3VzIHNlbGVjdHMgaW50byB0aGUgcGFuZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxvYWRlZEZpbHRlciBUaGUgbG9hZGVkIGZpbHRlcnMgZnJvbSBhIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5fcmVsb2FkU2VsZWN0ID0gZnVuY3Rpb24gKGxvYWRlZEZpbHRlcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXRlIHdhcyBub3Qgc2F2ZWQgZG9uJ3Qgc2VsZWN0ZWQgYW55XG4gICAgICAgICAgICBpZiAobG9hZGVkRmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWR4O1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggcGFuZSwgY2hlY2sgdGhhdCB0aGUgbG9hZGVkRmlsdGVyIGxpc3QgZXhpc3RzIGFuZCBpcyBub3QgbnVsbCxcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGlkIG9mIGVhY2ggc2VhcmNoIGl0ZW0gYW5kIHNldCBpdCB0byBiZSBzZWxlY3RlZC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9hZGVkRmlsdGVyLnNlYXJjaFBhbmVzLnBhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZEZpbHRlci5zZWFyY2hQYW5lcy5wYW5lc1tpXS5pZCA9PT0gdGhpcy5zLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMucy5kdFBhbmU7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSB0YWJsZS5yb3dzKHsgb3JkZXI6ICdpbmRleCcgfSkuZGF0YSgpLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5maWx0ZXIgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmZpbHRlci50b1N0cmluZygpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDsgfSkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBsb2FkZWRGaWx0ZXIuc2VhcmNoUGFuZXMucGFuZXNbaWR4XS5zZWxlY3RlZDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcm93cy5pbmRleE9mKGZpbHRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnNlcnZlclNlbGVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5yb3coaWQpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnNlcnZlclNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgZGVjaWRlcyB3aGV0aGVyIGEgcm93IHNob3VsZCBjb250cmlidXRlIHRvIHRoZSBwYW5lIG9yIG5vdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZmlsdGVyIHRoZSB2YWx1ZSB0aGF0IHRoZSByb3cgaXMgdG8gYmUgZmlsdGVyZWQgb25cbiAgICAgICAgICogQHBhcmFtIGRhdGFJbmRleCB0aGUgcm93IGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5fc2VhcmNoID0gZnVuY3Rpb24gKGZpbHRlciwgZGF0YUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29sT3B0cyA9IHRoaXMucy5jb2xPcHRzO1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5zLmR0O1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggaXRlbSBzZWxlY3RlZCBpbiB0aGUgcGFuZSwgY2hlY2sgaWYgaXQgaXMgYXZhaWxhYmxlIGluIHRoZSBjZWxsXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zZWxlY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xTZWxlY3QgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xTZWxlY3QuZmlsdGVyID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlsdGVyIHZhbHVlIHdpbGwgbm90IGhhdmUgdGhlICZhbXA7IGluIHBsYWNlIGJ1dCBhICYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZG8gYSByZXBsYWNlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXkgd2lsbCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb2xTZWxlY3QuZmlsdGVyID0gY29sU2VsZWN0LmZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmaWx0ZXIgaXMgYW4gYXJyYXkgdGhlbiBpcyB0aGUgY29sdW1uIHByZXNlbnQgaW4gaXRcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuaW5jbHVkZXMoY29sU2VsZWN0LmZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmaWx0ZXIgaXMgYSBmdW5jdGlvbiB0aGVuIGRvZXMgaXQgbWVldCB0aGUgY3JpdGVyaWEgb2YgdGhhdCBmdW5jdGlvbiBvciBub3RcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29sU2VsZWN0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sU2VsZWN0LmZpbHRlci5jYWxsKHRhYmxlLCB0YWJsZS5yb3coZGF0YUluZGV4KS5kYXRhKCksIGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xPcHRzLmNvbWJpbmVyID09PSAnb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbWJpbmVyIGlzIGFuIFwiYW5kXCIgdGhlbiB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgYWxsIHBvc3NpYmxlIHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gaWYgaXQgZmFpbHMgaGVyZSB0aGVuIHRoZSBhbmQgaXMgbm90IG1ldCBhbmQgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbE9wdHMuY29tYmluZXIgPT09ICdhbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIHRoZSB0d28gZmlsdGVyIHZhbHVlcyBhcmUgZXF1YWwgdGhlbiByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlciA9PT0gY29sU2VsZWN0LmZpbHRlciB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBMb29zZSB0eXBlIGNoZWNraW5nIGluY2FzZSBudW1iZXIgdHlwZSBpbiBjb2x1bW4gY29tcGFyaW5nIHRvIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICAgICAgISh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyAmJiBmaWx0ZXIubGVuZ3RoID09PSAwKSAmJiBmaWx0ZXIgPT0gY29sU2VsZWN0LmZpbHRlciB8fFxuICAgICAgICAgICAgICAgICAgICBjb2xTZWxlY3QuZmlsdGVyID09PSBudWxsICYmIHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnICYmIGZpbHRlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbWJpbmVyIGlzIGFuIGFuZCB0aGVuIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdCBhbGwgcG9zc2libGUgc2VsZWN0aW9uc1xuICAgICAgICAgICAgLy8gc28gcmV0dXJuIHRydWUgaGVyZSBpZiBzbyBiZWNhdXNlIGl0IHdvdWxkIGhhdmUgcmV0dXJuZWQgZmFsc2UgZWFybGllciBpZiBpdCBoYWQgZmFpbGVkXG4gICAgICAgICAgICBpZiAoY29sT3B0cy5jb21iaW5lciA9PT0gJ2FuZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBoYXNuJ3QgbWF0Y2hlZCB3aXRoIGFueXRoaW5nIGJ5IHRoaXMgcG9pbnQgc28gaXQgbXVzdCBiZSBmYWxzZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgY29udGVudHMgb2YgdGhlIHNlYXJjaENvbnQgZGl2XG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEUgVGhpcyBpcyBvdmVycmlkZGVuIHdoZW4gc2VtYW50aWMgdWkgc3R5bGluZyBpbiBvcmRlciB0byBpbnRlZ3JhdGUgdGhlIHNlYXJjaCBidXR0b24gaW50byB0aGUgdGV4dCBib3guXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lLnByb3RvdHlwZS5fc2VhcmNoQ29udFNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYy5jb250cm9scyAmJiB0aGlzLnMuY29sT3B0cy5jb250cm9scykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnNlYXJjaEJ1dHRvbi5hcHBlbmRUbyh0aGlzLmRvbS5zZWFyY2hMYWJlbENvbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEodGhpcy5jLmR0T3B0cy5zZWFyY2hpbmcgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zLmNvbE9wdHMuZHRPcHRzLnNlYXJjaGluZyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5kdE9wdHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5kdE9wdHMuc2VhcmNoaW5nICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuY3VzdG9tUGFuZVNldHRpbmdzLmR0T3B0cy5zZWFyY2hpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uc2VhcmNoTGFiZWxDb250LmFwcGVuZFRvKHRoaXMuZG9tLnNlYXJjaENvbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBvdXRsaW5lIHRvIHRoZSBwYW5lIHdoZW4gYSBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZVxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuX3NlYXJjaEV4dHJhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGluZyA9IHRoaXMucy51cGRhdGluZztcbiAgICAgICAgICAgIHRoaXMucy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IHRoaXMucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS5wbHVjaygnZmlsdGVyJykudG9BcnJheSgpO1xuICAgICAgICAgICAgdmFyIG51bGxJbmRleCA9IGZpbHRlcnMuaW5kZXhPZih0aGlzLmVtcHR5TWVzc2FnZSgpKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSAkKHRoaXMucy5kdFBhbmUudGFibGUoKS5jb250YWluZXIoKSk7XG4gICAgICAgICAgICAvLyBJZiBudWxsIGluZGV4IGlzIGZvdW5kIHRoZW4gc2VhcmNoIGZvciBlbXB0eSBjZWxscyBhcyBhIGZpbHRlci5cbiAgICAgICAgICAgIGlmIChudWxsSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcnNbbnVsbEluZGV4XSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBmaWx0ZXIgaGFzIGJlZW4gYXBwbGllZCB0aGVuIG91dGxpbmUgdGhlIHJlc3BlY3RpdmUgcGFuZSwgcmVtb3ZlIGl0IHdoZW4gaXQgbm8gbG9uZ2VyIGlzLlxuICAgICAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucy51cGRhdGluZyA9IHVwZGF0aW5nO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgdGhlIHJhdGlvIG9mIHRoZSBudW1iZXIgb2YgZGlmZmVyZW50IG9wdGlvbnMgaW4gdGhlIHRhYmxlIHRvIHRoZSBudW1iZXIgb2Ygcm93c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYmlucyB0aGUgbnVtYmVyIG9mIGRpZmZlcmVudCBvcHRpb25zIGluIHRoZSB0YWJsZVxuICAgICAgICAgKiBAcGFyYW0gcm93Q291bnQgdGhlIHRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSB0YWJsZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXR1cm5zIHRoZSByYXRpb1xuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuX3VuaXF1ZVJhdGlvID0gZnVuY3Rpb24gKGJpbnMsIHJvd0NvdW50KSB7XG4gICAgICAgICAgICBpZiAocm93Q291bnQgPiAwICYmXG4gICAgICAgICAgICAgICAgKHRoaXMucy5yb3dEYXRhLnRvdGFsT3B0aW9ucyA+IDAgJiYgIXRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlICYmIHRoaXMucy50YWJsZUxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbnMgLyB0aGlzLnMucm93RGF0YS50b3RhbE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVwZGF0ZXMgdGhlIG9wdGlvbnMgd2l0aGluIHRoZSBwYW5lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkcmF3IGEgZmxhZyB0byBkZWZpbmUgd2hldGhlciB0aGlzIGhhcyBiZWVuIGNhbGxlZCBkdWUgdG8gYSBkcmF3IGV2ZW50IG9yIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZS5wcm90b3R5cGUuX3VwZGF0ZUNvbW1vbiA9IGZ1bmN0aW9uIChkcmF3KSB7XG4gICAgICAgICAgICBpZiAoZHJhdyA9PT0gdm9pZCAwKSB7IGRyYXcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwYW5lcyBpZiBkb2luZyBhIGRlc2VsZWN0LiBpZiBkb2luZyBhIHNlbGVjdCB0aGVuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYWxsIG9mIHRoZSBwYW5lcyBleGNlcHQgZm9yIHRoZSBvbmUgY2F1c2luZyB0aGUgY2hhbmdlXG4gICAgICAgICAgICBpZiAoIXRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgKCF0aGlzLnMuZmlsdGVyaW5nQWN0aXZlIHx8IHRoaXMuYy5jYXNjYWRlUGFuZXMgfHwgZHJhdyA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jLmNhc2NhZGVQYW5lcyAhPT0gdHJ1ZSB8fCB0aGlzLnMuc2VsZWN0UHJlc2VudCAhPT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAoIXRoaXMucy5sYXN0U2VsZWN0IHx8ICF0aGlzLnMubGFzdENhc2NhZGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbE9wdHMgPSB0aGlzLnMuY29sT3B0cztcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIHZhciByb3dEYXRhID0gdGhpcy5zLnJvd0RhdGE7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHBhbmUgaW4gcHJlcGFyYXRpb24gZm9yIGFkZGluZyB0aGUgdXBkYXRlZCBzZWFyY2ggb3B0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMucy5kdFBhbmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgYSBjdXN0b20gcGFuZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbEV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biBwb3B1bGF0ZVBhbmUgaWYgdGhlIGRhdGEgaGFzIG5vdCBiZWVuIGNvbGxlY3RlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0RhdGEuYXJyYXlGaWx0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3B1bGF0ZVBhbmUoIXRoaXMucy5maWx0ZXJpbmdBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNhc2NhZGVQYW5lcyBpcyBhY3RpdmUgYW5kIHRoZSB0YWJsZSBoYXMgcmV0dXJuZWQgdG8gaXRzIGRlZmF1bHQgc3RhdGUgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBhIG5lZWQgdG8gdXBkYXRlIGNlcnRhaW4gcGFydHMgb2Z0aGUgcm93RGF0YS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jLmNhc2NhZGVQYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zLmR0LnJvd3MoKS5kYXRhKCkudG9BcnJheSgpLmxlbmd0aCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuZHQucm93cyh7IHNlYXJjaDogJ2FwcGxpZWQnIH0pLmRhdGEoKS50b0FycmF5KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhLmFycmF5RmlsdGVyID0gcm93RGF0YS5hcnJheU9yaWdpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YS5iaW5zID0gcm93RGF0YS5iaW5zT3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHZpZXdUb3RhbCBvciBjYXNjYWRlUGFuZXMgaXMgYWN0aXZlIHRoZW4gdGhlIGRhdGEgZnJvbSB0aGUgdGFibGUgbXVzdCBiZSByZWFkLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmMudmlld1RvdGFsIHx8IHRoaXMuYy5jYXNjYWRlUGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlUGFuZSghdGhpcy5zLmZpbHRlcmluZ0FjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZpZXdUb3RhbCBvcHRpb24gaXMgc2VsZWN0ZWQgdGhlbiBmaW5kIHRoZSB0b3RhbHMgZm9yIHRoZSB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jLnZpZXdUb3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGV0YWlsc1BhbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0RhdGEuYmluc1RvdGFsID0gcm93RGF0YS5iaW5zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmMudmlld1RvdGFsICYmICF0aGlzLmMuY2FzY2FkZVBhbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhLmFycmF5RmlsdGVyID0gcm93RGF0YS5hcnJheVRvdGFscztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChkYXRhUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYm90aCB2aWV3IFRvdGFsIGFuZCBjYXNjYWRlUGFuZXMgaGF2ZSBiZWVuIHNlbGVjdGVkIGFuZCB0aGUgY291bnQgb2YgdGhlIHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IDAgdGhlbiBhZGQgaXQgdG8gcGFuZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gdGhpcyBhbHNvIGlmIHRoZSB2aWV3VG90YWwgb3B0aW9uIGhhcyBiZWVuIHNlbGVjdGVkIGFuZCBjYXNjYWRlUGFuZXMgaGFzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFQICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJvd0RhdGEuYmluc1tkYXRhUC5maWx0ZXJdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YS5iaW5zW2RhdGFQLmZpbHRlcl0gIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmMuY2FzY2FkZVBhbmVzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzXzEuYy5jYXNjYWRlUGFuZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnMuY2xlYXJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXNfMS5hZGRSb3coZGF0YVAuZGlzcGxheSwgZGF0YVAuZmlsdGVyLCAhdGhpc18xLmMudmlld1RvdGFsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YS5iaW5zW2RhdGFQLmZpbHRlcl0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhLmJpbnNbZGF0YVAuZmlsdGVyXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0RhdGEuYmluc1tkYXRhUC5maWx0ZXJdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIHRoaXNfMS5jLnZpZXdUb3RhbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyhyb3dEYXRhLmJpbnNUb3RhbFtkYXRhUC5maWx0ZXJdKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0RhdGEuYmluc1tkYXRhUC5maWx0ZXJdLCBkYXRhUC5zb3J0LCBkYXRhUC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG91dCBpZiB0aGUgZmlsdGVyIHdhcyBzZWxlY3RlZCBpbiB0aGUgcHJldmlvdXMgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHNvIHNlbGVjdCBpdCBhbmQgcmVtb3ZlIGZyb20gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEluZGV4ID0gc2VsZWN0ZWQuZmluZEluZGV4KGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmZpbHRlciA9PT0gZGF0YVAuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2Uoc2VsZWN0SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSByb3dEYXRhLmFycmF5RmlsdGVyOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFQID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShkYXRhUCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbE9wdHMuc2VhcmNoUGFuZXMgIT09IHVuZGVmaW5lZCAmJiBjb2xPcHRzLnNlYXJjaFBhbmVzLm9wdGlvbnMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBjb2xPcHRzLm9wdGlvbnMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncyAhPT0gbnVsbCAmJiB0aGlzLmN1c3RvbVBhbmVTZXR0aW5ncy5vcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9nZXRDb21wYXJpc29uUm93cygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RJbmRleCA9IHNlbGVjdGVkLmZpbmRJbmRleChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmRpc3BsYXkgPT09IHJvdy5kYXRhKCkuZGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKHNlbGVjdEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCByb3dzXzEgPSByb3dzOyBfYiA8IHJvd3NfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSByb3dzXzFbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMihyb3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBzZWFyY2ggb3B0aW9ucyB3aGljaCB3ZXJlIHByZXZpb3VzbHkgc2VsZWN0ZWQgYnV0IHdob3MgcmVzdWx0cyBhcmUgbm9cbiAgICAgICAgICAgICAgICAvLyBsb25nZXIgcHJlc2VudCBpbiB0aGUgcmVzdWx0aW5nIGRhdGEgc2V0LlxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgc2VsZWN0ZWRfMSA9IHNlbGVjdGVkOyBfYyA8IHNlbGVjdGVkXzEubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEVsID0gc2VsZWN0ZWRfMVtfY107XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmFkZFJvdyhzZWxlY3RlZEVsLmRpc3BsYXksIHNlbGVjdGVkRWwuZmlsdGVyLCAwLCB0aGlzLmMudmlld1RvdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdGVkRWwudG90YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCwgc2VsZWN0ZWRFbC5kaXNwbGF5LCBzZWxlY3RlZEVsLmRpc3BsYXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByb3cuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucy51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMuZHRQYW5lLnRhYmxlKCkubm9kZSgpLnBhcmVudE5vZGUuc2Nyb2xsVG9wID0gdGhpcy5zLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2VhcmNoUGFuZS52ZXJzaW9uID0gJzEuMy4wJztcbiAgICAgICAgU2VhcmNoUGFuZS5jbGFzc2VzID0ge1xuICAgICAgICAgICAgYm9yZGVyZWQ6ICdkdHNwLWJvcmRlcmVkJyxcbiAgICAgICAgICAgIGJ1dHRvbkdyb3VwOiAnZHRzcC1idXR0b25Hcm91cCcsXG4gICAgICAgICAgICBidXR0b25TdWI6ICdkdHNwLWJ1dHRvblN1YicsXG4gICAgICAgICAgICBjbGVhcjogJ2R0c3AtY2xlYXInLFxuICAgICAgICAgICAgY2xlYXJBbGw6ICdkdHNwLWNsZWFyQWxsJyxcbiAgICAgICAgICAgIGNsZWFyQnV0dG9uOiAnY2xlYXJCdXR0b24nLFxuICAgICAgICAgICAgY29sbGFwc2VBbGw6ICdkdHNwLWNvbGxhcHNlQWxsJyxcbiAgICAgICAgICAgIGNvbGxhcHNlQnV0dG9uOiAnZHRzcC1jb2xsYXBzZUJ1dHRvbicsXG4gICAgICAgICAgICBjb250YWluZXI6ICdkdHNwLXNlYXJjaFBhbmUnLFxuICAgICAgICAgICAgY291bnRCdXR0b246ICdkdHNwLWNvdW50QnV0dG9uJyxcbiAgICAgICAgICAgIGRpc2FibGVkQnV0dG9uOiAnZHRzcC1kaXNhYmxlZEJ1dHRvbicsXG4gICAgICAgICAgICBoaWRkZW46ICdkdHNwLWhpZGRlbicsXG4gICAgICAgICAgICBoaWRlOiAnZHRzcC1oaWRlJyxcbiAgICAgICAgICAgIGxheW91dDogJ2R0c3AtJyxcbiAgICAgICAgICAgIG5hbWU6ICdkdHNwLW5hbWUnLFxuICAgICAgICAgICAgbmFtZUJ1dHRvbjogJ2R0c3AtbmFtZUJ1dHRvbicsXG4gICAgICAgICAgICBuYW1lQ29udDogJ2R0c3AtbmFtZUNvbnQnLFxuICAgICAgICAgICAgbmFycm93OiAnZHRzcC1uYXJyb3cnLFxuICAgICAgICAgICAgcGFuZUJ1dHRvbjogJ2R0c3AtcGFuZUJ1dHRvbicsXG4gICAgICAgICAgICBwYW5lSW5wdXRCdXR0b246ICdkdHNwLXBhbmVJbnB1dEJ1dHRvbicsXG4gICAgICAgICAgICBwaWxsOiAnZHRzcC1waWxsJyxcbiAgICAgICAgICAgIHJvdGF0ZWQ6ICdkdHNwLXJvdGF0ZWQnLFxuICAgICAgICAgICAgc2VhcmNoOiAnZHRzcC1zZWFyY2gnLFxuICAgICAgICAgICAgc2VhcmNoQ29udDogJ2R0c3Atc2VhcmNoQ29udCcsXG4gICAgICAgICAgICBzZWFyY2hJY29uOiAnZHRzcC1zZWFyY2hJY29uJyxcbiAgICAgICAgICAgIHNlYXJjaExhYmVsQ29udDogJ2R0c3Atc2VhcmNoQnV0dG9uQ29udCcsXG4gICAgICAgICAgICBzZWxlY3RlZDogJ2R0c3Atc2VsZWN0ZWQnLFxuICAgICAgICAgICAgc21hbGxHYXA6ICdkdHNwLXNtYWxsR2FwJyxcbiAgICAgICAgICAgIHN1YlJvdzE6ICdkdHNwLXN1YlJvdzEnLFxuICAgICAgICAgICAgc3ViUm93MjogJ2R0c3Atc3ViUm93MicsXG4gICAgICAgICAgICBzdWJSb3dzQ29udGFpbmVyOiAnZHRzcC1zdWJSb3dzQ29udGFpbmVyJyxcbiAgICAgICAgICAgIHRpdGxlOiAnZHRzcC10aXRsZScsXG4gICAgICAgICAgICB0b3BSb3c6ICdkdHNwLXRvcFJvdydcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGVmaW5lIFNlYXJjaFBhbmVzIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBTZWFyY2hQYW5lLmRlZmF1bHRzID0ge1xuICAgICAgICAgICAgY2FzY2FkZVBhbmVzOiBmYWxzZSxcbiAgICAgICAgICAgIGNsZWFyOiB0cnVlLFxuICAgICAgICAgICAgY29sbGFwc2U6IHRydWUsXG4gICAgICAgICAgICBjb21iaW5lcjogJ29yJyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR0LnRhYmxlKCkuY29udGFpbmVyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbHM6IHRydWUsXG4gICAgICAgICAgICBkdE9wdHM6IHt9LFxuICAgICAgICAgICAgZW1wdHlNZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgaGlkZUNvdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgICBjbGVhclBhbmU6ICcmdGltZXM7JyxcbiAgICAgICAgICAgICAgICBjb3VudDogJ3t0b3RhbH0nLFxuICAgICAgICAgICAgICAgIGNvdW50RmlsdGVyZWQ6ICd7c2hvd259ICh7dG90YWx9KScsXG4gICAgICAgICAgICAgICAgZW1wdHlNZXNzYWdlOiAnPGVtPk5vIGRhdGE8L2VtPidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0Q29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3JkZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgb3J0aG9nb25hbDoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6ICdmaWx0ZXInLFxuICAgICAgICAgICAgICAgIGhpZGVDb3VudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiAnZmlsdGVyJyxcbiAgICAgICAgICAgICAgICBzaG93OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc29ydDogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMC42LFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICB2aWV3Q291bnQ6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTZWxlY3Q6IFtdLFxuICAgICAgICAgICAgdGhyZXNob2xkOiAwLjYsXG4gICAgICAgICAgICB2aWV3Q291bnQ6IHRydWUsXG4gICAgICAgICAgICB2aWV3VG90YWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTZWFyY2hQYW5lO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgJCQxO1xuICAgIHZhciBkYXRhVGFibGUkMTtcbiAgICBmdW5jdGlvbiBzZXRKUXVlcnkkMShqcSkge1xuICAgICAgICAkJDEgPSBqcTtcbiAgICAgICAgZGF0YVRhYmxlJDEgPSBqcS5mbi5kYXRhVGFibGU7XG4gICAgfVxuICAgIHZhciBTZWFyY2hQYW5lcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2VhcmNoUGFuZXMocGFuZVNldHRpbmdzLCBvcHRzLCBmcm9tSW5pdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChmcm9tSW5pdCA9PT0gdm9pZCAwKSB7IGZyb21Jbml0ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHRoaXMucmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZXF1aXJlZCB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgaW5jbHVkZWRcbiAgICAgICAgICAgIGlmICghZGF0YVRhYmxlJDEgfHwgIWRhdGFUYWJsZSQxLnZlcnNpb25DaGVjayB8fCAhZGF0YVRhYmxlJDEudmVyc2lvbkNoZWNrKCcxLjEwLjAnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoUGFuZSByZXF1aXJlcyBEYXRhVGFibGVzIDEuMTAgb3IgbmV3ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgU2VsZWN0IGlzIGluY2x1ZGVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgICAgICBpZiAoIWRhdGFUYWJsZSQxLnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoUGFuZSByZXF1aXJlcyBTZWxlY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YWJsZSA9IG5ldyBkYXRhVGFibGUkMS5BcGkocGFuZVNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9ICQkMS5leHRlbmQodHJ1ZSwge30sIFNlYXJjaFBhbmVzLmNsYXNzZXMpO1xuICAgICAgICAgICAgLy8gR2V0IG9wdGlvbnMgZnJvbSB1c2VyXG4gICAgICAgICAgICB0aGlzLmMgPSAkJDEuZXh0ZW5kKHRydWUsIHt9LCBTZWFyY2hQYW5lcy5kZWZhdWx0cywgb3B0cyk7XG4gICAgICAgICAgICAvLyBBZGQgZXh0cmEgZWxlbWVudHMgdG8gRE9NIG9iamVjdCBpbmNsdWRpbmcgY2xlYXJcbiAgICAgICAgICAgIHRoaXMuZG9tID0ge1xuICAgICAgICAgICAgICAgIGNsZWFyQWxsOiAkJDEoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPkNsZWFyIEFsbDwvYnV0dG9uPicpLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5jbGVhckFsbCksXG4gICAgICAgICAgICAgICAgY29sbGFwc2VBbGw6ICQkMSgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCI+Q29sbGFwc2UgQWxsPC9idXR0b24+JykuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmNvbGxhcHNlQWxsKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6ICQkMSgnPGRpdi8+JykuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnBhbmVzKS50ZXh0KHRhYmxlLmkxOG4oJ3NlYXJjaFBhbmVzLmxvYWRNZXNzYWdlJywgdGhpcy5jLmkxOG4ubG9hZE1lc3NhZ2UpKSxcbiAgICAgICAgICAgICAgICBlbXB0eU1lc3NhZ2U6ICQkMSgnPGRpdi8+JykuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmVtcHR5TWVzc2FnZSksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogJCQxKCc8ZGl2Lz4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuY29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICBwYW5lczogJCQxKCc8ZGl2Lz4nKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuY29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICBzaG93QWxsOiAkJDEoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPlNob3cgQWxsPC9idXR0b24+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5zaG93QWxsKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAkJDEoJzxkaXYvPicpLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy50aXRsZSksXG4gICAgICAgICAgICAgICAgdGl0bGVSb3c6ICQkMSgnPGRpdi8+JykuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnRpdGxlUm93KSxcbiAgICAgICAgICAgICAgICB3cmFwcGVyOiAkJDEoJzxkaXYvPicpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zID0ge1xuICAgICAgICAgICAgICAgIGNvbE9wdHM6IFtdLFxuICAgICAgICAgICAgICAgIGR0OiB0YWJsZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb3VudDogMCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQYW5lOiAtMSxcbiAgICAgICAgICAgICAgICBwYWdlOiAwLFxuICAgICAgICAgICAgICAgIHBhZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFuZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgIHNlcnZlckRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIHN0YXRlUmVhZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXBkYXRpbmc6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRhYmxlLnNldHRpbmdzKClbMF0uX3NlYXJjaFBhbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlKSB7XG4gICAgICAgICAgICAgICAgdGFibGUub24oJ3ByZVhoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zZWFyY2hQYW5lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlYXJjaFBhbmVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2VhcmNoUGFuZXNfbnVsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlYXJjaFBhbmVzX251bGwgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMucy5zZWxlY3Rpb25MaXN0OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmMgPSBfdGhpcy5zLmR0LmNvbHVtbihzZWxlY3Rpb24uaW5kZXgpLmRhdGFTcmMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlYXJjaFBhbmVzW3NyY10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXNbc3JjXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2VhcmNoUGFuZXNfbnVsbFtzcmNdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlYXJjaFBhbmVzX251bGxbc3JjXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXNbc3JjXVtpXSA9IHNlbGVjdGlvbi5yb3dzW2ldLmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zZWFyY2hQYW5lc1tzcmNdW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXNfbnVsbFtzcmNdW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFyZSB1c2luZyB0aGUgeGhyIGV2ZW50IHRvIHJlYnVpbGQgdGhlIHBhbmVzIGlmIHJlcXVpcmVkIGR1ZSB0byB2aWV3VG90YWwgYmVpbmcgZW5hYmxlZFxuICAgICAgICAgICAgLy8gSWYgdmlld1RvdGFsIGlzIG5vdCBlbmFibGVkIHRoZW4gd2Ugc2ltcGx5IHVwZGF0ZSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIHRhYmxlLm9uKCd4aHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24sIHhocikge1xuICAgICAgICAgICAgICAgIGlmIChqc29uICYmIGpzb24uc2VhcmNoUGFuZXMgJiYganNvbi5zZWFyY2hQYW5lcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnMuc2VydmVyRGF0YSA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnMuc2VydmVyRGF0YS50YWJsZUxlbmd0aCA9IGpzb24ucmVjb3Jkc1RvdGFsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VydmVyVG90YWxzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YWJsZS5zZXR0aW5ncygpWzBdLl9zZWFyY2hQYW5lcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGVhckFsbC50ZXh0KHRhYmxlLmkxOG4oJ3NlYXJjaFBhbmVzLmNsZWFyTWVzc2FnZScsIHRoaXMuYy5pMThuLmNsZWFyTWVzc2FnZSkpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29sbGFwc2VBbGwudGV4dCh0YWJsZS5pMThuKCdzZWFyY2hQYW5lcy5jb2xsYXBzZU1lc3NhZ2UnLCB0aGlzLmMuaTE4bi5jb2xsYXBzZU1lc3NhZ2UpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNob3dBbGwudGV4dCh0YWJsZS5pMThuKCdzZWFyY2hQYW5lcy5zaG93TWVzc2FnZScsIHRoaXMuYy5pMThuLnNob3dNZXNzYWdlKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zLmR0LnNldHRpbmdzKClbMF0uX2JJbml0Q29tcGxldGUgfHwgZnJvbUluaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYW5lRGVjbGFyZSh0YWJsZSwgcGFuZVNldHRpbmdzLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhYmxlLm9uZSgncHJlSW5pdC5kdCcsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGFuZURlY2xhcmUodGFibGUsIHBhbmVTZXR0aW5ncywgb3B0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgdGhlIHNlbGVjdGlvbnMgb2YgYWxsIG9mIHRoZSBwYW5lc1xuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZXMucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIExvYWQgaW4gYWxsIG9mIHRoZSBzZWFyY2hCb3hlcyBpbiB0aGUgZG9jdW1lbnRzXG4gICAgICAgICAgICB2YXIgc2VhcmNoZXMgPSB0aGlzLmRvbS5jb250YWluZXIuZmluZCgnLicgKyB0aGlzLmNsYXNzZXMuc2VhcmNoLnJlcGxhY2UoL1xccysvZywgJy4nKSk7XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBzZWFyY2hCb3ggc2V0IHRoZSBpbnB1dCB0ZXh0IHRvIGJlIGVtcHR5IGFuZCB0aGVuIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIGFuIGlucHV0IG9uIHRoZW0gc28gdGhhdCB0aGV5IG5vIGxvbmdlciBmaWx0ZXIgdGhlIHBhbmVzXG4gICAgICAgICAgICBzZWFyY2hlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkJDEodGhpcykudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAkJDEodGhpcykudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJldHVybkFycmF5ID0gW107XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgc2VsZWN0aW9uTGlzdCB0byBwcmV2ZW50IGNhc2NhZGVQYW5lcyBmcm9tIHJlc2VsZWN0aW5nIHJvd3NcbiAgICAgICAgICAgIHRoaXMucy5zZWxlY3Rpb25MaXN0ID0gW107XG4gICAgICAgICAgICAvLyBGb3IgZXZlcnkgcGFuZSwgY2xlYXIgdGhlIHNlbGVjdGlvbnMgaW4gdGhlIHBhbmVcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMucGFuZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUucy5kdFBhbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKHBhbmUuY2xlYXJQYW5lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5BcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgdGhlIGNvbnRhaW5lciBub2RlIGZvciB0aGUgc2VhcmNoUGFuZXNcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlYnVpbGRzIGFsbCBvZiB0aGUgcGFuZXNcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5yZWJ1aWxkID0gZnVuY3Rpb24gKHRhcmdldElkeCwgbWFpbnRhaW5TZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRJZHggPT09IHZvaWQgMCkgeyB0YXJnZXRJZHggPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKG1haW50YWluU2VsZWN0aW9uID09PSB2b2lkIDApIHsgbWFpbnRhaW5TZWxlY3Rpb24gPSBmYWxzZTsgfVxuICAgICAgICAgICAgdGhpcy5kb20uZW1wdHlNZXNzYWdlLnJlbW92ZSgpO1xuICAgICAgICAgICAgLy8gQXMgYSByZWJ1aWxkIGZyb20gc2NyYXRjaCBpcyByZXF1aXJlZCwgZW1wdHkgdGhlIHNlYXJjaHBhbmVzIGNvbnRhaW5lci5cbiAgICAgICAgICAgIHZhciByZXR1cm5BcnJheSA9IFtdO1xuICAgICAgICAgICAgLy8gUmVidWlsZCBlYWNoIHBhbmUgaW5kaXZpZHVhbGx5LCBpZiBhIHNwZWNpZmljIHBhbmUgaGFzIGJlZW4gc2VsZWN0ZWQgdGhlbiBvbmx5IHJlYnVpbGQgdGhhdCBvbmVcbiAgICAgICAgICAgIGlmICh0YXJnZXRJZHggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucGFuZXMuZW1wdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMucGFuZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldElkeCAhPT0gZmFsc2UgJiYgcGFuZS5zLmluZGV4ICE9PSB0YXJnZXRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmUuY2xlYXJEYXRhKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuQXJyYXkucHVzaChcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGEgYm9vbGVhbiB0byBzYXkgd2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNob2ljZSBtYWRlIGZvciBtYWludGFpbmluZyBzZWxlY3Rpb25zIHdoZW4gcmVidWlsZGluZ1xuICAgICAgICAgICAgICAgIHBhbmUucmVidWlsZFBhbmUodGhpcy5zLnNlbGVjdGlvbkxpc3RbdGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoIC0gMV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5pbmRleCA9PT0gdGhpcy5zLnNlbGVjdGlvbkxpc3RbdGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoIC0gMV0uaW5kZXggOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZSwgdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VydmVyRGF0YSA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgbnVsbCwgbWFpbnRhaW5TZWxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5wYW5lcy5hcHBlbmQocGFuZS5kb20uY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmMuY2FzY2FkZVBhbmVzIHx8IHRoaXMuYy52aWV3VG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhd1BhbmVzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRhY2ggcGFuZXMsIGNsZWFyIGJ1dHRvbnMsIGFuZCB0aXRsZSBiYXIgdG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGaWx0ZXJDb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoUGFuZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbnMgYXJlIHRvIGJlIG1haW50YWluZWQsIHRoZW4gaXQgaXMgc2FmZSB0byBhc3N1bWUgdGhhdCBwYWdpbmcgaXMgYWxzbyB0byBiZSBtYWludGFpbmVkXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBwYWdpbmcgc2hvdWxkIGJlIHJlc2V0XG4gICAgICAgICAgICB0aGlzLnMuZHQuZHJhdyghbWFpbnRhaW5TZWxlY3Rpb24pO1xuICAgICAgICAgICAgLy8gUmVzaXplIHRoZSBwYW5lcyBpbmNhc2UgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2VcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGFuZXMoKTtcbiAgICAgICAgICAgIC8vIElmIGEgc2luZ2xlIHBhbmUgaGFzIGJlZW4gcmVidWlsdCB0aGVuIHJldHVybiBvbmx5IHRoYXQgcGFuZVxuICAgICAgICAgICAgaWYgKHJldHVybkFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5BcnJheVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gYWxsIG9mIHRoZSBwYW5lcyB0aGF0IGhhdmUgYmVlbiByZWJ1aWx0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWRyYXdzIGFsbCBvZiB0aGUgcGFuZXNcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5yZWRyYXdQYW5lcyA9IGZ1bmN0aW9uIChyZWJ1aWxkKSB7XG4gICAgICAgICAgICBpZiAocmVidWlsZCA9PT0gdm9pZCAwKSB7IHJlYnVpbGQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5zLmR0O1xuICAgICAgICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZSByZWRyYXcgaXNuJ3QgYmVpbmcgdHJpZ2dlcmVkIGJ5IHRoZSBwYW5lcyB1cGRhdGluZyB0aGVtc2VsdmVzXG4gICAgICAgICAgICBpZiAoIXRoaXMucy51cGRhdGluZyAmJiAhdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyUGFuZSA9IHRoaXMucy5maWx0ZXJQYW5lO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RUb3RhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRvdGFsICs9IHBhbmUucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS50b0FycmF5KCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2Ygcm93cyBjdXJyZW50bHkgdmlzaWJsZSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRhYmxlXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB0aGVyZSBjYW4ndCBiZSBhbnkgZmlsdGVyaW5nIHRha2luZyBwbGFjZVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUb3RhbCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0YWJsZS5yb3dzKHsgc2VhcmNoOiAnYXBwbGllZCcgfSkuZGF0YSgpLnRvQXJyYXkoKS5sZW5ndGggPT09IHRhYmxlLnJvd3MoKS5kYXRhKCkudG9BcnJheSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHZpZXdUb3RhbCBpcyBhY3RpdmUgdGhlbiBpdCBpcyBuZWNlc3NhcnkgdG8gZGV0ZXJtaW5lIHdoaWNoIHBhbmVzIGEgc2VsZWN0IGlzIHByZXNlbnQgaW4uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgcGFuZSB3aXRoIGEgc2VsZWN0aW9uIHByZXNlbnQgdGhlbiBpdCBzaG91bGQgbm90IHNob3cgdGhlIGZpbHRlcmVkIG1lc3NhZ2UgYXNcbiAgICAgICAgICAgICAgICAvLyBtb3JlIHNlbGVjdGlvbnMgbWF5IGJlIG1hZGUgaW4gdGhhdCBwYW5lLlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYy52aWV3VG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMucy5wYW5lczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUucy5kdFBhbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RMZW5ndGggPSBwYW5lLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSB0aGlzLnMuc2VsZWN0aW9uTGlzdDsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmluZGV4ID09PSBwYW5lLnMuaW5kZXggJiYgc2VsZWN0aW9uLnJvd3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0TGVuZ3RoID0gc2VsZWN0aW9uLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGZpbHRlclBhbmUgPT09IC0xIHRoZW4gYSBwYW5lIHdpdGggYSBzZWxlY3Rpb24gaGFzIG5vdCBiZWVuIGZvdW5kIHlldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBzZXQgZmlsdGVyUGFuZSB0byB0aGF0IHBhbmVzIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdExlbmd0aCA+IDAgJiYgZmlsdGVyUGFuZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyUGFuZSA9IHBhbmUucy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiBpZiBhbm90aGVyIHBhbmUgaXMgZm91bmQgd2l0aCBhIHNlbGVjdGlvbiB0aGVuIHNldCBmaWx0ZXJQYW5lIHRvIG51bGwgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IHRoYXQgbXVsdGlwbGUgcGFuZXMgaGF2ZSBzZWxlY3Rpb25zIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclBhbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VhcmNoYm94IGlzIGluIHBsYWNlIGFuZCBmaWx0ZXJpbmcgaXMgYXBwbGllZCB0aGVuIG5lZWQgdG8gY2FzY2FkZSBkb3duIGFueXdheVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0VG90YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclBhbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZXNlbGVjdElkeCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHJ1biB0aGlzIGlmIGl0IGlzIGR1ZSB0byB0aGUgcGFuZXMgcmVnZW5lcmF0aW5nXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlZ2VuZXJhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IDAsIF9nID0gdGhpcy5zLnBhbmVzOyBfZiA8IF9nLmxlbmd0aDsgX2YrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfZ1tfZl07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZGVudGlmeSB0aGUgcGFuZSB3aGVyZSBhIHNlbGVjdGlvbiBvciBkZXNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlIGFuZCBhZGQgaXQgdG8gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5zLnNlbGVjdFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhbmUucy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M6IHBhbmUucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS50b0FycmF5KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhbmUucy5kZXNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2VsZWN0SWR4ID0gcGFuZS5zLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZERhdGEgPSBwYW5lLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYW5lLnMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93czogc2VsZWN0ZWREYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnMuc2VsZWN0aW9uTGlzdFt0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9oID0gMCwgX2ogPSB0aGlzLnMucGFuZXM7IF9oIDwgX2oubGVuZ3RoOyBfaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfaltfaF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmxhc3RTZWxlY3QgPSBwYW5lLnMuaW5kZXggPT09IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbnMgZnJvbSB0aGUgbGlzdCBmcm9tIHRoZSBwYW5lIHdoZXJlIGEgZGVzZWxlY3QgaGFzIHRha2VuIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnMuc2VsZWN0aW9uTGlzdFtpXS5pbmRleCAhPT0gZGVzZWxlY3RJZHggfHwgdGhpcy5zLnNlbGVjdGlvbkxpc3RbaV0ucHJvdGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdXJ0aGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBvdXQgaWYgdGhpcyBzZWxlY3Rpb24gaXMgdGhlIGxhc3Qgb25lIGluIHRoZSBsaXN0IGZvciB0aGF0IHBhbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCB0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zLnNlbGVjdGlvbkxpc3Rbal0uaW5kZXggPT09IHRoaXMucy5zZWxlY3Rpb25MaXN0W2ldLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdXJ0aGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc2VsZWN0aW9ucyBmb3IgdGhpcyBwYW5lIGluIHRoZSBsaXN0IHRoZW4ganVzdCBwdXNoIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmdXJ0aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbkxpc3QucHVzaCh0aGlzLnMuc2VsZWN0aW9uTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucy5zZWxlY3Rpb25MaXN0W2ldLnByb3RlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbGVQYW5lID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb25MaXN0Lmxlbmd0aCA9PT0gMSAmJiBzZWxlY3RUb3RhbCAhPT0gbnVsbCAmJiBzZWxlY3RUb3RhbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29sZVBhbmUgPSBuZXdTZWxlY3Rpb25MaXN0WzBdLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgb2YgdGhlIHBhbmVzIHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBfbCA9IHRoaXMucy5wYW5lczsgX2sgPCBfbC5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2xbX2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUucy5kdFBhbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wRmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnMuZmlsdGVyaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyUGFuZSAhPT0gLTEgJiYgZmlsdGVyUGFuZSAhPT0gbnVsbCAmJiBmaWx0ZXJQYW5lID09PSBwYW5lLnMuaW5kZXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQWN0aXZlID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnMuaW5kZXggPT09IHNvbGVQYW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmZpbHRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnVwZGF0ZVBhbmUoIXRlbXBGaWx0ZXIgPyBmYWxzZSA6IGZpbHRlckFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgc2VsZWN0aW9ucyBhcmUgZGlmZmVyZW50IHRoZW4gc29tZSBvZiB0aGVtIGhhdmUgYmVlblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGFuZCBhIGRlc2VsZWN0IGhhcyBvY2N1cmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb25MaXN0Lmxlbmd0aCA+IDAgJiYgKG5ld1NlbGVjdGlvbkxpc3QubGVuZ3RoIDwgdGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoIHx8IHJlYnVpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXNjYWRlUmVnZW4obmV3U2VsZWN0aW9uTGlzdCwgc2VsZWN0VG90YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBuZXdTZWxlY3Rpb25MaXN0W25ld1NlbGVjdGlvbkxpc3QubGVuZ3RoIC0gMV0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIF9vID0gdGhpcy5zLnBhbmVzOyBfbSA8IF9vLmxlbmd0aDsgX20rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX29bX21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5sYXN0U2VsZWN0ID0gcGFuZS5zLmluZGV4ID09PSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdGlvbkxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBvZiB0aGUgb3RoZXIgcGFuZXMgYXMgeW91IHdvdWxkIGp1c3QgbWFraW5nIGEgbm9ybWFsIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3AgPSAwLCBfcSA9IHRoaXMucy5wYW5lczsgX3AgPCBfcS5sZW5ndGg7IF9wKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZVVwZGF0ZSA9IF9xW19wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZVVwZGF0ZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wRmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZVVwZGF0ZS5zLmZpbHRlcmluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJQYW5lICE9PSAtMSAmJiBmaWx0ZXJQYW5lICE9PSBudWxsICYmIGZpbHRlclBhbmUgPT09IHBhbmVVcGRhdGUucy5pbmRleCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQWN0aXZlID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZVVwZGF0ZS5zLmluZGV4ID09PSBzb2xlUGFuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZVVwZGF0ZS5zLmZpbHRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVVcGRhdGUudXBkYXRlUGFuZSghdGVtcEZpbHRlciA/IHRlbXBGaWx0ZXIgOiBmaWx0ZXJBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhYmVsIHRoYXQgc2hvd3MgaG93IG1hbnkgZmlsdGVycyBhcmUgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRmlsdGVyQ291bnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xlUGFuZSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2VsZWN0aW9uTGlzdC5sZW5ndGggPT09IDEgJiYgc2VsZWN0VG90YWwgIT09IG51bGwgJiYgc2VsZWN0VG90YWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbGVQYW5lID0gbmV3U2VsZWN0aW9uTGlzdFswXS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfciA9IDAsIF9zID0gdGhpcy5zLnBhbmVzOyBfciA8IF9zLmxlbmd0aDsgX3IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfc1tfcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBGaWx0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5maWx0ZXJpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJQYW5lICE9PSAtMSAmJiBmaWx0ZXJQYW5lICE9PSBudWxsICYmIGZpbHRlclBhbmUgPT09IHBhbmUucy5pbmRleCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJBY3RpdmUgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5pbmRleCA9PT0gc29sZVBhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnMuZmlsdGVyaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUudXBkYXRlUGFuZSghdGVtcEZpbHRlciA/IHRlbXBGaWx0ZXIgOiBmaWx0ZXJBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFiZWwgdGhhdCBzaG93cyBob3cgbWFueSBmaWx0ZXJzIGFyZSBpbiBwbGFjZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVGaWx0ZXJDb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlckFjdGl2ZSB8fCBzZWxlY3RUb3RhbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZXMgYWxsIG9mIHRoZSBwYW5lc1xuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZXMucHJvdG90eXBlLnJlc2l6ZVBhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYy5sYXlvdXQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIHZhciBjb250V2lkdGggPSAkJDEodGhpcy5zLmR0LnNlYXJjaFBhbmVzLmNvbnRhaW5lcigpKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmZsb29yKGNvbnRXaWR0aCAvIDI2MC4wKTsgLy8gVGhlIG5lYXRlc3QgbnVtYmVyIG9mIHBhbmVzIHBlciByb3dcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGVzdCA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hlc3Rtb2QgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBkaXNwSW5kZXggPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4ZXMgb2YgYWxsIG9mIHRoZSBkaXNwbGF5ZWQgcGFuZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUucy5kaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BJbmRleC5wdXNoKHBhbmUucy5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlDb3VudCA9IGRpc3BJbmRleC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5lYXRlc3QgbnVtYmVyIGlzIHRoZSBudW1iZXIgd2UgaGF2ZSB0aGVuIHVzZSB0aGlzLlxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGRpc3BsYXlDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBoaWdoZXN0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR28gZnJvbSB0aGUgdGFyZ2V0IGRvd24gYW5kIGZpbmQgdGhlIHZhbHVlIHdpdGggdGhlIG1vc3QgcGFuZXMgbGVmdCBvdmVyLCB0aGlzIHdpbGwgYmUgdGhlIGJlc3QgZml0XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBwciA9IHRhcmdldDsgcHByID4gMTsgcHByLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW0gPSBkaXNwbGF5Q291bnQgJSBwcHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGVzdCA9IHBwcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0bW9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIGxlZnQgb3ZlciBhdCB0aGlzIGFtb3VudCBvZiBwYW5lcyBwZXIgcm93IChwcHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IGZpdHMgYmV0dGVyIHNvIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbSA+IGhpZ2hlc3Rtb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0ID0gcHByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3Rtb2QgPSByZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZXJmZWN0IGZpdCB0aGVuIG5vbmUgYXJlIHRvIGJlIHdpZGVyXG4gICAgICAgICAgICAgICAgdmFyIHdpZGVySW5kZXhlcyA9IGhpZ2hlc3Rtb2QgIT09IDAgPyBkaXNwSW5kZXguc2xpY2UoZGlzcEluZGV4Lmxlbmd0aCAtIGhpZ2hlc3Rtb2QsIGRpc3BJbmRleC5sZW5ndGgpIDogW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMucy5wYW5lczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2l6ZSB0aGUgcGFuZSB3aXRoIHRoZSBuZXcgbGF5b3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZGlzcGxheWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gJ2NvbHVtbnMtJyArICghd2lkZXJJbmRleGVzLmluY2x1ZGVzKHBhbmUucy5pbmRleCkgPyBoaWdoZXN0IDogaGlnaGVzdG1vZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnJlc2l6ZShsYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IHRoaXMucy5wYW5lczsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuYWRqdXN0VG9wUm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggdGhlIHBhbmVzLCBidXR0b25zIGFuZCB0aXRsZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5fYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgICAgICB0aGlzLmRvbS50aXRsZVJvdy5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgICAgICB0aGlzLmRvbS50aXRsZVJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRpdGxlLmFwcGVuZFRvKHRoaXMuZG9tLnRpdGxlUm93KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjbGVhciBidXR0b24gaXMgcGVybWl0dGVkIGF0dGFjaCBpdFxuICAgICAgICAgICAgaWYgKHRoaXMuYy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLmFwcGVuZFRvKHRoaXMuZG9tLnRpdGxlUm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGVhckFsbC5vbignY2xpY2suZHRzcHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYy5jb2xsYXBzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbGxhcHNlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLnRpdGxlUm93LmFwcGVuZFRvKHRoaXMuZG9tLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIGNvbnRhaW5lciBmb3IgZWFjaCBpbmRpdmlkdWFsIHBhbmUgdG8gdGhlIG92ZXJhbGwgY29udGFpbmVyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHBhbmUuZG9tLmNvbnRhaW5lci5hcHBlbmRUbyh0aGlzLmRvbS5wYW5lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRhY2ggZXZlcnl0aGluZyB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhbmVzLmFwcGVuZFRvKHRoaXMuZG9tLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoJCQxKCdkaXYuJyArIHRoaXMuY2xhc3Nlcy5jb250YWluZXIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5wcmVwZW5kVG8odGhpcy5zLmR0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbS5jb250YWluZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggdGhlIHRvcCByb3cgY29udGFpbmluZyB0aGUgZmlsdGVyIGNvdW50IGFuZCBjbGVhciBhbGwgYnV0dG9uXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2F0dGFjaEV4dHJhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgICAgICB0aGlzLmRvbS50aXRsZVJvdy5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgICAgICB0aGlzLmRvbS50aXRsZVJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRpdGxlLmFwcGVuZFRvKHRoaXMuZG9tLnRpdGxlUm93KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjbGVhciBidXR0b24gaXMgcGVybWl0dGVkIGF0dGFjaCBpdFxuICAgICAgICAgICAgaWYgKHRoaXMuYy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLmFwcGVuZFRvKHRoaXMuZG9tLnRpdGxlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNvbGxhcHNpbmcgaXMgcGVybWl0dGVkIGF0dGFjaCB0aG9zZSBidXR0b25zXG4gICAgICAgICAgICBpZiAodGhpcy5jLmNvbGxhcHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uc2hvd0FsbC5hcHBlbmRUbyh0aGlzLmRvbS50aXRsZVJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29sbGFwc2VBbGwuYXBwZW5kVG8odGhpcy5kb20udGl0bGVSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb20udGl0bGVSb3cuYXBwZW5kVG8odGhpcy5kb20uY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbS5jb250YWluZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSBhcmUgbm8gcGFuZXMgdG8gZGlzcGxheSB0aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byBlaXRoZXJcbiAgICAgICAgICogZGlzcGxheSBhIG1lc3NhZ2UgaW4gdGhlaXIgcGxhY2Ugb3IgaGlkZSB0aGVtIGNvbXBsZXRlbHkuXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2F0dGFjaE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gdGhlIHNjcmVlblxuICAgICAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnMuZHQuaTE4bignc2VhcmNoUGFuZXMuZW1wdHlQYW5lcycsIHRoaXMuYy5pMThuLmVtcHR5UGFuZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgbWVzc2FnZSBpcyBhbiBlbXB0eSBzdHJpbmcgdGhlbiBzZWFyY2hQYW5lcy5lbXB0eVBhbmVzIGlzIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIHRoZXJlZm9yZSB0aGUgcGFuZSBjb250YWluZXIgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmhpZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnRpdGxlUm93LnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5oaWRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmhpZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnRpdGxlUm93LmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5oaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBkaXNwbGF5IHRoZSBtZXNzYWdlXG4gICAgICAgICAgICB0aGlzLmRvbS5lbXB0eU1lc3NhZ2UudGV4dChtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmVtcHR5TWVzc2FnZS5hcHBlbmRUbyh0aGlzLmRvbS5jb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaGVzIHRoZSBwYW5lcyB0byB0aGUgZG9jdW1lbnQgYW5kIGRpc3BsYXlzIGEgbWVzc2FnZSBvciBoaWRlcyBpZiB0aGVyZSBhcmUgbm9uZVxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZXMucHJvdG90eXBlLl9hdHRhY2hQYW5lQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgYSBwYW5lIGlzIHRvIGJlIGRpc3BsYXllZCB0aGVuIGF0dGFjaCB0aGUgbm9ybWFsIHBhbmUgb3V0cHV0XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZGlzcGxheWVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgYXR0YWNoIHRoZSBjdXN0b20gbWVzc2FnZSBvciByZW1vdmUgdGhlIGNvbnRhaW5lciBmcm9tIHRoZSBkaXNwbGF5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNoTWVzc2FnZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJlcGFyZXMgdGhlIHBhbmVzIGZvciBzZWxlY3Rpb25zIHRvIGJlIG1hZGUgd2hlbiBjYXNjYWRlIGlzIGFjdGl2ZSBhbmQgYSBkZXNlbGVjdCBoYXMgb2NjdXJlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV3U2VsZWN0aW9uTGlzdCB0aGUgbGlzdCBvZiBzZWxlY3Rpb25zIHdoaWNoIGFyZSB0byBiZSBtYWRlXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2Nhc2NhZGVSZWdlbiA9IGZ1bmN0aW9uIChuZXdTZWxlY3Rpb25MaXN0LCBzZWxlY3RUb3RhbCkge1xuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBzbyB0aGF0IHRoZSBhY3Rpb25zIHRha2VuIGRvIG5vdCBjYXVzZSB0aGlzIHRvIHJ1biB1bnRpbCBpdCBpcyBmaW5pc2hlZFxuICAgICAgICAgICAgdGhpcy5yZWdlbmVyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgLy8gSWYgb25seSBvbmUgcGFuZSBoYXMgYmVlbiBzZWxlY3RlZCB0aGVuIHRha2Ugbm90ZSBvZiBpdHMgaW5kZXhcbiAgICAgICAgICAgIHZhciBzb2xlUGFuZSA9IC0xO1xuICAgICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbkxpc3QubGVuZ3RoID09PSAxICYmIHNlbGVjdFRvdGFsICE9PSBudWxsICYmIHNlbGVjdFRvdGFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc29sZVBhbmUgPSBuZXdTZWxlY3Rpb25MaXN0WzBdLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV0IHRoZSBwYW5lIGtub3cgdGhhdCBhIGNhc2NhZGVSZWdlbiBpcyB0YWtpbmcgcGxhY2UgdG8gYXZvaWQgdW5leHBlY3RlZCBiZWhhdmlvdXJcbiAgICAgICAgICAgIC8vIGFuZCBjbGVhciBhbGwgb2YgdGhlIHByZXZpb3VzIHNlbGVjdGlvbnMgaW4gdGhlIHBhbmVcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMucGFuZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgcGFuZS5zZXRDYXNjYWRlUmVnZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgcGFuZS5zZXRDbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBwYW5lIHdpdGggdGhlIG9ubHkgc2VsZWN0aW9uIHRoZW4gcGFzcyBpdCBhcyBhIHBhcmFtZXRlciBpbnRvIGNsZWFyUGFuZVxuICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQgJiYgcGFuZS5zLmluZGV4ID09PSBzb2xlUGFuZSB8fCBwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5jbGVhclBhbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFuZS5zZXRDbGVhcihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWJpbiBwYW5lc1xuICAgICAgICAgICAgdGhpcy5zLmR0LmRyYXcoKTtcbiAgICAgICAgICAgIC8vIFdoaWxlIGFsbCBvZiB0aGUgc2VsZWN0aW9ucyBoYXZlIGJlZW4gcmVtb3ZlZCwgY2hlY2sgdGhlIHRhYmxlIGxlbmd0aHNcbiAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIGRpZmZlcmVudCwgYW5vdGhlciBmaWx0ZXIgaXMgaW4gcGxhY2UgYW5kIHdlIG5lZWQgdG8gZm9yY2Ugdmlld1RvdGFsIHRvIGJlIHVzZWRcbiAgICAgICAgICAgIHZhciBub1NlbGVjdGlvbnNUYWJsZUxlbmd0aCA9IHRoaXMucy5kdC5yb3dzKHsgc2VhcmNoOiAnYXBwbGllZCcgfSkuZGF0YSgpLnRvQXJyYXkoKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdGFibGVMZW5ndGggPSB0aGlzLnMuZHQucm93cygpLmRhdGEoKS50b0FycmF5KCkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRhYmxlTGVuZ3RoICE9PSBub1NlbGVjdGlvbnNUYWJsZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLnMucGFuZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBwYW5lLnMuZm9yY2VWaWV3VG90YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSB0aGlzLnMucGFuZXM7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgcGFuZS51cGRhdGVQYW5lKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWtlIFNlbGVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX21ha2VDYXNjYWRlU2VsZWN0aW9ucyhuZXdTZWxlY3Rpb25MaXN0KTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgc2VsZWN0aW9uIGxpc3QgcHJvcGVydHkgdG8gYmUgdGhlIGxpc3Qgd2l0aG91dCB0aGUgc2VsZWN0aW9ucyBmcm9tIHRoZSBkZXNlbGVjdCBwYW5lXG4gICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdCA9IG5ld1NlbGVjdGlvbkxpc3Q7XG4gICAgICAgICAgICAvLyBUaGUgcmVnZW5lcmF0aW9uIG9mIHNlbGVjdGlvbnMgaXMgb3ZlciBzbyBzZXQgaXQgYmFjayB0byBmYWxzZVxuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSAwLCBfZyA9IHRoaXMucy5wYW5lczsgX2YgPCBfZy5sZW5ndGg7IF9mKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9nW19mXTtcbiAgICAgICAgICAgICAgICBwYW5lLnNldENhc2NhZGVSZWdlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVmlld1RvdGFsIGhhcyBhbHJlYWR5IGJlZW4gZm9yY2VkIGF0IHRoaXMgcG9pbnQgc28gY2FuIGNhbmNlbCB0aGF0IGZvciBmdXR1cmVcbiAgICAgICAgICAgIGlmICh0YWJsZUxlbmd0aCAhPT0gbm9TZWxlY3Rpb25zVGFibGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaCA9IDAsIF9qID0gdGhpcy5zLnBhbmVzOyBfaCA8IF9qLmxlbmd0aDsgX2grKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9qW19oXTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmZvcmNlVmlld1RvdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoZXMgdGhlIG1lc3NhZ2UgdG8gdGhlIGRvY3VtZW50IGJ1dCBkb2VzIG5vdCBhZGQgYW55IHBhbmVzXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2NoZWNrTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcGFuZSBpcyB0byBiZSBkaXNwbGF5ZWQgdGhlbiBhdHRhY2ggdGhlIG5vcm1hbCBwYW5lIG91dHB1dFxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmRpc3BsYXllZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZW1wdHkgbWVzc2FnZSBpcyByZW1vdmVkIGlmIGEgcGFuZSBpcyBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uZW1wdHlNZXNzYWdlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS50aXRsZVJvdy5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgYXR0YWNoIHRoZSBjdXN0b20gbWVzc2FnZSBvciByZW1vdmUgdGhlIGNvbnRhaW5lciBmcm9tIHRoZSBkaXNwbGF5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNoTWVzc2FnZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoaWNoIHBhbmVzIGFyZSBjb2xsYXBzZWQgYW5kIHRoZW4gcGVyZm9ybXMgcmVsZXZhbnQgYWN0aW9ucyB0byB0aGUgY29sbGFwc2Uvc2hvdyBhbGwgYnV0dG9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFuZSBUaGUgcGFuZSB0byBiZSBjaGVja2VkXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2NoZWNrQ29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZUNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlU2hvdyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZGlzcGxheWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IHRoZSBwYW5lIGlzIG5vdCBjb2xsYXBzZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYW5lLmRvbS5jb2xsYXBzZUJ1dHRvbi5oYXNDbGFzcyhwYW5lLmNsYXNzZXMucm90YXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSB0aGUgY29sbGFwc2UgYWxsIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY29sbGFwc2VBbGwucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgZW5hYmxlIHRoZSBzaG93IGFsbCBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLnNob3dBbGwucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoaXMgZmxhZyBpcyBzdGlsbCB0cnVlLCBubyBwYW5lcyBhcmUgb3BlbiBzbyB0aGUgY2xvc2UgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKGRpc2FibGVDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbGxhcHNlQWxsLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbikuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhpcyBmbGFnIGlzIHN0aWxsIHRydWUsIG5vIHBhbmVzIGFyZSBjbG9zZWQgc28gdGhlIHNob3cgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKGRpc2FibGVTaG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uc2hvd0FsbC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pLmF0dHIoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxhcHNlcyBhbGwgb2YgdGhlIHBhbmVzXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2NvbGxhcHNlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBwYW5lLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBzZWxlY3Rpb24gbGlzdCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgc3RvcmVzIGl0IGluIHRoZSBzZWxlY3Rpb25MaXN0IFByb3BlcnR5XG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX2dldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvYWRlZEZpbHRlciA9IHRoaXMucy5kdC5zdGF0ZS5sb2FkZWQoKTtcbiAgICAgICAgICAgIGlmIChsb2FkZWRGaWx0ZXIgJiYgbG9hZGVkRmlsdGVyLnNlYXJjaFBhbmVzICYmIGxvYWRlZEZpbHRlci5zZWFyY2hQYW5lcy5zZWxlY3Rpb25MaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdCA9IGxvYWRlZEZpbHRlci5zZWFyY2hQYW5lcy5zZWxlY3Rpb25MaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYWxsIG9mIHRoZSBzZWxlY3Rpb25zIHdoZW4gY2FzY2FkZSBpcyBhY3RpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ld1NlbGVjdGlvbkxpc3QgdGhlIGxpc3Qgb2Ygc2VsZWN0aW9ucyB0byBiZSBtYWRlLCBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIG9yaWdpbmFsbHkgc2VsZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5fbWFrZUNhc2NhZGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKG5ld1NlbGVjdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc2VsZWN0aW9ucyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIG1hZGUgcHJldmlvdXNseSxcbiAgICAgICAgICAgIC8vIGV4Y2x1ZGluZyB0aG9zZSBmcm9tIHRoZSBwYW5lIHdoZXJlIGEgZGVzZWxlY3Qgd2FzIG1hZGVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2VsZWN0aW9uTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUucy5pbmRleCA9PT0gbmV3U2VsZWN0aW9uTGlzdFtpXS5pbmRleCAmJiBwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmVnZW5lcmF0aW5nIHRoZSBjYXNjYWRlIHNlbGVjdGlvbnMgd2UgbmVlZCB0aGlzIGZsYWcgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhbmVzIGFyZSBvbmx5IGlnbm9yZWQgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBsYXN0IHNlbGVjdGlvbiBhbmQgdGhlIHBhbmUgZm9yIHRoYXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbmV3U2VsZWN0aW9uTGlzdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmxhc3RDYXNjYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0aW9ucyBjdXJyZW50bHkgaW4gdGhlIHBhbmUgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVzZWxlY3QgdGhlbSBhcyB3ZSBhcmUgYWJvdXQgdG8gbWFrZSBvdXIgbmV3IHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpLmxlbmd0aCA+IDAgJiYgcGFuZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zZXRDbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLmNsZWFyUGFuZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuc2V0Q2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmR0UGFuZS5yb3dzKCkuZXZlcnkoZnVuY3Rpb24gKHJvd0lkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmR0UGFuZS5yb3cocm93SWR4KS5kYXRhKCkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5kdFBhbmUucm93KHJvd0lkeCkuZGF0YSgpLmZpbHRlciA9PT0gcm93LmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmR0UGFuZS5yb3cocm93SWR4KS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1JvdyA9IHBhbmUuYWRkUm93KHJvdy5kaXNwbGF5LCByb3cuZmlsdGVyLCAwLCByb3cudG90YWwsIHJvdy5zb3J0LCByb3cudHlwZSwgcm93LmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0IGV2ZXJ5IHJvdyBpbiB0aGUgcGFuZSB0aGF0IHdhcyBzZWxlY3RlZCBwcmV2aW91c2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbmV3U2VsZWN0aW9uTGlzdFtpXS5yb3dzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMihyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLnNjcm9sbFRvcCA9ICQkMShwYW5lLnMuZHRQYW5lLnRhYmxlKCkubm9kZSgpKS5wYXJlbnQoKVswXS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnMuZHRQYW5lLmRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5kdFBhbmUudGFibGUoKS5ub2RlKCkucGFyZW50Tm9kZS5zY3JvbGxUb3AgPSBwYW5lLnMuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmxhc3RDYXNjYWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEFzIHRoZSBzZWxlY3Rpb25zIG1heSBoYXZlIGJlZW4gbWFkZSBhY3Jvc3MgdGhlIHBhbmVzXG4gICAgICAgICAgICAgICAgLy8gaW4gYSBkaWZmZXJlbnQgb3JkZXIgdG8gdGhlIHBhbmUgaW5kZXggd2UgbXVzdCBpZGVudGlmeVxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHBhbmUgaGFzIHRoZSBpbmRleCBvZiB0aGUgc2VsZWN0aW9uLiBUaGlzIGlzIGFsc28gaW1wb3J0YW50IGZvciBjb2xyZW9yZGVyIGV0Y1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnMucGFuZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKHBhbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY2xhcmVzIHRoZSBpbnN0YW5jZXMgb2YgaW5kaXZpZHVhbCBzZWFyY2hwYW5lcyBkZXBlbmRhbnQgb24gdGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAgICAgKiBJdCBpcyBuZWNlc3NhcnkgdG8gcnVuIHRoaXMgb25jZSBwcmVJbml0IGhhcyBjb21wbGV0ZWQgb3RoZXJ3aXNlIG5vIHBhbmVzIHdpbGwgYmVcbiAgICAgICAgICogY3JlYXRlZCBhcyB0aGUgY29sdW1uIGNvdW50IHdpbGwgYmUgMC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRhYmxlIHRoZSBEYXRhVGFibGUgYXBpIGZvciB0aGUgcGFyZW50IHRhYmxlXG4gICAgICAgICAqIEBwYXJhbSBwYW5lU2V0dGluZ3MgdGhlIHNldHRpbmdzIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gb3B0cyB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5fcGFuZURlY2xhcmUgPSBmdW5jdGlvbiAodGFibGUsIHBhbmVTZXR0aW5ncywgb3B0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIENyZWF0ZSBQYW5lc1xuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICAuY29sdW1ucyh0aGlzLmMuY29sdW1ucy5sZW5ndGggPiAwID8gdGhpcy5jLmNvbHVtbnMgOiB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgLmVxKDApXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnMucGFuZXMucHVzaChuZXcgU2VhcmNoUGFuZShwYW5lU2V0dGluZ3MsIG9wdHMsIGlkeCwgX3RoaXMuYy5sYXlvdXQsIF90aGlzLmRvbS5wYW5lcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbnkgZXh0cmEgY3VzdG9tIHBhbmVzIGRlZmluZWQgdGhlbiBjcmVhdGUgcGFuZXMgZm9yIHRoZW0gdG9vXG4gICAgICAgICAgICB2YXIgcm93TGVuZ3RoID0gdGFibGUuY29sdW1ucygpLmVxKDApLnRvQXJyYXkoKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcGFuZUxlbmd0aCA9IHRoaXMuYy5wYW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhbmVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHJvd0xlbmd0aCArIGk7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnBhbmVzLnB1c2gobmV3IFNlYXJjaFBhbmUocGFuZVNldHRpbmdzLCBvcHRzLCBpZCwgdGhpcy5jLmxheW91dCwgdGhpcy5kb20ucGFuZXMsIHRoaXMuYy5wYW5lc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gb3JkZXJpbmcgaXMgYmVpbmcgdXNlZFxuICAgICAgICAgICAgaWYgKHRoaXMuYy5vcmRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIG5ldyBBcnJheSBvZiBwYW5lcyBiYXNlZCB1cG9uIHRoZSBvcmRlclxuICAgICAgICAgICAgICAgIHZhciBuZXdQYW5lcyA9IHRoaXMuYy5vcmRlci5tYXAoZnVuY3Rpb24gKG5hbWUsIGluZGV4LCB2YWx1ZXMpIHsgcmV0dXJuIF90aGlzLl9maW5kUGFuZShuYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgcGFuZXMgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucGFuZXMuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMucGFuZXMgPSBuZXdQYW5lcztcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHBhbmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLnBhbmVzLmFwcGVuZChwYW5lLmRvbS5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaW50ZXJuYWwgcHJvcGVydHkgaXMgdHJ1ZSB0aGVuIHRoZSBEYXRhVGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLl9iSW5pdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnR1cCh0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIHRoZSBwYW5lU3RhcnR1cCBmdW5jdGlvbiB0byB0aGUgbGlzdCBvZiBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFyZSB0byBiZSBydW4gd2hlbiB0aGUgdGFibGUgaXMgaW5pdGlhbGlzZWQuIFRoaXMgd2lsbCBnYXJhdW50ZWUgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBwYW5lcyBhcmUgaW5pdGlhbGlzZWQgYmVmb3JlIHRoZSBpbml0IGV2ZW50IGFuZCBpbml0IENvbXBsZXRlIGNhbGxiYWNrIGlzIGZpcmVkXG4gICAgICAgICAgICAgICAgdGhpcy5zLmR0LnNldHRpbmdzKClbMF0uYW9Jbml0Q29tcGxldGUucHVzaCh7IGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3RhcnR1cCh0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kcyBhIHBhbmUgYmFzZWQgdXBvbiB0aGUgbmFtZSBvZiB0aGF0IHBhbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5hbWUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgcGFuZVxuICAgICAgICAgKiBAcmV0dXJucyBTZWFyY2hQYW5lIFRoZSBwYW5lIHdoaWNoIGhhcyB0aGF0IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5fZmluZFBhbmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gcGFuZS5zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV29ya3Mgb3V0IHdoaWNoIHBhbmVzIHRvIHVwZGF0ZSB3aGVuIGRhdGEgaXMgcmVjaWV2ZWQgZnJvbSB0aGUgc2VydmVyIGFuZCB2aWV3VG90YWwgaXMgYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX3NlcnZlclRvdGFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZGVzZWxlY3RQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSB0aGlzLnMuZHQ7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIC8vIElkZW50aWZ5IHRoZSBwYW5lIHdoZXJlIGEgc2VsZWN0aW9uIG9yIGRlc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUgYW5kIGFkZCBpdCB0byB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICBpZiAocGFuZS5zLnNlbGVjdFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnNlbGVjdGlvbkxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcGFuZS5zLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzOiBwYW5lLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwYW5lLnMuc2VsZWN0UHJlc2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhbmUucy5kZXNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRhID0gcGFuZS5zLmR0UGFuZS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGF0YSgpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcGFuZS5zLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93czogc2VsZWN0ZWREYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVzZWxlY3RQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCBhbiB1cGRhdGVkIGxpc3QgYmFzZWQgb24gYW55IHNlbGVjdGlvbnMgb3IgZGVzZWxlY3Rpb25zIGFkZGVkXG4gICAgICAgICAgICBpZiAoIXNlbGVjdFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnMuc2VsZWN0aW9uTGlzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlbGVjdGlvbkxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucy5zZWxlY3Rpb25MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdXJ0aGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgb3V0IGlmIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBsYXN0IG9uZSBpbiB0aGUgbGlzdCBmb3IgdGhhdCBwYW5lXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IHRoaXMucy5zZWxlY3Rpb25MaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zLnNlbGVjdGlvbkxpc3Rbal0uaW5kZXggPT09IHRoaXMucy5zZWxlY3Rpb25MaXN0W2ldLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVydGhlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHNlbGVjdGlvbnMgZm9yIHRoaXMgcGFuZSBpbiB0aGUgbGlzdCB0aGVuIGp1c3QgcHVzaCB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1cnRoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5zLnBhbmVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuaW5kZXggPT09IHRoaXMucy5zZWxlY3Rpb25MaXN0W2ldLmluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS50b0FycmF5KCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbkxpc3QucHVzaCh0aGlzLnMuc2VsZWN0aW9uTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zLnNlbGVjdGlvbkxpc3QgPSBuZXdTZWxlY3Rpb25MaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluaXRJZHggPSAtMTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIGEgZGVzZWxlY3QgYW5kIG9ubHkgb25lIHBhbmUgaGFzIGEgc2VsZWN0aW9uIHRoZW4gdXBkYXRlIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIGlmIChkZXNlbGVjdFByZXNlbnQgJiYgdGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IHRoaXMucy5wYW5lczsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5sYXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5kZXNlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkICYmIHBhbmUucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS50b0FycmF5KCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdElkeCA9IHBhbmUucy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiB0aGVyZSBhcmUgbW9yZSAxIHNlbGVjdGlvbnMgdGhlbiBmaW5kIHRoZSBsYXN0IG9uZSBhbmQgc2V0IGl0IHRvIG5vdCB1cGRhdGUgdGhhdCBwYW5lXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnMuc2VsZWN0aW9uTGlzdFt0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IDAsIF9nID0gdGhpcy5zLnBhbmVzOyBfZiA8IF9nLmxlbmd0aDsgX2YrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9nW19mXTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmxhc3RTZWxlY3QgPSBwYW5lLnMuaW5kZXggPT09IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5kZXNlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiB0aGVyZSBhcmUgbm8gc2VsZWN0aW9ucyB0aGVuIGZpbmQgd2hlcmUgdGhhdCB0b29rIHBsYWNlIGFuZCBkbyBub3QgdXBkYXRlIHRvIG1haW50YWluIHNjcm9sbGluZ1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2ggPSAwLCBfaiA9IHRoaXMucy5wYW5lczsgX2ggPCBfai5sZW5ndGg7IF9oKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfaltfaF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhbmUucy5sYXN0U2VsZWN0ID0gKHBhbmUucy5kZXNlbGVjdCA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5sYXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5kZXNlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tLnBhbmVzLmVtcHR5KCk7XG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHRoZSBkZXNpcmVkIHBhbmVzXG4gICAgICAgICAgICBmb3IgKHZhciBfayA9IDAsIF9sID0gdGhpcy5zLnBhbmVzOyBfayA8IF9sLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2xbX2tdO1xuICAgICAgICAgICAgICAgIGlmICghcGFuZS5zLmxhc3RTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5yZWJ1aWxkUGFuZSh1bmRlZmluZWQsIHRoaXMucy5kdC5wYWdlLmluZm8oKS5zZXJ2ZXJTaWRlID8gdGhpcy5zLnNlcnZlckRhdGEgOiB1bmRlZmluZWQsIHBhbmUucy5pbmRleCA9PT0gaW5pdElkeCA/IHRydWUgOiBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuX3NldExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgYWxsIG9mIHRoZSBwYW5lcyBhbmQgZW5hYmxlIHNlbGVjdFxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnBhbmVzLmFwcGVuZChwYW5lLmRvbS5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCQxKHBhbmUucy5kdFBhbmUudGFibGUoKS5ub2RlKCkpLnBhcmVudCgpWzBdLnNjcm9sbFRvcCA9IHBhbmUucy5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgICAgICAgICAgICAgJCQxLmZuLmRhdGFUYWJsZS5zZWxlY3QuaW5pdChwYW5lLnMuZHRQYW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGxpc3RlbmVycyBmb3IgdGhlIGNvbGxhcHNlIGFuZCBzaG93IGFsbCBidXR0b25zXG4gICAgICAgICAqIEFsc28gc2V0cyBhbmQgcGVyZm9ybXMgY2hlY2tzIG9uIGN1cnJlbnQgcGFuZXMgdG8gc2VlIGlmIHRoZXkgYXJlIGNvbGxhcHNlZFxuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZXMucHJvdG90eXBlLl9zZXRDb2xsYXBzZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbGxhcHNlQWxsLm9uKCdjbGljay5kdHNwcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29sbGFwc2VBbGwoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY29sbGFwc2VBbGwuYWRkQ2xhc3MoX3RoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbikuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5zaG93QWxsLnJlbW92ZUNsYXNzKF90aGlzLmNsYXNzZXMuZGlzYWJsZWRCdXR0b24pLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucy5kdC5zdGF0ZS5zYXZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNob3dBbGwub24oJ2NsaWNrLmR0c3BzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zaG93QWxsKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLnNob3dBbGwuYWRkQ2xhc3MoX3RoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbikuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jb2xsYXBzZUFsbC5yZW1vdmVDbGFzcyhfdGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuc3RhdGUuc2F2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSB0aGUgc2FtZSBjaGVjayB3aGVuZXZlciB0aGVyZSBpcyBhIGNvbGxhcHNlL2V4cGFuZFxuICAgICAgICAgICAgICAgIHBhbmUuZG9tLmNvbGxhcHNlQnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jaGVja0NvbGxhcHNlKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tDb2xsYXBzZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvd3MgYWxsIG9mIHRoZSBwYW5lc1xuICAgICAgICAgKi9cbiAgICAgICAgU2VhcmNoUGFuZXMucHJvdG90eXBlLl9zaG93QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBwYW5lLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpc2VzIHRoZSB0YWJsZXMgcHJldmlvdXMvcHJlc2V0IHNlbGVjdGlvbnMgYW5kIGluaXRpYWxpc2VzIGNhbGxiYWNrcyBmb3IgZXZlbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0YWJsZSB0aGUgcGFyZW50IHRhYmxlIGZvciB3aGljaCB0aGUgc2VhcmNoUGFuZXMgYXJlIGJlaW5nIGNyZWF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIFNlYXJjaFBhbmVzLnByb3RvdHlwZS5fc3RhcnR1cCA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci50ZXh0KCcnKTtcbiAgICAgICAgICAgIC8vIEF0dGFjaCBjbGVhciBidXR0b24gYW5kIHRpdGxlIGJhciB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhcygpO1xuICAgICAgICAgICAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZCh0aGlzLmRvbS5wYW5lcyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5wYW5lcy5lbXB0eSgpO1xuICAgICAgICAgICAgdmFyIGxvYWRlZEZpbHRlciA9IHRoaXMucy5kdC5zdGF0ZS5sb2FkZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmMudmlld1RvdGFsICYmICF0aGlzLmMuY2FzY2FkZVBhbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZEZpbHRlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRGaWx0ZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRGaWx0ZXIuc2VhcmNoUGFuZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRGaWx0ZXIuc2VhcmNoUGFuZXMucGFuZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBsb2FkZWRGaWx0ZXIuc2VhcmNoUGFuZXMucGFuZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLnNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLnMucGFuZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLnNob3dGaWx0ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gdGhpcy5zLnBhbmVzOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2VbX2RdO1xuICAgICAgICAgICAgICAgIHBhbmUucmVidWlsZFBhbmUodW5kZWZpbmVkLCBPYmplY3Qua2V5cyh0aGlzLnMuc2VydmVyRGF0YSkubGVuZ3RoID4gMCA/IHRoaXMucy5zZXJ2ZXJEYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5wYW5lcy5hcHBlbmQocGFuZS5kb20uY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXlvdXQgaXMgc2V0IHRvIGF1dG8gdGhlbiB0aGUgcGFuZXMgbmVlZCB0byBiZSByZXNpemVkIHRvIHRoZWlyIGJlc3QgZml0XG4gICAgICAgICAgICBpZiAodGhpcy5jLmxheW91dCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVQYW5lcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhZ2luZyBpZiB0aGF0IGhhcyBiZWVuIHNhdmVkIGluIHRoZSBzdGF0ZVxuICAgICAgICAgICAgaWYgKCF0aGlzLnMuc3RhdGVSZWFkICYmIGxvYWRlZEZpbHRlciAhPT0gbnVsbCAmJiBsb2FkZWRGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucy5kdC5wYWdlKGxvYWRlZEZpbHRlci5zdGFydCAvIHRoaXMucy5kdC5wYWdlLmxlbigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMuZHQuZHJhdygncGFnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zLnN0YXRlUmVhZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jLnZpZXdUb3RhbCAmJiAhdGhpcy5jLmNhc2NhZGVQYW5lcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gMCwgX2cgPSB0aGlzLnMucGFuZXM7IF9mIDwgX2cubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2dbX2ZdO1xuICAgICAgICAgICAgICAgICAgICBwYW5lLnVwZGF0ZVBhbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja01lc3NhZ2UoKTtcbiAgICAgICAgICAgIC8vIFdoZW4gYSBkcmF3IGlzIGNhbGxlZCBvbiB0aGUgRGF0YVRhYmxlLCB1cGRhdGUgYWxsIG9mIHRoZSBwYW5lcyBpbmNhc2UgdGhlIGRhdGEgaW4gdGhlIERhdGFUYWJsZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgdGFibGUub24oJ3ByZURyYXcuZHRzcHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcGFuZXMgYXJlIG5vdCB1cGRhdGluZyB0byBhdm9pZCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIC8vIEFsc28gY2hlY2sgdGhhdCB0aGlzIGRyYXcgaXMgbm90IGR1ZSB0byBwYWdpbmdcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnMudXBkYXRpbmcgJiYgIV90aGlzLnMucGFnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX3RoaXMuYy5jYXNjYWRlUGFuZXMgfHwgX3RoaXMuYy52aWV3VG90YWwpICYmICFfdGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZHJhd1BhbmVzKF90aGlzLmMudmlld1RvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVGaWx0ZXJDb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZmlsdGVyUGFuZSA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYWdpbmcgZmxhZyByZXNldCAtIHdlIG9ubHkgbmVlZCB0byBkb2RnZSB0aGUgZHJhdyBvbmNlXG4gICAgICAgICAgICAgICAgX3RoaXMucy5wYWdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCQxKHdpbmRvdykub24oJ3Jlc2l6ZS5kdHNwJywgZGF0YVRhYmxlJDEudXRpbC50aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplUGFuZXMoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIFdoZW5ldmVyIGEgc3RhdGUgc2F2ZSBvY2N1cnMgc3RvcmUgdGhlIHNlbGVjdGlvbiBsaXN0IGluIHRoZSBzdGF0ZSBvYmplY3RcbiAgICAgICAgICAgIHRoaXMucy5kdC5vbignc3RhdGVTYXZlUGFyYW1zLmR0c3AnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zZWFyY2hQYW5lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lcy5zZWxlY3Rpb25MaXN0ID0gX3RoaXMucy5zZWxlY3Rpb25MaXN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMaXN0ZW5lciBmb3IgcGFnaW5nIG9uIG1haW4gdGFibGVcbiAgICAgICAgICAgIHRhYmxlLm9mZigncGFnZScpO1xuICAgICAgICAgICAgdGFibGUub24oJ3BhZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucy5wYWdpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnMucGFnZSA9IF90aGlzLnMuZHQucGFnZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zLmR0LnBhZ2UuaW5mbygpLnNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICB0YWJsZS5vZmYoJ3ByZVhoci5kdCcpO1xuICAgICAgICAgICAgICAgIHRhYmxlLm9uKCdwcmVYaHIuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2VhcmNoUGFuZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlYXJjaFBhbmVzX251bGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lc19udWxsID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgaG93IG1hbnkgZmlsdGVycyBhcmUgYmVpbmcgYXBwbGllZFxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IF90aGlzLnMuZHQuY29sdW1uKHBhbmUucy5pbmRleCkuZGF0YVNyYygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2VhcmNoUGFuZXNbc3JjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lc1tzcmNdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zZWFyY2hQYW5lc19udWxsW3NyY10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2VhcmNoUGFuZXNfbnVsbFtzcmNdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0RhdGEgPSBwYW5lLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlYXJjaFBhbmVzW3NyY11baV0gPSByb3dEYXRhW2ldLmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2VhcmNoUGFuZXNbc3JjXVtpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWFyY2hQYW5lc19udWxsW3NyY11baV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jLnZpZXdUb3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXBWaWV3VG90YWwoZmlsdGVyQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZmlsdGVyIHRvIGJlIGFwcGxpZWQsIHRoZW4gd2UgbmVlZCB0byByZWFkIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSByZXN1bHQgc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzZXQgdGhlIHBhZ2luZyB0byAwLiBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZiBjbGllbnQgc2lkZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgZmlsdGVycyBoYXMgY2hhbmdlZCB3ZSBuZWVkIHRvIHJlYWQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgc2V0IGFuZCByZXNldCB0aGUgcGFnaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyQ291bnQgIT09IF90aGlzLnMuZmlsdGVyQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLnBhZ2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IGlzIGEgcGFnaW5nIHJlcXVlc3QgYW5kIHdlIG5lZWQgdG8gcmVhZCBmcm9tIHdoYXRldmVyIHRoZSBwYWdpbmcgaGFzIGJlZW4gc2V0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gX3RoaXMucy5wYWdlICogX3RoaXMucy5kdC5wYWdlLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5wYWdlKF90aGlzLnMucGFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmZpbHRlckNvdW50ID0gZmlsdGVyQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhYmxlLm9uKCdwcmVYaHIuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLnMucGFuZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuY2xlYXJEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGlzIHJlbG9hZGVkIGZyb20gdGhlIHNlcnZlciB0aGVuIGl0IGlzIHBvc3NpYmxlIHRoYXQgaXQgaGFzIGNoYW5nZWQgY29tcGxldGVseSxcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmVidWlsZCB0aGUgcGFuZXNcbiAgICAgICAgICAgIHRoaXMucy5kdC5vbigneGhyJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uLCB4aHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MublRhYmxlICE9PSBfdGhpcy5zLmR0LnRhYmxlKCkubm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zLmR0Lm9uZSgncHJlRHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBfdGhpcy5zLmR0LnBhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20ucGFuZXMuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuY2xlYXJEYXRhKCk7IC8vIENsZWFycyBhbGwgb2YgdGhlIGJpbnMgYW5kIHdpbGwgbWVhbiB0aGF0IHRoZSBkYXRhIGhhcyB0byBiZSByZS1yZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBhIGJvb2xlYW4gdG8gc2F5IHdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaG9pY2UgbWFkZSBmb3IgbWFpbnRhaW5pbmcgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVidWlsZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucmVidWlsZFBhbmUoX3RoaXMucy5zZWxlY3Rpb25MaXN0W190aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGggLSAxXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmluZGV4ID09PSBfdGhpcy5zLnNlbGVjdGlvbkxpc3RbX3RoaXMucy5zZWxlY3Rpb25MaXN0Lmxlbmd0aCAtIDFdLmluZGV4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20ucGFuZXMuYXBwZW5kKHBhbmUuZG9tLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnMuZHQucGFnZS5pbmZvKCkuc2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMuZHQuZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmMuY2FzY2FkZVBhbmVzIHx8IF90aGlzLmMudmlld1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVkcmF3UGFuZXMoX3RoaXMuYy5jYXNjYWRlUGFuZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5vbmUoJ2RyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucy5kdC5wYWdlKHBhZ2UpLmRyYXcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnMudXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFByZVNlbGVjdCBhbnkgc2VsZWN0aW9ucyB3aGljaCBoYXZlIGJlZW4gZGVmaW5lZCB1c2luZyB0aGUgcHJlU2VsZWN0IG9wdGlvblxuICAgICAgICAgICAgZm9yICh2YXIgX2ggPSAwLCBfaiA9IHRoaXMucy5wYW5lczsgX2ggPCBfai5sZW5ndGg7IF9oKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9qW19oXTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5kdFBhbmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAocGFuZS5zLmNvbE9wdHMucHJlU2VsZWN0ICE9PSB1bmRlZmluZWQgJiYgcGFuZS5zLmNvbE9wdHMucHJlU2VsZWN0Lmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuY3VzdG9tUGFuZVNldHRpbmdzICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5jdXN0b21QYW5lU2V0dGluZ3MucHJlU2VsZWN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLmN1c3RvbVBhbmVTZXR0aW5ncy5wcmVTZWxlY3QubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gcGFuZS5zLmR0UGFuZS5yb3dzKCkuZGF0YSgpLnRvQXJyYXkoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUucy5jb2xPcHRzLnByZVNlbGVjdC5pbmNsdWRlcyhwYW5lLnMuZHRQYW5lLmNlbGwoaSwgMCkuZGF0YSgpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuY3VzdG9tUGFuZVNldHRpbmdzICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuY3VzdG9tUGFuZVNldHRpbmdzLnByZVNlbGVjdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuY3VzdG9tUGFuZVNldHRpbmdzLnByZVNlbGVjdC5pbmNsdWRlcyhwYW5lLnMuZHRQYW5lLmNlbGwoaSwgMCkuZGF0YSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5kdFBhbmUucm93KGkpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhbmUudXBkYXRlVGFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zLnNlbGVjdGlvbkxpc3QgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnMuc2VsZWN0aW9uTGlzdFt0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IDAsIF9sID0gdGhpcy5zLnBhbmVzOyBfayA8IF9sLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9sW19rXTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5zLmxhc3RTZWxlY3QgPSBwYW5lLnMuaW5kZXggPT09IGxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgY2FzY2FkZVBhbmVzIGlzIGFjdGl2ZSB0aGVuIG1ha2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbnMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBwcmV2aW91c2x5XG4gICAgICAgICAgICBpZiAodGhpcy5zLnNlbGVjdGlvbkxpc3QubGVuZ3RoID4gMCAmJiB0aGlzLmMuY2FzY2FkZVBhbmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FzY2FkZVJlZ2VuKHRoaXMucy5zZWxlY3Rpb25MaXN0LCB0aGlzLnMuc2VsZWN0aW9uTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aXRsZSBiYXIgdG8gc2hvdyBob3cgbWFueSBmaWx0ZXJzIGhhdmUgYmVlbiBzZWxlY3RlZFxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRmlsdGVyQ291bnQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0YWJsZSBpcyBkZXN0cm95ZWQgYW5kIHJlc3RhcnRlZCB0aGVuIGNsZWFyIHRoZSBzZWxlY3Rpb25zIHNvIHRoYXQgdGhleSBkbyBub3QgcGVyc2lzdC5cbiAgICAgICAgICAgIHRhYmxlLm9uKCdkZXN0cm95LmR0c3BzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhYmxlLm9mZignLmR0c3BzJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNvbGxhcHNlQWxsLm9mZignLmR0c3BzJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLnNob3dBbGwub2ZmKCcuZHRzcHMnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXJBbGwub2ZmKCcuZHRzcHMnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jLmNvbGxhcHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29sbGFwc2VMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgY2xlYXIgQWxsIGJ1dHRvbiBoYXMgYmVlbiBwcmVzc2VkIGNsZWFyIGFsbCBvZiB0aGUgc2VsZWN0aW9ucyBpbiB0aGUgcGFuZXNcbiAgICAgICAgICAgIGlmICh0aGlzLmMuY2xlYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGVhckFsbC5vbignY2xpY2suZHRzcHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0dGluZ3MoKVswXS5fc2VhcmNoUGFuZXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVGhpcyBzdGF0ZSBzYXZlIGlzIHJlcXVpcmVkIHNvIHRoYXQgc3RhdGUgaXMgbWFpbnRhaW5lZCBvdmVyIG11bHRpcGxlIHJlZnJlc2hlcyBpZiBubyBhY3Rpb25zIGFyZSBtYWRlXG4gICAgICAgICAgICB0aGlzLnMuZHQuc3RhdGUuc2F2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX3ByZXBWaWV3VG90YWwgPSBmdW5jdGlvbiAoc2VsZWN0VG90YWwpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJQYW5lID0gdGhpcy5zLmZpbHRlclBhbmU7XG4gICAgICAgICAgICB2YXIgZmlsdGVyQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdExlbmd0aCA9IHBhbmUucy5kdFBhbmUucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRhdGEoKS50b0FycmF5KCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBmaWx0ZXJQYW5lID09PSAtMSB0aGVuIGEgcGFuZSB3aXRoIGEgc2VsZWN0aW9uIGhhcyBub3QgYmVlbiBmb3VuZCB5ZXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHNldCBmaWx0ZXJQYW5lIHRvIHRoYXQgcGFuZXMgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdExlbmd0aCA+IDAgJiYgZmlsdGVyUGFuZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclBhbmUgPSBwYW5lLnMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gaWYgYW5vdGhlciBwYW5lIGlzIGZvdW5kIHdpdGggYSBzZWxlY3Rpb24gdGhlbiBzZXQgZmlsdGVyUGFuZSB0byBudWxsIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3cgdGhhdCBtdWx0aXBsZSBwYW5lcyBoYXZlIHNlbGVjdGlvbnMgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQYW5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RUb3RhbCAhPT0gbnVsbCAmJiBzZWxlY3RUb3RhbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlclBhbmUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBvZiB0aGUgcGFuZXMgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmlsdGVyc1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMucy5wYW5lczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUucy5maWx0ZXJpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyUGFuZSAhPT0gLTEgJiYgZmlsdGVyUGFuZSAhPT0gbnVsbCAmJiBmaWx0ZXJQYW5lID09PSBwYW5lLnMuaW5kZXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUucy5maWx0ZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIG51bWJlciBvZiBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGFwcGxpZWQgaW4gdGhlIHRpdGxlXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX3VwZGF0ZUZpbHRlckNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlckNvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGFsbCBvZiB0aGUgZmlsdGVycyB0aHJvdWdob3V0IHRoZSBwYW5lc1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucy5wYW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZS5zLmR0UGFuZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckNvdW50ICs9IHBhbmUuZ2V0UGFuZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIHRoZSBtZXNzYWdlIHRocm91Z2ggdGhlIGludGVybmF0aW9uYWxpc2F0aW9uIG1ldGhvZCB0byBpbXByb3ZlIHJlYWRhYmlsaXR5XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMucy5kdC5pMThuKCdzZWFyY2hQYW5lcy50aXRsZScsIHRoaXMuYy5pMThuLnRpdGxlLCBmaWx0ZXJDb3VudCk7XG4gICAgICAgICAgICB0aGlzLmRvbS50aXRsZS50ZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYy5maWx0ZXJDaGFuZ2VkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRoaXMuYy5maWx0ZXJDaGFuZ2VkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jLmZpbHRlckNoYW5nZWQuY2FsbCh0aGlzLnMuZHQsIGZpbHRlckNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyQWxsLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5kaXNhYmxlZEJ1dHRvbikuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xlYXJBbGwucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmRpc2FibGVkQnV0dG9uKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgc2VsZWN0aW9uTGlzdCB3aGVuIGNhc2NhZGUgaXMgbm90IGluIHBsYWNlXG4gICAgICAgICAqL1xuICAgICAgICBTZWFyY2hQYW5lcy5wcm90b3R5cGUuX3VwZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucy5zZWxlY3Rpb25MaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zLnBhbmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lLnMuZHRQYW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zLnNlbGVjdGlvbkxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcGFuZS5zLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzOiBwYW5lLnMuZHRQYW5lLnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5kYXRhKCkudG9BcnJheSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2VhcmNoUGFuZXMudmVyc2lvbiA9ICcxLjQuMCc7XG4gICAgICAgIFNlYXJjaFBhbmVzLmNsYXNzZXMgPSB7XG4gICAgICAgICAgICBjbGVhcjogJ2R0c3AtY2xlYXInLFxuICAgICAgICAgICAgY2xlYXJBbGw6ICdkdHNwLWNsZWFyQWxsJyxcbiAgICAgICAgICAgIGNvbGxhcHNlQWxsOiAnZHRzcC1jb2xsYXBzZUFsbCcsXG4gICAgICAgICAgICBjb250YWluZXI6ICdkdHNwLXNlYXJjaFBhbmVzJyxcbiAgICAgICAgICAgIGRpc2FibGVkQnV0dG9uOiAnZHRzcC1kaXNhYmxlZEJ1dHRvbicsXG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2U6ICdkdHNwLWVtcHR5TWVzc2FnZScsXG4gICAgICAgICAgICBoaWRlOiAnZHRzcC1oaWRkZW4nLFxuICAgICAgICAgICAgcGFuZXM6ICdkdHNwLXBhbmVzQ29udGFpbmVyJyxcbiAgICAgICAgICAgIHNlYXJjaDogJ2R0c3Atc2VhcmNoJyxcbiAgICAgICAgICAgIHNob3dBbGw6ICdkdHNwLXNob3dBbGwnLFxuICAgICAgICAgICAgdGl0bGU6ICdkdHNwLXRpdGxlJyxcbiAgICAgICAgICAgIHRpdGxlUm93OiAnZHRzcC10aXRsZVJvdydcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGVmaW5lIFNlYXJjaFBhbmVzIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBTZWFyY2hQYW5lcy5kZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGNhc2NhZGVQYW5lczogZmFsc2UsXG4gICAgICAgICAgICBjbGVhcjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbGxhcHNlOiB0cnVlLFxuICAgICAgICAgICAgY29sdW1uczogW10sXG4gICAgICAgICAgICBjb250YWluZXI6IGZ1bmN0aW9uIChkdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkdC50YWJsZSgpLmNvbnRhaW5lcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlckNoYW5nZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgICBjbGVhck1lc3NhZ2U6ICdDbGVhciBBbGwnLFxuICAgICAgICAgICAgICAgIGNsZWFyUGFuZTogJyZ0aW1lczsnLFxuICAgICAgICAgICAgICAgIGNvbGxhcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIDA6ICdTZWFyY2hQYW5lcycsXG4gICAgICAgICAgICAgICAgICAgIF86ICdTZWFyY2hQYW5lcyAoJWQpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29sbGFwc2VNZXNzYWdlOiAnQ29sbGFwc2UgQWxsJyxcbiAgICAgICAgICAgICAgICBjb3VudDogJ3t0b3RhbH0nLFxuICAgICAgICAgICAgICAgIGNvdW50RmlsdGVyZWQ6ICd7c2hvd259ICh7dG90YWx9KScsXG4gICAgICAgICAgICAgICAgZW1wdHlNZXNzYWdlOiAnPGVtPk5vIGRhdGE8L2VtPicsXG4gICAgICAgICAgICAgICAgZW1wdHlQYW5lczogJ05vIFNlYXJjaFBhbmVzJyxcbiAgICAgICAgICAgICAgICBsb2FkTWVzc2FnZTogJ0xvYWRpbmcgU2VhcmNoIFBhbmVzLi4uJyxcbiAgICAgICAgICAgICAgICBzaG93TWVzc2FnZTogJ1Nob3cgQWxsJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0ZpbHRlcnMgQWN0aXZlIC0gJWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGF5b3V0OiAnYXV0bycsXG4gICAgICAgICAgICBvcmRlcjogW10sXG4gICAgICAgICAgICBwYW5lczogW10sXG4gICAgICAgICAgICB2aWV3VG90YWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTZWFyY2hQYW5lcztcbiAgICB9KCkpO1xuXG4gICAgLyohIFNlYXJjaFBhbmVzIDEuNC4wXG4gICAgICogMjAxOS0yMDIwIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gICAgICovXG4gICAgLy8gRGF0YVRhYmxlcyBleHRlbnNpb25zIGNvbW1vbiBVTUQuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyBmb3IgQU1ELCBDb21tb25KU1xuICAgIC8vICh3aXRoIHdpbmRvdyBhbmQgalF1ZXJ5IGJlaW5nIGFsbG93ZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgcmV0dXJuZWRcbiAgICAvLyBmdW5jdGlvbikgb3IganVzdCBkZWZhdWx0IGJyb3dzZXIgbG9hZGluZy5cbiAgICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgICAgLy8gQU1EXG4gICAgICAgICAgICBkZWZpbmUoWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnXSwgZnVuY3Rpb24gKCQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCB3aW5kb3csIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gQ29tbW9uSlNcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEkIHx8ICEkLmZuLmRhdGFUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgICAgICAgICAgICAgICAkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQnKShyb290LCAkKS4kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCByb290LCByb290LmRvY3VtZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCcm93c2VyIC0gYXNzdW1lIGpRdWVyeSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAgICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH0oZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgICAgICAgc2V0SlF1ZXJ5KCQpO1xuICAgICAgICBzZXRKUXVlcnkkMSgkKTtcbiAgICAgICAgdmFyIGRhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgICQuZm4uZGF0YVRhYmxlLlNlYXJjaFBhbmVzID0gU2VhcmNoUGFuZXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgJC5mbi5EYXRhVGFibGUuU2VhcmNoUGFuZXMgPSBTZWFyY2hQYW5lcztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAkLmZuLmRhdGFUYWJsZS5TZWFyY2hQYW5lID0gU2VhcmNoUGFuZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAkLmZuLkRhdGFUYWJsZS5TZWFyY2hQYW5lID0gU2VhcmNoUGFuZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICB2YXIgYXBpUmVnaXN0ZXIgPSAkLmZuLmRhdGFUYWJsZS5BcGkucmVnaXN0ZXI7XG4gICAgICAgIGFwaVJlZ2lzdGVyKCdzZWFyY2hQYW5lcygpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgICAgICBhcGlSZWdpc3Rlcignc2VhcmNoUGFuZXMuY2xlYXJTZWxlY3Rpb25zKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5fc2VhcmNoUGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Ll9zZWFyY2hQYW5lcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaVJlZ2lzdGVyKCdzZWFyY2hQYW5lcy5yZWJ1aWxkUGFuZSgpJywgZnVuY3Rpb24gKHRhcmdldElkeCwgbWFpbnRhaW5TZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5fc2VhcmNoUGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Ll9zZWFyY2hQYW5lcy5yZWJ1aWxkKHRhcmdldElkeCwgbWFpbnRhaW5TZWxlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaVJlZ2lzdGVyKCdzZWFyY2hQYW5lcy5yZXNpemVQYW5lcygpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcbiAgICAgICAgICAgIHJldHVybiBjdHguX3NlYXJjaFBhbmVzID9cbiAgICAgICAgICAgICAgICBjdHguX3NlYXJjaFBhbmVzLnJlc2l6ZVBhbmVzKCkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBhcGlSZWdpc3Rlcignc2VhcmNoUGFuZXMuY29udGFpbmVyKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5fc2VhcmNoUGFuZXNcbiAgICAgICAgICAgICAgICA/IGN0eC5fc2VhcmNoUGFuZXMuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgJC5mbi5kYXRhVGFibGUuZXh0LmJ1dHRvbnMuc2VhcmNoUGFuZXNDbGVhciA9IHtcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKGUsIGR0LCBub2RlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBkdC5zZWFyY2hQYW5lcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiAnQ2xlYXIgUGFuZXMnXG4gICAgICAgIH07XG4gICAgICAgICQuZm4uZGF0YVRhYmxlLmV4dC5idXR0b25zLnNlYXJjaFBhbmVzID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoZSwgZHQsIG5vZGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyKGNvbmZpZy5fcGFuZXMuZ2V0Tm9kZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiAnZHQtY29udGFpbmVyJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGFuZXMucmVidWlsZCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZHQsIG5vZGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lcyA9IG5ldyAkLmZuLmRhdGFUYWJsZS5TZWFyY2hQYW5lcyhkdCwgJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDaGFuZ2VkOiBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGR0LmNvbnRleHRbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBkdC5idXR0b24obm9kZSkudGV4dChkdC5pMThuKCdzZWFyY2hQYW5lcy5jb2xsYXBzZScsIGR0LmNvbnRleHRbMF0ub0xhbmd1YWdlLnNlYXJjaFBhbmVzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0LmNvbnRleHRbMF0ub0xhbmd1YWdlLnNlYXJjaFBhbmVzLmNvbGxhcHNlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdC5jb250ZXh0WzBdLl9zZWFyY2hQYW5lcy5jLmkxOG4uY29sbGFwc2UsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjb25maWcuY29uZmlnKSk7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBkdC5pMThuKCdzZWFyY2hQYW5lcy5jb2xsYXBzZScsIHBhbmVzLmMuaTE4bi5jb2xsYXBzZSwgMCk7XG4gICAgICAgICAgICAgICAgZHQuYnV0dG9uKG5vZGUpLnRleHQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wYW5lcyA9IHBhbmVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6ICdTZWFyY2ggUGFuZXMnXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIF9pbml0KHNldHRpbmdzLCBvcHRpb25zLCBmcm9tUHJlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoZnJvbVByZSA9PT0gdm9pZCAwKSB7IGZyb21QcmUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGFwaSA9IG5ldyBkYXRhVGFibGUuQXBpKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHZhciBvcHRzID0gb3B0aW9uc1xuICAgICAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgICAgIDogYXBpLmluaXQoKS5zZWFyY2hQYW5lcyB8fCBkYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoUGFuZXM7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUGFuZXMgPSBuZXcgU2VhcmNoUGFuZXMoYXBpLCBvcHRzLCBmcm9tUHJlKTtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2VhcmNoUGFuZXMuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXR0YWNoIGEgbGlzdGVuZXIgdG8gdGhlIGRvY3VtZW50IHdoaWNoIGxpc3RlbnMgZm9yIERhdGFUYWJsZXMgaW5pdGlhbGlzYXRpb25cbiAgICAgICAgLy8gZXZlbnRzIHNvIHdlIGNhbiBhdXRvbWF0aWNhbGx5IGluaXRpYWxpc2VcbiAgICAgICAgJChkb2N1bWVudCkub24oJ3ByZUluaXQuZHQuZHRzcCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuICAgICAgICAgICAgaWYgKGUubmFtZXNwYWNlICE9PSAnZHQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9Jbml0LnNlYXJjaFBhbmVzIHx8XG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaFBhbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5fc2VhcmNoUGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX2luaXQoc2V0dGluZ3MsIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERhdGFUYWJsZXMgYGRvbWAgZmVhdHVyZSBvcHRpb25cbiAgICAgICAgZGF0YVRhYmxlLmV4dC5mZWF0dXJlLnB1c2goe1xuICAgICAgICAgICAgY0ZlYXR1cmU6ICdQJyxcbiAgICAgICAgICAgIGZuSW5pdDogX2luaXRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERhdGFUYWJsZXMgMiBsYXlvdXQgZmVhdHVyZVxuICAgICAgICBpZiAoZGF0YVRhYmxlLmV4dC5mZWF0dXJlcykge1xuICAgICAgICAgICAgZGF0YVRhYmxlLmV4dC5mZWF0dXJlcy5yZWdpc3Rlcignc2VhcmNoUGFuZXMnLCBfaW5pdCk7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbn0oKSk7XG4iLCIvKiEgQm9vdHN0cmFwIDUgc3R5bGluZyB3cmFwcGVyIGZvciBTZWxlY3RcbiAqIMKpMjAyMSBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICovXG5cbihmdW5jdGlvbiggZmFjdG9yeSApe1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0LWJzNScsICdkYXRhdGFibGVzLm5ldC1zZWxlY3QnXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnM1Jykocm9vdCwgJCkuJDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQuZm4uZGF0YVRhYmxlLnNlbGVjdCApIHtcblx0XHRcdFx0cmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtc2VsZWN0Jykocm9vdCwgJCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxucmV0dXJuICQuZm4uZGF0YVRhYmxlO1xuXG59KSk7IiwiLyohIFNlbGVjdCBmb3IgRGF0YVRhYmxlcyAxLjMuM1xuICogMjAxNS0yMDIxIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIFNlbGVjdCBmb3IgRGF0YVRhYmxlc1xuICogQGRlc2NyaXB0aW9uIEEgY29sbGVjdGlvbiBvZiBBUEkgbWV0aG9kcywgZXZlbnRzIGFuZCBidXR0b25zIGZvciBEYXRhVGFibGVzXG4gKiAgIHRoYXQgcHJvdmlkZXMgc2VsZWN0aW9uIG9wdGlvbnMgb2YgdGhlIGl0ZW1zIGluIGEgRGF0YVRhYmxlXG4gKiBAdmVyc2lvbiAgICAgMS4zLjNcbiAqIEBmaWxlICAgICAgICBkYXRhVGFibGVzLnNlbGVjdC5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGQgKHd3dy5zcHJ5bWVkaWEuY28udWspXG4gKiBAY29udGFjdCAgICAgZGF0YXRhYmxlcy5uZXQvZm9ydW1zXG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMTUtMjAyMSBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZS9taXRcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxuICogV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAqIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIGxpY2Vuc2UgZmlsZXMgZm9yIGRldGFpbHMuXG4gKlxuICogRm9yIGRldGFpbHMgcGxlYXNlIHJlZmVyIHRvOiBodHRwOi8vd3d3LmRhdGF0YWJsZXMubmV0L2V4dGVuc2lvbnMvc2VsZWN0XG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApe1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0cm9vdCA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQgfHwgISAkLmZuLmRhdGFUYWJsZSApIHtcblx0XHRcdFx0JCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jykocm9vdCwgJCkuJDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHJvb3QsIHJvb3QuZG9jdW1lbnQgKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0fVxufShmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xuXG5cbi8vIFZlcnNpb24gaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2VyXG5EYXRhVGFibGUuc2VsZWN0ID0ge307XG5cbkRhdGFUYWJsZS5zZWxlY3QudmVyc2lvbiA9ICcxLjMuMyc7XG5cbkRhdGFUYWJsZS5zZWxlY3QuaW5pdCA9IGZ1bmN0aW9uICggZHQgKSB7XG5cdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHR2YXIgaW5pdCA9IGN0eC5vSW5pdC5zZWxlY3Q7XG5cdHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5zZWxlY3Q7XG5cdHZhciBvcHRzID0gaW5pdCA9PT0gdW5kZWZpbmVkID9cblx0XHRkZWZhdWx0cyA6XG5cdFx0aW5pdDtcblxuXHQvLyBTZXQgZGVmYXVsdHNcblx0dmFyIGl0ZW1zID0gJ3Jvdyc7XG5cdHZhciBzdHlsZSA9ICdhcGknO1xuXHR2YXIgYmx1cmFibGUgPSBmYWxzZTtcblx0dmFyIHRvZ2dsZWFibGUgPSB0cnVlO1xuXHR2YXIgaW5mbyA9IHRydWU7XG5cdHZhciBzZWxlY3RvciA9ICd0ZCwgdGgnO1xuXHR2YXIgY2xhc3NOYW1lID0gJ3NlbGVjdGVkJztcblx0dmFyIHNldFN0eWxlID0gZmFsc2U7XG5cblx0Y3R4Ll9zZWxlY3QgPSB7fTtcblxuXHQvLyBJbml0aWFsaXNhdGlvbiBjdXN0b21pc2F0aW9uc1xuXHRpZiAoIG9wdHMgPT09IHRydWUgKSB7XG5cdFx0c3R5bGUgPSAnb3MnO1xuXHRcdHNldFN0eWxlID0gdHJ1ZTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnICkge1xuXHRcdHN0eWxlID0gb3B0cztcblx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdH1cblx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggb3B0cyApICkge1xuXHRcdGlmICggb3B0cy5ibHVyYWJsZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ymx1cmFibGUgPSBvcHRzLmJsdXJhYmxlO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoIG9wdHMudG9nZ2xlYWJsZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dG9nZ2xlYWJsZSA9IG9wdHMudG9nZ2xlYWJsZTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMuaW5mbyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aW5mbyA9IG9wdHMuaW5mbztcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMuaXRlbXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGl0ZW1zID0gb3B0cy5pdGVtcztcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMuc3R5bGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHN0eWxlID0gb3B0cy5zdHlsZTtcblx0XHRcdHNldFN0eWxlID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzdHlsZSA9ICdvcyc7XG5cdFx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9IG9wdHMuc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2xhc3NOYW1lID0gb3B0cy5jbGFzc05hbWU7XG5cdFx0fVxuXHR9XG5cblx0ZHQuc2VsZWN0LnNlbGVjdG9yKCBzZWxlY3RvciApO1xuXHRkdC5zZWxlY3QuaXRlbXMoIGl0ZW1zICk7XG5cdGR0LnNlbGVjdC5zdHlsZSggc3R5bGUgKTtcblx0ZHQuc2VsZWN0LmJsdXJhYmxlKCBibHVyYWJsZSApO1xuXHRkdC5zZWxlY3QudG9nZ2xlYWJsZSggdG9nZ2xlYWJsZSApO1xuXHRkdC5zZWxlY3QuaW5mbyggaW5mbyApO1xuXHRjdHguX3NlbGVjdC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cblxuXHQvLyBTb3J0IHRhYmxlIGJhc2VkIG9uIHNlbGVjdGVkIHJvd3MuIFJlcXVpcmVzIFNlbGVjdCBEYXRhdGFibGVzIGV4dGVuc2lvblxuXHQkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ3NlbGVjdC1jaGVja2JveCddID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sICkge1xuXHRcdHJldHVybiB0aGlzLmFwaSgpLmNvbHVtbiggY29sLCB7b3JkZXI6ICdpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQgKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzLl9zZWxlY3QuaXRlbXMgPT09ICdyb3cnICkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGQgKS5wYXJlbnQoKS5oYXNDbGFzcyggc2V0dGluZ3MuX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHNldHRpbmdzLl9zZWxlY3QuaXRlbXMgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0cmV0dXJuICQoIHRkICkuaGFzQ2xhc3MoIHNldHRpbmdzLl9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSk7XG5cdH07XG5cblx0Ly8gSWYgdGhlIGluaXQgb3B0aW9ucyBoYXZlbid0IGVuYWJsZWQgc2VsZWN0LCBidXQgdGhlcmUgaXMgYSBzZWxlY3RhYmxlXG5cdC8vIGNsYXNzIG5hbWUsIHRoZW4gZW5hYmxlXG5cdGlmICggISBzZXRTdHlsZSAmJiAkKCBkdC50YWJsZSgpLm5vZGUoKSApLmhhc0NsYXNzKCAnc2VsZWN0YWJsZScgKSApIHtcblx0XHRkdC5zZWxlY3Quc3R5bGUoICdvcycgKTtcblx0fVxufTtcblxuLypcblxuU2VsZWN0IGlzIGEgY29sbGVjdGlvbiBvZiBBUEkgbWV0aG9kcywgZXZlbnQgaGFuZGxlcnMsIGV2ZW50IGVtaXR0ZXJzIGFuZFxuYnV0dG9ucyAoZm9yIHRoZSBgQnV0dG9uc2AgZXh0ZW5zaW9uKSBmb3IgRGF0YVRhYmxlcy4gSXQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZ1xuZmVhdHVyZXMsIHdpdGggYW4gb3ZlcnZpZXcgb2YgaG93IHRoZXkgYXJlIGltcGxlbWVudGVkOlxuXG4jIyBTZWxlY3Rpb24gb2Ygcm93cywgY29sdW1ucyBhbmQgY2VsbHMuIFdoZXRoZXIgYW4gaXRlbSBpcyBzZWxlY3RlZCBvciBub3QgaXNcbiAgIHN0b3JlZCBpbjpcblxuKiByb3dzOiBhIGBfc2VsZWN0X3NlbGVjdGVkYCBwcm9wZXJ0eSB3aGljaCBjb250YWlucyBhIGJvb2xlYW4gdmFsdWUgb2YgdGhlXG4gIERhdGFUYWJsZXMnIGBhb0RhdGFgIG9iamVjdCBmb3IgZWFjaCByb3dcbiogY29sdW1uczogYSBgX3NlbGVjdF9zZWxlY3RlZGAgcHJvcGVydHkgd2hpY2ggY29udGFpbnMgYSBib29sZWFuIHZhbHVlIG9mIHRoZVxuICBEYXRhVGFibGVzJyBgYW9Db2x1bW5zYCBvYmplY3QgZm9yIGVhY2ggY29sdW1uXG4qIGNlbGxzOiBhIGBfc2VsZWN0ZWRfY2VsbHNgIHByb3BlcnR5IHdoaWNoIGNvbnRhaW5zIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzXG4gIG9mIHRoZSBgYW9EYXRhYCBvYmplY3QgZm9yIGVhY2ggcm93LiBUaGUgYXJyYXkgaXMgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuICBjb2x1bW5zIGFycmF5LCB3aXRoIGVhY2ggZWxlbWVudCBvZiBpdCByZXByZXNlbnRpbmcgYSBjZWxsLlxuXG5UaGlzIG1ldGhvZCBvZiB1c2luZyBib29sZWFuIGZsYWdzIGFsbG93cyBTZWxlY3QgdG8gb3BlcmF0ZSB3aGVuIG5vZGVzIGhhdmUgbm90XG5iZWVuIGNyZWF0ZWQgZm9yIHJvd3MgLyBjZWxscyAoRGF0YVRhYmxlcycgZGVmZXIgcmVuZGVyaW5nIGZlYXR1cmUpLlxuXG4jIyBBUEkgbWV0aG9kc1xuXG5BIHJhbmdlIG9mIEFQSSBtZXRob2RzIGFyZSBhdmFpbGFibGUgZm9yIHRyaWdnZXJpbmcgc2VsZWN0aW9uIGFuZCBkZS1zZWxlY3Rpb25cbm9mIHJvd3MuIE1ldGhvZHMgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGNvbmZpZ3VyZSB0aGUgc2VsZWN0aW9uIGV2ZW50cyB0aGF0IGNhblxuYmUgdHJpZ2dlcmVkIGJ5IGFuIGVuZCB1c2VyIChzdWNoIGFzIHdoaWNoIGl0ZW1zIGFyZSB0byBiZSBzZWxlY3RlZCkuIFRvIGEgbGFyZ2VcbmV4dGVudCwgdGhlc2Ugb2YgQVBJIG1ldGhvZHMgKmlzKiBTZWxlY3QuIEl0IGlzIGJhc2ljYWxseSBhIGNvbGxlY3Rpb24gb2YgaGVscGVyXG5mdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBzZWxlY3QgaXRlbXMgaW4gYSBEYXRhVGFibGUuXG5cbkNvbmZpZ3VyYXRpb24gb2Ygc2VsZWN0IGlzIGhlbGQgaW4gdGhlIG9iamVjdCBgX3NlbGVjdGAgd2hpY2ggaXMgYXR0YWNoZWQgdG8gdGhlXG5EYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBvbiBpbml0aWFsaXNhdGlvbi4gU2VsZWN0IGJlaW5nIGF2YWlsYWJsZSBvbiBhIHRhYmxlXG5pcyBub3Qgb3B0aW9uYWwgd2hlbiBTZWxlY3QgaXMgbG9hZGVkLCBidXQgaXRzIGRlZmF1bHQgaXMgZm9yIHNlbGVjdGlvbiBvbmx5IHRvXG5iZSBhdmFpbGFibGUgdmlhIHRoZSBBUEkgLSBzbyB0aGUgZW5kIHVzZXIgd291bGRuJ3QgYmUgYWJsZSB0byBzZWxlY3Qgcm93c1xud2l0aG91dCBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24uXG5cblRoZSBgX3NlbGVjdGAgb2JqZWN0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblxuYGBgXG57XG5cdGl0ZW1zOnN0cmluZyAgICAgICAtIENhbiBiZSBgcm93c2AsIGBjb2x1bW5zYCBvciBgY2VsbHNgLiBEZWZpbmVzIHdoYXQgaXRlbSBcblx0ICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBzZWxlY3RlZCBpZiB0aGUgdXNlciBpcyBhbGxvd2VkIHRvIGFjdGl2YXRlIHJvd1xuXHQgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gdXNpbmcgdGhlIG1vdXNlLlxuXHRzdHlsZTpzdHJpbmcgICAgICAgLSBDYW4gYmUgYG5vbmVgLCBgc2luZ2xlYCwgYG11bHRpYCBvciBgb3NgLiBEZWZpbmVzIHRoZVxuXHQgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiBzdHlsZSB3aGVuIHNlbGVjdGluZyBpdGVtc1xuXHRibHVyYWJsZTpib29sZWFuICAgLSBJZiByb3cgc2VsZWN0aW9uIGNhbiBiZSBjbGVhcmVkIGJ5IGNsaWNraW5nIG91dHNpZGUgb2Zcblx0ICAgICAgICAgICAgICAgICAgICAgdGhlIHRhYmxlXG5cdHRvZ2dsZWFibGU6Ym9vbGVhbiAtIElmIHJvdyBzZWxlY3Rpb24gY2FuIGJlIGNhbmNlbGxlZCBieSByZXBlYXRlZCBjbGlja2luZ1xuXHQgICAgICAgICAgICAgICAgICAgICBvbiB0aGUgcm93XG5cdGluZm86Ym9vbGVhbiAgICAgICAtIElmIHRoZSBzZWxlY3Rpb24gc3VtbWFyeSBzaG91bGQgYmUgc2hvd24gaW4gdGhlIHRhYmxlXG5cdCAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIGVsZW1lbnRzXG59XG5gYGBcblxuSW4gYWRkaXRpb24gdG8gdGhlIEFQSSBtZXRob2RzLCBTZWxlY3QgYWxzbyBleHRlbmRzIHRoZSBEYXRhVGFibGVzIHNlbGVjdG9yXG5vcHRpb25zIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBhZGRpbmcgYSBgc2VsZWN0ZWRgIG9wdGlvbiB0byB0aGUgc2VsZWN0b3Jcbm9wdGlvbnMgb2JqZWN0LCBhbGxvd2luZyB0aGUgZGV2ZWxvcGVyIHRvIHNlbGVjdCBvbmx5IHNlbGVjdGVkIGl0ZW1zIG9yXG51bnNlbGVjdGVkIGl0ZW1zLlxuXG4jIyBNb3VzZSBzZWxlY3Rpb24gb2YgaXRlbXNcblxuQ2xpY2tpbmcgb24gaXRlbXMgY2FuIGJlIHVzZWQgdG8gc2VsZWN0IGl0ZW1zLiBUaGlzIGlzIGRvbmUgYnkgYSBzaW1wbGUgZXZlbnRcbmhhbmRsZXIgdGhhdCB3aWxsIHNlbGVjdCB0aGUgaXRlbXMgdXNpbmcgdGhlIEFQSSBtZXRob2RzLlxuXG4gKi9cblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogTG9jYWwgZnVuY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBBZGQgb25lIG9yIG1vcmUgY2VsbHMgdG8gdGhlIHNlbGVjdGlvbiB3aGVuIHNoaWZ0IGNsaWNraW5nIGluIE9TIHNlbGVjdGlvblxuICogc3R5bGUgY2VsbCBzZWxlY3Rpb24uXG4gKlxuICogQ2VsbCByYW5nZSBpcyBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gcm93IGFuZCBjb2x1bW4gYXMgd2Ugd2FudCB0byBzZWxlY3RcbiAqIGluIHRoZSB2aXNpYmxlIGdyaWQgcmF0aGVyIHRoYW4gYnkgaW5kZXggaW4gc2VxdWVuY2UuIEZvciBleGFtcGxlLCBpZiB5b3VcbiAqIGNsaWNrIGZpcnN0IGluIGNlbGwgMS0xIGFuZCB0aGVuIHNoaWZ0IGNsaWNrIGluIDItMiAtIGNlbGxzIDEtMiBhbmQgMi0xXG4gKiBzaG91bGQgYWxzbyBiZSBzZWxlY3RlZCAoYW5kIG5vdCAxLTMsIDEtNC4gZXRjKVxuICogXG4gKiBAcGFyYW0gIHtEYXRhVGFibGUuQXBpfSBkdCAgIERhdGFUYWJsZVxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgaWR4ICBDZWxsIGluZGV4IHRvIHNlbGVjdCB0b1xuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgbGFzdCBDZWxsIGluZGV4IHRvIHNlbGVjdCBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjZWxsUmFuZ2UoIGR0LCBpZHgsIGxhc3QgKVxue1xuXHR2YXIgaW5kZXhlcztcblx0dmFyIGNvbHVtbkluZGV4ZXM7XG5cdHZhciByb3dJbmRleGVzO1xuXHR2YXIgc2VsZWN0Q29sdW1ucyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblx0XHRpZiAoIHN0YXJ0ID4gZW5kICkge1xuXHRcdFx0dmFyIHRtcCA9IGVuZDtcblx0XHRcdGVuZCA9IHN0YXJ0O1xuXHRcdFx0c3RhcnQgPSB0bXA7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciByZWNvcmQgPSBmYWxzZTtcblx0XHRyZXR1cm4gZHQuY29sdW1ucyggJzp2aXNpYmxlJyApLmluZGV4ZXMoKS5maWx0ZXIoIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZiAoIGkgPT09IHN0YXJ0ICkge1xuXHRcdFx0XHRyZWNvcmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIGkgPT09IGVuZCApIHsgLy8gbm90IGVsc2UgaWYsIGFzIHN0YXJ0IG1pZ2h0ID09PSBlbmRcblx0XHRcdFx0cmVjb3JkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVjb3JkO1xuXHRcdH0gKTtcblx0fTtcblxuXHR2YXIgc2VsZWN0Um93cyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblx0XHR2YXIgaW5kZXhlcyA9IGR0LnJvd3MoIHsgc2VhcmNoOiAnYXBwbGllZCcgfSApLmluZGV4ZXMoKTtcblxuXHRcdC8vIFdoaWNoIGNvbWVzIGZpcnN0IC0gbWlnaHQgbmVlZCB0byBzd2FwXG5cdFx0aWYgKCBpbmRleGVzLmluZGV4T2YoIHN0YXJ0ICkgPiBpbmRleGVzLmluZGV4T2YoIGVuZCApICkge1xuXHRcdFx0dmFyIHRtcCA9IGVuZDtcblx0XHRcdGVuZCA9IHN0YXJ0O1xuXHRcdFx0c3RhcnQgPSB0bXA7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY29yZCA9IGZhbHNlO1xuXHRcdHJldHVybiBpbmRleGVzLmZpbHRlciggZnVuY3Rpb24gKGkpIHtcblx0XHRcdGlmICggaSA9PT0gc3RhcnQgKSB7XG5cdFx0XHRcdHJlY29yZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggaSA9PT0gZW5kICkge1xuXHRcdFx0XHRyZWNvcmQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWNvcmQ7XG5cdFx0fSApO1xuXHR9O1xuXG5cdGlmICggISBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgJiYgISBsYXN0ICkge1xuXHRcdC8vIHNlbGVjdCBmcm9tIHRoZSB0b3AgbGVmdCBjZWxsIHRvIHRoaXMgb25lXG5cdFx0Y29sdW1uSW5kZXhlcyA9IHNlbGVjdENvbHVtbnMoIDAsIGlkeC5jb2x1bW4gKTtcblx0XHRyb3dJbmRleGVzID0gc2VsZWN0Um93cyggMCAsIGlkeC5yb3cgKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHZXQgY29sdW1uIGluZGV4ZXMgYmV0d2VlbiBvbGQgYW5kIG5ld1xuXHRcdGNvbHVtbkluZGV4ZXMgPSBzZWxlY3RDb2x1bW5zKCBsYXN0LmNvbHVtbiwgaWR4LmNvbHVtbiApO1xuXHRcdHJvd0luZGV4ZXMgPSBzZWxlY3RSb3dzKCBsYXN0LnJvdyAsIGlkeC5yb3cgKTtcblx0fVxuXG5cdGluZGV4ZXMgPSBkdC5jZWxscyggcm93SW5kZXhlcywgY29sdW1uSW5kZXhlcyApLmZsYXR0ZW4oKTtcblxuXHRpZiAoICEgZHQuY2VsbHMoIGlkeCwgeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0Ly8gU2VsZWN0IHJhbmdlXG5cdFx0ZHQuY2VsbHMoIGluZGV4ZXMgKS5zZWxlY3QoKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBEZXNlbGVjdCByYW5nZVxuXHRcdGR0LmNlbGxzKCBpbmRleGVzICkuZGVzZWxlY3QoKTtcblx0fVxufVxuXG4vKipcbiAqIERpc2FibGUgbW91c2Ugc2VsZWN0aW9uIGJ5IHJlbW92aW5nIHRoZSBzZWxlY3RvcnNcbiAqXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGR0IERhdGFUYWJsZSB0byByZW1vdmUgZXZlbnRzIGZyb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVNb3VzZVNlbGVjdGlvbiggZHQgKVxue1xuXHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblx0dmFyIHNlbGVjdG9yID0gY3R4Ll9zZWxlY3Quc2VsZWN0b3I7XG5cblx0JCggZHQudGFibGUoKS5jb250YWluZXIoKSApXG5cdFx0Lm9mZiggJ21vdXNlZG93bi5kdFNlbGVjdCcsIHNlbGVjdG9yIClcblx0XHQub2ZmKCAnbW91c2V1cC5kdFNlbGVjdCcsIHNlbGVjdG9yIClcblx0XHQub2ZmKCAnY2xpY2suZHRTZWxlY3QnLCBzZWxlY3RvciApO1xuXG5cdCQoJ2JvZHknKS5vZmYoICdjbGljay5kdFNlbGVjdCcgKyBfc2FmZUlkKGR0LnRhYmxlKCkubm9kZSgpKSApO1xufVxuXG4vKipcbiAqIEF0dGFjaCBtb3VzZSBsaXN0ZW5lcnMgdG8gdGhlIHRhYmxlIHRvIGFsbG93IG1vdXNlIHNlbGVjdGlvbiBvZiBpdGVtc1xuICpcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gZHQgRGF0YVRhYmxlIHRvIHJlbW92ZSBldmVudHMgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlTW91c2VTZWxlY3Rpb24gKCBkdCApXG57XG5cdHZhciBjb250YWluZXIgPSAkKCBkdC50YWJsZSgpLmNvbnRhaW5lcigpICk7XG5cdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHR2YXIgc2VsZWN0b3IgPSBjdHguX3NlbGVjdC5zZWxlY3Rvcjtcblx0dmFyIG1hdGNoU2VsZWN0aW9uO1xuXG5cdGNvbnRhaW5lclxuXHRcdC5vbiggJ21vdXNlZG93bi5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBEaXNhbGxvdyB0ZXh0IHNlbGVjdGlvbiBmb3Igc2hpZnQgY2xpY2tpbmcgb24gdGhlIHRhYmxlIHNvIG11bHRpXG5cdFx0XHQvLyBlbGVtZW50IHNlbGVjdGlvbiBkb2Vzbid0IGxvb2sgdGVycmlibGUhXG5cdFx0XHRpZiAoIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleSApIHtcblx0XHRcdFx0Y29udGFpbmVyXG5cdFx0XHRcdFx0LmNzcyggJy1tb3otdXNlci1zZWxlY3QnLCAnbm9uZScgKVxuXHRcdFx0XHRcdC5vbmUoJ3NlbGVjdHN0YXJ0LmR0U2VsZWN0Jywgc2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luZG93LmdldFNlbGVjdGlvbiApIHtcblx0XHRcdFx0bWF0Y2hTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fSApXG5cdFx0Lm9uKCAnbW91c2V1cC5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIEFsbG93IHRleHQgc2VsZWN0aW9uIHRvIG9jY3VyIGFnYWluLCBNb3ppbGxhIHN0eWxlICh0ZXN0ZWQgaW4gRkZcblx0XHRcdC8vIDM1LjAuMSAtIHN0aWxsIHJlcXVpcmVkKVxuXHRcdFx0Y29udGFpbmVyLmNzcyggJy1tb3otdXNlci1zZWxlY3QnLCAnJyApO1xuXHRcdH0gKVxuXHRcdC5vbiggJ2NsaWNrLmR0U2VsZWN0Jywgc2VsZWN0b3IsIGZ1bmN0aW9uICggZSApIHtcblx0XHRcdHZhciBpdGVtcyA9IGR0LnNlbGVjdC5pdGVtcygpO1xuXHRcdFx0dmFyIGlkeDtcblxuXHRcdFx0Ly8gSWYgdGV4dCB3YXMgc2VsZWN0ZWQgKGNsaWNrIGFuZCBkcmFnKSwgdGhlbiB3ZSBzaG91bGRuJ3QgY2hhbmdlXG5cdFx0XHQvLyB0aGUgcm93J3Mgc2VsZWN0ZWQgc3RhdGVcblx0XHRcdGlmICggbWF0Y2hTZWxlY3Rpb24gKSB7XG5cdFx0XHRcdHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgc2VsZWN0aW9uIGlzIG5vdCBpbiB0aGUgdGFibGUsIHdlIGNhbiBpZ25vcmUgaXRcblx0XHRcdFx0Ly8gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBkZXZlbG9wZXIgc2VsZWN0cyB0ZXh0IGZyb20gdGhlIGNsaWNrIGV2ZW50XG5cdFx0XHRcdGlmICggISBzZWxlY3Rpb24uYW5jaG9yTm9kZSB8fCAkKHNlbGVjdGlvbi5hbmNob3JOb2RlKS5jbG9zZXN0KCd0YWJsZScpWzBdID09PSBkdC50YWJsZSgpLm5vZGUoKSApIHtcblx0XHRcdFx0XHRpZiAoIHNlbGVjdGlvbiAhPT0gbWF0Y2hTZWxlY3Rpb24gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHRcdFx0dmFyIHdyYXBwZXJDbGFzcyA9IGR0LnNldHRpbmdzKClbMF0ub0NsYXNzZXMuc1dyYXBwZXIudHJpbSgpLnJlcGxhY2UoLyArL2csICcuJyk7XG5cblx0XHRcdC8vIElnbm9yZSBjbGlja3MgaW5zaWRlIGEgc3ViLXRhYmxlXG5cdFx0XHRpZiAoICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2Rpdi4nK3dyYXBwZXJDbGFzcylbMF0gIT0gZHQudGFibGUoKS5jb250YWluZXIoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2VsbCA9IGR0LmNlbGwoICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3RkLCB0aCcpICk7XG5cblx0XHRcdC8vIENoZWNrIHRoZSBjZWxsIGFjdHVhbGx5IGJlbG9uZ3MgdG8gdGhlIGhvc3QgRGF0YVRhYmxlIChzbyBjaGlsZFxuXHRcdFx0Ly8gcm93cywgZXRjLCBhcmUgaWdub3JlZClcblx0XHRcdGlmICggISBjZWxsLmFueSgpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBldmVudCA9ICQuRXZlbnQoJ3VzZXItc2VsZWN0LmR0Jyk7XG5cdFx0XHRldmVudFRyaWdnZXIoIGR0LCBldmVudCwgWyBpdGVtcywgY2VsbCwgZSBdICk7XG5cblx0XHRcdGlmICggZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNlbGxJbmRleCA9IGNlbGwuaW5kZXgoKTtcblx0XHRcdGlmICggaXRlbXMgPT09ICdyb3cnICkge1xuXHRcdFx0XHRpZHggPSBjZWxsSW5kZXgucm93O1xuXHRcdFx0XHR0eXBlU2VsZWN0KCBlLCBkdCwgY3R4LCAncm93JywgaWR4ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaXRlbXMgPT09ICdjb2x1bW4nICkge1xuXHRcdFx0XHRpZHggPSBjZWxsLmluZGV4KCkuY29sdW1uO1xuXHRcdFx0XHR0eXBlU2VsZWN0KCBlLCBkdCwgY3R4LCAnY29sdW1uJywgaWR4ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaXRlbXMgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0aWR4ID0gY2VsbC5pbmRleCgpO1xuXHRcdFx0XHR0eXBlU2VsZWN0KCBlLCBkdCwgY3R4LCAnY2VsbCcsIGlkeCApO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbCA9IGNlbGxJbmRleDtcblx0XHR9ICk7XG5cblx0Ly8gQmx1cmFibGVcblx0JCgnYm9keScpLm9uKCAnY2xpY2suZHRTZWxlY3QnICsgX3NhZmVJZChkdC50YWJsZSgpLm5vZGUoKSksIGZ1bmN0aW9uICggZSApIHtcblx0XHRpZiAoIGN0eC5fc2VsZWN0LmJsdXJhYmxlICkge1xuXHRcdFx0Ly8gSWYgdGhlIGNsaWNrIHdhcyBpbnNpZGUgdGhlIERhdGFUYWJsZXMgY29udGFpbmVyLCBkb24ndCBibHVyXG5cdFx0XHRpZiAoICQoZS50YXJnZXQpLnBhcmVudHMoKS5maWx0ZXIoIGR0LnRhYmxlKCkuY29udGFpbmVyKCkgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWdub3JlIGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIERPTSAoaS5lLiBwYWdpbmdcblx0XHRcdC8vIGJ1dHRvbnMpXG5cdFx0XHRpZiAoICQoZS50YXJnZXQpLnBhcmVudHMoJ2h0bWwnKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHQgXHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIERvbid0IGJsdXIgaW4gRWRpdG9yIGZvcm1cblx0XHRcdGlmICggJChlLnRhcmdldCkucGFyZW50cygnZGl2LkRURScpLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGVhciggY3R4LCB0cnVlICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBvbiBhIERhdGFUYWJsZVxuICpcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gYXBpICAgICAgRGF0YVRhYmxlIHRvIHRyaWdnZXIgZXZlbnRzIG9uXG4gKiBAcGFyYW0gIHtib29sZWFufSAgICAgIHNlbGVjdGVkIHRydWUgaWYgc2VsZWN0ZWQsIGZhbHNlIGlmIGRlc2VsZWN0ZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgdHlwZSAgICAgSXRlbSB0eXBlIGFjdGluZyBvblxuICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBhbnkgICAgICBSZXF1aXJlIHRoYXQgdGhlcmUgYXJlIHZhbHVlcyBiZWZvcmVcbiAqICAgICB0cmlnZ2VyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFRyaWdnZXIgKCBhcGksIHR5cGUsIGFyZ3MsIGFueSApXG57XG5cdGlmICggYW55ICYmICEgYXBpLmZsYXR0ZW4oKS5sZW5ndGggKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0dHlwZSA9IHR5cGUgKycuZHQnO1xuXHR9XG5cblx0YXJncy51bnNoaWZ0KCBhcGkgKTtcblxuXHQkKGFwaS50YWJsZSgpLm5vZGUoKSkudHJpZ2dlciggdHlwZSwgYXJncyApO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBvZiB0aGUgRGF0YVRhYmxlIHNob3dpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBpdGVtcyBzZWxlY3RlZC4gVGhpcyBpcyBkb25lIGJ5IGFkZGluZyB0YWdzIHRvIHRoZSBleGlzdGluZyB0ZXh0XG4gKiBcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gYXBpIERhdGFUYWJsZSB0byB1cGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZm8gKCBhcGkgKVxue1xuXHR2YXIgY3R4ID0gYXBpLnNldHRpbmdzKClbMF07XG5cblx0aWYgKCAhIGN0eC5fc2VsZWN0LmluZm8gfHwgISBjdHguYWFuRmVhdHVyZXMuaSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIGFwaS5zZWxlY3Quc3R5bGUoKSA9PT0gJ2FwaScgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJvd3MgICAgPSBhcGkucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblx0dmFyIGNvbHVtbnMgPSBhcGkuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblx0dmFyIGNlbGxzICAgPSBhcGkuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cblx0dmFyIGFkZCA9IGZ1bmN0aW9uICggZWwsIG5hbWUsIG51bSApIHtcblx0XHRlbC5hcHBlbmQoICQoJzxzcGFuIGNsYXNzPVwic2VsZWN0LWl0ZW1cIi8+JykuYXBwZW5kKCBhcGkuaTE4bihcblx0XHRcdCdzZWxlY3QuJytuYW1lKydzJyxcblx0XHRcdHsgXzogJyVkICcrbmFtZSsncyBzZWxlY3RlZCcsIDA6ICcnLCAxOiAnMSAnK25hbWUrJyBzZWxlY3RlZCcgfSxcblx0XHRcdG51bVxuXHRcdCkgKSApO1xuXHR9O1xuXG5cdC8vIEludGVybmFsIGtub3dsZWRnZSBvZiBEYXRhVGFibGVzIHRvIGxvb3Agb3ZlciBhbGwgaW5mb3JtYXRpb24gZWxlbWVudHNcblx0JC5lYWNoKCBjdHguYWFuRmVhdHVyZXMuaSwgZnVuY3Rpb24gKCBpLCBlbCApIHtcblx0XHRlbCA9ICQoZWwpO1xuXG5cdFx0dmFyIG91dHB1dCAgPSAkKCc8c3BhbiBjbGFzcz1cInNlbGVjdC1pbmZvXCIvPicpO1xuXHRcdGFkZCggb3V0cHV0LCAncm93Jywgcm93cyApO1xuXHRcdGFkZCggb3V0cHV0LCAnY29sdW1uJywgY29sdW1ucyApO1xuXHRcdGFkZCggb3V0cHV0LCAnY2VsbCcsIGNlbGxzICApO1xuXG5cdFx0dmFyIGV4aXNpdGluZyA9IGVsLmNoaWxkcmVuKCdzcGFuLnNlbGVjdC1pbmZvJyk7XG5cdFx0aWYgKCBleGlzaXRpbmcubGVuZ3RoICkge1xuXHRcdFx0ZXhpc2l0aW5nLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGlmICggb3V0cHV0LnRleHQoKSAhPT0gJycgKSB7XG5cdFx0XHRlbC5hcHBlbmQoIG91dHB1dCApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIEluaXRpYWxpc2F0aW9uIG9mIGEgbmV3IHRhYmxlLiBBdHRhY2ggZXZlbnQgaGFuZGxlcnMgYW5kIGNhbGxiYWNrcyB0byBhbGxvd1xuICogU2VsZWN0IHRvIG9wZXJhdGUgY29ycmVjdGx5LlxuICpcbiAqIFRoaXMgd2lsbCBvY2N1ciBfYWZ0ZXJfIHRoZSBpbml0aWFsIERhdGFUYWJsZXMgaW5pdGlhbGlzYXRpb24sIGFsdGhvdWdoXG4gKiBiZWZvcmUgQWpheCBkYXRhIGlzIHJlbmRlcmVkLCBpZiB0aGVyZSBpcyBhamF4IGRhdGFcbiAqXG4gKiBAcGFyYW0gIHtEYXRhVGFibGUuc2V0dGluZ3N9IGN0eCBTZXR0aW5ncyBvYmplY3QgdG8gb3BlcmF0ZSBvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdCAoIGN0eCApIHtcblx0dmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKTtcblxuXHQvLyBSb3cgY2FsbGJhY2sgc28gdGhhdCBjbGFzc2VzIGNhbiBiZSBhZGRlZCB0byByb3dzIGFuZCBjZWxscyBpZiB0aGUgaXRlbVxuXHQvLyB3YXMgc2VsZWN0ZWQgYmVmb3JlIHRoZSBlbGVtZW50IHdhcyBjcmVhdGVkLiBUaGlzIHdpbGwgaGFwcGVuIHdpdGggdGhlXG5cdC8vIGBkZWZlclJlbmRlcmAgb3B0aW9uIGVuYWJsZWQuXG5cdC8vIFxuXHQvLyBUaGlzIG1ldGhvZCBvZiBhdHRhY2hpbmcgdG8gYGFvUm93Q3JlYXRlZENhbGxiYWNrYCBpcyBhIGhhY2sgdW50aWxcblx0Ly8gRGF0YVRhYmxlcyBoYXMgcHJvcGVyIGV2ZW50cyBmb3Igcm93IG1hbmlwdWxhdGlvbiBJZiB5b3UgYXJlIHJldmlld2luZ1xuXHQvLyB0aGlzIGNvZGUgdG8gY3JlYXRlIHlvdXIgb3duIHBsdWctaW5zLCBwbGVhc2UgZG8gbm90IGRvIHRoaXMhXG5cdGN0eC5hb1Jvd0NyZWF0ZWRDYWxsYmFjay5wdXNoKCB7XG5cdFx0Zm46IGZ1bmN0aW9uICggcm93LCBkYXRhLCBpbmRleCApIHtcblx0XHRcdHZhciBpLCBpZW47XG5cdFx0XHR2YXIgZCA9IGN0eC5hb0RhdGFbIGluZGV4IF07XG5cblx0XHRcdC8vIFJvd1xuXHRcdFx0aWYgKCBkLl9zZWxlY3Rfc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdCQoIHJvdyApLmFkZENsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2VsbHMgYW5kIGNvbHVtbnMgLSBpZiBzZXBhcmF0ZWQgb3V0LCB3ZSB3b3VsZCBuZWVkIHRvIGRvIHR3b1xuXHRcdFx0Ly8gbG9vcHMsIHNvIGl0IG1ha2VzIHNlbnNlIHRvIGNvbWJpbmUgdGhlbSBpbnRvIGEgc2luZ2xlIG9uZVxuXHRcdFx0Zm9yICggaT0wLCBpZW49Y3R4LmFvQ29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjdHguYW9Db2x1bW5zW2ldLl9zZWxlY3Rfc2VsZWN0ZWQgfHwgKGQuX3NlbGVjdGVkX2NlbGxzICYmIGQuX3NlbGVjdGVkX2NlbGxzW2ldKSApIHtcblx0XHRcdFx0XHQkKGQuYW5DZWxsc1tpXSkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzTmFtZTogJ3NlbGVjdC1kZWZlclJlbmRlcidcblx0fSApO1xuXG5cdC8vIE9uIEFqYXggcmVsb2FkIHdlIHdhbnQgdG8gcmVzZWxlY3QgYWxsIHJvd3Mgd2hpY2ggYXJlIGN1cnJlbnRseSBzZWxlY3RlZCxcblx0Ly8gaWYgdGhlcmUgaXMgYW4gcm93SWQgKGkuZS4gYSB1bmlxdWUgdmFsdWUgdG8gaWRlbnRpZnkgZWFjaCByb3cgd2l0aClcblx0YXBpLm9uKCAncHJlWGhyLmR0LmR0U2VsZWN0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzKSB7XG5cdFx0aWYgKHNldHRpbmdzICE9PSBhcGkuc2V0dGluZ3MoKVswXSkge1xuXHRcdFx0Ly8gTm90IHRyaWdnZXJlZCBieSBvdXIgRGF0YVRhYmxlIVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG5vdGUgdGhhdCBjb2x1bW4gc2VsZWN0aW9uIGRvZXNuJ3QgbmVlZCB0byBiZSBjYWNoZWQgYW5kIHRoZW5cblx0XHQvLyByZXNlbGVjdGVkLCBhcyB0aGV5IGFyZSBhbHJlYWR5IHNlbGVjdGVkXG5cdFx0dmFyIHJvd3MgPSBhcGkucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuaWRzKCB0cnVlICkuZmlsdGVyKCBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRyZXR1cm4gZCAhPT0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdHZhciBjZWxscyA9IGFwaS5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZXEoMCkubWFwKCBmdW5jdGlvbiAoIGNlbGxJZHggKSB7XG5cdFx0XHR2YXIgaWQgPSBhcGkucm93KCBjZWxsSWR4LnJvdyApLmlkKCB0cnVlICk7XG5cdFx0XHRyZXR1cm4gaWQgP1xuXHRcdFx0XHR7IHJvdzogaWQsIGNvbHVtbjogY2VsbElkeC5jb2x1bW4gfSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9ICkuZmlsdGVyKCBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRyZXR1cm4gZCAhPT0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIE9uIHRoZSBuZXh0IGRyYXcsIHJlc2VsZWN0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXNcblx0XHRhcGkub25lKCAnZHJhdy5kdC5kdFNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGFwaS5yb3dzKCByb3dzICkuc2VsZWN0KCk7XG5cblx0XHRcdC8vIGBjZWxsc2AgaXMgbm90IGEgY2VsbCBpbmRleCBzZWxlY3Rvciwgc28gaXQgbmVlZHMgYSBsb29wXG5cdFx0XHRpZiAoIGNlbGxzLmFueSgpICkge1xuXHRcdFx0XHRjZWxscy5lYWNoKCBmdW5jdGlvbiAoIGlkICkge1xuXHRcdFx0XHRcdGFwaS5jZWxscyggaWQucm93LCBpZC5jb2x1bW4gKS5zZWxlY3QoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xuXG5cdC8vIFVwZGF0ZSB0aGUgdGFibGUgaW5mb3JtYXRpb24gZWxlbWVudCB3aXRoIHNlbGVjdGVkIGl0ZW0gc3VtbWFyeVxuXHRhcGkub24oICdkcmF3LmR0U2VsZWN0LmR0IHNlbGVjdC5kdFNlbGVjdC5kdCBkZXNlbGVjdC5kdFNlbGVjdC5kdCBpbmZvLmR0JywgZnVuY3Rpb24gKCkge1xuXHRcdGluZm8oIGFwaSApO1xuXHR9ICk7XG5cblx0Ly8gQ2xlYW4gdXAgYW5kIHJlbGVhc2Vcblx0YXBpLm9uKCAnZGVzdHJveS5kdFNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcblx0XHRhcGkucm93cyh7c2VsZWN0ZWQ6IHRydWV9KS5kZXNlbGVjdCgpO1xuXG5cdFx0ZGlzYWJsZU1vdXNlU2VsZWN0aW9uKCBhcGkgKTtcblx0XHRhcGkub2ZmKCAnLmR0U2VsZWN0JyApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGl0ZW1zIChyb3dzIG9yIGNvbHVtbnMpIHRvIHRoZSBzZWxlY3Rpb24gd2hlbiBzaGlmdCBjbGlja2luZ1xuICogaW4gT1Mgc2VsZWN0aW9uIHN0eWxlXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLkFwaX0gZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgIHR5cGUgUm93IG9yIGNvbHVtbiByYW5nZSBzZWxlY3RvclxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgaWR4ICBJdGVtIGluZGV4IHRvIHNlbGVjdCB0b1xuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgbGFzdCBJdGVtIGluZGV4IHRvIHNlbGVjdCBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByb3dDb2x1bW5SYW5nZSggZHQsIHR5cGUsIGlkeCwgbGFzdCApXG57XG5cdC8vIEFkZCBhIHJhbmdlIG9mIHJvd3MgZnJvbSB0aGUgbGFzdCBzZWxlY3RlZCByb3cgdG8gdGhpcyBvbmVcblx0dmFyIGluZGV4ZXMgPSBkdFt0eXBlKydzJ10oIHsgc2VhcmNoOiAnYXBwbGllZCcgfSApLmluZGV4ZXMoKTtcblx0dmFyIGlkeDEgPSAkLmluQXJyYXkoIGxhc3QsIGluZGV4ZXMgKTtcblx0dmFyIGlkeDIgPSAkLmluQXJyYXkoIGlkeCwgaW5kZXhlcyApO1xuXG5cdGlmICggISBkdFt0eXBlKydzJ10oIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICYmIGlkeDEgPT09IC0xICkge1xuXHRcdC8vIHNlbGVjdCBmcm9tIHRvcCB0byBoZXJlIC0gc2xpZ2h0bHkgb2RkLCBidXQgYm90aCBXaW5kb3dzIGFuZCBNYWMgT1Ncblx0XHQvLyBkbyB0aGlzXG5cdFx0aW5kZXhlcy5zcGxpY2UoICQuaW5BcnJheSggaWR4LCBpbmRleGVzICkrMSwgaW5kZXhlcy5sZW5ndGggKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyByZXZlcnNlIHNvIHdlIGNhbiBzaGlmdCBjbGljayAndXAnIGFzIHdlbGwgYXMgZG93blxuXHRcdGlmICggaWR4MSA+IGlkeDIgKSB7XG5cdFx0XHR2YXIgdG1wID0gaWR4Mjtcblx0XHRcdGlkeDIgPSBpZHgxO1xuXHRcdFx0aWR4MSA9IHRtcDtcblx0XHR9XG5cblx0XHRpbmRleGVzLnNwbGljZSggaWR4MisxLCBpbmRleGVzLmxlbmd0aCApO1xuXHRcdGluZGV4ZXMuc3BsaWNlKCAwLCBpZHgxICk7XG5cdH1cblxuXHRpZiAoICEgZHRbdHlwZV0oIGlkeCwgeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0Ly8gU2VsZWN0IHJhbmdlXG5cdFx0ZHRbdHlwZSsncyddKCBpbmRleGVzICkuc2VsZWN0KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRGVzZWxlY3QgcmFuZ2UgLSBuZWVkIHRvIGtlZXAgdGhlIGNsaWNrZWQgb24gcm93IHNlbGVjdGVkXG5cdFx0aW5kZXhlcy5zcGxpY2UoICQuaW5BcnJheSggaWR4LCBpbmRleGVzICksIDEgKTtcblx0XHRkdFt0eXBlKydzJ10oIGluZGV4ZXMgKS5kZXNlbGVjdCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIHNlbGVjdGVkIGl0ZW1zXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggU2V0dGluZ3Mgb2JqZWN0IG9mIHRoZSBob3N0IERhdGFUYWJsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBGb3JjZSB0aGUgZGUtc2VsZWN0aW9uIHRvIGhhcHBlbiwgcmVnYXJkbGVzc1xuICogICAgIG9mIHNlbGVjdGlvbiBzdHlsZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXIoIGN0eCwgZm9yY2UgKVxue1xuXHRpZiAoIGZvcmNlIHx8IGN0eC5fc2VsZWN0LnN0eWxlID09PSAnc2luZ2xlJyApIHtcblx0XHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApO1xuXHRcdFxuXHRcdGFwaS5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5kZXNlbGVjdCgpO1xuXHRcdGFwaS5jb2x1bW5zKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5kZXNlbGVjdCgpO1xuXHRcdGFwaS5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZGVzZWxlY3QoKTtcblx0fVxufVxuXG4vKipcbiAqIFNlbGVjdCBpdGVtcyBiYXNlZCBvbiB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZvciBzdHlsZSBhbmQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICBlICAgIE1vdXNlIGV2ZW50IG9iamVjdFxuICogQHBhcmFtICB7RGF0YVRhYmxlcy5BcGl9ICAgICBkdCAgIERhdGFUYWJsZVxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggIFNldHRpbmdzIG9iamVjdCBvZiB0aGUgaG9zdCBEYXRhVGFibGVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgdHlwZSBJdGVtcyB0byBzZWxlY3RcbiAqIEBwYXJhbSAge2ludHxvYmplY3R9ICAgICAgICAgaWR4ICBJbmRleCBvZiB0aGUgaXRlbSB0byBzZWxlY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHR5cGVTZWxlY3QgKCBlLCBkdCwgY3R4LCB0eXBlLCBpZHggKVxue1xuXHR2YXIgc3R5bGUgPSBkdC5zZWxlY3Quc3R5bGUoKTtcblx0dmFyIHRvZ2dsZWFibGUgPSBkdC5zZWxlY3QudG9nZ2xlYWJsZSgpO1xuXHR2YXIgaXNTZWxlY3RlZCA9IGR0W3R5cGVdKCBpZHgsIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpO1xuXHRcblx0aWYgKCBpc1NlbGVjdGVkICYmICEgdG9nZ2xlYWJsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIHN0eWxlID09PSAnb3MnICkge1xuXHRcdGlmICggZS5jdHJsS2V5IHx8IGUubWV0YUtleSApIHtcblx0XHRcdC8vIEFkZCBvciByZW1vdmUgZnJvbSB0aGUgc2VsZWN0aW9uXG5cdFx0XHRkdFt0eXBlXSggaWR4ICkuc2VsZWN0KCAhIGlzU2VsZWN0ZWQgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0Y2VsbFJhbmdlKCBkdCwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCB8fCBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93Q29sdW1uUmFuZ2UoIGR0LCB0eXBlLCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsID9cblx0XHRcdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbFt0eXBlXSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5vIGNtZCBvciBzaGlmdCBjbGljayAtIGRlc2VsZWN0IGlmIHNlbGVjdGVkLCBvciBzZWxlY3Rcblx0XHRcdC8vIHRoaXMgcm93IG9ubHlcblx0XHRcdHZhciBzZWxlY3RlZCA9IGR0W3R5cGUrJ3MnXSggeyBzZWxlY3RlZDogdHJ1ZSB9ICk7XG5cblx0XHRcdGlmICggaXNTZWxlY3RlZCAmJiBzZWxlY3RlZC5mbGF0dGVuKCkubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRkdFt0eXBlXSggaWR4ICkuZGVzZWxlY3QoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZWxlY3RlZC5kZXNlbGVjdCgpO1xuXHRcdFx0XHRkdFt0eXBlXSggaWR4ICkuc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBzdHlsZSA9PSAnbXVsdGkrc2hpZnQnICkge1xuXHRcdGlmICggZS5zaGlmdEtleSApIHtcblx0XHRcdGlmICggdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRjZWxsUmFuZ2UoIGR0LCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsIHx8IG51bGwgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3dDb2x1bW5SYW5nZSggZHQsIHR5cGUsIGlkeCwgY3R4Ll9zZWxlY3RfbGFzdENlbGwgP1xuXHRcdFx0XHRcdGN0eC5fc2VsZWN0X2xhc3RDZWxsW3R5cGVdIDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZHRbIHR5cGUgXSggaWR4ICkuc2VsZWN0KCAhIGlzU2VsZWN0ZWQgKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZHRbIHR5cGUgXSggaWR4ICkuc2VsZWN0KCAhIGlzU2VsZWN0ZWQgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBfc2FmZUlkKCBub2RlICkge1xuXHRyZXR1cm4gbm9kZS5pZC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLVxcX10vZywgJy0nKTtcbn1cblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIHNlbGVjdG9yc1xuICovXG5cbi8vIHJvdyBhbmQgY29sdW1uIGFyZSBiYXNpY2FsbHkgaWRlbnRpY2FsIGp1c3QgYXNzaWduZWQgdG8gZGlmZmVyZW50IHByb3BlcnRpZXNcbi8vIGFuZCBjaGVja2luZyBhIGRpZmZlcmVudCBhcnJheSwgc28gd2UgY2FuIGR5bmFtaWNhbGx5IGNyZWF0ZSB0aGUgZnVuY3Rpb25zIHRvXG4vLyByZWR1Y2UgdGhlIGNvZGUgc2l6ZVxuJC5lYWNoKCBbXG5cdHsgdHlwZTogJ3JvdycsIHByb3A6ICdhb0RhdGEnIH0sXG5cdHsgdHlwZTogJ2NvbHVtbicsIHByb3A6ICdhb0NvbHVtbnMnIH1cbl0sIGZ1bmN0aW9uICggaSwgbyApIHtcblx0RGF0YVRhYmxlLmV4dC5zZWxlY3Rvclsgby50eXBlIF0ucHVzaCggZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cywgaW5kZXhlcyApIHtcblx0XHR2YXIgc2VsZWN0ZWQgPSBvcHRzLnNlbGVjdGVkO1xuXHRcdHZhciBkYXRhO1xuXHRcdHZhciBvdXQgPSBbXTtcblxuXHRcdGlmICggc2VsZWN0ZWQgIT09IHRydWUgJiYgc2VsZWN0ZWQgIT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGluZGV4ZXM7XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWluZGV4ZXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRkYXRhID0gc2V0dGluZ3NbIG8ucHJvcCBdWyBpbmRleGVzW2ldIF07XG5cblx0XHRcdGlmICggKHNlbGVjdGVkID09PSB0cnVlICYmIGRhdGEuX3NlbGVjdF9zZWxlY3RlZCA9PT0gdHJ1ZSkgfHxcblx0XHRcdCAgICAgKHNlbGVjdGVkID09PSBmYWxzZSAmJiAhIGRhdGEuX3NlbGVjdF9zZWxlY3RlZCApXG5cdFx0XHQpIHtcblx0XHRcdFx0b3V0LnB1c2goIGluZGV4ZXNbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9ICk7XG59ICk7XG5cbkRhdGFUYWJsZS5leHQuc2VsZWN0b3IuY2VsbC5wdXNoKCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzLCBjZWxscyApIHtcblx0dmFyIHNlbGVjdGVkID0gb3B0cy5zZWxlY3RlZDtcblx0dmFyIHJvd0RhdGE7XG5cdHZhciBvdXQgPSBbXTtcblxuXHRpZiAoIHNlbGVjdGVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIGNlbGxzO1xuXHR9XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIGNlbGxzW2ldLnJvdyBdO1xuXG5cdFx0aWYgKCAoc2VsZWN0ZWQgPT09IHRydWUgJiYgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHMgJiYgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHNbIGNlbGxzW2ldLmNvbHVtbiBdID09PSB0cnVlKSB8fFxuXHRcdCAgICAgKHNlbGVjdGVkID09PSBmYWxzZSAmJiAoICEgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHMgfHwgISByb3dEYXRhLl9zZWxlY3RlZF9jZWxsc1sgY2VsbHNbaV0uY29sdW1uIF0gKSApXG5cdFx0KSB7XG5cdFx0XHRvdXQucHVzaCggY2VsbHNbaV0gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIERhdGFUYWJsZXMgQVBJXG4gKlxuICogRm9yIGNvbXBsZXRlIGRvY3VtZW50YXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgZG9jcy9hcGkgZGlyZWN0b3J5IG9yIHRoZVxuICogRGF0YVRhYmxlcyBzaXRlXG4gKi9cblxuLy8gTG9jYWwgdmFyaWFibGVzIHRvIGltcHJvdmUgY29tcHJlc3Npb25cbnZhciBhcGlSZWdpc3RlciA9IERhdGFUYWJsZS5BcGkucmVnaXN0ZXI7XG52YXIgYXBpUmVnaXN0ZXJQbHVyYWwgPSBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC5ibHVyYWJsZSgpJywgZnVuY3Rpb24gKCBmbGFnICkge1xuXHRpZiAoIGZsYWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuYmx1cmFibGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuYmx1cmFibGUgPSBmbGFnO1xuXHR9ICk7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LnRvZ2dsZWFibGUoKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LnRvZ2dsZWFibGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QudG9nZ2xlYWJsZSA9IGZsYWc7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QuaW5mbygpJywgZnVuY3Rpb24gKCBmbGFnICkge1xuXHRpZiAoIGZsYWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuaW5mbztcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRjdHguX3NlbGVjdC5pbmZvID0gZmxhZztcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC5pdGVtcygpJywgZnVuY3Rpb24gKCBpdGVtcyApIHtcblx0aWYgKCBpdGVtcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC5pdGVtcztcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRjdHguX3NlbGVjdC5pdGVtcyA9IGl0ZW1zO1xuXG5cdFx0ZXZlbnRUcmlnZ2VyKCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICksICdzZWxlY3RJdGVtcycsIFsgaXRlbXMgXSApO1xuXHR9ICk7XG59ICk7XG5cbi8vIFRha2VzIGVmZmVjdCBmcm9tIHRoZSBfbmV4dF8gc2VsZWN0aW9uLiBOb25lIGRpc2FibGVzIGZ1dHVyZSBzZWxlY3Rpb24sIGJ1dFxuLy8gZG9lcyBub3QgY2xlYXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBVc2UgdGhlIGBkZXNlbGVjdGAgbWV0aG9kcyBmb3IgdGhhdFxuYXBpUmVnaXN0ZXIoICdzZWxlY3Quc3R5bGUoKScsIGZ1bmN0aW9uICggc3R5bGUgKSB7XG5cdGlmICggc3R5bGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3Quc3R5bGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3Quc3R5bGUgPSBzdHlsZTtcblxuXHRcdGlmICggISBjdHguX3NlbGVjdF9pbml0ICkge1xuXHRcdFx0aW5pdCggY3R4ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIC8gcmVtb3ZlIG1vdXNlIGV2ZW50IGhhbmRsZXJzLiBUaGV5IGFyZW4ndCByZXF1aXJlZCB3aGVuIG9ubHlcblx0XHQvLyBBUEkgc2VsZWN0aW9uIGlzIGF2YWlsYWJsZVxuXHRcdHZhciBkdCA9IG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKTtcblx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oIGR0ICk7XG5cdFx0XG5cdFx0aWYgKCBzdHlsZSAhPT0gJ2FwaScgKSB7XG5cdFx0XHRlbmFibGVNb3VzZVNlbGVjdGlvbiggZHQgKTtcblx0XHR9XG5cblx0XHRldmVudFRyaWdnZXIoIG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKSwgJ3NlbGVjdFN0eWxlJywgWyBzdHlsZSBdICk7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3Quc2VsZWN0b3IoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3Quc2VsZWN0b3I7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0ZGlzYWJsZU1vdXNlU2VsZWN0aW9uKCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcblxuXHRcdGN0eC5fc2VsZWN0LnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRpZiAoIGN0eC5fc2VsZWN0LnN0eWxlICE9PSAnYXBpJyApIHtcblx0XHRcdGVuYWJsZU1vdXNlU2VsZWN0aW9uKCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcblx0XHR9XG5cdH0gKTtcbn0gKTtcblxuXG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAncm93cygpLnNlbGVjdCgpJywgJ3JvdygpLnNlbGVjdCgpJywgZnVuY3Rpb24gKCBzZWxlY3QgKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdGlmICggc2VsZWN0ID09PSBmYWxzZSApIHtcblx0XHRyZXR1cm4gdGhpcy5kZXNlbGVjdCgpO1xuXHR9XG5cblx0dGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggY3R4LCBpZHggKSB7XG5cdFx0Y2xlYXIoIGN0eCApO1xuXG5cdFx0Y3R4LmFvRGF0YVsgaWR4IF0uX3NlbGVjdF9zZWxlY3RlZCA9IHRydWU7XG5cdFx0JCggY3R4LmFvRGF0YVsgaWR4IF0ublRyICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdzZWxlY3QnLCBbICdyb3cnLCBhcGlbaV0gXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnNlbGVjdCgpJywgJ2NvbHVtbigpLnNlbGVjdCgpJywgZnVuY3Rpb24gKCBzZWxlY3QgKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdGlmICggc2VsZWN0ID09PSBmYWxzZSApIHtcblx0XHRyZXR1cm4gdGhpcy5kZXNlbGVjdCgpO1xuXHR9XG5cblx0dGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggY3R4LCBpZHggKSB7XG5cdFx0Y2xlYXIoIGN0eCApO1xuXG5cdFx0Y3R4LmFvQ29sdW1uc1sgaWR4IF0uX3NlbGVjdF9zZWxlY3RlZCA9IHRydWU7XG5cblx0XHR2YXIgY29sdW1uID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApLmNvbHVtbiggaWR4ICk7XG5cblx0XHQkKCBjb2x1bW4uaGVhZGVyKCkgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0JCggY29sdW1uLmZvb3RlcigpICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXG5cdFx0Y29sdW1uLm5vZGVzKCkudG8kKCkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdzZWxlY3QnLCBbICdjb2x1bW4nLCBhcGlbaV0gXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5zZWxlY3QoKScsICdjZWxsKCkuc2VsZWN0KCknLCBmdW5jdGlvbiAoIHNlbGVjdCApIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0aWYgKCBzZWxlY3QgPT09IGZhbHNlICkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggY3R4LCByb3dJZHgsIGNvbElkeCApIHtcblx0XHRjbGVhciggY3R4ICk7XG5cblx0XHR2YXIgZGF0YSA9IGN0eC5hb0RhdGFbIHJvd0lkeCBdO1xuXG5cdFx0aWYgKCBkYXRhLl9zZWxlY3RlZF9jZWxscyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0ZGF0YS5fc2VsZWN0ZWRfY2VsbHMgPSBbXTtcblx0XHR9XG5cblx0XHRkYXRhLl9zZWxlY3RlZF9jZWxsc1sgY29sSWR4IF0gPSB0cnVlO1xuXG5cdFx0aWYgKCBkYXRhLmFuQ2VsbHMgKSB7XG5cdFx0XHQkKCBkYXRhLmFuQ2VsbHNbIGNvbElkeCBdICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnc2VsZWN0JywgWyAnY2VsbCcsIGFwaS5jZWxscyhhcGlbaV0pLmluZGV4ZXMoKS50b0FycmF5KCkgXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuZGVzZWxlY3QoKScsICdyb3coKS5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHR0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjdHguYW9EYXRhWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gZmFsc2U7XG5cdFx0Y3R4Ll9zZWxlY3RfbGFzdENlbGwgPSBudWxsO1xuXHRcdCQoIGN0eC5hb0RhdGFbIGlkeCBdLm5UciApLnJlbW92ZUNsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnZGVzZWxlY3QnLCBbICdyb3cnLCBhcGlbaV0gXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmRlc2VsZWN0KCknLCAnY29sdW1uKCkuZGVzZWxlY3QoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0dGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggY3R4LCBpZHggKSB7XG5cdFx0Y3R4LmFvQ29sdW1uc1sgaWR4IF0uX3NlbGVjdF9zZWxlY3RlZCA9IGZhbHNlO1xuXG5cdFx0dmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKTtcblx0XHR2YXIgY29sdW1uID0gYXBpLmNvbHVtbiggaWR4ICk7XG5cblx0XHQkKCBjb2x1bW4uaGVhZGVyKCkgKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0JCggY29sdW1uLmZvb3RlcigpICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXG5cdFx0Ly8gTmVlZCB0byBsb29wIG92ZXIgZWFjaCBjZWxsLCByYXRoZXIgdGhhbiBqdXN0IHVzaW5nXG5cdFx0Ly8gYGNvbHVtbigpLm5vZGVzKClgIGFzIGNlbGxzIHdoaWNoIGFyZSBpbmRpdmlkdWFsbHkgc2VsZWN0ZWQgc2hvdWxkXG5cdFx0Ly8gbm90IGhhdmUgdGhlIGBzZWxlY3RlZGAgY2xhc3MgcmVtb3ZlZCBmcm9tIHRoZW1cblx0XHRhcGkuY2VsbHMoIG51bGwsIGlkeCApLmluZGV4ZXMoKS5lYWNoKCBmdW5jdGlvbiAoY2VsbElkeCkge1xuXHRcdFx0dmFyIGRhdGEgPSBjdHguYW9EYXRhWyBjZWxsSWR4LnJvdyBdO1xuXHRcdFx0dmFyIGNlbGxTZWxlY3RlZCA9IGRhdGEuX3NlbGVjdGVkX2NlbGxzO1xuXG5cdFx0XHRpZiAoIGRhdGEuYW5DZWxscyAmJiAoISBjZWxsU2VsZWN0ZWQgfHwgISBjZWxsU2VsZWN0ZWRbIGNlbGxJZHguY29sdW1uIF0pICkge1xuXHRcdFx0XHQkKCBkYXRhLmFuQ2VsbHNbIGNlbGxJZHguY29sdW1uICBdICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnZGVzZWxlY3QnLCBbICdjb2x1bW4nLCBhcGlbaV0gXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5kZXNlbGVjdCgpJywgJ2NlbGwoKS5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHR0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggY3R4LCByb3dJZHgsIGNvbElkeCApIHtcblx0XHR2YXIgZGF0YSA9IGN0eC5hb0RhdGFbIHJvd0lkeCBdO1xuXG5cdFx0ZGF0YS5fc2VsZWN0ZWRfY2VsbHNbIGNvbElkeCBdID0gZmFsc2U7XG5cblx0XHQvLyBSZW1vdmUgY2xhc3Mgb25seSBpZiB0aGUgY2VsbHMgZXhpc3QsIGFuZCB0aGUgY2VsbCBpcyBub3QgY29sdW1uXG5cdFx0Ly8gc2VsZWN0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIGNsYXNzIHNob3VsZCByZW1haW4gKHNpbmNlIGl0IGlzIHNlbGVjdGVkXG5cdFx0Ly8gaW4gdGhlIGNvbHVtbilcblx0XHRpZiAoIGRhdGEuYW5DZWxscyAmJiAhIGN0eC5hb0NvbHVtbnNbIGNvbElkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgKSB7XG5cdFx0XHQkKCBkYXRhLmFuQ2VsbHNbIGNvbElkeCBdICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnZGVzZWxlY3QnLCBbICdjZWxsJywgYXBpW2ldIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIEJ1dHRvbnNcbiAqL1xuZnVuY3Rpb24gaTE4biggbGFiZWwsIGRlZiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChkdCkge1xuXHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy4nK2xhYmVsLCBkZWYgKTtcblx0fTtcbn1cblxuLy8gQ29tbW9uIGV2ZW50cyB3aXRoIHN1aXRhYmxlIG5hbWVzcGFjZXNcbmZ1bmN0aW9uIG5hbWVzcGFjZWRFdmVudHMgKCBjb25maWcgKSB7XG5cdHZhciB1bmlxdWUgPSBjb25maWcuX2V2ZW50TmFtZXNwYWNlO1xuXG5cdHJldHVybiAnZHJhdy5kdC5EVCcrdW5pcXVlKycgc2VsZWN0LmR0LkRUJyt1bmlxdWUrJyBkZXNlbGVjdC5kdC5EVCcrdW5pcXVlO1xufVxuXG5mdW5jdGlvbiBlbmFibGVkICggZHQsIGNvbmZpZyApIHtcblx0aWYgKCAkLmluQXJyYXkoICdyb3dzJywgY29uZmlnLmxpbWl0VG8gKSAhPT0gLTEgJiYgZHQucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoICQuaW5BcnJheSggJ2NvbHVtbnMnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5jb2x1bW5zKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggJC5pbkFycmF5KCAnY2VsbHMnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfYnV0dG9uTmFtZXNwYWNlID0gMDtcblxuJC5leHRlbmQoIERhdGFUYWJsZS5leHQuYnV0dG9ucywge1xuXHRzZWxlY3RlZDoge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RlZCcsICdTZWxlY3RlZCcgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdGVkJyxcblx0XHRsaW1pdFRvOiBbICdyb3dzJywgJ2NvbHVtbnMnLCAnY2VsbHMnIF0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0Ly8gLkRUIG5hbWVzcGFjZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgYnkgRGF0YVRhYmxlcyBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBvbiB0YWJsZSBkZXN0cm95XG5cdFx0XHRkdC5vbiggbmFtZXNwYWNlZEV2ZW50cyhjb25maWcpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBlbmFibGVkKGR0LCBjb25maWcpICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0ZHQub2ZmKCBjb25maWcuX2V2ZW50TmFtZXNwYWNlICk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3RlZFNpbmdsZToge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RlZFNpbmdsZScsICdTZWxlY3RlZCBzaW5nbGUnICksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3RlZC1zaW5nbGUnLFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmZpZyApIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgPSAnLnNlbGVjdCcrKF9idXR0b25OYW1lc3BhY2UrKyk7XG5cblx0XHRcdGR0Lm9uKCBuYW1lc3BhY2VkRXZlbnRzKGNvbmZpZyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gZHQucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNvbHVtbnMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGggK1xuXHRcdFx0XHQgICAgICAgICAgICBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblxuXHRcdFx0XHR0aGF0LmVuYWJsZSggY291bnQgPT09IDEgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH0sXG5cdHNlbGVjdEFsbDoge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RBbGwnLCAnU2VsZWN0IGFsbCcgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdC1hbGwnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHRoaXNbIGl0ZW1zKydzJyBdKCkuc2VsZWN0KCk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3ROb25lOiB7XG5cdFx0dGV4dDogaTE4biggJ3NlbGVjdE5vbmUnLCAnRGVzZWxlY3QgYWxsJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LW5vbmUnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXIoIHRoaXMuc2V0dGluZ3MoKVswXSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0ZHQub24oIG5hbWVzcGFjZWRFdmVudHMoY29uZmlnKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY291bnQgPSBkdC5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoICtcblx0XHRcdFx0ICAgICAgICAgICAgZHQuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBjb3VudCA+IDAgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuJC5lYWNoKCBbICdSb3cnLCAnQ29sdW1uJywgJ0NlbGwnIF0sIGZ1bmN0aW9uICggaSwgaXRlbSApIHtcblx0dmFyIGxjID0gaXRlbS50b0xvd2VyQ2FzZSgpO1xuXG5cdERhdGFUYWJsZS5leHQuYnV0dG9uc1sgJ3NlbGVjdCcraXRlbSsncycgXSA9IHtcblx0XHR0ZXh0OiBpMThuKCAnc2VsZWN0JytpdGVtKydzJywgJ1NlbGVjdCAnK2xjKydzJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LScrbGMrJ3MnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZWxlY3QuaXRlbXMoIGxjICk7XG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0XHRkdC5vbiggJ3NlbGVjdEl0ZW1zLmR0LkRUJywgZnVuY3Rpb24gKCBlLCBjdHgsIGl0ZW1zICkge1xuXHRcdFx0XHR0aGF0LmFjdGl2ZSggaXRlbXMgPT09IGxjICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIEluaXRpYWxpc2F0aW9uXG4gKi9cblxuLy8gRGF0YVRhYmxlcyBjcmVhdGlvbiAtIGNoZWNrIGlmIHNlbGVjdCBoYXMgYmVlbiBkZWZpbmVkIGluIHRoZSBvcHRpb25zLiBOb3RlXG4vLyB0aGlzIHJlcXVpcmVkIHRoYXQgdGhlIHRhYmxlIGJlIGluIHRoZSBkb2N1bWVudCEgSWYgaXQgaXNuJ3QgdGhlbiBzb21ldGhpbmdcbi8vIG5lZWRzIHRvIHRyaWdnZXIgdGhpcyBtZXRob2QgdW5mb3J0dW5hdGVseS4gVGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZlxuLy8gRGF0YVRhYmxlcyB3aWxsIHJld29yayB0aGUgZXZlbnRzIGFuZCBhZGRyZXNzIHRoaXMuXG4kKGRvY3VtZW50KS5vbiggJ3ByZUluaXQuZHQuZHRTZWxlY3QnLCBmdW5jdGlvbiAoZSwgY3R4KSB7XG5cdGlmICggZS5uYW1lc3BhY2UgIT09ICdkdCcgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcbn0gKTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlLnNlbGVjdDtcbn0pKTtcbiIsIi8qISBEYXRhVGFibGVzIDEuMTEuM1xuICogwqkyMDA4LTIwMjEgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5ICAgICBEYXRhVGFibGVzXG4gKiBAZGVzY3JpcHRpb24gUGFnaW5hdGUsIHNlYXJjaCBhbmQgb3JkZXIgSFRNTCB0YWJsZXNcbiAqIEB2ZXJzaW9uICAgICAxLjExLjNcbiAqIEBmaWxlICAgICAgICBqcXVlcnkuZGF0YVRhYmxlcy5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGRcbiAqIEBjb250YWN0ICAgICB3d3cuZGF0YXRhYmxlcy5uZXRcbiAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAwOC0yMDIxIFNwcnlNZWRpYSBMdGQuXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBmcmVlIHNvZnR3YXJlLCBhdmFpbGFibGUgdW5kZXIgdGhlIGZvbGxvd2luZyBsaWNlbnNlOlxuICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHVuZGVmOiB0cnVlLCBicm93c2VyOiB0cnVlICovXG4vKmdsb2JhbHMgJCxyZXF1aXJlLGpRdWVyeSxkZWZpbmUsX3NlbGVjdG9yX3J1bixfc2VsZWN0b3Jfb3B0cyxfc2VsZWN0b3JfZmlyc3QsX3NlbGVjdG9yX3Jvd19pbmRleGVzLF9leHQsX0FwaSxfYXBpX3JlZ2lzdGVyLF9hcGlfcmVnaXN0ZXJQbHVyYWwsX3JlX25ld19saW5lcyxfcmVfaHRtbCxfcmVfZm9ybWF0dGVkX251bWVyaWMsX3JlX2VzY2FwZV9yZWdleCxfZW1wdHksX2ludFZhbCxfbnVtVG9EZWNpbWFsLF9pc051bWJlcixfaXNIdG1sLF9odG1sTnVtZXJpYyxfcGx1Y2ssX3BsdWNrX29yZGVyLF9yYW5nZSxfc3RyaXBIdG1sLF91bmlxdWUsX2ZuQnVpbGRBamF4LF9mbkFqYXhVcGRhdGUsX2ZuQWpheFBhcmFtZXRlcnMsX2ZuQWpheFVwZGF0ZURyYXcsX2ZuQWpheERhdGFTcmMsX2ZuQWRkQ29sdW1uLF9mbkNvbHVtbk9wdGlvbnMsX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLF9mblZpc2libGVUb0NvbHVtbkluZGV4LF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLF9mblZpc2JsZUNvbHVtbnMsX2ZuR2V0Q29sdW1ucyxfZm5Db2x1bW5UeXBlcyxfZm5BcHBseUNvbHVtbkRlZnMsX2ZuSHVuZ2FyaWFuTWFwLF9mbkNhbWVsVG9IdW5nYXJpYW4sX2ZuTGFuZ3VhZ2VDb21wYXQsX2ZuQnJvd3NlckRldGVjdCxfZm5BZGREYXRhLF9mbkFkZFRyLF9mbk5vZGVUb0RhdGFJbmRleCxfZm5Ob2RlVG9Db2x1bW5JbmRleCxfZm5HZXRDZWxsRGF0YSxfZm5TZXRDZWxsRGF0YSxfZm5TcGxpdE9iak5vdGF0aW9uLF9mbkdldE9iamVjdERhdGFGbixfZm5TZXRPYmplY3REYXRhRm4sX2ZuR2V0RGF0YU1hc3RlcixfZm5DbGVhclRhYmxlLF9mbkRlbGV0ZUluZGV4LF9mbkludmFsaWRhdGUsX2ZuR2V0Um93RWxlbWVudHMsX2ZuQ3JlYXRlVHIsX2ZuQnVpbGRIZWFkLF9mbkRyYXdIZWFkLF9mbkRyYXcsX2ZuUmVEcmF3LF9mbkFkZE9wdGlvbnNIdG1sLF9mbkRldGVjdEhlYWRlcixfZm5HZXRVbmlxdWVUaHMsX2ZuRmVhdHVyZUh0bWxGaWx0ZXIsX2ZuRmlsdGVyQ29tcGxldGUsX2ZuRmlsdGVyQ3VzdG9tLF9mbkZpbHRlckNvbHVtbixfZm5GaWx0ZXIsX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLF9mbkVzY2FwZVJlZ2V4LF9mbkZpbHRlckRhdGEsX2ZuRmVhdHVyZUh0bWxJbmZvLF9mblVwZGF0ZUluZm8sX2ZuSW5mb01hY3JvcyxfZm5Jbml0aWFsaXNlLF9mbkluaXRDb21wbGV0ZSxfZm5MZW5ndGhDaGFuZ2UsX2ZuRmVhdHVyZUh0bWxMZW5ndGgsX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxfZm5QYWdlQ2hhbmdlLF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxfZm5Qcm9jZXNzaW5nRGlzcGxheSxfZm5GZWF0dXJlSHRtbFRhYmxlLF9mblNjcm9sbERyYXcsX2ZuQXBwbHlUb0NoaWxkcmVuLF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxfZm5UaHJvdHRsZSxfZm5Db252ZXJ0VG9XaWR0aCxfZm5HZXRXaWRlc3ROb2RlLF9mbkdldE1heExlblN0cmluZyxfZm5TdHJpbmdUb0NzcyxfZm5Tb3J0RmxhdHRlbixfZm5Tb3J0LF9mblNvcnRBcmlhLF9mblNvcnRMaXN0ZW5lcixfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsX2ZuU29ydGluZ0NsYXNzZXMsX2ZuU29ydERhdGEsX2ZuU2F2ZVN0YXRlLF9mbkxvYWRTdGF0ZSxfZm5TZXR0aW5nc0Zyb21Ob2RlLF9mbkxvZyxfZm5NYXAsX2ZuQmluZEFjdGlvbixfZm5DYWxsYmFja1JlZyxfZm5DYWxsYmFja0ZpcmUsX2ZuTGVuZ3RoT3ZlcmZsb3csX2ZuUmVuZGVyZXIsX2ZuRGF0YVNvdXJjZSxfZm5Sb3dBdHRyaWJ1dGVzKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0Ly8gQ29tbW9uSlMgZW52aXJvbm1lbnRzIHdpdGhvdXQgYSB3aW5kb3cgZ2xvYmFsIG11c3QgcGFzcyBhXG5cdFx0XHRcdC8vIHJvb3QuIFRoaXMgd2lsbCBnaXZlIGFuIGVycm9yIG90aGVyd2lzZVxuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCApIHtcblx0XHRcdFx0JCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gLy8galF1ZXJ5J3MgZmFjdG9yeSBjaGVja3MgZm9yIGEgZ2xvYmFsIHdpbmRvd1xuXHRcdFx0XHRcdHJlcXVpcmUoJ2pxdWVyeScpIDpcblx0XHRcdFx0XHRyZXF1aXJlKCdqcXVlcnknKSggcm9vdCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHdpbmRvdy5EYXRhVGFibGUgPSBmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0fVxufVxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIGlzIGEgcGx1Zy1pbiBmb3IgdGhlIGpRdWVyeSBKYXZhc2NyaXB0IGxpYnJhcnkuIEl0IGlzIGEgaGlnaGx5XG5cdCAqIGZsZXhpYmxlIHRvb2wsIGJhc2VkIHVwb24gdGhlIGZvdW5kYXRpb25zIG9mIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LFxuXHQgKiB3aGljaCB3aWxsIGFkZCBhZHZhbmNlZCBpbnRlcmFjdGlvbiBjb250cm9scyB0byBhbnkgSFRNTCB0YWJsZS4gRm9yIGFcblx0ICogZnVsbCBsaXN0IG9mIGZlYXR1cmVzIHBsZWFzZSByZWZlciB0b1xuXHQgKiBbRGF0YVRhYmxlcy5uZXRdKGhyZWY9XCJodHRwOi8vZGF0YXRhYmxlcy5uZXQpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGVgIG9iamVjdCBpcyBub3QgYSBnbG9iYWwgdmFyaWFibGUgYnV0IGlzIGFsaWFzZWRcblx0ICogdG8gYGpRdWVyeS5mbi5EYXRhVGFibGVgIGFuZCBgalF1ZXJ5LmZuLmRhdGFUYWJsZWAgdGhyb3VnaCB3aGljaCBpdCBtYXlcblx0ICogYmUgIGFjY2Vzc2VkLlxuXHQgKlxuXHQgKiAgQGNsYXNzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gW2luaXQ9e31dIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBEYXRhVGFibGVzLiBPcHRpb25zXG5cdCAqICAgIGFyZSBkZWZpbmVkIGJ5IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9XG5cdCAqICBAcmVxdWlyZXMgalF1ZXJ5IDEuNytcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIEJhc2ljIGluaXRpYWxpc2F0aW9uXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gSW5pdGlhbGlzYXRpb24gd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMgLSBpbiB0aGlzIGNhc2UsIGRpc2FibGVcblx0ICogICAgLy8gcGFnaW5hdGlvbiBhbmQgc29ydGluZy5cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcblx0ICogICAgICAgIFwic29ydFwiOiBmYWxzZVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dmFyIERhdGFUYWJsZSA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdGlvbnMgKVxuXHR7XG5cdFx0Ly8gV2hlbiBjcmVhdGluZyB3aXRoIGBuZXdgLCBjcmVhdGUgYSBuZXcgRGF0YVRhYmxlLCByZXR1cm5pbmcgdGhlIEFQSSBpbnN0YW5jZVxuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgRGF0YVRhYmxlKSB7XG5cdFx0XHRyZXR1cm4gJChzZWxlY3RvcikuRGF0YVRhYmxlKG9wdGlvbnMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEFyZ3VtZW50IHN3aXRjaGluZ1xuXHRcdFx0b3B0aW9ucyA9IHNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXG5cdFx0ICogcmV0dXJuIHRoZSByZXN1bHRpbmcgalF1ZXJ5IG9iamVjdC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5maWx0ZXI9bm9uZV0gU2VsZWN0IFRSIGVsZW1lbnRzIHRoYXQgbWVldCB0aGUgY3VycmVudCBmaWx0ZXJcblx0XHQgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgVFIgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cblx0XHQgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuXHRcdCAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG5cdFx0ICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuXHRcdCAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXG5cdFx0ICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSGlnaGxpZ2h0IGV2ZXJ5IHNlY29uZCByb3dcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvIHJvd3Mgd2l0aCAnV2Via2l0JyBpbiB0aGVtLCBhZGQgYSBiYWNrZ3JvdW5kIGNvbG91ciBhbmQgdGhlblxuXHRcdCAqICAgICAgLy8gcmVtb3ZlIHRoZSBmaWx0ZXIsIHRodXMgaGlnaGxpZ2h0aW5nIHRoZSAnV2Via2l0JyByb3dzIG9ubHkuXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSkuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCAnYmx1ZScpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCcnKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy4kID0gZnVuY3Rpb24gKCBzU2VsZWN0b3IsIG9PcHRzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkodHJ1ZSkuJCggc1NlbGVjdG9yLCBvT3B0cyApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWxtb3N0IGlkZW50aWNhbCB0byAkIGluIG9wZXJhdGlvbiwgYnV0IGluIHRoaXMgY2FzZSByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbWF0Y2hlZFxuXHRcdCAqIHJvd3MgLSBhcyBzdWNoLCB0aGUgalF1ZXJ5IHNlbGVjdG9yIHVzZWQgc2hvdWxkIG1hdGNoIFRSIHJvdyBub2RlcyBvciBURC9USCBjZWxsIG5vZGVzXG5cdFx0ICogcmF0aGVyIHRoYW4gYW55IGRlc2NlbmRhbnRzLCBzbyB0aGUgZGF0YSBjYW4gYmUgb2J0YWluZWQgZm9yIHRoZSByb3cvY2VsbC4gSWYgbWF0Y2hpbmdcblx0XHQgKiByb3dzIGFyZSBmb3VuZCwgdGhlIGRhdGEgcmV0dXJuZWQgaXMgdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkvb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG9cblx0XHQgKiBjcmVhdGUgdGhlIHJvdyAob3IgYSBnZW5lcmF0ZWQgYXJyYXkgaWYgZnJvbSBhIERPTSBzb3VyY2UpLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgb2Z0ZW4gdXNlZnVsIGluLWNvbWJpbmF0aW9uIHdpdGggJCB3aGVyZSBib3RoIGZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlXG5cdFx0ICogc2FtZSBwYXJhbWV0ZXJzIGFuZCB0aGUgYXJyYXkgaW5kZXhlcyB3aWxsIG1hdGNoIGlkZW50aWNhbGx5LlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuXHRcdCAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBkYXRhIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXG5cdFx0ICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3Jcblx0XHQgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxuXHRcdCAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcblx0XHQgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IERhdGEgZm9yIHRoZSBtYXRjaGVkIGVsZW1lbnRzLiBJZiBhbnkgZWxlbWVudHMsIGFzIGEgcmVzdWx0IG9mIHRoZVxuXHRcdCAqICAgIHNlbGVjdG9yLCB3ZXJlIG5vdCBUUiwgVEQgb3IgVEggZWxlbWVudHMgaW4gdGhlIERhdGFUYWJsZSwgdGhleSB3aWxsIGhhdmUgYSBudWxsXG5cdFx0ICogICAgZW50cnkgaW4gdGhlIGFycmF5LlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZVxuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHI6Zmlyc3QnKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBkYXRhXG5cdFx0ICogICAgICBhbGVydCggXCJGaXJzdCBjZWxsIGlzOiBcIitkYXRhWzBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvICdXZWJraXQnIGFuZCBnZXQgYWxsIGRhdGEgZm9yXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGFcblx0XHQgKiAgICAgIGFsZXJ0KCBkYXRhLmxlbmd0aCtcIiByb3dzIG1hdGNoZWQgdGhlIHNlYXJjaFwiICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuXyA9IGZ1bmN0aW9uICggc1NlbGVjdG9yLCBvT3B0cyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKHRydWUpLnJvd3MoIHNTZWxlY3Rvciwgb09wdHMgKS5kYXRhKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBEYXRhVGFibGVzIEFwaSBpbnN0YW5jZSwgd2l0aCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYmxlcyBmb3Jcblx0XHQgKiB0aGUgQXBpJ3MgY29udGV4dC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFkaXRpb25hbD1mYWxzZV0gU2V0IHRoZSBBUEkgaW5zdGFuY2UncyBjb250ZXh0IHRvIGJlXG5cdFx0ICogICBvbmx5IHRoZSB0YWJsZSByZWZlcnJlZCB0byBieSB0aGUgYERhdGFUYWJsZS5leHQuaUFwaUluZGV4YCBvcHRpb24sIGFzIHdhc1xuXHRcdCAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxuXHRcdCAqICAgb3IgaWYgYWxsIHRhYmxlcyBjYXB0dXJlZCBpbiB0aGUgalF1ZXJ5IG9iamVjdCBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBAcmV0dXJuIHtEYXRhVGFibGVzLkFwaX1cblx0XHQgKi9cblx0XHR0aGlzLmFwaSA9IGZ1bmN0aW9uICggdHJhZGl0aW9uYWwgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cmFkaXRpb25hbCA/XG5cdFx0XHRcdG5ldyBfQXBpKFxuXHRcdFx0XHRcdF9mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbIF9leHQuaUFwaUluZGV4IF0gKVxuXHRcdFx0XHQpIDpcblx0XHRcdFx0bmV3IF9BcGkoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXG5cdFx0ICogdGhhdCB0aGlzIGlzIHN1aXRhYmxlIGZvciBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIG9ubHkgLSBpZiB5b3UgYXJlIHVzaW5nXG5cdFx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAoaS5lLiBcImJTZXJ2ZXJTaWRlXCI6IHRydWUpLCB0aGVuIHRvIGFkZCBkYXRhLCB5b3Vcblx0XHQgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRhYmxlLiBUaGlzIGNhbiBiZTpcblx0XHQgKiAgICA8dWw+XG5cdFx0ICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XG5cdFx0ICogICAgICA8bGk+MkQgYXJyYXkgb2YgYXJyYXlzIC0gYWRkIG11bHRpcGxlIHJvd3MgaW4gYSBzaW5nbGUgY2FsbDwvbGk+XG5cdFx0ICogICAgICA8bGk+b2JqZWN0IC0gZGF0YSBvYmplY3Qgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgIDwvdWw+XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxuXHRcdCAqICAgIDxpPmFvRGF0YTwvaT4gKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc30pIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvXG5cdFx0ICogICAgdGhlIHRhYmxlLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBHbG9iYWwgdmFyIGZvciBjb3VudGVyXG5cdFx0ICogICAgdmFyIGdpQ291bnQgPSAyO1xuXHRcdCAqXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIGZuQ2xpY2tBZGRSb3coKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjFcIixcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi4yXCIsXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjRcIiBdXG5cdFx0ICogICAgICApO1xuXHRcdCAqXG5cdFx0ICogICAgICBnaUNvdW50Kys7XG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGREYXRhID0gZnVuY3Rpb24oIGRhdGEsIHJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHQvKiBDaGVjayBpZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSByb3dzIG9yIG5vdCAqL1xuXHRcdFx0dmFyIHJvd3MgPSBBcnJheS5pc0FycmF5KGRhdGEpICYmICggQXJyYXkuaXNBcnJheShkYXRhWzBdKSB8fCAkLmlzUGxhaW5PYmplY3QoZGF0YVswXSkgKSA/XG5cdFx0XHRcdGFwaS5yb3dzLmFkZCggZGF0YSApIDpcblx0XHRcdFx0YXBpLnJvdy5hZGQoIGRhdGEgKTtcblx0XHRcblx0XHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIHJvd3MuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIERhdGFUYWJsZXMgcmVjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXplcywgYmFzZWQgb24gdGhlIGRhdGFcblx0XHQgKiBjb250YWluZWQgaW4gdGhlIHRhYmxlIGFuZCB0aGUgc2l6ZXMgYXBwbGllZCB0byB0aGUgY29sdW1ucyAoaW4gdGhlIERPTSwgQ1NTIG9yXG5cdFx0ICogdGhyb3VnaCB0aGUgc1dpZHRoIHBhcmFtZXRlcikuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUnc1xuXHRcdCAqIHBhcmVudCBlbGVtZW50IGNoYW5nZXMgKGZvciBleGFtcGxlIGEgd2luZG93IHJlc2l6ZSkuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3QsIHlvdSB3aWxsIHR5cGljYWxseSB3YW50IHRvXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic1Njcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcImJQYWdpbmF0ZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgb1RhYmxlLmZuQWRqdXN0Q29sdW1uU2l6aW5nKCk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGp1c3RDb2x1bW5TaXppbmcgPSBmdW5jdGlvbiAoIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSBhcGkuc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsLnNYICE9PSBcIlwiIHx8IHNjcm9sbC5zWSAhPT0gXCJcIiApIHtcblx0XHRcdFx0LyogSWYgbm90IHJlZHJhd2luZywgYnV0IHNjcm9sbGluZywgd2Ugd2FudCB0byBhcHBseSB0aGUgbmV3IGNvbHVtbiBzaXplcyBhbnl3YXkgKi9cblx0XHRcdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFF1aWNrbHkgYW5kIHNpbXBseSBjbGVhciBhIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW1tZWRpYXRlbHkgJ251a2UnIHRoZSBjdXJyZW50IHJvd3MgKHBlcmhhcHMgd2FpdGluZyBmb3IgYW4gQWpheCBjYWxsYmFjay4uLilcblx0XHQgKiAgICAgIG9UYWJsZS5mbkNsZWFyVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkNsZWFyVGFibGUgPSBmdW5jdGlvbiggYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY2xlYXIoKTtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXhhY3Qgb3Bwb3NpdGUgb2YgJ29wZW5pbmcnIGEgcm93LCB0aGlzIGZ1bmN0aW9uIHdpbGwgY2xvc2UgYW55IHJvd3Mgd2hpY2hcblx0XHQgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byAnY2xvc2UnXG5cdFx0ICogIEByZXR1cm5zIHtpbnR9IDAgb24gc3VjY2Vzcywgb3IgMSBpZiBmYWlsZWQgKGNhbid0IGZpbmQgdGhlIHJvdylcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHRcdCAqICAgICAgICB9IGVsc2Uge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkNsb3NlID0gZnVuY3Rpb24oIG5UciApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmhpZGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhIHJvdyBmb3IgdGhlIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7bWl4ZWR9IHRhcmdldCBUaGUgaW5kZXggb2YgdGhlIHJvdyBmcm9tIGFvRGF0YSB0byBiZSBkZWxldGVkLCBvclxuXHRcdCAqICAgIHRoZSBUUiBlbGVtZW50IHlvdSB3YW50IHRvIGRlbGV0ZVxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IFtjYWxsQmFja10gQ2FsbGJhY2sgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEByZXR1cm5zIHthcnJheX0gVGhlIHJvdyB0aGF0IHdhcyBkZWxldGVkXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgZmlyc3Qgcm93XG5cdFx0ICogICAgICBvVGFibGUuZm5EZWxldGVSb3coIDAgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkRlbGV0ZVJvdyA9IGZ1bmN0aW9uKCB0YXJnZXQsIGNhbGxiYWNrLCByZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFx0dmFyIHJvd3MgPSBhcGkucm93cyggdGFyZ2V0ICk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSByb3dzLnNldHRpbmdzKClbMF07XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93c1swXVswXSBdO1xuXHRcdFxuXHRcdFx0cm93cy5yZW1vdmUoKTtcblx0XHRcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXMsIHNldHRpbmdzLCBkYXRhICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVzdG9yZSB0aGUgdGFibGUgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSBpbiB0aGUgRE9NIGJ5IHJlbW92aW5nIGFsbCBvZiBEYXRhVGFibGVzXG5cdFx0ICogZW5oYW5jZW1lbnRzLCBhbHRlcmF0aW9ucyB0byB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdGFibGUgYW5kIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKiAgQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlPWZhbHNlXSBDb21wbGV0ZWx5IHJlbW92ZSB0aGUgdGFibGUgZnJvbSB0aGUgRE9NXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgLy8gVGhpcyBleGFtcGxlIGlzIGZhaXJseSBwb2ludGxlc3MgaW4gcmVhbGl0eSwgYnV0IHNob3dzIGhvdyBmbkRlc3Ryb3kgY2FuIGJlIHVzZWRcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRGVzdHJveSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRGVzdHJveSA9IGZ1bmN0aW9uICggcmVtb3ZlIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLmRlc3Ryb3koIHJlbW92ZSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVkcmF3IHRoZSB0YWJsZVxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtjb21wbGV0ZT10cnVlXSBSZS1maWx0ZXIgYW5kIHJlc29ydCAoaWYgZW5hYmxlZCkgdGhlIHRhYmxlIGJlZm9yZSB0aGUgZHJhdy5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gUmUtZHJhdyB0aGUgdGFibGUgLSB5b3Ugd291bGRuJ3Qgd2FudCB0byBkbyBpdCBoZXJlLCBidXQgaXQncyBhbiBleGFtcGxlIDotKVxuXHRcdCAqICAgICAgb1RhYmxlLmZuRHJhdygpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRHJhdyA9IGZ1bmN0aW9uKCBjb21wbGV0ZSApXG5cdFx0e1xuXHRcdFx0Ly8gTm90ZSB0aGF0IHRoaXMgaXNuJ3QgYW4gZXhhY3QgbWF0Y2ggdG8gdGhlIG9sZCBjYWxsIHRvIF9mbkRyYXcgLSBpdCB0YWtlc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50IHRoZSBuZXcgZGF0YSwgYnV0IGNhbiBob2xkIHBvc2l0aW9uLlxuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5kcmF3KCBjb21wbGV0ZSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyIHRoZSBpbnB1dCBiYXNlZCBvbiBkYXRhXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgU3RyaW5nIHRvIGZpbHRlciB0aGUgdGFibGUgb25cblx0XHQgKiAgQHBhcmFtIHtpbnR8bnVsbH0gW2lDb2x1bW5dIENvbHVtbiB0byBsaW1pdCBmaWx0ZXJpbmcgdG9cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZ2V4PWZhbHNlXSBUcmVhdCBhcyByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JTbWFydD10cnVlXSBQZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlNob3dHbG9iYWw9dHJ1ZV0gU2hvdyB0aGUgaW5wdXQgZ2xvYmFsIGZpbHRlciBpbiBpdCdzIGlucHV0IGJveChlcylcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYkNhc2VJbnNlbnNpdGl2ZT10cnVlXSBEbyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nICh0cnVlKSBvciBub3QgKGZhbHNlKVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTb21ldGltZSBsYXRlciAtIGZpbHRlci4uLlxuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCAndGVzdCBzdHJpbmcnICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5GaWx0ZXIgPSBmdW5jdGlvbiggc0lucHV0LCBpQ29sdW1uLCBiUmVnZXgsIGJTbWFydCwgYlNob3dHbG9iYWwsIGJDYXNlSW5zZW5zaXRpdmUgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0aWYgKCBpQ29sdW1uID09PSBudWxsIHx8IGlDb2x1bW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0YXBpLnNlYXJjaCggc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5jb2x1bW4oIGlDb2x1bW4gKS5zZWFyY2goIHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB3aG9sZSB0YWJsZSwgYW4gaW5kaXZpZHVhbCByb3cgb3IgYW4gaW5kaXZpZHVhbCBjZWxsIGJhc2VkIG9uIHRoZVxuXHRcdCAqIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG5cdFx0ICogIEBwYXJhbSB7aW50fG5vZGV9IFtzcmNdIEEgVFIgcm93IG5vZGUsIFREL1RIIGNlbGwgbm9kZSBvciBhbiBpbnRlZ2VyLiBJZiBnaXZlbiBhc1xuXHRcdCAqICAgIGEgVFIgbm9kZSB0aGVuIHRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhXG5cdFx0ICogICAgVEQvVEggY2VsbCBub2RlIHRoZW4gaUNvbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdGhlIGRhdGEgZm9yIHRoZVxuXHRcdCAqICAgIGNlbGwgcmV0dXJuZWQuIElmIGdpdmVuIGFzIGFuIGludGVnZXIsIHRoZW4gdGhpcyBpcyB0cmVhdGVkIGFzIHRoZSBhb0RhdGEgaW50ZXJuYWxcblx0XHQgKiAgICBkYXRhIGluZGV4IGZvciB0aGUgcm93IChzZWUgZm5HZXRQb3NpdGlvbikgYW5kIHRoZSBkYXRhIGZvciB0aGF0IHJvdyB1c2VkLlxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2NvbF0gT3B0aW9uYWwgY29sdW1uIGluZGV4IHRoYXQgeW91IHdhbnQgdGhlIGRhdGEgb2YuXG5cdFx0ICogIEByZXR1cm5zIHthcnJheXxvYmplY3R8c3RyaW5nfSBJZiBtUm93IGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgZGF0YSBmb3IgYWxsIHJvd3MgaXNcblx0XHQgKiAgICByZXR1cm5lZC4gSWYgbVJvdyBpcyBkZWZpbmVkLCBqdXN0IGRhdGEgZm9yIHRoYXQgcm93LCBhbmQgaXMgaUNvbCBpc1xuXHRcdCAqICAgIGRlZmluZWQsIG9ubHkgZGF0YSBmb3IgdGhlIGRlc2lnbmF0ZWQgY2VsbCBpcyByZXR1cm5lZC5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUm93IGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIHZhciBkYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuXHRcdCAqICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFycmF5IC8gb2JqZWN0IG9mIGRhdGEgZm9yIHRoZSByb3dcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBJbmRpdmlkdWFsIGNlbGwgZGF0YVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgdmFyIHNEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuXHRcdCAqICAgICAgICBhbGVydCggJ1RoZSBjZWxsIGNsaWNrZWQgb24gaGFkIHRoZSB2YWx1ZSBvZiAnK3NEYXRhICk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5HZXREYXRhID0gZnVuY3Rpb24oIHNyYywgY29sIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdGlmICggc3JjICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gc3JjLm5vZGVOYW1lID8gc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0XHRcblx0XHRcdFx0cmV0dXJuIGNvbCAhPT0gdW5kZWZpbmVkIHx8IHR5cGUgPT0gJ3RkJyB8fCB0eXBlID09ICd0aCcgP1xuXHRcdFx0XHRcdGFwaS5jZWxsKCBzcmMsIGNvbCApLmRhdGEoKSA6XG5cdFx0XHRcdFx0YXBpLnJvdyggc3JjICkuZGF0YSgpIHx8IG51bGw7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRyZXR1cm4gYXBpLmRhdGEoKS50b0FycmF5KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgYW4gYXJyYXkgb2YgdGhlIFRSIG5vZGVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlJ3MgYm9keS4gTm90ZSB0aGF0IHlvdSB3aWxsXG5cdFx0ICogdHlwaWNhbGx5IHdhbnQgdG8gdXNlIHRoZSAnJCcgQVBJIG1ldGhvZCBpbiBwcmVmZXJlbmNlIHRvIHRoaXMgYXMgaXQgaXMgbW9yZVxuXHRcdCAqIGZsZXhpYmxlLlxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2lSb3ddIE9wdGlvbmFsIHJvdyBpbmRleCBmb3IgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnRcblx0XHQgKiAgQHJldHVybnMge2FycmF5fG5vZGV9IElmIGlSb3cgaXMgdW5kZWZpbmVkLCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBUUiBlbGVtZW50c1xuXHRcdCAqICAgIGluIHRoZSB0YWJsZSdzIGJvZHksIG9yIGlSb3cgaXMgZGVmaW5lZCwganVzdCB0aGUgVFIgZWxlbWVudCByZXF1ZXN0ZWQuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEdldCB0aGUgbm9kZXMgZnJvbSB0aGUgdGFibGVcblx0XHQgKiAgICAgIHZhciBuTm9kZXMgPSBvVGFibGUuZm5HZXROb2RlcyggKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldE5vZGVzID0gZnVuY3Rpb24oIGlSb3cgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0cmV0dXJuIGlSb3cgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGFwaS5yb3coIGlSb3cgKS5ub2RlKCkgOlxuXHRcdFx0XHRhcGkucm93cygpLm5vZGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgYXJyYXkgaW5kZXhlcyBvZiBhIHBhcnRpY3VsYXIgY2VsbCBmcm9tIGl0J3MgRE9NIGVsZW1lbnRcblx0XHQgKiBhbmQgY29sdW1uIGluZGV4IGluY2x1ZGluZyBoaWRkZW4gY29sdW1uc1xuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5vZGUgdGhpcyBjYW4gZWl0aGVyIGJlIGEgVFIsIFREIG9yIFRIIGluIHRoZSB0YWJsZSdzIGJvZHlcblx0XHQgKiAgQHJldHVybnMge2ludH0gSWYgbk5vZGUgaXMgZ2l2ZW4gYXMgYSBUUiwgdGhlbiBhIHNpbmdsZSBpbmRleCBpcyByZXR1cm5lZCwgb3Jcblx0XHQgKiAgICBpZiBnaXZlbiBhcyBhIGNlbGwsIGFuIGFycmF5IG9mIFtyb3cgaW5kZXgsIGNvbHVtbiBpbmRleCAodmlzaWJsZSksXG5cdFx0ICogICAgY29sdW1uIGluZGV4IChhbGwpXSBpcyBnaXZlbi5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0YSBmcm9tIHRoZSBub2RlXG5cdFx0ICogICAgICAgIHZhciBhUG9zID0gb1RhYmxlLmZuR2V0UG9zaXRpb24oIHRoaXMgKTtcblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBHZXQgdGhlIGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogICAgICAgIHZhciBhRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIGFQb3NbMF0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBVcGRhdGUgdGhlIGRhdGEgYXJyYXkgYW5kIHJldHVybiB0aGUgdmFsdWVcblx0XHQgKiAgICAgICAgYURhdGFbIGFQb3NbMV0gXSA9ICdjbGlja2VkJztcblx0XHQgKiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnY2xpY2tlZCc7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEluaXQgRGF0YVRhYmxlc1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldFBvc2l0aW9uID0gZnVuY3Rpb24oIG5vZGUgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdFxuXHRcdFx0aWYgKCBub2RlTmFtZSA9PSAnVFInICkge1xuXHRcdFx0XHRyZXR1cm4gYXBpLnJvdyggbm9kZSApLmluZGV4KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggbm9kZU5hbWUgPT0gJ1REJyB8fCBub2RlTmFtZSA9PSAnVEgnICkge1xuXHRcdFx0XHR2YXIgY2VsbCA9IGFwaS5jZWxsKCBub2RlICkuaW5kZXgoKTtcblx0XHRcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRjZWxsLnJvdyxcblx0XHRcdFx0XHRjZWxsLmNvbHVtblZpc2libGUsXG5cdFx0XHRcdFx0Y2VsbC5jb2x1bW5cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgdG8gc2VlIGlmIGEgcm93IGlzICdvcGVuJyBvciBub3QuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIHRoZSB0YWJsZSByb3cgdG8gY2hlY2tcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdyBpcyBjdXJyZW50bHkgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgfSBlbHNlIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Jc09wZW4gPSBmdW5jdGlvbiggblRyIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmlzU2hvd24oKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XG5cdFx0ICogb24gZGlzcGxheSBvbiB0aGUgcGFnZSwgd2l0aCB0aGUgSFRNTCBjb250ZW50cyB0aGF0IGlzIHBhc3NlZCBpbnRvIHRoZVxuXHRcdCAqIGZ1bmN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gYXNrIGZvciBjb25maXJtYXRpb24gdGhhdCBhXG5cdFx0ICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIFRoZSB0YWJsZSByb3cgdG8gJ29wZW4nXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBtSHRtbCBUaGUgSFRNTCB0byBwdXQgaW50byB0aGUgcm93XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcblx0XHQgKiAgQHJldHVybnMge25vZGV9IFRoZSByb3cgb3BlbmVkLiBOb3RlIHRoYXQgaWYgdGhlIHRhYmxlIHJvdyBwYXNzZWQgaW4gYXMgdGhlXG5cdFx0ICogICAgZmlyc3QgcGFyYW1ldGVyLCBpcyBub3QgZm91bmQgaW4gdGhlIHRhYmxlLCB0aGlzIG1ldGhvZCB3aWxsIHNpbGVudGx5XG5cdFx0ICogICAgcmV0dXJuLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGU7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG5cdFx0ICogICAgICAgIH0gZWxzZSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuT3BlbiA9IGZ1bmN0aW9uKCBuVHIsIG1IdG1sLCBzQ2xhc3MgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSggdHJ1ZSApXG5cdFx0XHRcdC5yb3coIG5UciApXG5cdFx0XHRcdC5jaGlsZCggbUh0bWwsIHNDbGFzcyApXG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LmNoaWxkKClbMF07XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIHBhZ2luYXRpb24gLSBwcm92aWRlcyB0aGUgaW50ZXJuYWwgbG9naWMgZm9yIHBhZ2luYXRpb24gaW4gYSBzaW1wbGUgQVBJXG5cdFx0ICogZnVuY3Rpb24uIFdpdGggdGhpcyBmdW5jdGlvbiB5b3UgY2FuIGhhdmUgYSBEYXRhVGFibGVzIHRhYmxlIGdvIHRvIHRoZSBuZXh0LFxuXHRcdCAqIHByZXZpb3VzLCBmaXJzdCBvciBsYXN0IHBhZ2VzLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IG1BY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIiwgXCJuZXh0XCIgb3IgXCJsYXN0XCJcblx0XHQgKiAgICBvciBwYWdlIG51bWJlciB0byBqdW1wIHRvIChpbnRlZ2VyKSwgbm90ZSB0aGF0IHBhZ2UgMCBpcyB0aGUgZmlyc3QgcGFnZS5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuUGFnZUNoYW5nZSggJ25leHQnICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5QYWdlQ2hhbmdlID0gZnVuY3Rpb24gKCBtQWN0aW9uLCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5wYWdlKCBtQWN0aW9uICk7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBTaG93IGEgcGFydGljdWxhciBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgVGhlIGNvbHVtbiB3aG9zZSBkaXNwbGF5IHNob3VsZCBiZSBjaGFuZ2VkXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gYlNob3cgU2hvdyAodHJ1ZSkgb3IgaGlkZSAoZmFsc2UpIHRoZSBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBIaWRlIHRoZSBzZWNvbmQgY29sdW1uIGFmdGVyIGluaXRpYWxpc2F0aW9uXG5cdFx0ICogICAgICBvVGFibGUuZm5TZXRDb2x1bW5WaXMoIDEsIGZhbHNlICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5TZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIGlDb2wsIGJTaG93LCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jb2x1bW4oIGlDb2wgKS52aXNpYmxlKCBiU2hvdyApO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmNvbHVtbnMuYWRqdXN0KCkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzZXR0aW5ncyBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cblx0XHQgKiAgQHJldHVybnMge29iamVjdH0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIHZhciBvU2V0dGluZ3MgPSBvVGFibGUuZm5TZXR0aW5ncygpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTaG93IGFuIGV4YW1wbGUgcGFyYW1ldGVyIGZyb20gdGhlIHNldHRpbmdzXG5cdFx0ICogICAgICBhbGVydCggb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5TZXR0aW5ncyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tfZXh0LmlBcGlJbmRleF0gKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNvcnQgdGhlIHRhYmxlIGJ5IGEgcGFydGljdWxhciBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgdGhlIGRhdGEgaW5kZXggdG8gc29ydCBvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgbWF0Y2ggdGhlXG5cdFx0ICogICAgJ2Rpc3BsYXkgaW5kZXgnIGlmIHlvdSBoYXZlIGhpZGRlbiBkYXRhIGVudHJpZXNcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29ydCBpbW1lZGlhdGVseSB3aXRoIGNvbHVtbnMgMCBhbmQgMVxuXHRcdCAqICAgICAgb1RhYmxlLmZuU29ydCggWyBbMCwnYXNjJ10sIFsxLCdhc2MnXSBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Tb3J0ID0gZnVuY3Rpb24oIGFhU29ydCApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5vcmRlciggYWFTb3J0ICkuZHJhdygpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5Ob2RlIHRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc29ydCBsaXN0ZW5lciB0b1xuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtmbkNhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvcnQgb24gY29sdW1uIDEsIHdoZW4gJ3NvcnRlcicgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgb1RhYmxlLmZuU29ydExpc3RlbmVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29ydGVyJyksIDEgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5vcmRlci5saXN0ZW5lciggbk5vZGUsIGlDb2x1bW4sIGZuQ2FsbGJhY2sgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSBhIHRhYmxlIGNlbGwgb3Igcm93IC0gdGhpcyBtZXRob2Qgd2lsbCBhY2NlcHQgZWl0aGVyIGEgc2luZ2xlIHZhbHVlIHRvXG5cdFx0ICogdXBkYXRlIHRoZSBjZWxsIHdpdGgsIGFuIGFycmF5IG9mIHZhbHVlcyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGNvbHVtbiBvclxuXHRcdCAqIGFuIG9iamVjdCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlLiBUaGUgZnVuY3Rpb24gaXNcblx0XHQgKiBzZWxmLXJlZmVyZW5jaW5nIGluIG9yZGVyIHRvIG1ha2UgdGhlIG11bHRpIGNvbHVtbiB1cGRhdGVzIGVhc2llci5cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfSBtRGF0YSBEYXRhIHRvIHVwZGF0ZSB0aGUgY2VsbC9yb3cgd2l0aFxuXHRcdCAqICBAcGFyYW0ge25vZGV8aW50fSBtUm93IFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gdXBkYXRlIG9yIHRoZSBhb0RhdGEgaW5kZXhcblx0XHQgKiAgQHBhcmFtIHtpbnR9IFtpQ29sdW1uXSBUaGUgY29sdW1uIHRvIHVwZGF0ZSwgZ2l2ZSBhcyBudWxsIG9yIHVuZGVmaW5lZCB0b1xuXHRcdCAqICAgIHVwZGF0ZSBhIHdob2xlIHJvdy5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiQWN0aW9uPXRydWVdIFBlcmZvcm0gcHJlLWRyYXcgYWN0aW9ucyBvciBub3Rcblx0XHQgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCAxIG9uIGVycm9yXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5VcGRhdGUoICdFeGFtcGxlIHVwZGF0ZScsIDAsIDAgKTsgLy8gU2luZ2xlIGNlbGxcblx0XHQgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgJCgndGJvZHkgdHInKVswXSApOyAvLyBSb3dcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblVwZGF0ZSA9IGZ1bmN0aW9uKCBtRGF0YSwgbVJvdywgaUNvbHVtbiwgYlJlZHJhdywgYkFjdGlvbiApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRpZiAoIGlDb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBpQ29sdW1uID09PSBudWxsICkge1xuXHRcdFx0XHRhcGkucm93KCBtUm93ICkuZGF0YSggbURhdGEgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhcGkuY2VsbCggbVJvdywgaUNvbHVtbiApLmRhdGEoIG1EYXRhICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIGJBY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBiQWN0aW9uICkge1xuXHRcdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nIHVzZWQsIGluIG9yZGVyXG5cdFx0ICogdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzVmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLiBOb3RlIHRoYXQgdGhlXG5cdFx0ICogICAgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZSByZXF1aXJlZFxuXHRcdCAqICAgIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90IHN1aXRhYmxlXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIGFsZXJ0KCBvVGFibGUuZm5WZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuVmVyc2lvbkNoZWNrID0gX2V4dC5mblZlcnNpb25DaGVjaztcblx0XHRcblxuXHRcdHZhciBfdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGVtcHR5SW5pdCA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZDtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGVtcHR5SW5pdCApIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9XG5cblx0XHR0aGlzLm9BcGkgPSB0aGlzLmludGVybmFsID0gX2V4dC5pbnRlcm5hbDtcblxuXHRcdC8vIEV4dGVuZCB3aXRoIG9sZCBzdHlsZSBwbHVnLWluIEFQSSBtZXRob2RzXG5cdFx0Zm9yICggdmFyIGZuIGluIERhdGFUYWJsZS5leHQuaW50ZXJuYWwgKSB7XG5cdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHR0aGlzW2ZuXSA9IF9mbkV4dGVybkFwaUZ1bmMoZm4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdC8vIEZvciBlYWNoIGluaXRpYWxpc2F0aW9uIHdlIHdhbnQgdG8gZ2l2ZSBpdCBhIGNsZWFuIGluaXRpYWxpc2F0aW9uXG5cdFx0XHQvLyBvYmplY3QgdGhhdCBjYW4gYmUgYmFzaGVkIGFyb3VuZFxuXHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdHZhciBvSW5pdCA9IGxlbiA+IDEgPyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSB0YWJsZSBjYXNlXG5cdFx0XHRcdF9mbkV4dGVuZCggbywgb3B0aW9ucywgdHJ1ZSApIDpcblx0XHRcdFx0b3B0aW9ucztcblxuXHRcdFx0LypnbG9iYWwgb0luaXQsX3RoYXQsZW1wdHlJbml0Ki9cblx0XHRcdHZhciBpPTAsIGlMZW4sIGosIGpMZW4sIGssIGtMZW47XG5cdFx0XHR2YXIgc0lkID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdHZhciBiSW5pdEhhbmRlZE9mZiA9IGZhbHNlO1xuXHRcdFx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvKiBTYW5pdHkgY2hlY2sgKi9cblx0XHRcdGlmICggdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICd0YWJsZScgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5Mb2coIG51bGwsIDAsICdOb24tdGFibGUgbm9kZSBpbml0aWFsaXNhdGlvbiAoJyt0aGlzLm5vZGVOYW1lKycpJywgMiApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgZGVmYXVsdHMgKi9cblx0XHRcdF9mbkNvbXBhdE9wdHMoIGRlZmF1bHRzICk7XG5cdFx0XHRfZm5Db21wYXRDb2xzKCBkZWZhdWx0cy5jb2x1bW4gKTtcblx0XHRcdFxuXHRcdFx0LyogQ29udmVydCB0aGUgY2FtZWwtY2FzZSBkZWZhdWx0cyB0byBIdW5nYXJpYW4gKi9cblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCBkZWZhdWx0cywgdHJ1ZSApO1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUgKTtcblx0XHRcdFxuXHRcdFx0LyogU2V0dGluZyB1cCB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0ICovXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgJC5leHRlbmQoIG9Jbml0LCAkdGhpcy5kYXRhKCkgKSwgdHJ1ZSApO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xuXHRcdFx0dmFyIGFsbFNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFsbFNldHRpbmdzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBzID0gYWxsU2V0dGluZ3NbaV07XG5cdFx0XHRcblx0XHRcdFx0LyogQmFzZSBjaGVjayBvbiB0YWJsZSBub2RlICovXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRzLm5UYWJsZSA9PSB0aGlzIHx8XG5cdFx0XHRcdFx0KHMublRIZWFkICYmIHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcykgfHxcblx0XHRcdFx0XHQocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdFx0dmFyIGJEZXN0cm95ID0gb0luaXQuYkRlc3Ryb3kgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJEZXN0cm95IDogZGVmYXVsdHMuYkRlc3Ryb3k7XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBzLm9JbnN0YW5jZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGJEZXN0cm95IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxuXHRcdFx0XHQgKiBpbml0aWFsaXNlZCwgYnV0IHRoZSB0YWJsZSBub2RlcyBkb24ndCBtYXRjaCAoZnJvbSBiZWZvcmUpIHRoZW4gd2UgZGVzdHJveSB0aGUgb2xkXG5cdFx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0XHQgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFNldHRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cblx0XHRcdGlmICggc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIiApXG5cdFx0XHR7XG5cdFx0XHRcdHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIisoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuXHRcdFx0XHR0aGlzLmlkID0gc0lkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xuXHRcdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFx0XCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XHRcInNJbnN0YW5jZVwiOiAgICAgc0lkLFxuXHRcdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkXG5cdFx0XHR9ICk7XG5cdFx0XHRvU2V0dGluZ3MublRhYmxlID0gdGhpcztcblx0XHRcdG9TZXR0aW5ncy5vQXBpICAgPSBfdGhhdC5pbnRlcm5hbDtcblx0XHRcdG9TZXR0aW5ncy5vSW5pdCAgPSBvSW5pdDtcblx0XHRcdFxuXHRcdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdC8vIE5lZWQgdG8gYWRkIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBhZGRlZFxuXHRcdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRcdG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoPT09MSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRcdF9mbkNvbXBhdE9wdHMoIG9Jbml0ICk7XG5cdFx0XHRfZm5MYW5ndWFnZUNvbXBhdCggb0luaXQub0xhbmd1YWdlICk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBsZW5ndGggbWVudSBpcyBnaXZlbiwgYnV0IHRoZSBpbml0IGRpc3BsYXkgbGVuZ3RoIGlzIG5vdCwgdXNlIHRoZSBsZW5ndGggbWVudVxuXHRcdFx0aWYgKCBvSW5pdC5hTGVuZ3RoTWVudSAmJiAhIG9Jbml0LmlEaXNwbGF5TGVuZ3RoIClcblx0XHRcdHtcblx0XHRcdFx0b0luaXQuaURpc3BsYXlMZW5ndGggPSBBcnJheS5pc0FycmF5KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApID9cblx0XHRcdFx0XHRvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcdFwiYkluZm9cIixcblx0XHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFx0XCJhc1N0cmlwZUNsYXNzZXNcIixcblx0XHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XHRcInNBamF4U291cmNlXCIsXG5cdFx0XHRcdFwic0FqYXhEYXRhUHJvcFwiLFxuXHRcdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFx0XCJyb3dJZFwiLFxuXHRcdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFx0WyBcImFvU2VhcmNoQ29sc1wiLCBcImFvUHJlU2VhcmNoQ29sc1wiIF0sXG5cdFx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF1cblx0XHRcdF0gKTtcblx0XHRcdF9mbk1hcCggb1NldHRpbmdzLm9TY3JvbGwsIG9Jbml0LCBbXG5cdFx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxZXCIsIFwic1lcIiBdLFxuXHRcdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdFx0XSApO1xuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0xhbmd1YWdlLCBvSW5pdCwgXCJmbkluZm9DYWxsYmFja1wiICk7XG5cdFx0XHRcblx0XHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAgICAgICBvSW5pdC5mbkRyYXdDYWxsYmFjaywgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICAgICAgIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgICAgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQsICAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCAgICAgICAgb0luaXQuZm5Sb3dDYWxsYmFjaywgICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3csICAgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAgICAgICBvSW5pdC5mbkluaXRDb21wbGV0ZSwgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAgICd1c2VyJyApO1xuXHRcdFx0XG5cdFx0XHRvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbiggb0luaXQucm93SWQgKTtcblx0XHRcdFxuXHRcdFx0LyogQnJvd3NlciBzdXBwb3J0IGRldGVjdGlvbiAqL1xuXHRcdFx0X2ZuQnJvd3NlckRldGVjdCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdHZhciBvQ2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFxuXHRcdFx0JC5leHRlbmQoIG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0XHQkdGhpcy5hZGRDbGFzcyggb0NsYXNzZXMuc1RhYmxlICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXG5cdFx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQuaURlZmVyTG9hZGluZyAhPT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHRtcCA9IEFycmF5LmlzQXJyYXkoIG9Jbml0LmlEZWZlckxvYWRpbmcgKTtcblx0XHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzBdIDogb0luaXQuaURlZmVyTG9hZGluZztcblx0XHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gdG1wID8gb0luaXQuaURlZmVyTG9hZGluZ1sxXSA6IG9Jbml0LmlEZWZlckxvYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIExhbmd1YWdlIGRlZmluaXRpb25zICovXG5cdFx0XHR2YXIgb0xhbmd1YWdlID0gb1NldHRpbmdzLm9MYW5ndWFnZTtcblx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFx0XG5cdFx0XHRpZiAoIG9MYW5ndWFnZS5zVXJsIClcblx0XHRcdHtcblx0XHRcdFx0LyogR2V0IHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyBmcm9tIGEgZmlsZSAtIGJlY2F1c2UgdGhpcyBBamF4IGNhbGwgbWFrZXMgdGhlIGxhbmd1YWdlXG5cdFx0XHRcdCAqIGdldCBhc3luYyB0byB0aGUgcmVtYWluZGVyIG9mIHRoaXMgZnVuY3Rpb24gd2UgdXNlIGJJbml0SGFuZGVkT2ZmIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdFx0ICogX2ZuSW5pdGlhbGlzZSB3aWxsIGJlIGZpcmVkIGJ5IHRoZSByZXR1cm5lZCBBamF4IGhhbmRsZXIsIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvclxuXHRcdFx0XHQgKi9cblx0XHRcdFx0JC5hamF4KCB7XG5cdFx0XHRcdFx0ZGF0YVR5cGU6ICdqc29uJyxcblx0XHRcdFx0XHR1cmw6IG9MYW5ndWFnZS5zVXJsLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdFx0X2ZuTGFuZ3VhZ2VDb21wYXQoIGpzb24gKTtcblx0XHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIGpzb24gKTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdpMThuJywgW29TZXR0aW5nc10pO1xuXHRcdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlLCBjb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxuXHRcdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGJJbml0SGFuZGVkT2ZmID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ2kxOG4nLCBbb1NldHRpbmdzXSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQgKiBTdHJpcGVzXG5cdFx0XHQgKi9cblx0XHRcdGlmICggb0luaXQuYXNTdHJpcGVDbGFzc2VzID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0b1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcyA9W1xuXHRcdFx0XHRcdG9DbGFzc2VzLnNTdHJpcGVPZGQsXG5cdFx0XHRcdFx0b0NsYXNzZXMuc1N0cmlwZUV2ZW5cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogUmVtb3ZlIHJvdyBzdHJpcGUgY2xhc3NlcyBpZiB0aGV5IGFyZSBhbHJlYWR5IG9uIHRoZSB0YWJsZSByb3cgKi9cblx0XHRcdHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcztcblx0XHRcdHZhciByb3dPbmUgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKS5maW5kKCd0cicpLmVxKDApO1xuXHRcdFx0aWYgKCAkLmluQXJyYXkoIHRydWUsICQubWFwKCBzdHJpcGVDbGFzc2VzLCBmdW5jdGlvbihlbCwgaSkge1xuXHRcdFx0XHRyZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcblx0XHRcdH0gKSApICE9PSAtMSApIHtcblx0XHRcdFx0JCgndGJvZHkgdHInLCB0aGlzKS5yZW1vdmVDbGFzcyggc3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykgKTtcblx0XHRcdFx0b1NldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMgPSBzdHJpcGVDbGFzc2VzLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQgKiBDb2x1bW5zXG5cdFx0XHQgKiBTZWUgaWYgd2Ugc2hvdWxkIGxvYWQgY29sdW1ucyBhdXRvbWF0aWNhbGx5IG9yIHVzZSBkZWZpbmVkIG9uZXNcblx0XHRcdCAqL1xuXHRcdFx0dmFyIGFuVGhzID0gW107XG5cdFx0XHR2YXIgYW9Db2x1bW5zSW5pdDtcblx0XHRcdHZhciBuVGhlYWQgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aGVhZCcpO1xuXHRcdFx0aWYgKCBuVGhlYWQubGVuZ3RoICE9PSAwIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MuYW9IZWFkZXIsIG5UaGVhZFswXSApO1xuXHRcdFx0XHRhblRocyA9IF9mbkdldFVuaXF1ZVRocyggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIElmIG5vdCBnaXZlbiBhIGNvbHVtbiBhcnJheSwgZ2VuZXJhdGUgb25lIHdpdGggbnVsbHMgKi9cblx0XHRcdGlmICggb0luaXQuYW9Db2x1bW5zID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0YW9Db2x1bW5zSW5pdCA9IFtdO1xuXHRcdFx0XHRmb3IgKCBpPTAsIGlMZW49YW5UaHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFvQ29sdW1uc0luaXQucHVzaCggbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGFvQ29sdW1uc0luaXQgPSBvSW5pdC5hb0NvbHVtbnM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEFkZCB0aGUgY29sdW1ucyAqL1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29sdW1uc0luaXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MsIGFuVGhzID8gYW5UaHNbaV0gOiBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEFwcGx5IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgKi9cblx0XHRcdF9mbkFwcGx5Q29sdW1uRGVmcyggb1NldHRpbmdzLCBvSW5pdC5hb0NvbHVtbkRlZnMsIGFvQ29sdW1uc0luaXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XG5cdFx0XHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb0RlZiApO1xuXHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHQvKiBIVE1MNSBhdHRyaWJ1dGUgZGV0ZWN0aW9uIC0gYnVpbGQgYW4gbURhdGEgb2JqZWN0IGF1dG9tYXRpY2FsbHkgaWYgdGhlXG5cdFx0XHQgKiBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIHJvd09uZS5sZW5ndGggKSB7XG5cdFx0XHRcdHZhciBhID0gZnVuY3Rpb24gKCBjZWxsLCBuYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBjZWxsLmdldEF0dHJpYnV0ZSggJ2RhdGEtJytuYW1lICkgIT09IG51bGwgPyBuYW1lIDogbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XHQkKCByb3dPbmVbMF0gKS5jaGlsZHJlbigndGgsIHRkJykuZWFjaCggZnVuY3Rpb24gKGksIGNlbGwpIHtcblx0XHRcdFx0XHR2YXIgY29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcblx0XHRcdFxuXHRcdFx0XHRcdGlmICggY29sLm1EYXRhID09PSBpICkge1xuXHRcdFx0XHRcdFx0dmFyIHNvcnQgPSBhKCBjZWxsLCAnc29ydCcgKSB8fCBhKCBjZWxsLCAnb3JkZXInICk7XG5cdFx0XHRcdFx0XHR2YXIgZmlsdGVyID0gYSggY2VsbCwgJ2ZpbHRlcicgKSB8fCBhKCBjZWxsLCAnc2VhcmNoJyApO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoIHNvcnQgIT09IG51bGwgfHwgZmlsdGVyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRjb2wubURhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XzogICAgICBpKycuZGlzcGxheScsXG5cdFx0XHRcdFx0XHRcdFx0c29ydDogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyOiBmaWx0ZXIgIT09IG51bGwgPyBpKycuQGRhdGEtJytmaWx0ZXIgOiB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XHRcdHZhciBsb2FkZWRJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBTb3J0aW5nXG5cdFx0XHRcdCAqIEB0b2RvIEZvciBtb2R1bGFyaXNhdGlvbiAoMS4xMSkgdGhpcyBuZWVkcyB0byBkbyBpbnRvIGEgc29ydCBzdGFydCB1cCBoYW5kbGVyXG5cdFx0XHRcdCAqL1xuXHRcdFx0XG5cdFx0XHRcdC8vIElmIGFhU29ydGluZyBpcyBub3QgZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGluZGljYXRvciBpbiBhc1NvcnRpbmdcblx0XHRcdFx0Ly8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cblx0XHRcdFx0aWYgKCBvSW5pdC5hYVNvcnRpbmcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR2YXIgc29ydGluZyA9IG9TZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0XHRcdFx0Zm9yICggaT0wLCBpTGVuPXNvcnRpbmcubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0c29ydGluZ1tpXVsxXSA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGkgXS5hc1NvcnRpbmdbMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cblx0XHRcdFx0ICogYWNjb3VudCwgYW5kIGFsc28gd2lsbCBhcHBseSBzb3J0aW5nIGRpc2FibGVkIGNsYXNzZXMgaWYgZGlzYWJsZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdFxuXHRcdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmICggb1NldHRpbmdzLmJTb3J0ZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdFx0dmFyIHNvcnRlZENvbHVtbnMgPSB7fTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHQkLmVhY2goIGFTb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0c29ydGVkQ29sdW1uc1sgdmFsLnNyYyBdID0gdmFsLmRpcjtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydCwgc29ydGVkQ29sdW1uc10gKTtcblx0XHRcdFx0XHRcdFx0X2ZuU29ydEFyaWEoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIgKSB7XG5cdFx0XHRcdFx0XHRfZm5Tb3J0aW5nQ2xhc3Nlcyggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAnc2MnICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBGaW5hbCBpbml0XG5cdFx0XHRcdCAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcblx0XHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xuXHRcdFx0XHR2YXIgY2FwdGlvbnMgPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLl9jYXB0aW9uU2lkZSA9ICQodGhpcykuY3NzKCdjYXB0aW9uLXNpZGUnKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHRcdHZhciB0aGVhZCA9ICR0aGlzLmNoaWxkcmVuKCd0aGVhZCcpO1xuXHRcdFx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHR0aGVhZCA9ICQoJzx0aGVhZC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcblx0XHRcdFx0aWYgKCB0Ym9keS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0dGJvZHkgPSAkKCc8dGJvZHkvPicpLmluc2VydEFmdGVyKHRoZWFkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XG5cdFx0XHRcblx0XHRcdFx0dmFyIHRmb290ID0gJHRoaXMuY2hpbGRyZW4oJ3Rmb290Jyk7XG5cdFx0XHRcdGlmICggdGZvb3QubGVuZ3RoID09PSAwICYmIGNhcHRpb25zLmxlbmd0aCA+IDAgJiYgKG9TZXR0aW5ncy5vU2Nyb2xsLnNYICE9PSBcIlwiIHx8IG9TZXR0aW5ncy5vU2Nyb2xsLnNZICE9PSBcIlwiKSApIHtcblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgYSBzY3JvbGxpbmcgdGFibGUsIGFuZCBubyBmb290ZXIgaGFzIGJlZW4gZ2l2ZW4sIHRoZW4gd2UgbmVlZCB0byBjcmVhdGVcblx0XHRcdFx0XHQvLyBhIHRmb290IGVsZW1lbnQgZm9yIHRoZSBjYXB0aW9uIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgdG9cblx0XHRcdFx0XHR0Zm9vdCA9ICQoJzx0Zm9vdC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0aWYgKCB0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0JHRoaXMuYWRkQ2xhc3MoIG9DbGFzc2VzLnNOb0Zvb3RlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0Zm9vdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdG9TZXR0aW5ncy5uVEZvb3QgPSB0Zm9vdFswXTtcblx0XHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIG9TZXR0aW5ncy5hb0Zvb3Rlciwgb1NldHRpbmdzLm5URm9vdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yICovXG5cdFx0XHRcdGlmICggb0luaXQuYWFEYXRhICkge1xuXHRcdFx0XHRcdGZvciAoIGk9MCA7IGk8b0luaXQuYWFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRcdF9mbkFkZERhdGEoIG9TZXR0aW5ncywgb0luaXQuYWFEYXRhWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdkb20nICkge1xuXHRcdFx0XHRcdC8qIEdyYWIgdGhlIGRhdGEgZnJvbSB0aGUgcGFnZSAtIG9ubHkgZG8gdGhpcyB3aGVuIGRlZmVycmVkIGxvYWRpbmcgb3Igbm8gQWpheFxuXHRcdFx0XHRcdCAqIHNvdXJjZSBzaW5jZSB0aGVyZSBpcyBubyBwb2ludCBpbiByZWFkaW5nIHRoZSBET00gZGF0YSBpZiB3ZSBhcmUgdGhlbiBnb2luZ1xuXHRcdFx0XHRcdCAqIHRvIHJlcGxhY2UgaXQgd2l0aCBBamF4IGRhdGFcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRfZm5BZGRUciggb1NldHRpbmdzLCAkKG9TZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpICk7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHQvKiBDb3B5IHRoZSBkYXRhIGluZGV4IGFycmF5ICovXG5cdFx0XHRcdG9TZXR0aW5ncy5haURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XHRcblx0XHRcdFx0LyogSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd24gKi9cblx0XHRcdFx0b1NldHRpbmdzLmJJbml0aWFsaXNlZCA9IHRydWU7XG5cdFx0XHRcblx0XHRcdFx0LyogQ2hlY2sgaWYgd2UgbmVlZCB0byBpbml0aWFsaXNlIHRoZSB0YWJsZSAoaXQgbWlnaHQgbm90IGhhdmUgYmVlbiBoYW5kZWQgb2ZmIHRvIHRoZVxuXHRcdFx0XHQgKiBsYW5ndWFnZSBwcm9jZXNzb3IpXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGJJbml0SGFuZGVkT2ZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyogTXVzdCBiZSBkb25lIGFmdGVyIGV2ZXJ5dGhpbmcgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0YXRlIHNhdmluZyEgKi9cblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIF9mblNhdmVTdGF0ZSwgJ3N0YXRlX3NhdmUnICk7XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQuYlN0YXRlU2F2ZSApXG5cdFx0XHR7XG5cdFx0XHRcdGZlYXR1cmVzLmJTdGF0ZVNhdmUgPSB0cnVlO1xuXHRcdFx0XHRfZm5Mb2FkU3RhdGUoIG9TZXR0aW5ncywgb0luaXQsIGxvYWRlZEluaXQgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsb2FkZWRJbml0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9ICk7XG5cdFx0X3RoYXQgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdFxuXHQvKlxuXHQgKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXG5cdCAqIERhdGFUYWJsZXMgZnVuY3Rpb25zIGNhbiBhY2Nlc3MgdGhlbSBhbmQgdGhleSBkb24ndCBsZWFrIGludG8gZ2xvYmFsIHNwYWNlLlxuXHQgKiBBdCB0aGUgc2FtZSB0aW1lIHRoZXNlIGZ1bmN0aW9ucyBhcmUgb2Z0ZW4gdXNlZnVsIG92ZXIgbXVsdGlwbGUgZmlsZXMgaW4gdGhlXG5cdCAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcblx0ICogYnkgRGF0YVRhYmxlcyBhcyBwcml2YXRlIHZhcmlhYmxlcyBoZXJlLiBUaGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vXG5cdCAqIGNsYXNoaW5nIG9mIHZhcmlhYmxlIG5hbWVzIGFuZCB0aGF0IHRoZXkgY2FuIGVhc2lseSByZWZlcmVuY2VkIGZvciByZXVzZS5cblx0ICovXG5cdFxuXHRcblx0Ly8gRGVmaW5lZCBlbHNlIHdoZXJlXG5cdC8vICBfc2VsZWN0b3JfcnVuXG5cdC8vICBfc2VsZWN0b3Jfb3B0c1xuXHQvLyAgX3NlbGVjdG9yX2ZpcnN0XG5cdC8vICBfc2VsZWN0b3Jfcm93X2luZGV4ZXNcblx0XG5cdHZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XG5cdHZhciBfQXBpOyAvLyBEYXRhVGFibGUuQXBpXG5cdHZhciBfYXBpX3JlZ2lzdGVyOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyXG5cdHZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXG5cdFxuXHR2YXIgX3JlX2RpYyA9IHt9O1xuXHR2YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXFx1MjAyOF0vZztcblx0dmFyIF9yZV9odG1sID0gLzwuKj8+L2c7XG5cdFxuXHQvLyBUaGlzIGlzIG5vdCBzdHJpY3QgSVNPODYwMSAtIERhdGUucGFyc2UoKSBpcyBxdWl0ZSBsYXgsIGFsdGhvdWdoXG5cdC8vIGltcGxlbWVudGF0aW9ucyBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy5cblx0dmFyIF9yZV9kYXRlID0gL15cXGR7Miw0fVtcXC5cXC9cXC1dXFxkezEsMn1bXFwuXFwvXFwtXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6XFwuXVxcZHsyfShbXFwuOl1cXGR7Mn0pPyk/JC87XG5cdFxuXHQvLyBFc2NhcGUgcmVndWxhciBleHByZXNzaW9uIHNwZWNpYWwgY2hhcmFjdGVyc1xuXHR2YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoICcoXFxcXCcgKyBbICcvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJywgJyQnLCAnXicsICctJyBdLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyApO1xuXHRcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JlaWduX2V4Y2hhbmdlX21hcmtldFxuXHQvLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxuXHQvLyAtIFxcdTIwYTkgLSBTb3V0aCBLb3JlYW4gV29uXG5cdC8vIC0gXFx1MjBCQSAtIFR1cmtpc2ggTGlyYVxuXHQvLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcblx0Ly8gLSBSIC0gQnJhemlsIChSJCkgYW5kIFNvdXRoIEFmcmljYVxuXHQvLyAtIGZyIC0gU3dpc3MgRnJhbmNcblx0Ly8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXG5cdC8vIC0gXFx1MjAwOSBpcyB0aGluIHNwYWNlIGFuZCBcXHUyMDJGIGlzIG5hcnJvdyBuby1icmVhayBzcGFjZSwgYm90aCB1c2VkIGluIG1hbnlcblx0Ly8gLSDJgyAtIEJpdGNvaW5cblx0Ly8gLSDOniAtIEV0aGVyZXVtXG5cdC8vICAgc3RhbmRhcmRzIGFzIHRob3VzYW5kcyBzZXBhcmF0b3JzLlxuXHR2YXIgX3JlX2Zvcm1hdHRlZF9udW1lcmljID0gL1snXFx1MDBBMCwkwqPigqzCpSVcXHUyMDA5XFx1MjAyRlxcdTIwQkRcXHUyMGE5XFx1MjBCQXJma8mDzp5dL2dpO1xuXHRcblx0XG5cdHZhciBfZW1wdHkgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfaW50VmFsID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoIHMsIDEwICk7XG5cdFx0cmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xuXHR9O1xuXHRcblx0Ly8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXG5cdC8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcblx0dmFyIF9udW1Ub0RlY2ltYWwgPSBmdW5jdGlvbiAoIG51bSwgZGVjaW1hbFBvaW50ICkge1xuXHRcdC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cblx0XHRpZiAoICEgX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gKSB7XG5cdFx0XHRfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSA9IG5ldyBSZWdFeHAoIF9mbkVzY2FwZVJlZ2V4KCBkZWNpbWFsUG9pbnQgKSwgJ2cnICk7XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBkZWNpbWFsUG9pbnQgIT09ICcuJyA/XG5cdFx0XHRudW0ucmVwbGFjZSggL1xcLi9nLCAnJyApLnJlcGxhY2UoIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdLCAnLicgKSA6XG5cdFx0XHRudW07XG5cdH07XG5cdFxuXHRcblx0dmFyIF9pc051bWJlciA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSB7XG5cdFx0dmFyIHN0clR5cGUgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZyc7XG5cdFxuXHRcdC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcblx0XHQvLyBmb3JtYXR0ZWQgc3RyaW5nICh0aGlzIHN0b3BzIHRoZSBzdHJpbmcgXCJrXCIsIG9yIFwia3JcIiwgZXRjIGJlaW5nIGRldGVjdGVkXG5cdFx0Ly8gYXMgYSBmb3JtYXR0ZWQgbnVtYmVyIGZvciBjdXJyZW5jeVxuXHRcdGlmICggX2VtcHR5KCBkICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0XHRkID0gX251bVRvRGVjaW1hbCggZCwgZGVjaW1hbFBvaW50ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZvcm1hdHRlZCAmJiBzdHJUeXBlICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChkKSApICYmIGlzRmluaXRlKCBkICk7XG5cdH07XG5cdFxuXHRcblx0Ly8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcblx0dmFyIF9pc0h0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcblx0fTtcblx0XG5cdFxuXHR2YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApIHtcblx0XHRpZiAoIF9lbXB0eSggZCApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHRtbCA9IF9pc0h0bWwoIGQgKTtcblx0XHRyZXR1cm4gISBodG1sID9cblx0XHRcdG51bGwgOlxuXHRcdFx0X2lzTnVtYmVyKCBfc3RyaXBIdG1sKCBkICksIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkICkgP1xuXHRcdFx0XHR0cnVlIDpcblx0XHRcdFx0bnVsbDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3BsdWNrID0gZnVuY3Rpb24gKCBhLCBwcm9wLCBwcm9wMiApIHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGk9MCwgaWVuPWEubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhW2ldICYmIGFbaV1bIHByb3AgXSApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFbaV0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdC8vIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBfcGx1Y2ssIGJ1dCByYXRoZXIgdGhhbiBsb29waW5nIG92ZXIgYGFgIHdlIHVzZSBgb3JkZXJgXG5cdC8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcblx0dmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uICggYSwgb3JkZXIsIHByb3AsIHByb3AyIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgaT0wLCBpZW49b3JkZXIubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JhbmdlID0gZnVuY3Rpb24gKCBsZW4sIHN0YXJ0IClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgZW5kO1xuXHRcblx0XHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRlbmQgPSBsZW47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IGxlbjtcblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPXN0YXJ0IDsgaTxlbmQgOyBpKysgKSB7XG5cdFx0XHRvdXQucHVzaCggaSApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKCBhIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gKSB7IC8vIGNhcmVmdWwgLSB3aWxsIHJlbW92ZSBhbGwgZmFsc3kgdmFsdWVzIVxuXHRcdFx0XHRvdXQucHVzaCggYVtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gZC5yZXBsYWNlKCBfcmVfaHRtbCwgJycgKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGFsbCB2YWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB1bmlxdWUuIFRoaXMgbWVhbnMgd2UgY2FuIHNob3J0XG5cdCAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuXHQgKiB0byBlYXNpbHkgY2hlY2sgdGhlIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbGwgdW5pcXVlLCBmYWxzZSBvdGhlcndpc2Vcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9hcmVBbGxVbmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRpZiAoIHNyYy5sZW5ndGggPCAyICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHRcdHZhciBsYXN0ID0gc29ydGVkWzBdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBzb3J0ZWRbaV0gPT09IGxhc3QgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRsYXN0ID0gc29ydGVkW2ldO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbmQgdGhlIHVuaXF1ZSBlbGVtZW50cyBpbiBhIHNvdXJjZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX3VuaXF1ZSA9IGZ1bmN0aW9uICggc3JjIClcblx0e1xuXHRcdGlmICggX2FyZUFsbFVuaXF1ZSggc3JjICkgKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcblx0XHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdFx0Ly8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcblx0XHQvLyBpbmZvcm1hdGlvbi5cblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0XHRqLCBrPTA7XG5cdFxuXHRcdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhbCA9IHNyY1tpXTtcblx0XG5cdFx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRcdGlmICggb3V0W2pdID09PSB2YWwgKSB7XG5cdFx0XHRcdFx0Y29udGludWUgYWdhaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0XHRrKys7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0Ly8gU3VycHJpc2luZ2x5IHRoaXMgaXMgZmFzdGVyIHRoYW4gW10uY29uY2F0LmFwcGx5XG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9mbGF0dGVuLWFuLWFycmF5LWxvb3AtdnMtcmVkdWNlLzJcblx0dmFyIF9mbGF0dGVuID0gZnVuY3Rpb24gKG91dCwgdmFsKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTx2YWwubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRcdF9mbGF0dGVuKG91dCwgdmFsW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRvdXQucHVzaCh2YWwpO1xuXHRcdH1cblx0ICBcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cdFxuXHR2YXIgX2luY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaCwgc3RhcnQpIHtcblx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XHRcblx0fTtcblx0XG5cdC8vIEFycmF5LmlzQXJyYXkgcG9seWZpbGwuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcblx0aWYgKCEgQXJyYXkuaXNBcnJheSkge1xuXHQgICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuXHQgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0ICAgIH07XG5cdH1cblx0XG5cdGlmICghIEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xuXHRcdEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcyA9IF9pbmNsdWRlcztcblx0fVxuXHRcblx0Ly8gLnRyaW0oKSBwb2x5ZmlsbFxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbVxuXHRpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHQgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cdCAgfTtcblx0fVxuXHRcblx0aWYgKCEgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcykge1xuXHRcdFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMgPSBfaW5jbHVkZXM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIHV0aWxpdHkgbWV0aG9kc1xuXHQgKiBcblx0ICogVGhpcyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIG1ldGhvZHMgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW50ZXJuYWxseSB0b1xuXHQgKiBjcmVhdGUgYSBEYXRhVGFibGUsIGJ1dCB3aGljaCBhcmUgbm90IGV4Y2x1c2l2ZWx5IHVzZWQgb25seSBmb3IgRGF0YVRhYmxlcy5cblx0ICogVGhlc2UgbWV0aG9kcyBjYW4gYmUgdXNlZCBieSBleHRlbnNpb24gYXV0aG9ycyB0byBzYXZlIHRoZSBkdXBsaWNhdGlvbiBvZlxuXHQgKiBjb2RlLlxuXHQgKlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLnV0aWwgPSB7XG5cdFx0LyoqXG5cdFx0ICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZFxuXHRcdCAqIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfSBmcmVxIENhbGwgZnJlcXVlbmN5IGluIG1TXG5cdFx0ICogQHJldHVybiB7ZnVuY3Rpb259IFdyYXBwZWQgZnVuY3Rpb25cblx0XHQgKi9cblx0XHR0aHJvdHRsZTogZnVuY3Rpb24gKCBmbiwgZnJlcSApIHtcblx0XHRcdHZhclxuXHRcdFx0XHRmcmVxdWVuY3kgPSBmcmVxICE9PSB1bmRlZmluZWQgPyBmcmVxIDogMjAwLFxuXHRcdFx0XHRsYXN0LFxuXHRcdFx0XHR0aW1lcjtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRub3cgID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcblx0XG5cdFx0XHRcdGlmICggbGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5ICkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGltZXIgKTtcblx0XG5cdFx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0Zm4uYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHR9LCBmcmVxdWVuY3kgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsYXN0ID0gbm93O1xuXHRcdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gdmFsIHN0cmluZyB0byBlc2NhcGVcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0XHQgKi9cblx0XHRlc2NhcGVSZWdleDogZnVuY3Rpb24gKCB2YWwgKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIF9yZV9lc2NhcGVfcmVnZXgsICdcXFxcJDEnICk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHdyaXRlIHRvIGEgbmVzdGVkIG9iamVjdCBvciBhcnJheVxuXHRcdCAqIEBwYXJhbSB7Kn0gc291cmNlIEpTT04gbm90YXRpb24gc3RyaW5nXG5cdFx0ICogQHJldHVybnMgV3JpdGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRzZXQ6IGZ1bmN0aW9uICggc291cmNlICkge1xuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNvdXJjZSApICkge1xuXHRcdFx0XHQvKiBVbmxpa2UgZ2V0LCBvbmx5IHRoZSB1bmRlcnNjb3JlIChnbG9iYWwpIG9wdGlvbiBpcyB1c2VkIGZvciBmb3Jcblx0XHRcdFx0ICogc2V0dGluZyBkYXRhIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIHR5cGUgaGVyZS4gVGhpcyBpcyB3aHkgYW4gb2JqZWN0XG5cdFx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0XHQgKiBmb3IgYG1SZW5kZXJgIHdoaWNoIGlzIHJlYWQgb25seS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdHJldHVybiBEYXRhVGFibGUudXRpbC5zZXQoIHNvdXJjZS5fICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc291cmNlID09PSBudWxsICkge1xuXHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvIHdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGxcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsLCBtZXRhKSB7XG5cdFx0XHRcdFx0c291cmNlKCBkYXRhLCAnc2V0JywgdmFsLCBtZXRhICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgKHNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHRcdFx0ICBzb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBzb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkgKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBMaWtlIHRoZSBnZXQsIHdlIG5lZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIG5lc3RlZCBvYmplY3Rcblx0XHRcdFx0dmFyIHNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdmFsLCBzcmMpIHtcblx0XHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApLCBiO1xuXHRcdFx0XHRcdHZhciBhTGFzdCA9IGFbYS5sZW5ndGgtMV07XG5cdFx0XHRcdFx0dmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgbywgaW5uZXJTcmM7XG5cdFx0XG5cdFx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aC0xIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0XHRcdGlmIChhW2ldID09PSAnX19wcm90b19fJyB8fCBhW2ldID09PSAnY29uc3RydWN0b3InKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBwcm90b3R5cGUgdmFsdWVzJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG5vdGF0aW9uIHJlcXVlc3Rcblx0XHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0XHRmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cdFx0XG5cdFx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IFtdO1xuXHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBzZXQgc28gd2UgY2FuIHJlY3Vyc2Vcblx0XHRcdFx0XHRcdFx0YiA9IGEuc2xpY2UoKTtcblx0XHRcdFx0XHRcdFx0Yi5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0XHRpbm5lclNyYyA9IGIuam9pbignLicpO1xuXHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49dmFsLmxlbmd0aCA7IGo8akxlbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRcdHNldERhdGEoIG8sIHZhbFtqXSwgaW5uZXJTcmMgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFdlJ3ZlIGJlZW4gYXNrZWQgdG8gc2F2ZSBkYXRhIHRvIGFuIGFycmF5LCBidXQgaXRcblx0XHRcdFx0XHRcdFx0XHQvLyBpc24ndCBhcnJheSBkYXRhIHRvIGJlIHNhdmVkLiBCZXN0IHRoYXQgY2FuIGJlIGRvbmVcblx0XHRcdFx0XHRcdFx0XHQvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxuXHRcdFx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IHZhbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBUaGUgaW5uZXIgY2FsbCB0byBzZXREYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSBhbmQgaGFzIHNldCB0aGUgZGF0YSwgdGh1cyB3ZSBjYW4gZXhpdCBoZXJlXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXSggdmFsICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgbmVzdGVkIG9iamVjdCBkb2Vzbid0IGN1cnJlbnRseSBleGlzdCAtIHNpbmNlIHdlIGFyZVxuXHRcdFx0XHRcdFx0Ly8gdHJ5aW5nIHRvIHNldCB0aGUgdmFsdWUgLSBjcmVhdGUgaXRcblx0XHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB7fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRcdC8vIExhc3QgaXRlbSBpbiB0aGUgaW5wdXQgLSBpLmUsIHRoZSBhY3R1YWwgc2V0XG5cdFx0XHRcdFx0aWYgKCBhTGFzdC5tYXRjaChfX3JlRm4gKSApIHtcblx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVGbiwgJycpIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIElmIGFycmF5IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGp1c3Qgd2FudCB0byBzdHJpcCBpdCBhbmQgdXNlIHRoZSBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdFx0XHQvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxuXHRcdFx0XHRcdFx0ZGF0YVsgYUxhc3QucmVwbGFjZShfX3JlQXJyYXksICcnKSBdID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdFx0cmV0dXJuIHNldERhdGEoIGRhdGEsIHZhbCwgc291cmNlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZ1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0XHRkYXRhW3NvdXJjZV0gPSB2YWw7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlYWQgbmVzdGVkIG9iamVjdHMgZnJvbSBhcnJheXMsIGJhc2VkIG9uIEpTT04gbm90YXRpb25cblx0XHQgKiBAcGFyYW0geyp9IHNvdXJjZSBKU09OIG5vdGF0aW9uIHN0cmluZ1xuXHRcdCAqIEByZXR1cm5zIFZhbHVlIHJlYWRcblx0XHQgKi9cblx0XHRnZXQ6IGZ1bmN0aW9uICggc291cmNlICkge1xuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNvdXJjZSApICkge1xuXHRcdFx0XHQvLyBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsXG5cdFx0XHRcdHZhciBvID0ge307XG5cdFx0XHRcdCQuZWFjaCggc291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdG9ba2V5XSA9IERhdGFUYWJsZS51dGlsLmdldCggdmFsICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSBvW3R5cGVdIHx8IG8uXztcblx0XHRcdFx0XHRyZXR1cm4gdCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHRcdHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG5cdFx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNvdXJjZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0Ly8gR2l2ZSBhbiBlbXB0eSBzdHJpbmcgZm9yIHJlbmRlcmluZyAvIHNvcnRpbmcgZXRjXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyB0eXBlLCByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNvdXJjZSggZGF0YSwgdHlwZSwgcm93LCBtZXRhICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgKHNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHRcdFx0ICBzb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBzb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxuXHRcdFx0XHQgKiBuZXN0ZWQgb2JqZWN0IHNvIHdlIGxvb3Agb3ZlciB0aGUgZGF0YSBmb3IgZWFjaCBsZXZlbCB0byBnZXQgdGhlIG5leHRcblx0XHRcdFx0ICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XG5cdFx0XHRcdCAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXG5cdFx0XHRcdCAqIGJlIHVzZWQgaWYgZGVmaW5lZCwgcmF0aGVyIHRoYW4gdGhyb3dpbmcgYW4gZXJyb3Jcblx0XHRcdFx0ICovXG5cdFx0XHRcdHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XG5cdFx0XHRcdFx0dmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgb3V0LCBpbm5lclNyYztcblx0XHRcblx0XHRcdFx0XHRpZiAoIHNyYyAhPT0gXCJcIiApIHtcblx0XHRcdFx0XHRcdHZhciBhID0gX2ZuU3BsaXRPYmpOb3RhdGlvbiggc3JjICk7XG5cdFx0XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cblx0XHRcdFx0XHRcdFx0YXJyYXlOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUFycmF5KTtcblx0XHRcdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQXJyYXkgbm90YXRpb25cblx0XHRcdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xuXHRcdFxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYVtpXSAhPT0gXCJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG91dCA9IFtdO1xuXHRcdFxuXHRcdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIGdldFxuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKCAwLCBpKzEgKTtcblx0XHRcdFx0XHRcdFx0XHRpbm5lclNyYyA9IGEuam9pbignLicpO1xuXHRcdFxuXHRcdFx0XHRcdFx0XHRcdC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IGdldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvdXQucHVzaCggZmV0Y2hEYXRhKCBkYXRhW2pdLCB0eXBlLCBpbm5lclNyYyApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRcdFx0XHRcdC8vIElmIGEgc3RyaW5nIGlzIGdpdmVuIGluIGJldHdlZW4gdGhlIGFycmF5IG5vdGF0aW9uIGluZGljYXRvcnMsIHRoYXRcblx0XHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHRcdHZhciBqb2luID0gYXJyYXlOb3RhdGlvblswXS5zdWJzdHJpbmcoMSwgYXJyYXlOb3RhdGlvblswXS5sZW5ndGgtMSk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IChqb2luPT09XCJcIikgPyBvdXQgOiBvdXQuam9pbihqb2luKTtcblx0XHRcblx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgaW5uZXIgY2FsbCB0byBmZXRjaERhdGEgaGFzIGFscmVhZHkgdHJhdmVyc2VkIHRocm91Z2ggdGhlIHJlbWFpbmRlclxuXHRcdFx0XHRcdFx0XHRcdC8vIG9mIHRoZSBzb3VyY2UgcmVxdWVzdGVkLCBzbyB3ZSBleGl0IGZyb20gdGhlIGxvb3Bcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmICggZnVuY05vdGF0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVGbiwgJycpO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oKTtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGEgPT09IG51bGwgfHwgZGF0YVsgYVtpXSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH07XG5cdFx0XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRcdHJldHVybiBmZXRjaERhdGEoIGRhdGEsIHR5cGUsIHNvdXJjZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmdcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFbc291cmNlXTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBtYXBwaW5nIG9iamVjdCB0aGF0IGFsbG93cyBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gYmUgbG9va2VkIHVwXG5cdCAqIGZvciB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzLiBUaGUgbWFwcGluZyBpcyBzdG9yZWQgaW4gYSBwcml2YXRlXG5cdCAqIHBhcmFtZXRlciBjYWxsZWQgYF9odW5nYXJpYW5NYXBgIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBvbiB0aGUgc291cmNlIG9iamVjdC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkh1bmdhcmlhbk1hcCAoIG8gKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRodW5nYXJpYW4gPSAnYSBhYSBhaSBhbyBhcyBiIGZuIGkgbSBvIHMgJyxcblx0XHRcdG1hdGNoLFxuXHRcdFx0bmV3S2V5LFxuXHRcdFx0bWFwID0ge307XG5cdFxuXHRcdCQuZWFjaCggbywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXihbXkEtWl0rPykoW0EtWl0pLyk7XG5cdFxuXHRcdFx0aWYgKCBtYXRjaCAmJiBodW5nYXJpYW4uaW5kZXhPZihtYXRjaFsxXSsnICcpICE9PSAtMSApXG5cdFx0XHR7XG5cdFx0XHRcdG5ld0tleSA9IGtleS5yZXBsYWNlKCBtYXRjaFswXSwgbWF0Y2hbMl0udG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0XHRtYXBbIG5ld0tleSBdID0ga2V5O1xuXHRcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gJ28nIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9mbkh1bmdhcmlhbk1hcCggb1trZXldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdG8uX2h1bmdhcmlhbk1hcCA9IG1hcDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiwgYmFzZWQgb24gYSBIdW5nYXJpYW4gbWFwXG5cdCAqIGNyZWF0ZWQgYnkgX2ZuSHVuZ2FyaWFuTWFwLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXG5cdCAqICAgIG1hcHBlZC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcblx0ICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XG5cdCAqICAgIHdvbid0IGJlLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYW1lbFRvSHVuZ2FyaWFuICggc3JjLCB1c2VyLCBmb3JjZSApXG5cdHtcblx0XHRpZiAoICEgc3JjLl9odW5nYXJpYW5NYXAgKSB7XG5cdFx0XHRfZm5IdW5nYXJpYW5NYXAoIHNyYyApO1xuXHRcdH1cblx0XG5cdFx0dmFyIGh1bmdhcmlhbktleTtcblx0XG5cdFx0JC5lYWNoKCB1c2VyLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdGh1bmdhcmlhbktleSA9IHNyYy5faHVuZ2FyaWFuTWFwWyBrZXkgXTtcblx0XG5cdFx0XHRpZiAoIGh1bmdhcmlhbktleSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCB1c2VyW2h1bmdhcmlhbktleV0gPT09IHVuZGVmaW5lZCkgKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBGb3Igb2JqZWN0cywgd2UgbmVlZCB0byBidXp6IGRvd24gaW50byB0aGUgb2JqZWN0IHRvIGNvcHkgcGFyYW1ldGVyc1xuXHRcdFx0XHRpZiAoIGh1bmdhcmlhbktleS5jaGFyQXQoMCkgPT09ICdvJyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBDb3B5IHRoZSBjYW1lbENhc2Ugb3B0aW9ucyBvdmVyIHRvIHRoZSBodW5nYXJpYW5cblx0XHRcdFx0XHRpZiAoICEgdXNlclsgaHVuZ2FyaWFuS2V5IF0gKSB7XG5cdFx0XHRcdFx0XHR1c2VyWyBodW5nYXJpYW5LZXkgXSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgdXNlcltodW5nYXJpYW5LZXldLCB1c2VyW2tleV0gKTtcblx0XG5cdFx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggc3JjW2h1bmdhcmlhbktleV0sIHVzZXJbaHVuZ2FyaWFuS2V5XSwgZm9yY2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR1c2VyW2h1bmdhcmlhbktleV0gPSB1c2VyWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBMYW5ndWFnZSBjb21wYXRpYmlsaXR5IC0gd2hlbiBjZXJ0YWluIG9wdGlvbnMgYXJlIGdpdmVuLCBhbmQgb3RoZXJzIGFyZW4ndCwgd2Vcblx0ICogbmVlZCB0byBkdXBsaWNhdGUgdGhlIHZhbHVlcyBvdmVyLCBpbiBvcmRlciB0byBwcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdCAqIHdpdGggb2xkZXIgbGFuZ3VhZ2UgZmlsZXMuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkxhbmd1YWdlQ29tcGF0KCBsYW5nIClcblx0e1xuXHRcdC8vIE5vdGUgdGhlIHVzZSBvZiB0aGUgSHVuZ2FyaWFuIG5vdGF0aW9uIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIG1ldGhvZCBhc1xuXHRcdC8vIHRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSBtYXBwaW5nIG9mIGNhbWVsQ2FzZSB0byBIdW5nYXJpYW5cblx0XHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlO1xuXHRcblx0XHQvLyBEZWZhdWx0IG1hcHBpbmdcblx0XHR2YXIgZGVmYXVsdERlY2ltYWwgPSBkZWZhdWx0cy5zRGVjaW1hbDtcblx0XHRpZiAoIGRlZmF1bHREZWNpbWFsICkge1xuXHRcdFx0X2FkZE51bWVyaWNTb3J0KCBkZWZhdWx0RGVjaW1hbCApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBsYW5nICkge1xuXHRcdFx0dmFyIHplcm9SZWNvcmRzID0gbGFuZy5zWmVyb1JlY29yZHM7XG5cdFxuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgLSBpZiB0aGVyZSBpcyBubyBzRW1wdHlUYWJsZSBnaXZlbiwgdGhlbiB1c2UgdGhlIHNhbWUgYXNcblx0XHRcdC8vIHNaZXJvUmVjb3JkcyAtIGFzc3VtaW5nIHRoYXQgaXMgZ2l2ZW4uXG5cdFx0XHRpZiAoICEgbGFuZy5zRW1wdHlUYWJsZSAmJiB6ZXJvUmVjb3JkcyAmJlxuXHRcdFx0XHRkZWZhdWx0cy5zRW1wdHlUYWJsZSA9PT0gXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTWFwKCBsYW5nLCBsYW5nLCAnc1plcm9SZWNvcmRzJywgJ3NFbXB0eVRhYmxlJyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIExpa2V3aXNlIHdpdGggbG9hZGluZyByZWNvcmRzXG5cdFx0XHRpZiAoICEgbGFuZy5zTG9hZGluZ1JlY29yZHMgJiYgemVyb1JlY29yZHMgJiZcblx0XHRcdFx0ZGVmYXVsdHMuc0xvYWRpbmdSZWNvcmRzID09PSBcIkxvYWRpbmcuLi5cIiApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbk1hcCggbGFuZywgbGFuZywgJ3NaZXJvUmVjb3JkcycsICdzTG9hZGluZ1JlY29yZHMnICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT2xkIHBhcmFtZXRlciBuYW1lIG9mIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIG1hcHBlZCBvbnRvIHRoZSBuZXdcblx0XHRcdGlmICggbGFuZy5zSW5mb1Rob3VzYW5kcyApIHtcblx0XHRcdFx0bGFuZy5zVGhvdXNhbmRzID0gbGFuZy5zSW5mb1Rob3VzYW5kcztcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgZGVjaW1hbCA9IGxhbmcuc0RlY2ltYWw7XG5cdFx0XHRpZiAoIGRlY2ltYWwgJiYgZGVmYXVsdERlY2ltYWwgIT09IGRlY2ltYWwgKSB7XG5cdFx0XHRcdF9hZGROdW1lcmljU29ydCggZGVjaW1hbCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIE9iamVjdCB0byBtYXBcblx0ICogIEBwYXJhbSB7Kn0ga25ldyBUaGUgbmV3IHBhcmFtZXRlciBuYW1lXG5cdCAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXG5cdCAqL1xuXHR2YXIgX2ZuQ29tcGF0TWFwID0gZnVuY3Rpb24gKCBvLCBrbmV3LCBvbGQgKSB7XG5cdFx0aWYgKCBvWyBrbmV3IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9bIG9sZCBdID0gb1sga25ldyBdO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcblx0ICogb3B0aW9ucyBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZVxuXHQgKiBjaGFuZ2Ugb25seS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMgKCBpbml0IClcblx0e1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyaW5nJywgICAgICAnYlNvcnQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJNdWx0aScsICAgICdiU29ydE11bHRpJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2xhc3NlcycsICAnYlNvcnRDbGFzc2VzJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2VsbHNUb3AnLCAnYlNvcnRDZWxsc1RvcCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcicsICAgICAgICAgJ2FhU29ydGluZycgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckZpeGVkJywgICAgJ2FhU29ydGluZ0ZpeGVkJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZycsICAgICAgICAnYlBhZ2luYXRlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZ1R5cGUnLCAgICAnc1BhZ2luYXRpb25UeXBlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2VMZW5ndGgnLCAgICAnaURpc3BsYXlMZW5ndGgnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnc2VhcmNoaW5nJywgICAgICdiRmlsdGVyJyApO1xuXHRcblx0XHQvLyBCb29sZWFuIGluaXRpYWxpc2F0aW9uIG9mIHgtc2Nyb2xsaW5nXG5cdFx0aWYgKCB0eXBlb2YgaW5pdC5zU2Nyb2xsWCA9PT0gJ2Jvb2xlYW4nICkge1xuXHRcdFx0aW5pdC5zU2Nyb2xsWCA9IGluaXQuc1Njcm9sbFggPyAnMTAwJScgOiAnJztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgaW5pdC5zY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRpbml0LnNjcm9sbFggPSBpbml0LnNjcm9sbFggPyAnMTAwJScgOiAnJztcblx0XHR9XG5cdFxuXHRcdC8vIENvbHVtbiBzZWFyY2ggb2JqZWN0cyBhcmUgaW4gYW4gYXJyYXksIHNvIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuXHRcdC8vIGVsZW1lbnQgYnkgZWxlbWVudFxuXHRcdHZhciBzZWFyY2hDb2xzID0gaW5pdC5hb1NlYXJjaENvbHM7XG5cdFxuXHRcdGlmICggc2VhcmNoQ29scyApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zZWFyY2hDb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNlYXJjaENvbHNbaV0gKSB7XG5cdFx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgY29sdW1uIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3IG9wdGlvbnNcblx0ICogYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2UgY2hhbmdlXG5cdCAqIG9ubHkuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Db21wYXRDb2xzICggaW5pdCApXG5cdHtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcmFibGUnLCAgICAgJ2JTb3J0YWJsZScgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckRhdGEnLCAgICAgJ2FEYXRhU29ydCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlclNlcXVlbmNlJywgJ2FzU29ydGluZycgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckRhdGFUeXBlJywgJ3NvcnREYXRhVHlwZScgKTtcblx0XG5cdFx0Ly8gb3JkZXJEYXRhIGNhbiBiZSBnaXZlbiBhcyBhbiBpbnRlZ2VyXG5cdFx0dmFyIGRhdGFTb3J0ID0gaW5pdC5hRGF0YVNvcnQ7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YVNvcnQgPT09ICdudW1iZXInICYmICEgQXJyYXkuaXNBcnJheSggZGF0YVNvcnQgKSApIHtcblx0XHRcdGluaXQuYURhdGFTb3J0ID0gWyBkYXRhU29ydCBdO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCcm93c2VyIGZlYXR1cmUgZGV0ZWN0aW9uIGZvciBjYXBhYmlsaXRpZXMsIHF1aXJrc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkJyb3dzZXJEZXRlY3QoIHNldHRpbmdzIClcblx0e1xuXHRcdC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gdGhpcyBldmVyeSB0aW1lIERhdGFUYWJsZXMgaXMgY29uc3RydWN0ZWQsIHRoZSB2YWx1ZXNcblx0XHQvLyBjYWxjdWxhdGVkIGFyZSBzcGVjaWZpYyB0byB0aGUgYnJvd3NlciBhbmQgT1MgY29uZmlndXJhdGlvbiB3aGljaCB3ZVxuXHRcdC8vIGRvbid0IGV4cGVjdCB0byBjaGFuZ2UgYmV0d2VlbiBpbml0aWFsaXNhdGlvbnNcblx0XHRpZiAoICEgRGF0YVRhYmxlLl9fYnJvd3NlciApIHtcblx0XHRcdHZhciBicm93c2VyID0ge307XG5cdFx0XHREYXRhVGFibGUuX19icm93c2VyID0gYnJvd3Nlcjtcblx0XG5cdFx0XHQvLyBTY3JvbGxpbmcgZmVhdHVyZSAvIHF1aXJrcyBkZXRlY3Rpb25cblx0XHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAnZml4ZWQnLFxuXHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRsZWZ0OiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpKi0xLCAvLyBhbGxvdyBmb3Igc2Nyb2xsaW5nXG5cdFx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHRcdFx0dG9wOiAxLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiAxLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogMTAwLFxuXHRcdFx0XHRcdFx0XHRvdmVyZmxvdzogJ3Njcm9sbCdcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAxMFxuXHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHQpXG5cdFx0XHRcdC5hcHBlbmRUbyggJ2JvZHknICk7XG5cdFxuXHRcdFx0dmFyIG91dGVyID0gbi5jaGlsZHJlbigpO1xuXHRcdFx0dmFyIGlubmVyID0gb3V0ZXIuY2hpbGRyZW4oKTtcblx0XG5cdFx0XHQvLyBOdW1iZXJzIGJlbG93LCBpbiBvcmRlciwgYXJlOlxuXHRcdFx0Ly8gaW5uZXIub2Zmc2V0V2lkdGgsIGlubmVyLmNsaWVudFdpZHRoLCBvdXRlci5vZmZzZXRXaWR0aCwgb3V0ZXIuY2xpZW50V2lkdGhcblx0XHRcdC8vXG5cdFx0XHQvLyBJRTYgWFA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwIDEwMCAxMDAgIDgzXG5cdFx0XHQvLyBJRTcgVmlzdGE6ICAgICAgICAgICAgICAgICAgICAgICAgMTAwIDEwMCAxMDAgIDgzXG5cdFx0XHQvLyBJRSA4KyBXaW5kb3dzOiAgICAgICAgICAgICAgICAgICAgIDgzICA4MyAxMDAgIDgzXG5cdFx0XHQvLyBFdmVyZ3JlZW4gV2luZG93czogICAgICAgICAgICAgICAgIDgzICA4MyAxMDAgIDgzXG5cdFx0XHQvLyBFdmVyZ3JlZW4gTWFjIHdpdGggc2Nyb2xsYmFyczogICAgIDg1ICA4NSAxMDAgIDg1XG5cdFx0XHQvLyBFdmVyZ3JlZW4gTWFjIHdpdGhvdXQgc2Nyb2xsYmFyczogMTAwIDEwMCAxMDAgMTAwXG5cdFxuXHRcdFx0Ly8gR2V0IHNjcm9sbGJhciB3aWR0aFxuXHRcdFx0YnJvd3Nlci5iYXJXaWR0aCA9IG91dGVyWzBdLm9mZnNldFdpZHRoIC0gb3V0ZXJbMF0uY2xpZW50V2lkdGg7XG5cdFxuXHRcdFx0Ly8gSUU2Lzcgd2lsbCBvdmVyc2l6ZSBhIHdpZHRoIDEwMCUgZWxlbWVudCBpbnNpZGUgYSBzY3JvbGxpbmcgZWxlbWVudCwgdG9cblx0XHRcdC8vIGluY2x1ZGUgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGxiYXIsIHdoaWxlIG90aGVyIGJyb3dzZXJzIGVuc3VyZSB0aGUgaW5uZXJcblx0XHRcdC8vIGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhvdXQgZm9yY2luZyBzY3JvbGxpbmdcblx0XHRcdGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplID0gaW5uZXJbMF0ub2Zmc2V0V2lkdGggPT09IDEwMCAmJiBvdXRlclswXS5jbGllbnRXaWR0aCAhPT0gMTAwO1xuXHRcblx0XHRcdC8vIEluIHJ0bCB0ZXh0IGxheW91dCwgc29tZSBicm93c2VycyAobW9zdCwgYnV0IG5vdCBhbGwpIHdpbGwgcGxhY2UgdGhlXG5cdFx0XHQvLyBzY3JvbGxiYXIgb24gdGhlIGxlZnQsIHJhdGhlciB0aGFuIHRoZSByaWdodC5cblx0XHRcdGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPSBNYXRoLnJvdW5kKCBpbm5lci5vZmZzZXQoKS5sZWZ0ICkgIT09IDE7XG5cdFxuXHRcdFx0Ly8gSUU4LSBkb24ndCBwcm92aWRlIGhlaWdodCBhbmQgd2lkdGggZm9yIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0YnJvd3Nlci5iQm91bmRpbmcgPSBuWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID8gdHJ1ZSA6IGZhbHNlO1xuXHRcblx0XHRcdG4ucmVtb3ZlKCk7XG5cdFx0fVxuXHRcblx0XHQkLmV4dGVuZCggc2V0dGluZ3Mub0Jyb3dzZXIsIERhdGFUYWJsZS5fX2Jyb3dzZXIgKTtcblx0XHRzZXR0aW5ncy5vU2Nyb2xsLmlCYXJXaWR0aCA9IERhdGFUYWJsZS5fX2Jyb3dzZXIuYmFyV2lkdGg7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXJyYXkucHJvdG90eXBlIHJlZHVjZVtSaWdodF0gbWV0aG9kLCB1c2VkIGZvciBicm93c2VycyB3aGljaCBkb24ndCBzdXBwb3J0XG5cdCAqIEpTIDEuNi4gRG9uZSB0aGlzIHdheSB0byByZWR1Y2UgY29kZSBzaXplLCBzaW5jZSB3ZSBpdGVyYXRlIGVpdGhlciB3YXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5SZWR1Y2UgKCB0aGF0LCBmbiwgaW5pdCwgc3RhcnQsIGVuZCwgaW5jIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSA9IHN0YXJ0LFxuXHRcdFx0dmFsdWUsXG5cdFx0XHRpc1NldCA9IGZhbHNlO1xuXHRcblx0XHRpZiAoIGluaXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gaW5pdDtcblx0XHRcdGlzU2V0ID0gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdHdoaWxlICggaSAhPT0gZW5kICkge1xuXHRcdFx0aWYgKCAhIHRoYXQuaGFzT3duUHJvcGVydHkoaSkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhbHVlID0gaXNTZXQgP1xuXHRcdFx0XHRmbiggdmFsdWUsIHRoYXRbaV0sIGksIHRoYXQgKSA6XG5cdFx0XHRcdHRoYXRbaV07XG5cdFxuXHRcdFx0aXNTZXQgPSB0cnVlO1xuXHRcdFx0aSArPSBpbmM7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGQgYSBjb2x1bW4gdG8gdGhlIGxpc3QgdXNlZCBmb3IgdGhlIHRhYmxlIHdpdGggZGVmYXVsdCB2YWx1ZXNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gblRoIFRoZSB0aCBlbGVtZW50IGZvciB0aGlzIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncywgblRoIClcblx0e1xuXHRcdC8vIEFkZCBjb2x1bW4gdG8gYW9Db2x1bW5zIGFycmF5XG5cdFx0dmFyIG9EZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW47XG5cdFx0dmFyIGlDb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcblx0XHR2YXIgb0NvbCA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uLCBvRGVmYXVsdHMsIHtcblx0XHRcdFwiblRoXCI6IG5UaCA/IG5UaCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyksXG5cdFx0XHRcInNUaXRsZVwiOiAgICBvRGVmYXVsdHMuc1RpdGxlICAgID8gb0RlZmF1bHRzLnNUaXRsZSAgICA6IG5UaCA/IG5UaC5pbm5lckhUTUwgOiAnJyxcblx0XHRcdFwiYURhdGFTb3J0XCI6IG9EZWZhdWx0cy5hRGF0YVNvcnQgPyBvRGVmYXVsdHMuYURhdGFTb3J0IDogW2lDb2xdLFxuXHRcdFx0XCJtRGF0YVwiOiBvRGVmYXVsdHMubURhdGEgPyBvRGVmYXVsdHMubURhdGEgOiBpQ29sLFxuXHRcdFx0aWR4OiBpQ29sXG5cdFx0fSApO1xuXHRcdG9TZXR0aW5ncy5hb0NvbHVtbnMucHVzaCggb0NvbCApO1xuXHRcblx0XHQvLyBBZGQgc2VhcmNoIG9iamVjdCBmb3IgY29sdW1uIHNwZWNpZmljIHNlYXJjaC4gTm90ZSB0aGF0IHRoZSBgc2VhcmNoQ29sc1sgaUNvbCBdYFxuXHRcdC8vIHBhc3NlZCBpbnRvIGV4dGVuZCBjYW4gYmUgdW5kZWZpbmVkLiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBnaXZlIGEgZGVmYXVsdFxuXHRcdC8vIHdpdGggb25seSBzb21lIG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQsIGFuZCBhbHNvIG5vdCBnaXZlIGEgZGVmYXVsdFxuXHRcdHZhciBzZWFyY2hDb2xzID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0XHRzZWFyY2hDb2xzWyBpQ29sIF0gPSAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1sgaUNvbCBdICk7XG5cdFxuXHRcdC8vIFVzZSB0aGUgZGVmYXVsdCBjb2x1bW4gb3B0aW9ucyBmdW5jdGlvbiB0byBpbml0aWFsaXNlIGNsYXNzZXMgZXRjXG5cdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCAkKG5UaCkuZGF0YSgpICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgb3B0aW9ucyBmb3IgYSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpQ29sIGNvbHVtbiBpbmRleCB0byBjb25zaWRlclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9PcHRpb25zIG9iamVjdCB3aXRoIHNUeXBlLCBiVmlzaWJsZSBhbmQgYlNlYXJjaGFibGUgZXRjXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb09wdGlvbnMgKVxuXHR7XG5cdFx0dmFyIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zWyBpQ29sIF07XG5cdFx0dmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciB0aCA9ICQob0NvbC5uVGgpO1xuXHRcblx0XHQvLyBUcnkgdG8gZ2V0IHdpZHRoIGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gV2UgY2FuJ3QgZ2V0IGl0IGZyb20gQ1NTXG5cdFx0Ly8gYXMgd2UnZCBuZWVkIHRvIHBhcnNlIHRoZSBDU1Mgc3R5bGVzaGVldC4gYHdpZHRoYCBvcHRpb24gY2FuIG92ZXJyaWRlXG5cdFx0aWYgKCAhIG9Db2wuc1dpZHRoT3JpZyApIHtcblx0XHRcdC8vIFdpZHRoIGF0dHJpYnV0ZVxuXHRcdFx0b0NvbC5zV2lkdGhPcmlnID0gdGguYXR0cignd2lkdGgnKSB8fCBudWxsO1xuXHRcblx0XHRcdC8vIFN0eWxlIGF0dHJpYnV0ZVxuXHRcdFx0dmFyIHQgPSAodGguYXR0cignc3R5bGUnKSB8fCAnJykubWF0Y2goL3dpZHRoOlxccyooXFxkK1tweGVtJV0rKS8pO1xuXHRcdFx0aWYgKCB0ICkge1xuXHRcdFx0XHRvQ29sLnNXaWR0aE9yaWcgPSB0WzFdO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogVXNlciBzcGVjaWZpZWQgY29sdW1uIG9wdGlvbnMgKi9cblx0XHRpZiAoIG9PcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb09wdGlvbnMgIT09IG51bGwgKVxuXHRcdHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRfZm5Db21wYXRDb2xzKCBvT3B0aW9ucyApO1xuXHRcblx0XHRcdC8vIE1hcCBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0c1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiwgb09wdGlvbnMsIHRydWUgKTtcblx0XG5cdFx0XHQvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgbURhdGFQcm9wICovXG5cdFx0XHRpZiAoIG9PcHRpb25zLm1EYXRhUHJvcCAhPT0gdW5kZWZpbmVkICYmICFvT3B0aW9ucy5tRGF0YSApXG5cdFx0XHR7XG5cdFx0XHRcdG9PcHRpb25zLm1EYXRhID0gb09wdGlvbnMubURhdGFQcm9wO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggb09wdGlvbnMuc1R5cGUgKVxuXHRcdFx0e1xuXHRcdFx0XHRvQ29sLl9zTWFudWFsVHlwZSA9IG9PcHRpb25zLnNUeXBlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGBjbGFzc2AgaXMgYSByZXNlcnZlZCB3b3JkIGluIEphdmFzY3JpcHQsIHNvIHdlIG5lZWQgdG8gcHJvdmlkZVxuXHRcdFx0Ly8gdGhlIGFiaWxpdHkgdG8gdXNlIGEgdmFsaWQgbmFtZSBmb3IgdGhlIGNhbWVsIGNhc2UgaW5wdXRcblx0XHRcdGlmICggb09wdGlvbnMuY2xhc3NOYW1lICYmICEgb09wdGlvbnMuc0NsYXNzIClcblx0XHRcdHtcblx0XHRcdFx0b09wdGlvbnMuc0NsYXNzID0gb09wdGlvbnMuY2xhc3NOYW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvT3B0aW9ucy5zQ2xhc3MgKSB7XG5cdFx0XHRcdHRoLmFkZENsYXNzKCBvT3B0aW9ucy5zQ2xhc3MgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQkLmV4dGVuZCggb0NvbCwgb09wdGlvbnMgKTtcblx0XHRcdF9mbk1hcCggb0NvbCwgb09wdGlvbnMsIFwic1dpZHRoXCIsIFwic1dpZHRoT3JpZ1wiICk7XG5cdFxuXHRcdFx0LyogaURhdGFTb3J0IHRvIGJlIGFwcGxpZWQgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSwgYnV0IGFEYXRhU29ydCB3aWxsIHRha2Vcblx0XHRcdCAqIHByaW9yaXR5IGlmIGRlZmluZWRcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBvT3B0aW9ucy5pRGF0YVNvcnQgIT09IHVuZGVmaW5lZCApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wuYURhdGFTb3J0ID0gWyBvT3B0aW9ucy5pRGF0YVNvcnQgXTtcblx0XHRcdH1cblx0XHRcdF9mbk1hcCggb0NvbCwgb09wdGlvbnMsIFwiYURhdGFTb3J0XCIgKTtcblx0XHR9XG5cdFxuXHRcdC8qIENhY2hlIHRoZSBkYXRhIGdldCBhbmQgc2V0IGZ1bmN0aW9ucyBmb3Igc3BlZWQgKi9cblx0XHR2YXIgbURhdGFTcmMgPSBvQ29sLm1EYXRhO1xuXHRcdHZhciBtRGF0YSA9IF9mbkdldE9iamVjdERhdGFGbiggbURhdGFTcmMgKTtcblx0XHR2YXIgbVJlbmRlciA9IG9Db2wubVJlbmRlciA/IF9mbkdldE9iamVjdERhdGFGbiggb0NvbC5tUmVuZGVyICkgOiBudWxsO1xuXHRcblx0XHR2YXIgYXR0clRlc3QgPSBmdW5jdGlvbiggc3JjICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyYy5pbmRleE9mKCdAJykgIT09IC0xO1xuXHRcdH07XG5cdFx0b0NvbC5fYkF0dHJTcmMgPSAkLmlzUGxhaW5PYmplY3QoIG1EYXRhU3JjICkgJiYgKFxuXHRcdFx0YXR0clRlc3QobURhdGFTcmMuc29ydCkgfHwgYXR0clRlc3QobURhdGFTcmMudHlwZSkgfHwgYXR0clRlc3QobURhdGFTcmMuZmlsdGVyKVxuXHRcdCk7XG5cdFx0b0NvbC5fc2V0dGVyID0gbnVsbDtcblx0XG5cdFx0b0NvbC5mbkdldERhdGEgPSBmdW5jdGlvbiAocm93RGF0YSwgdHlwZSwgbWV0YSkge1xuXHRcdFx0dmFyIGlubmVyRGF0YSA9IG1EYXRhKCByb3dEYXRhLCB0eXBlLCB1bmRlZmluZWQsIG1ldGEgKTtcblx0XG5cdFx0XHRyZXR1cm4gbVJlbmRlciAmJiB0eXBlID9cblx0XHRcdFx0bVJlbmRlciggaW5uZXJEYXRhLCB0eXBlLCByb3dEYXRhLCBtZXRhICkgOlxuXHRcdFx0XHRpbm5lckRhdGE7XG5cdFx0fTtcblx0XHRvQ29sLmZuU2V0RGF0YSA9IGZ1bmN0aW9uICggcm93RGF0YSwgdmFsLCBtZXRhICkge1xuXHRcdFx0cmV0dXJuIF9mblNldE9iamVjdERhdGFGbiggbURhdGFTcmMgKSggcm93RGF0YSwgdmFsLCBtZXRhICk7XG5cdFx0fTtcblx0XG5cdFx0Ly8gSW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBzaG91bGQgcmVhZCBET00gZGF0YSBhcyBhbiBvYmplY3Qgb3IgYXJyYXlcblx0XHQvLyBVc2VkIGluIF9mbkdldFJvd0VsZW1lbnRzXG5cdFx0aWYgKCB0eXBlb2YgbURhdGFTcmMgIT09ICdudW1iZXInICkge1xuXHRcdFx0b1NldHRpbmdzLl9yb3dSZWFkT2JqZWN0ID0gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdC8qIEZlYXR1cmUgc29ydGluZyBvdmVycmlkZXMgY29sdW1uIHNwZWNpZmljIHdoZW4gb2ZmICovXG5cdFx0aWYgKCAhb1NldHRpbmdzLm9GZWF0dXJlcy5iU29ydCApXG5cdFx0e1xuXHRcdFx0b0NvbC5iU29ydGFibGUgPSBmYWxzZTtcblx0XHRcdHRoLmFkZENsYXNzKCBvQ2xhc3Nlcy5zU29ydGFibGVOb25lICk7IC8vIEhhdmUgdG8gYWRkIGNsYXNzIGhlcmUgYXMgb3JkZXIgZXZlbnQgaXNuJ3QgY2FsbGVkXG5cdFx0fVxuXHRcblx0XHQvKiBDaGVjayB0aGF0IHRoZSBjbGFzcyBhc3NpZ25tZW50IGlzIGNvcnJlY3QgZm9yIHNvcnRpbmcgKi9cblx0XHR2YXIgYkFzYyA9ICQuaW5BcnJheSgnYXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcblx0XHR2YXIgYkRlc2MgPSAkLmluQXJyYXkoJ2Rlc2MnLCBvQ29sLmFzU29ydGluZykgIT09IC0xO1xuXHRcdGlmICggIW9Db2wuYlNvcnRhYmxlIHx8ICghYkFzYyAmJiAhYkRlc2MpIClcblx0XHR7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVOb25lO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gXCJcIjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGJBc2MgJiYgIWJEZXNjIClcblx0XHR7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVBc2M7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSUFzY0FsbG93ZWQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhYkFzYyAmJiBiRGVzYyApXG5cdFx0e1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlRGVzYztcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJRGVzY0FsbG93ZWQ7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGU7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWRqdXN0IHRoZSB0YWJsZSBjb2x1bW4gd2lkdGhzIGZvciBuZXcgZGF0YS4gTm90ZTogeW91IHdvdWxkIHByb2JhYmx5IHdhbnQgdG9cblx0ICogZG8gYSByZWRyYXcgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkanVzdENvbHVtblNpemluZyAoIHNldHRpbmdzIClcblx0e1xuXHRcdC8qIE5vdCBpbnRlcmVzdGVkIGluIGRvaW5nIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbiBpZiBhdXRvLXdpZHRoIGlzIGRpc2FibGVkICovXG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYkF1dG9XaWR0aCAhPT0gZmFsc2UgKVxuXHRcdHtcblx0XHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyggc2V0dGluZ3MgKTtcblx0XHRcdGZvciAoIHZhciBpPTAgLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0Y29sdW1uc1tpXS5uVGguc3R5bGUud2lkdGggPSBjb2x1bW5zW2ldLnNXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcdGlmICggc2Nyb2xsLnNZICE9PSAnJyB8fCBzY3JvbGwuc1ggIT09ICcnKVxuXHRcdHtcblx0XHRcdF9mblNjcm9sbERyYXcoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXNpemluZycsIFtzZXR0aW5nc10gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBpbmRleCBvZiBhIHZpc2libGUgY29sdW1uIHRvIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSAodGFrZSBhY2NvdW50XG5cdCAqIG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBWaXNpYmxlIGNvbHVtbiBpbmRleCB0byBsb29rdXBcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaU1hdGNoIClcblx0e1xuXHRcdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXHRcblx0XHRyZXR1cm4gdHlwZW9mIGFpVmlzW2lNYXRjaF0gPT09ICdudW1iZXInID9cblx0XHRcdGFpVmlzW2lNYXRjaF0gOlxuXHRcdFx0bnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuXHQgKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XHR2YXIgaVBvcyA9ICQuaW5BcnJheSggaU1hdGNoLCBhaVZpcyApO1xuXHRcblx0XHRyZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhciB2aXMgPSAwO1xuXHRcblx0XHQvLyBObyByZWR1Y2UgaW4gSUU4LCB1c2UgYSBsb29wIGZvciBub3dcblx0XHQkLmVhY2goIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0aWYgKCBjb2wuYlZpc2libGUgJiYgJChjb2wublRoKS5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnICkge1xuXHRcdFx0XHR2aXMrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiB2aXM7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRoYXQgbWF0Y2ggYSBnaXZlbiBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNQYXJhbSBQYXJhbWV0ZXIgaW4gYW9Db2x1bW5zIHRvIGxvb2sgZm9yIC0gdHlwaWNhbGx5XG5cdCAqICAgIGJWaXNpYmxlIG9yIGJTZWFyY2hhYmxlXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCBzUGFyYW0gKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0JC5tYXAoIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uKHZhbCwgaSkge1xuXHRcdFx0aWYgKCB2YWxbc1BhcmFtXSApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gYTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcblx0XHR2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcblx0XHR2YXIgY29sLCBjZWxsLCBkZXRlY3RlZFR5cGUsIGNhY2hlO1xuXHRcblx0XHQvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgXG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRjYWNoZSA9IFtdO1xuXHRcblx0XHRcdGlmICggISBjb2wuc1R5cGUgJiYgY29sLl9zTWFudWFsVHlwZSApIHtcblx0XHRcdFx0Y29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49dHlwZXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggaz0wLCBrZW49ZGF0YS5sZW5ndGggOyBrPGtlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdC8vIFVzZSBhIGNhY2hlIGFycmF5IHNvIHdlIG9ubHkgbmVlZCB0byBnZXQgdGhlIHR5cGUgZGF0YVxuXHRcdFx0XHRcdFx0Ly8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuXHRcdFx0XHRcdFx0aWYgKCBjYWNoZVtrXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRjYWNoZVtrXSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaywgaSwgJ3R5cGUnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gdHlwZXNbal0oIGNhY2hlW2tdLCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0XHRcdC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xuXHRcdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdGVzdGluZyBhbGwgY2VsbHMsIGJyZWFrIG91dC4gVGhlcmUgaXMgYW5cblx0XHRcdFx0XHRcdC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxuXHRcdFx0XHRcdFx0Ly8gdHlwZXNcblx0XHRcdFx0XHRcdGlmICggISBkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIE9ubHkgYSBzaW5nbGUgbWF0Y2ggaXMgbmVlZGVkIGZvciBodG1sIHR5cGUgc2luY2UgaXQgaXNcblx0XHRcdFx0XHRcdC8vIGJvdHRvbSBvZiB0aGUgcGlsZSBhbmQgdmVyeSBzaW1pbGFyIHRvIHN0cmluZyAtIGJ1dCBpdFxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBub3QgYmUgZW1wdHlcblx0XHRcdFx0XHRcdGlmICggZGV0ZWN0ZWRUeXBlID09PSAnaHRtbCcgJiYgISBfZW1wdHkoY2FjaGVba10pICkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFR5cGUgaXMgdmFsaWQgZm9yIGFsbCBkYXRhIHBvaW50cyBpbiB0aGUgY29sdW1uIC0gdXNlIHRoaXNcblx0XHRcdFx0XHQvLyB0eXBlXG5cdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgKSB7XG5cdFx0XHRcdFx0XHRjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xuXHRcdFx0XHRpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRcdGNvbC5zVHlwZSA9ICdzdHJpbmcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XG5cdCAqIHRoZXkgcmVsYXRlIHRvIGNvbHVtbiBpbmRleGVzLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCB0aGVuIGFwcGx5IHRoZVxuXHQgKiBkZWZpbml0aW9uIGZvdW5kIGZvciBhIGNvbHVtbiB0byBhIHN1aXRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xEZWZzIFRoZSBhb0NvbHVtbkRlZnMgYXJyYXkgdGhhdCBpcyB0byBiZSBhcHBsaWVkXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhb0NvbHMgVGhlIGFvQ29sdW1ucyBhcnJheSB0aGF0IGRlZmluZXMgY29sdW1ucyBpbmRpdmlkdWFsbHlcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXG5cdCAqICAgIGNvbHVtbiBpbmRleCBhbmQgdGhlIGRlZmluaXRpb24gZm9yIHRoYXQgY29sdW1uLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgYW9Db2xEZWZzLCBhb0NvbHMsIGZuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBkZWY7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHQvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xuXHRcdGlmICggYW9Db2xEZWZzIClcblx0XHR7XG5cdFx0XHQvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xuXHRcdFx0Zm9yICggaT1hb0NvbERlZnMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tIClcblx0XHRcdHtcblx0XHRcdFx0ZGVmID0gYW9Db2xEZWZzW2ldO1xuXHRcblx0XHRcdFx0LyogRWFjaCBkZWZpbml0aW9uIGNhbiB0YXJnZXQgbXVsdGlwbGUgY29sdW1ucywgYXMgaXQgaXMgYW4gYXJyYXkgKi9cblx0XHRcdFx0dmFyIGFUYXJnZXRzID0gZGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0ZGVmLnRhcmdldHMgOlxuXHRcdFx0XHRcdGRlZi5hVGFyZ2V0cztcblx0XG5cdFx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBhVGFyZ2V0cyApIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFUYXJnZXRzID0gWyBhVGFyZ2V0cyBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRmb3IgKCBqPTAsIGpMZW49YVRhcmdldHMubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA+PSAwIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBBZGQgY29sdW1ucyB0aGF0IHdlIGRvbid0IHlldCBrbm93IGFib3V0ICovXG5cdFx0XHRcdFx0XHR3aGlsZSggY29sdW1ucy5sZW5ndGggPD0gYVRhcmdldHNbal0gKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8qIEludGVnZXIsIGJhc2ljIGluZGV4ICovXG5cdFx0XHRcdFx0XHRmbiggYVRhcmdldHNbal0sIGRlZiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA8IDAgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIE5lZ2F0aXZlIGludGVnZXIsIHJpZ2h0IHRvIGxlZnQgY29sdW1uIGNvdW50aW5nICovXG5cdFx0XHRcdFx0XHRmbiggY29sdW1ucy5sZW5ndGgrYVRhcmdldHNbal0sIGRlZiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnc3RyaW5nJyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogQ2xhc3MgbmFtZSBtYXRjaGluZyBvbiBUSCBlbGVtZW50ICovXG5cdFx0XHRcdFx0XHRmb3IgKCBrPTAsIGtMZW49Y29sdW1ucy5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoIGFUYXJnZXRzW2pdID09IFwiX2FsbFwiIHx8XG5cdFx0XHRcdFx0XHRcdCAgICAgJChjb2x1bW5zW2tdLm5UaCkuaGFzQ2xhc3MoIGFUYXJnZXRzW2pdICkgKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Zm4oIGssIGRlZiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBTdGF0aWNhbGx5IGRlZmluZWQgY29sdW1ucyBhcnJheVxuXHRcdGlmICggYW9Db2xzIClcblx0XHR7XG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2xzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdGZuKCBpLCBhb0NvbHNbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGQgYSBkYXRhIGFycmF5IHRvIHRoZSB0YWJsZSwgY3JlYXRpbmcgRE9NIG5vZGUgZXRjLiBUaGlzIGlzIHRoZSBwYXJhbGxlbCB0b1xuXHQgKiBfZm5HYXRoZXJEYXRhLCBidXQgZm9yIGFkZGluZyByb3dzIGZyb20gYSBKYXZhc2NyaXB0IHNvdXJjZSwgcmF0aGVyIHRoYW4gYVxuXHQgKiBET00gc291cmNlLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYURhdGEgZGF0YSBhcnJheSB0byBiZSBhZGRlZFxuXHQgKiAgQHBhcmFtIHtub2RlfSBbblRyXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuXHQgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcblx0ICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG5cdCAqICAgIGlmIG5UciBpcy5cblx0ICogIEByZXR1cm5zIHtpbnR9ID49MCBpZiBzdWNjZXNzZnVsIChpbmRleCBvZiBuZXcgYW9EYXRhIGVudHJ5KSwgLTEgaWYgZmFpbGVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZERhdGEgKCBvU2V0dGluZ3MsIGFEYXRhSW4sIG5UciwgYW5UZHMgKVxuXHR7XG5cdFx0LyogQ3JlYXRlIHRoZSBvYmplY3QgZm9yIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBuZXcgcm93ICovXG5cdFx0dmFyIGlSb3cgPSBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aDtcblx0XHR2YXIgb0RhdGEgPSAkLmV4dGVuZCggdHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1Jvdywge1xuXHRcdFx0c3JjOiBuVHIgPyAnZG9tJyA6ICdkYXRhJyxcblx0XHRcdGlkeDogaVJvd1xuXHRcdH0gKTtcblx0XG5cdFx0b0RhdGEuX2FEYXRhID0gYURhdGFJbjtcblx0XHRvU2V0dGluZ3MuYW9EYXRhLnB1c2goIG9EYXRhICk7XG5cdFxuXHRcdC8qIENyZWF0ZSB0aGUgY2VsbHMgKi9cblx0XHR2YXIgblRkLCBzVGhpc1R5cGU7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSBjb2x1bW4gdHlwZXMgYXMgdGhlIG5ldyBkYXRhIG5lZWRzIHRvIGJlIHJldmFsaWRhdGVkXG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0Y29sdW1uc1tpXS5zVHlwZSA9IG51bGw7XG5cdFx0fVxuXHRcblx0XHQvKiBBZGQgdG8gdGhlIGRpc3BsYXkgYXJyYXkgKi9cblx0XHRvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnB1c2goIGlSb3cgKTtcblx0XG5cdFx0dmFyIGlkID0gb1NldHRpbmdzLnJvd0lkRm4oIGFEYXRhSW4gKTtcblx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvU2V0dGluZ3MuYUlkc1sgaWQgXSA9IG9EYXRhO1xuXHRcdH1cblx0XG5cdFx0LyogQ3JlYXRlIHRoZSBET00gaW5mb3JtYXRpb24sIG9yIHJlZ2lzdGVyIGl0IGlmIGFscmVhZHkgcHJlc2VudCAqL1xuXHRcdGlmICggblRyIHx8ICEgb1NldHRpbmdzLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIgKVxuXHRcdHtcblx0XHRcdF9mbkNyZWF0ZVRyKCBvU2V0dGluZ3MsIGlSb3csIG5UciwgYW5UZHMgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBpUm93O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBvbmUgb3IgbW9yZSBUUiBlbGVtZW50cyB0byB0aGUgdGFibGUuIEdlbmVyYWxseSB3ZSdkIGV4cGVjdCB0b1xuXHQgKiB1c2UgdGhpcyBmb3IgcmVhZGluZyBkYXRhIGZyb20gYSBET00gc291cmNlZCB0YWJsZSwgYnV0IGl0IGNvdWxkIGJlXG5cdCAqIHVzZWQgZm9yIGFuIFRSIGVsZW1lbnQuIE5vdGUgdGhhdCBpZiBhIFRSIGlzIGdpdmVuLCBpdCBpcyB1c2VkIChpLmUuXG5cdCAqIGl0IGlzIG5vdCBjbG9uZWQpLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2FycmF5fG5vZGV8alF1ZXJ5fSB0cnMgVGhlIFRSIGVsZW1lbnQocykgdG8gYWRkIHRvIHRoZSB0YWJsZVxuXHQgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIGZvciB0aGUgYWRkZWQgcm93c1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGRUciggc2V0dGluZ3MsIHRycyApXG5cdHtcblx0XHR2YXIgcm93O1xuXHRcblx0XHQvLyBBbGxvdyBhbiBpbmRpdmlkdWFsIG5vZGUgdG8gYmUgcGFzc2VkIGluXG5cdFx0aWYgKCAhICh0cnMgaW5zdGFuY2VvZiAkKSApIHtcblx0XHRcdHRycyA9ICQodHJzKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0cnMubWFwKCBmdW5jdGlvbiAoaSwgZWwpIHtcblx0XHRcdHJvdyA9IF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgZWwgKTtcblx0XHRcdHJldHVybiBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93LmRhdGEsIGVsLCByb3cuY2VsbHMgKTtcblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVGFrZSBhIFRSIGVsZW1lbnQgYW5kIGNvbnZlcnQgaXQgdG8gYW4gaW5kZXggaW4gYW9EYXRhXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IG4gdGhlIFRSIGVsZW1lbnQgdG8gZmluZFxuXHQgKiAgQHJldHVybnMge2ludH0gaW5kZXggaWYgdGhlIG5vZGUgaXMgZm91bmQsIG51bGwgaWYgbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbk5vZGVUb0RhdGFJbmRleCggb1NldHRpbmdzLCBuIClcblx0e1xuXHRcdHJldHVybiAobi5fRFRfUm93SW5kZXghPT11bmRlZmluZWQpID8gbi5fRFRfUm93SW5kZXggOiBudWxsO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgYSBURCBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IGludG8gYSBjb2x1bW4gZGF0YSBpbmRleCAobm90IHRoZSB2aXNpYmxlIGluZGV4KVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBudW1iZXIgdGhlIFREL1RIIGNhbiBiZSBmb3VuZCBpblxuXHQgKiAgQHBhcmFtIHtub2RlfSBuIFRoZSBURC9USCBlbGVtZW50IHRvIGZpbmRcblx0ICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCAtMSBpZiBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTm9kZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaVJvdywgbiApXG5cdHtcblx0XHRyZXR1cm4gJC5pbkFycmF5KCBuLCBvU2V0dGluZ3MuYW9EYXRhWyBpUm93IF0uYW5DZWxscyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBmb3IgYSBnaXZlbiBjZWxsIGZyb20gdGhlIGludGVybmFsIGNhY2hlLCB0YWtpbmcgaW50byBhY2NvdW50IGRhdGEgbWFwcGluZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gdHlwZSBkYXRhIGdldCB0eXBlICgnZGlzcGxheScsICd0eXBlJyAnZmlsdGVyfHNlYXJjaCcgJ3NvcnR8b3JkZXInKVxuXHQgKiAgQHJldHVybnMgeyp9IENlbGwgZGF0YVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB0eXBlIClcblx0e1xuXHRcdGlmICh0eXBlID09PSAnc2VhcmNoJykge1xuXHRcdFx0dHlwZSA9ICdmaWx0ZXInO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlID09PSAnb3JkZXInKSB7XG5cdFx0XHR0eXBlID0gJ3NvcnQnO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRyYXcgICAgICAgICAgID0gc2V0dGluZ3MuaURyYXc7XG5cdFx0dmFyIGNvbCAgICAgICAgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdFx0dmFyIHJvd0RhdGEgICAgICAgID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXHRcdHZhciBkZWZhdWx0Q29udGVudCA9IGNvbC5zRGVmYXVsdENvbnRlbnQ7XG5cdFx0dmFyIGNlbGxEYXRhICAgICAgID0gY29sLmZuR2V0RGF0YSggcm93RGF0YSwgdHlwZSwge1xuXHRcdFx0c2V0dGluZ3M6IHNldHRpbmdzLFxuXHRcdFx0cm93OiAgICAgIHJvd0lkeCxcblx0XHRcdGNvbDogICAgICBjb2xJZHhcblx0XHR9ICk7XG5cdFxuXHRcdGlmICggY2VsbERhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggc2V0dGluZ3MuaURyYXdFcnJvciAhPSBkcmF3ICYmIGRlZmF1bHRDb250ZW50ID09PSBudWxsICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBcIlJlcXVlc3RlZCB1bmtub3duIHBhcmFtZXRlciBcIitcblx0XHRcdFx0XHQodHlwZW9mIGNvbC5tRGF0YT09J2Z1bmN0aW9uJyA/ICd7ZnVuY3Rpb259JyA6IFwiJ1wiK2NvbC5tRGF0YStcIidcIikrXG5cdFx0XHRcdFx0XCIgZm9yIHJvdyBcIityb3dJZHgrXCIsIGNvbHVtbiBcIitjb2xJZHgsIDQgKTtcblx0XHRcdFx0c2V0dGluZ3MuaURyYXdFcnJvciA9IGRyYXc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVmYXVsdENvbnRlbnQ7XG5cdFx0fVxuXHRcblx0XHQvLyBXaGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsIGFuZCBhIHNwZWNpZmljIGRhdGEgdHlwZSBpcyByZXF1ZXN0ZWQgKGkuZS5cblx0XHQvLyBub3QgdGhlIG9yaWdpbmFsIGRhdGEpLCB3ZSBjYW4gdXNlIGRlZmF1bHQgY29sdW1uIGRhdGFcblx0XHRpZiAoIChjZWxsRGF0YSA9PT0gcm93RGF0YSB8fCBjZWxsRGF0YSA9PT0gbnVsbCkgJiYgZGVmYXVsdENvbnRlbnQgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2VsbERhdGEgPSBkZWZhdWx0Q29udGVudDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBjZWxsRGF0YSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIElmIHRoZSBkYXRhIHNvdXJjZSBpcyBhIGZ1bmN0aW9uLCB0aGVuIHdlIHJ1biBpdCBhbmQgdXNlIHRoZSByZXR1cm4sXG5cdFx0XHQvLyBleGVjdXRpbmcgaW4gdGhlIHNjb3BlIG9mIHRoZSBkYXRhIG9iamVjdCAoZm9yIGluc3RhbmNlcylcblx0XHRcdHJldHVybiBjZWxsRGF0YS5jYWxsKCByb3dEYXRhICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGNlbGxEYXRhID09PSBudWxsICYmIHR5cGUgPT09ICdkaXNwbGF5JyApIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFxuXHRcdGlmICggdHlwZSA9PT0gJ2ZpbHRlcicgKSB7XG5cdFx0XHR2YXIgZm9tYXR0ZXJzID0gRGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaDtcblx0XG5cdFx0XHRpZiAoIGZvbWF0dGVyc1sgY29sLnNUeXBlIF0gKSB7XG5cdFx0XHRcdGNlbGxEYXRhID0gZm9tYXR0ZXJzWyBjb2wuc1R5cGUgXSggY2VsbERhdGEgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBjZWxsRGF0YTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNlbGwsIGludG8gdGhlIGludGVybmFsIGRhdGEgY2FjaGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gc2V0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHZhbCApXG5cdHtcblx0XHR2YXIgY29sICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHRcdHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXHRcblx0XHRjb2wuZm5TZXREYXRhKCByb3dEYXRhLCB2YWwsIHtcblx0XHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0XHRjb2w6ICAgICAgY29sSWR4XG5cdFx0fSAgKTtcblx0fVxuXHRcblx0XG5cdC8vIFByaXZhdGUgdmFyaWFibGUgdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGFjdGlvbiBzeW50YXggaW4gdGhlIGRhdGEgcHJvcGVydHkgb2JqZWN0XG5cdHZhciBfX3JlQXJyYXkgPSAvXFxbLio/XFxdJC87XG5cdHZhciBfX3JlRm4gPSAvXFwoXFwpJC87XG5cdFxuXHQvKipcblx0ICogU3BsaXQgc3RyaW5nIG9uIHBlcmlvZHMsIHRha2luZyBpbnRvIGFjY291bnQgZXNjYXBlZCBwZXJpb2RzXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdFxuXHQgKiBAcmV0dXJuIHthcnJheX0gU3BsaXQgc3RyaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TcGxpdE9iak5vdGF0aW9uKCBzdHIgKVxuXHR7XG5cdFx0cmV0dXJuICQubWFwKCBzdHIubWF0Y2goLyhcXFxcLnxbXlxcLl0pKy9nKSB8fCBbJyddLCBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHRyZXR1cm4gcy5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuXHQgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdHZhciBfZm5HZXRPYmplY3REYXRhRm4gPSBEYXRhVGFibGUudXRpbC5nZXQ7XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuXHQgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgc2V0IGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdHZhciBfZm5TZXRPYmplY3REYXRhRm4gPSBEYXRhVGFibGUudXRpbC5zZXQ7XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBmdWxsIHRhYmxlIGRhdGFcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIGFycmF5IHthcnJheX0gYURhdGEgTWFzdGVyIGRhdGEgYXJyYXlcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0RGF0YU1hc3RlciAoIHNldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBOdWtlIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApXG5cdHtcblx0XHRzZXR0aW5ncy5hb0RhdGEubGVuZ3RoID0gMDtcblx0XHRzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoID0gMDtcblx0XHRzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoID0gMDtcblx0XHRzZXR0aW5ncy5hSWRzID0ge307XG5cdH1cblx0XG5cdFxuXHQgLyoqXG5cdCAqIFRha2UgYW4gYXJyYXkgb2YgaW50ZWdlcnMgKGluZGV4IGFycmF5KSBhbmQgcmVtb3ZlIGEgdGFyZ2V0IGludGVnZXIgKHZhbHVlIC0gbm90XG5cdCAqIHRoZSBrZXkhKVxuXHQgKiAgQHBhcmFtIHthcnJheX0gYSBJbmRleCBhcnJheSB0byB0YXJnZXRcblx0ICogIEBwYXJhbSB7aW50fSBpVGFyZ2V0IHZhbHVlIHRvIGZpbmRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRGVsZXRlSW5kZXgoIGEsIGlUYXJnZXQsIHNwbGljZSApXG5cdHtcblx0XHR2YXIgaVRhcmdldEluZGV4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGlmICggYVtpXSA9PSBpVGFyZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0aVRhcmdldEluZGV4ID0gaTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBhW2ldID4gaVRhcmdldCApXG5cdFx0XHR7XG5cdFx0XHRcdGFbaV0tLTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGlmICggaVRhcmdldEluZGV4ICE9IC0xICYmIHNwbGljZSA9PT0gdW5kZWZpbmVkIClcblx0XHR7XG5cdFx0XHRhLnNwbGljZSggaVRhcmdldEluZGV4LCAxICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE1hcmsgY2FjaGVkIGRhdGEgYXMgaW52YWxpZCBzdWNoIHRoYXQgYSByZS1yZWFkIG9mIHRoZSBkYXRhIHdpbGwgb2NjdXIgd2hlblxuXHQgKiB0aGUgY2FjaGVkIGRhdGEgaXMgbmV4dCByZXF1ZXN0ZWQuIEFsc28gdXBkYXRlIGZyb20gdGhlIGRhdGEgc291cmNlIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqIEBwYXJhbSB7aW50fSAgICByb3dJZHggICBSb3cgaW5kZXggdG8gaW52YWxpZGF0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gICAgU291cmNlIHRvIGludmFsaWRhdGUgZnJvbTogdW5kZWZpbmVkLCAnYXV0bycsICdkb20nXG5cdCAqICAgICBvciAnZGF0YSdcblx0ICogQHBhcmFtIHtpbnR9ICAgIFtjb2xJZHhdIENvbHVtbiBpbmRleCB0byBpbnZhbGlkYXRlLiBJZiB1bmRlZmluZWQgdGhlIHdob2xlXG5cdCAqICAgICByb3cgd2lsbCBiZSBpbnZhbGlkYXRlZFxuXHQgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICpcblx0ICogQHRvZG8gRm9yIHRoZSBtb2R1bGFyaXNhdGlvbiBvZiB2MS4xMSB0aGlzIHdpbGwgbmVlZCB0byBiZWNvbWUgYSBjYWxsYmFjaywgc29cblx0ICogICB0aGUgc29ydCBhbmQgZmlsdGVyIG1ldGhvZHMgY2FuIHN1YnNjcmliZSB0byBpdC4gVGhhdCB3aWxsIHJlcXVpcmVkXG5cdCAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBmb3Igc29ydGluZywgd2hpY2ggaXMgd2h5IGl0IGlzIG5vdCBhbHJlYWR5IGJha2VkIGluXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93SWR4LCBzcmMsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgcm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBjZWxsV3JpdGUgPSBmdW5jdGlvbiAoIGNlbGwsIGNvbCApIHtcblx0XHRcdC8vIFRoaXMgaXMgdmVyeSBmcnVzdHJhdGluZywgYnV0IGluIElFIGlmIHlvdSBqdXN0IHdyaXRlIGRpcmVjdGx5XG5cdFx0XHQvLyB0byBpbm5lckhUTUwsIGFuZCBlbGVtZW50cyB0aGF0IGFyZSBvdmVyd3JpdHRlbiBhcmUgR0MnZWQsXG5cdFx0XHQvLyBldmVuIGlmIHRoZXJlIGlzIGEgcmVmZXJlbmNlIHRvIHRoZW0gZWxzZXdoZXJlXG5cdFx0XHR3aGlsZSAoIGNlbGwuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQ2hpbGQoIGNlbGwuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGNlbGwuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbCwgJ2Rpc3BsYXknICk7XG5cdFx0fTtcblx0XG5cdFx0Ly8gQXJlIHdlIHJlYWRpbmcgbGFzdCBkYXRhIGZyb20gRE9NIG9yIHRoZSBkYXRhIG9iamVjdD9cblx0XHRpZiAoIHNyYyA9PT0gJ2RvbScgfHwgKCghIHNyYyB8fCBzcmMgPT09ICdhdXRvJykgJiYgcm93LnNyYyA9PT0gJ2RvbScpICkge1xuXHRcdFx0Ly8gUmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBET01cblx0XHRcdHJvdy5fYURhdGEgPSBfZm5HZXRSb3dFbGVtZW50cyhcblx0XHRcdFx0XHRzZXR0aW5ncywgcm93LCBjb2xJZHgsIGNvbElkeCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcm93Ll9hRGF0YVxuXHRcdFx0XHQpXG5cdFx0XHRcdC5kYXRhO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlYWRpbmcgZnJvbSBkYXRhIG9iamVjdCwgdXBkYXRlIHRoZSBET01cblx0XHRcdHZhciBjZWxscyA9IHJvdy5hbkNlbGxzO1xuXHRcblx0XHRcdGlmICggY2VsbHMgKSB7XG5cdFx0XHRcdGlmICggY29sSWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tjb2xJZHhdLCBjb2xJZHggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRmb3IgKCBpPTAsIGllbj1jZWxscy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdGNlbGxXcml0ZSggY2VsbHNbaV0sIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIEZvciBib3RoIHJvdyBhbmQgY2VsbCBpbnZhbGlkYXRpb24sIHRoZSBjYWNoZWQgZGF0YSBmb3Igc29ydGluZyBhbmRcblx0XHQvLyBmaWx0ZXJpbmcgaXMgbnVsbGVkIG91dFxuXHRcdHJvdy5fYVNvcnREYXRhID0gbnVsbDtcblx0XHRyb3cuX2FGaWx0ZXJEYXRhID0gbnVsbDtcblx0XG5cdFx0Ly8gSW52YWxpZGF0ZSB0aGUgdHlwZSBmb3IgYSBzcGVjaWZpYyBjb2x1bW4gKGlmIGdpdmVuKSBvciBhbGwgY29sdW1ucyBzaW5jZVxuXHRcdC8vIHRoZSBkYXRhIG1pZ2h0IGhhdmUgY2hhbmdlZFxuXHRcdHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdGlmICggY29sSWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjb2xzWyBjb2xJZHggXS5zVHlwZSA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggaT0wLCBpZW49Y29scy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y29sc1tpXS5zVHlwZSA9IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gVXBkYXRlIERhdGFUYWJsZXMgc3BlY2lhbCBgRFRfKmAgYXR0cmlidXRlcyBmb3IgdGhlIHJvd1xuXHRcdFx0X2ZuUm93QXR0cmlidXRlcyggc2V0dGluZ3MsIHJvdyApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCdWlsZCBhIGRhdGEgc291cmNlIG9iamVjdCBmcm9tIGFuIEhUTUwgcm93LCByZWFkaW5nIHRoZSBjb250ZW50cyBvZiB0aGVcblx0ICogY2VsbHMgdGhhdCBhcmUgaW4gdGhlIHJvdy5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqIEBwYXJhbSB7bm9kZXxvYmplY3R9IFRSIGVsZW1lbnQgZnJvbSB3aGljaCB0byByZWFkIGRhdGEgb3IgZXhpc3Rpbmcgcm93XG5cdCAqICAgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmUtcmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBjZWxsc1xuXHQgKiBAcGFyYW0ge2ludH0gW2NvbElkeF0gT3B0aW9uYWwgY29sdW1uIGluZGV4XG5cdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBbZF0gRGF0YSBzb3VyY2Ugb2JqZWN0LiBJZiBgY29sSWR4YCBpcyBnaXZlbiB0aGVuIHRoaXNcblx0ICogICBwYXJhbWV0ZXIgc2hvdWxkIGFsc28gYmUgZ2l2ZW4gYW5kIHdpbGwgYmUgdXNlZCB0byB3cml0ZSB0aGUgZGF0YSBpbnRvLlxuXHQgKiAgIE9ubHkgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiB3aWxsIGJlIHdyaXR0ZW5cblx0ICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IHdpdGggdHdvIHBhcmFtZXRlcnM6IGBkYXRhYCB0aGUgZGF0YSByZWFkLCBpblxuXHQgKiAgIGRvY3VtZW50IG9yZGVyLCBhbmQgYGNlbGxzYCBhbmQgYXJyYXkgb2Ygbm9kZXMgKHRoZXkgY2FuIGJlIHVzZWZ1bCB0byB0aGVcblx0ICogICBjYWxsZXIsIHNvIHJhdGhlciB0aGFuIG5lZWRpbmcgYSBzZWNvbmQgdHJhdmVyc2FsIHRvIGdldCB0aGVtLCBqdXN0IHJldHVyblxuXHQgKiAgIHRoZW0gZnJvbSBoZXJlKS5cblx0ICogQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRSb3dFbGVtZW50cyggc2V0dGluZ3MsIHJvdywgY29sSWR4LCBkIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dGRzID0gW10sXG5cdFx0XHR0ZCA9IHJvdy5maXJzdENoaWxkLFxuXHRcdFx0bmFtZSwgY29sLCBvLCBpPTAsIGNvbnRlbnRzLFxuXHRcdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdG9iamVjdFJlYWQgPSBzZXR0aW5ncy5fcm93UmVhZE9iamVjdDtcblx0XG5cdFx0Ly8gQWxsb3cgdGhlIGRhdGEgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiwgb3IgY29uc3RydWN0XG5cdFx0ZCA9IGQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRkIDpcblx0XHRcdG9iamVjdFJlYWQgP1xuXHRcdFx0XHR7fSA6XG5cdFx0XHRcdFtdO1xuXHRcblx0XHR2YXIgYXR0ciA9IGZ1bmN0aW9uICggc3RyLCB0ZCAgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR2YXIgaWR4ID0gc3RyLmluZGV4T2YoJ0AnKTtcblx0XG5cdFx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IHN0ci5zdWJzdHJpbmcoIGlkeCsxICk7XG5cdFx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggc3RyICk7XG5cdFx0XHRcdFx0c2V0dGVyKCBkLCB0ZC5nZXRBdHRyaWJ1dGUoIGF0dHIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0Ly8gUmVhZCBkYXRhIGZyb20gYSBjZWxsIGFuZCBzdG9yZSBpbnRvIHRoZSBkYXRhIG9iamVjdFxuXHRcdHZhciBjZWxsUHJvY2VzcyA9IGZ1bmN0aW9uICggY2VsbCApIHtcblx0XHRcdGlmICggY29sSWR4ID09PSB1bmRlZmluZWQgfHwgY29sSWR4ID09PSBpICkge1xuXHRcdFx0XHRjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHRjb250ZW50cyA9IChjZWxsLmlubmVySFRNTCkudHJpbSgpO1xuXHRcblx0XHRcdFx0aWYgKCBjb2wgJiYgY29sLl9iQXR0clNyYyApIHtcblx0XHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBjb2wubURhdGEuXyApO1xuXHRcdFx0XHRcdHNldHRlciggZCwgY29udGVudHMgKTtcblx0XG5cdFx0XHRcdFx0YXR0ciggY29sLm1EYXRhLnNvcnQsIGNlbGwgKTtcblx0XHRcdFx0XHRhdHRyKCBjb2wubURhdGEudHlwZSwgY2VsbCApO1xuXHRcdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5maWx0ZXIsIGNlbGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBEZXBlbmRpbmcgb24gdGhlIGBkYXRhYCBvcHRpb24gZm9yIHRoZSBjb2x1bW5zIHRoZSBkYXRhIGNhblxuXHRcdFx0XHRcdC8vIGJlIHJlYWQgdG8gZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cblx0XHRcdFx0XHRpZiAoIG9iamVjdFJlYWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICEgY29sLl9zZXR0ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBzZXR0ZXIgZnVuY3Rpb25cblx0XHRcdFx0XHRcdFx0Y29sLl9zZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIGNvbC5tRGF0YSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29sLl9zZXR0ZXIoIGQsIGNvbnRlbnRzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0ZFtpXSA9IGNvbnRlbnRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGkrKztcblx0XHR9O1xuXHRcblx0XHRpZiAoIHRkICkge1xuXHRcdFx0Ly8gYHRyYCBlbGVtZW50IHdhcyBwYXNzZWQgaW5cblx0XHRcdHdoaWxlICggdGQgKSB7XG5cdFx0XHRcdG5hbWUgPSB0ZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcblx0XHRcdFx0aWYgKCBuYW1lID09IFwiVERcIiB8fCBuYW1lID09IFwiVEhcIiApIHtcblx0XHRcdFx0XHRjZWxsUHJvY2VzcyggdGQgKTtcblx0XHRcdFx0XHR0ZHMucHVzaCggdGQgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0dGQgPSB0ZC5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBFeGlzdGluZyByb3cgb2JqZWN0IHBhc3NlZCBpblxuXHRcdFx0dGRzID0gcm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0Zm9yICggdmFyIGo9MCwgamVuPXRkcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0Y2VsbFByb2Nlc3MoIHRkc1tqXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gUmVhZCB0aGUgSUQgZnJvbSB0aGUgRE9NIGlmIHByZXNlbnRcblx0XHR2YXIgcm93Tm9kZSA9IHJvdy5maXJzdENoaWxkID8gcm93IDogcm93Lm5Ucjtcblx0XG5cdFx0aWYgKCByb3dOb2RlICkge1xuXHRcdFx0dmFyIGlkID0gcm93Tm9kZS5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XG5cdFx0XHRpZiAoIGlkICkge1xuXHRcdFx0XHRfZm5TZXRPYmplY3REYXRhRm4oIHNldHRpbmdzLnJvd0lkICkoIGQsIGlkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YTogZCxcblx0XHRcdGNlbGxzOiB0ZHNcblx0XHR9O1xuXHR9XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgVFIgZWxlbWVudCAoYW5kIGl0J3MgVEQgY2hpbGRyZW4pIGZvciBhIHJvd1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlSb3cgUm93IHRvIGNvbnNpZGVyXG5cdCAqICBAcGFyYW0ge25vZGV9IFtuVHJJbl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcblx0ICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XG5cdCAqICBAcGFyYW0ge2FycmF5fSBbYW5UZHNdIEFycmF5IG9mIFREfFRIIGVsZW1lbnRzIGZvciB0aGUgcm93IC0gbXVzdCBiZSBnaXZlblxuXHQgKiAgICBpZiBuVHIgaXMuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNyZWF0ZVRyICggb1NldHRpbmdzLCBpUm93LCBuVHJJbiwgYW5UZHMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRyb3cgPSBvU2V0dGluZ3MuYW9EYXRhW2lSb3ddLFxuXHRcdFx0cm93RGF0YSA9IHJvdy5fYURhdGEsXG5cdFx0XHRjZWxscyA9IFtdLFxuXHRcdFx0blRyLCBuVGQsIG9Db2wsXG5cdFx0XHRpLCBpTGVuLCBjcmVhdGU7XG5cdFxuXHRcdGlmICggcm93Lm5UciA9PT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0blRyID0gblRySW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblx0XG5cdFx0XHRyb3cublRyID0gblRyO1xuXHRcdFx0cm93LmFuQ2VsbHMgPSBjZWxscztcblx0XG5cdFx0XHQvKiBVc2UgYSBwcml2YXRlIHByb3BlcnR5IG9uIHRoZSBub2RlIHRvIGFsbG93IHJlc2VydmUgbWFwcGluZyBmcm9tIHRoZSBub2RlXG5cdFx0XHQgKiB0byB0aGUgYW9EYXRhIGFycmF5IGZvciBmYXN0IGxvb2sgdXBcblx0XHRcdCAqL1xuXHRcdFx0blRyLl9EVF9Sb3dJbmRleCA9IGlSb3c7XG5cdFxuXHRcdFx0LyogU3BlY2lhbCBwYXJhbWV0ZXJzIGNhbiBiZSBnaXZlbiBieSB0aGUgZGF0YSBzb3VyY2UgdG8gYmUgdXNlZCBvbiB0aGUgcm93ICovXG5cdFx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBvU2V0dGluZ3MsIHJvdyApO1xuXHRcblx0XHRcdC8qIFByb2Nlc3MgZWFjaCBjb2x1bW4gKi9cblx0XHRcdGZvciAoIGk9MCwgaUxlbj1vU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xuXHRcdFx0XHRjcmVhdGUgPSBuVHJJbiA/IGZhbHNlIDogdHJ1ZTtcblx0XG5cdFx0XHRcdG5UZCA9IGNyZWF0ZSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIG9Db2wuc0NlbGxUeXBlICkgOiBhblRkc1tpXTtcblx0XHRcdFx0blRkLl9EVF9DZWxsSW5kZXggPSB7XG5cdFx0XHRcdFx0cm93OiBpUm93LFxuXHRcdFx0XHRcdGNvbHVtbjogaVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y2VsbHMucHVzaCggblRkICk7XG5cdFxuXHRcdFx0XHQvLyBOZWVkIHRvIGNyZWF0ZSB0aGUgSFRNTCBpZiBuZXcsIG9yIGlmIGEgcmVuZGVyaW5nIGZ1bmN0aW9uIGlzIGRlZmluZWRcblx0XHRcdFx0aWYgKCBjcmVhdGUgfHwgKChvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcblx0XHRcdFx0XHQgKCEkLmlzUGxhaW5PYmplY3Qob0NvbC5tRGF0YSkgfHwgb0NvbC5tRGF0YS5fICE9PSBpKycuZGlzcGxheScpXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRuVGQuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSwgJ2Rpc3BsYXknICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8qIEFkZCB1c2VyIGRlZmluZWQgY2xhc3MgKi9cblx0XHRcdFx0aWYgKCBvQ29sLnNDbGFzcyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuVGQuY2xhc3NOYW1lICs9ICcgJytvQ29sLnNDbGFzcztcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gVmlzaWJpbGl0eSAtIGFkZCBvciByZW1vdmUgYXMgcmVxdWlyZWRcblx0XHRcdFx0aWYgKCBvQ29sLmJWaXNpYmxlICYmICEgblRySW4gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0blRyLmFwcGVuZENoaWxkKCBuVGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggISBvQ29sLmJWaXNpYmxlICYmIG5UckluIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5UZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBuVGQgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCBvQ29sLmZuQ3JlYXRlZENlbGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0b0NvbC5mbkNyZWF0ZWRDZWxsLmNhbGwoIG9TZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRcdFx0XHRuVGQsIF9mbkdldENlbGxEYXRhKCBvU2V0dGluZ3MsIGlSb3csIGkgKSwgcm93RGF0YSwgaVJvdywgaVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgbnVsbCwgW25Uciwgcm93RGF0YSwgaVJvdywgY2VsbHNdICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxuXHQgKiBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKVxuXHR7XG5cdFx0dmFyIHRyID0gcm93Lm5Ucjtcblx0XHR2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cdFxuXHRcdGlmICggdHIgKSB7XG5cdFx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhICk7XG5cdFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0dHIuaWQgPSBpZDtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93Q2xhc3MgKSB7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgY2xhc3NlcyBhZGRlZCBieSBEVF9Sb3dDbGFzcyBiZWZvcmVcblx0XHRcdFx0dmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XG5cdFx0XHRcdHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cblx0XHRcdFx0XHRfdW5pcXVlKCByb3cuX19yb3djLmNvbmNhdCggYSApICkgOlxuXHRcdFx0XHRcdGE7XG5cdFxuXHRcdFx0XHQkKHRyKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggcm93Ll9fcm93Yy5qb2luKCcgJykgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggZGF0YS5EVF9Sb3dDbGFzcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZGF0YS5EVF9Sb3dBdHRyICkge1xuXHRcdFx0XHQkKHRyKS5hdHRyKCBkYXRhLkRUX1Jvd0F0dHIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93RGF0YSApIHtcblx0XHRcdFx0JCh0cikuZGF0YSggZGF0YS5EVF9Sb3dEYXRhICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEhlYWQoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaWVuLCBjZWxsLCByb3csIGNvbHVtbjtcblx0XHR2YXIgdGhlYWQgPSBvU2V0dGluZ3MublRIZWFkO1xuXHRcdHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XG5cdFx0dmFyIGNyZWF0ZUhlYWRlciA9ICQoJ3RoLCB0ZCcsIHRoZWFkKS5sZW5ndGggPT09IDA7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdHJvdyA9ICQoJzx0ci8+JykuYXBwZW5kVG8oIHRoZWFkICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdGNlbGwgPSAkKCBjb2x1bW4ublRoICkuYWRkQ2xhc3MoIGNvbHVtbi5zQ2xhc3MgKTtcblx0XG5cdFx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdFx0Y2VsbC5hcHBlbmRUbyggcm93ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gMS4xMSBtb3ZlIGludG8gc29ydGluZ1xuXHRcdFx0aWYgKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRjZWxsLmFkZENsYXNzKCBjb2x1bW4uc1NvcnRpbmdDbGFzcyApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQuYXR0ciggJ3RhYmluZGV4Jywgb1NldHRpbmdzLmlUYWJJbmRleCApXG5cdFx0XHRcdFx0XHQuYXR0ciggJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQgKTtcblx0XG5cdFx0XHRcdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKCBvU2V0dGluZ3MsIGNvbHVtbi5uVGgsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggY29sdW1uLnNUaXRsZSAhPSBjZWxsWzBdLmlubmVySFRNTCApIHtcblx0XHRcdFx0Y2VsbC5odG1sKCBjb2x1bW4uc1RpdGxlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuUmVuZGVyZXIoIG9TZXR0aW5ncywgJ2hlYWRlcicgKShcblx0XHRcdFx0b1NldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCApO1xuXHRcdH1cblx0XG5cdFx0LyogRGVhbCB3aXRoIHRoZSBmb290ZXIgLSBhZGQgY2xhc3NlcyBpZiByZXF1aXJlZCAqL1xuXHRcdCQodGhlYWQpLmNoaWxkcmVuKCd0cicpLmNoaWxkcmVuKCd0aCwgdGQnKS5hZGRDbGFzcyggY2xhc3Nlcy5zSGVhZGVyVEggKTtcblx0XHQkKHRmb290KS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJykuYWRkQ2xhc3MoIGNsYXNzZXMuc0Zvb3RlclRIICk7XG5cdFxuXHRcdC8vIENhY2hlIHRoZSBmb290ZXIgY2VsbHMuIE5vdGUgdGhhdCB3ZSBvbmx5IHRha2UgdGhlIGNlbGxzIGZyb20gdGhlIGZpcnN0XG5cdFx0Ly8gcm93IGluIHRoZSBmb290ZXIuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcm93IHRoZSB1c2VyIHdhbnRzIHRvXG5cdFx0Ly8gaW50ZXJhY3Qgd2l0aCwgdGhleSBuZWVkIHRvIHVzZSB0aGUgdGFibGUoKS5mb290KCkgbWV0aG9kLiBOb3RlIGFsc28gdGhpc1xuXHRcdC8vIGFsbG93cyBjZWxscyB0byBiZSB1c2VkIGZvciBtdWx0aXBsZSBjb2x1bW5zIHVzaW5nIGNvbHNwYW5cblx0XHRpZiAoIHRmb290ICE9PSBudWxsICkge1xuXHRcdFx0dmFyIGNlbGxzID0gb1NldHRpbmdzLmFvRm9vdGVyWzBdO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHRjb2x1bW4ublRmID0gY2VsbHNbaV0uY2VsbDtcblx0XG5cdFx0XHRcdGlmICggY29sdW1uLnNDbGFzcyApIHtcblx0XHRcdFx0XHQkKGNvbHVtbi5uVGYpLmFkZENsYXNzKCBjb2x1bW4uc0NsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy4gVGhlXG5cdCAqIG1ldGhvZG9sb2d5IGhlcmUgaXMgdG8gdXNlIHRoZSBsYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXIsIG1vZGlmaWVkIGZvclxuXHQgKiB0aGUgaW5zdGFudGFuZW91cyBjb2x1bW4gdmlzaWJpbGl0eSwgdG8gY29uc3RydWN0IHRoZSBuZXcgbGF5b3V0LiBUaGUgZ3JpZCBpc1xuXHQgKiB0cmF2ZXJzZWQgb3ZlciBjZWxsIGF0IGEgdGltZSBpbiBhIHJvd3MgeCBjb2x1bW5zIGdyaWQgZmFzaGlvbiwgYWx0aG91Z2ggZWFjaFxuXHQgKiBjZWxsIGluc2VydCBjYW4gY292ZXIgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIGdyaWQgLSB3aGljaCBpcyB0cmFja3MgdXNpbmcgdGhlXG5cdCAqIGFBcHBsaWVkIGFycmF5LiBDZWxsIGluc2VydHMgaW4gdGhlIGdyaWQgd2lsbCBvbmx5IG9jY3VyIHdoZXJlIHRoZXJlIGlzbid0XG5cdCAqIGFscmVhZHkgYSBjZWxsIGluIHRoYXQgcG9zaXRpb24uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdHN9IGFvU291cmNlIExheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlclxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYkluY2x1ZGVIaWRkZW49ZmFsc2VdIElmIHRydWUgdGhlbiBpbmNsdWRlIHRoZSBoaWRkZW4gY29sdW1ucyBpbiB0aGUgY2FsYyxcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhd0hlYWQoIG9TZXR0aW5ncywgYW9Tb3VyY2UsIGJJbmNsdWRlSGlkZGVuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBuLCBuTG9jYWxUcjtcblx0XHR2YXIgYW9Mb2NhbCA9IFtdO1xuXHRcdHZhciBhQXBwbGllZCA9IFtdO1xuXHRcdHZhciBpQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBpUm93c3BhbiwgaUNvbHNwYW47XG5cdFxuXHRcdGlmICggISBhb1NvdXJjZSApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAgYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0YkluY2x1ZGVIaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aG91dCB0aGUgdmlzaWJsZSBjb2x1bW5zIGluIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvU291cmNlLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0YW9Mb2NhbFtpXSA9IGFvU291cmNlW2ldLnNsaWNlKCk7XG5cdFx0XHRhb0xvY2FsW2ldLm5UciA9IGFvU291cmNlW2ldLm5Ucjtcblx0XG5cdFx0XHQvKiBSZW1vdmUgYW55IGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBoaWRkZW4gKi9cblx0XHRcdGZvciAoIGo9aUNvbHVtbnMtMSA7IGo+PTAgOyBqLS0gKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFvU2V0dGluZ3MuYW9Db2x1bW5zW2pdLmJWaXNpYmxlICYmICFiSW5jbHVkZUhpZGRlbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhb0xvY2FsW2ldLnNwbGljZSggaiwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUHJlcCB0aGUgYXBwbGllZCBhcnJheSAtIGl0IG5lZWRzIGFuIGVsZW1lbnQgZm9yIGVhY2ggcm93ICovXG5cdFx0XHRhQXBwbGllZC5wdXNoKCBbXSApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvTG9jYWwubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRuTG9jYWxUciA9IGFvTG9jYWxbaV0ublRyO1xuXHRcblx0XHRcdC8qIEFsbCBjZWxscyBhcmUgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHNvIGVtcHR5IG91dCB0aGUgcm93ICovXG5cdFx0XHRpZiAoIG5Mb2NhbFRyIClcblx0XHRcdHtcblx0XHRcdFx0d2hpbGUoIChuID0gbkxvY2FsVHIuZmlyc3RDaGlsZCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGo9MCwgakxlbj1hb0xvY2FsW2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlSb3dzcGFuID0gMTtcblx0XHRcdFx0aUNvbHNwYW4gPSAxO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuXHRcdFx0XHQgKiBpbnNlcnQgcG9pbnQuIElmIHRoZXJlIGlzLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIuYXBwZW5kQ2hpbGQoIGFvTG9jYWxbaV1bal0uY2VsbCApO1xuXHRcdFx0XHRcdGFBcHBsaWVkW2ldW2pdID0gMTtcblx0XG5cdFx0XHRcdFx0LyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cblx0XHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaStpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaStpUm93c3Bhbl1bal0uY2VsbCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YUFwcGxpZWRbaStpUm93c3Bhbl1bal0gPSAxO1xuXHRcdFx0XHRcdFx0aVJvd3NwYW4rKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IGNvbHVtbnMgYXMgbmVlZGVkICovXG5cdFx0XHRcdFx0d2hpbGUgKCBhb0xvY2FsW2ldW2oraUNvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2ldW2oraUNvbHNwYW5dLmNlbGwgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIE11c3QgdXBkYXRlIHRoZSBhcHBsaWVkIGFycmF5IG92ZXIgdGhlIHJvd3MgZm9yIHRoZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGlSb3dzcGFuIDsgaysrIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YUFwcGxpZWRbaStrXVtqK2lDb2xzcGFuXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpQ29sc3BhbisrO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogRG8gdGhlIGFjdHVhbCBleHBhbnNpb24gaW4gdGhlIERPTSAqL1xuXHRcdFx0XHRcdCQoYW9Mb2NhbFtpXVtqXS5jZWxsKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3Bhbilcblx0XHRcdFx0XHRcdC5hdHRyKCdjb2xzcGFuJywgaUNvbHNwYW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSBhamF4Q29tcGxldGUgdHJ1ZSBhZnRlciBhamF4IGNhbGwgdG8gY29tcGxldGUgcmVuZGVyaW5nXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRyYXcoIG9TZXR0aW5ncywgYWpheENvbXBsZXRlIClcblx0e1xuXHRcdC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXG5cdFx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFQcmVEcmF3ICkgIT09IC0xIClcblx0XHR7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyIGksIGlMZW4sIG47XG5cdFx0dmFyIGFuUm93cyA9IFtdO1xuXHRcdHZhciBpUm93Q291bnQgPSAwO1xuXHRcdHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHRcdHZhciBpU3RyaXBlcyA9IGFzU3RyaXBlQ2xhc3Nlcy5sZW5ndGg7XG5cdFx0dmFyIGlPcGVuUm93cyA9IG9TZXR0aW5ncy5hb09wZW5Sb3dzLmxlbmd0aDtcblx0XHR2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdHZhciBpSW5pdERpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0XHR2YXIgYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheTtcblx0XG5cdFx0b1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcblx0XG5cdFx0LyogQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZyAqL1xuXHRcdGlmICggaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IGJTZXJ2ZXJTaWRlID9cblx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQgOlxuXHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydDtcblx0XG5cdFx0XHRvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcblx0XHR9XG5cdFxuXHRcdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHRcdHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcblx0XG5cdFx0LyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xuXHRcdGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhYlNlcnZlclNpZGUgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhYWpheENvbXBsZXRlKVxuXHRcdHtcblx0XHRcdF9mbkFqYXhVcGRhdGUoIG9TZXR0aW5ncyApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBhaURpc3BsYXkubGVuZ3RoICE9PSAwIClcblx0XHR7XG5cdFx0XHR2YXIgaVN0YXJ0ID0gYlNlcnZlclNpZGUgPyAwIDogaURpc3BsYXlTdGFydDtcblx0XHRcdHZhciBpRW5kID0gYlNlcnZlclNpZGUgPyBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA6IGlEaXNwbGF5RW5kO1xuXHRcblx0XHRcdGZvciAoIHZhciBqPWlTdGFydCA7IGo8aUVuZCA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBpRGF0YUluZGV4ID0gYWlEaXNwbGF5W2pdO1xuXHRcdFx0XHR2YXIgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YVsgaURhdGFJbmRleCBdO1xuXHRcdFx0XHRpZiAoIGFvRGF0YS5uVHIgPT09IG51bGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaURhdGFJbmRleCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR2YXIgblJvdyA9IGFvRGF0YS5uVHI7XG5cdFxuXHRcdFx0XHQvKiBSZW1vdmUgdGhlIG9sZCBzdHJpcGluZyBjbGFzc2VzIGFuZCB0aGVuIGFkZCB0aGUgbmV3IG9uZSAqL1xuXHRcdFx0XHRpZiAoIGlTdHJpcGVzICE9PSAwIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBzU3RyaXBlID0gYXNTdHJpcGVDbGFzc2VzWyBpUm93Q291bnQgJSBpU3RyaXBlcyBdO1xuXHRcdFx0XHRcdGlmICggYW9EYXRhLl9zUm93U3RyaXBlICE9IHNTdHJpcGUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdCQoblJvdykucmVtb3ZlQ2xhc3MoIGFvRGF0YS5fc1Jvd1N0cmlwZSApLmFkZENsYXNzKCBzU3RyaXBlICk7XG5cdFx0XHRcdFx0XHRhb0RhdGEuX3NSb3dTdHJpcGUgPSBzU3RyaXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gUm93IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIG1pZ2h0IHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGUgcm93XG5cdFx0XHRcdC8vIGlSb3dDb3VudCBhbmQgaiBhcmUgbm90IGN1cnJlbnRseSBkb2N1bWVudGVkLiBBcmUgdGhleSBhdCBhbGxcblx0XHRcdFx0Ly8gdXNlZnVsP1xuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxuXHRcdFx0XHRcdFtuUm93LCBhb0RhdGEuX2FEYXRhLCBpUm93Q291bnQsIGosIGlEYXRhSW5kZXhdICk7XG5cdFxuXHRcdFx0XHRhblJvd3MucHVzaCggblJvdyApO1xuXHRcdFx0XHRpUm93Q291bnQrKztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8qIFRhYmxlIGlzIGVtcHR5IC0gY3JlYXRlIGEgcm93IHdpdGggYW4gZW1wdHkgbWVzc2FnZSBpbiBpdCAqL1xuXHRcdFx0dmFyIHNaZXJvID0gb0xhbmcuc1plcm9SZWNvcmRzO1xuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaURyYXcgPT0gMSAmJiAgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ2FqYXgnIClcblx0XHRcdHtcblx0XHRcdFx0c1plcm8gPSBvTGFuZy5zTG9hZGluZ1JlY29yZHM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb0xhbmcuc0VtcHR5VGFibGUgJiYgb1NldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkgPT09IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHRzWmVybyA9IG9MYW5nLnNFbXB0eVRhYmxlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGFuUm93c1sgMCBdID0gJCggJzx0ci8+JywgeyAnY2xhc3MnOiBpU3RyaXBlcyA/IGFzU3RyaXBlQ2xhc3Nlc1swXSA6ICcnIH0gKVxuXHRcdFx0XHQuYXBwZW5kKCAkKCc8dGQgLz4nLCB7XG5cdFx0XHRcdFx0J3ZhbGlnbic6ICAndG9wJyxcblx0XHRcdFx0XHQnY29sU3Bhbic6IF9mblZpc2JsZUNvbHVtbnMoIG9TZXR0aW5ncyApLFxuXHRcdFx0XHRcdCdjbGFzcyc6ICAgb1NldHRpbmdzLm9DbGFzc2VzLnNSb3dFbXB0eVxuXHRcdFx0XHR9ICkuaHRtbCggc1plcm8gKSApWzBdO1xuXHRcdH1cblx0XG5cdFx0LyogSGVhZGVyIGFuZCBmb290ZXIgY2FsbGJhY2tzICovXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFsgJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcblx0XHRcdF9mbkdldERhdGFNYXN0ZXIoIG9TZXR0aW5ncyApLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5IF0gKTtcblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFsgJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcblx0XHRcdF9mbkdldERhdGFNYXN0ZXIoIG9TZXR0aW5ncyApLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5IF0gKTtcblx0XG5cdFx0dmFyIGJvZHkgPSAkKG9TZXR0aW5ncy5uVEJvZHkpO1xuXHRcblx0XHRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0Ym9keS5hcHBlbmQoICQoYW5Sb3dzKSApO1xuXHRcblx0XHQvKiBDYWxsIGFsbCByZXF1aXJlZCBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBlbmQgb2YgYSBkcmF3ICovXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10gKTtcblx0XG5cdFx0LyogRHJhdyBpcyBjb21wbGV0ZSwgc29ydGluZyBhbmQgZmlsdGVyaW5nIG11c3QgYmUgYXMgd2VsbCAqL1xuXHRcdG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XG5cdFx0b1NldHRpbmdzLmJGaWx0ZXJlZCA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5iRHJhd2luZyA9IGZhbHNlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlZHJhdyB0aGUgdGFibGUgLSB0YWtpbmcgYWNjb3VudCBvZiB0aGUgdmFyaW91cyBmZWF0dXJlcyB3aGljaCBhcmUgZW5hYmxlZFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbaG9sZFBvc2l0aW9uXSBLZWVwIHRoZSBjdXJyZW50IHBhZ2luZyBwb3NpdGlvbi4gQnkgZGVmYXVsdFxuXHQgKiAgICB0aGUgcGFnaW5nIGlzIHJlc2V0IHRvIHRoZSBmaXJzdCBwYWdlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiApXG5cdHtcblx0XHR2YXJcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdFx0c29ydCAgICAgPSBmZWF0dXJlcy5iU29ydCxcblx0XHRcdGZpbHRlciAgID0gZmVhdHVyZXMuYkZpbHRlcjtcblx0XG5cdFx0aWYgKCBzb3J0ICkge1xuXHRcdFx0X2ZuU29ydCggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZmlsdGVyICkge1xuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBmaWx0ZXJpbmcsIHNvIHdlIHdhbnQgdG8ganVzdCB1c2UgdGhlIGRpc3BsYXkgbWFzdGVyXG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHR9XG5cdFxuXHRcdGlmICggaG9sZFBvc2l0aW9uICE9PSB0cnVlICkge1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdH1cblx0XG5cdFx0Ly8gTGV0IGFueSBtb2R1bGVzIGtub3cgYWJvdXQgdGhlIGRyYXcgaG9sZCBwb3NpdGlvbiBzdGF0ZSAodXNlZCBieVxuXHRcdC8vIHNjcm9sbGluZyBpbnRlcm5hbGx5KVxuXHRcdHNldHRpbmdzLl9kcmF3SG9sZCA9IGhvbGRQb3NpdGlvbjtcblx0XG5cdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0c2V0dGluZ3MuX2RyYXdIb2xkID0gZmFsc2U7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQWRkIHRoZSBvcHRpb25zIHRvIHRoZSBwYWdlIEhUTUwgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGRPcHRpb25zSHRtbCAoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgY2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGFibGUgPSAkKG9TZXR0aW5ncy5uVGFibGUpO1xuXHRcdHZhciBob2xkaW5nID0gJCgnPGRpdi8+JykuaW5zZXJ0QmVmb3JlKCB0YWJsZSApOyAvLyBIb2xkaW5nIGVsZW1lbnQgZm9yIHNwZWVkXG5cdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XG5cdFx0Ly8gQWxsIERhdGFUYWJsZXMgYXJlIHdyYXBwZWQgaW4gYSBkaXZcblx0XHR2YXIgaW5zZXJ0ID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0aWQ6ICAgICAgb1NldHRpbmdzLnNUYWJsZUlkKydfd3JhcHBlcicsXG5cdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNXcmFwcGVyICsgKG9TZXR0aW5ncy5uVEZvb3QgPyAnJyA6ICcgJytjbGFzc2VzLnNOb0Zvb3Rlcilcblx0XHR9ICk7XG5cdFxuXHRcdG9TZXR0aW5ncy5uSG9sZGluZyA9IGhvbGRpbmdbMF07XG5cdFx0b1NldHRpbmdzLm5UYWJsZVdyYXBwZXIgPSBpbnNlcnRbMF07XG5cdFx0b1NldHRpbmdzLm5UYWJsZVJlaW5zZXJ0QmVmb3JlID0gb1NldHRpbmdzLm5UYWJsZS5uZXh0U2libGluZztcblx0XG5cdFx0LyogTG9vcCBvdmVyIHRoZSB1c2VyIHNldCBwb3NpdGlvbmluZyBhbmQgcGxhY2UgdGhlIGVsZW1lbnRzIGFzIG5lZWRlZCAqL1xuXHRcdHZhciBhRG9tID0gb1NldHRpbmdzLnNEb20uc3BsaXQoJycpO1xuXHRcdHZhciBmZWF0dXJlTm9kZSwgY09wdGlvbiwgbk5ld05vZGUsIGNOZXh0LCBzQXR0ciwgajtcblx0XHRmb3IgKCB2YXIgaT0wIDsgaTxhRG9tLmxlbmd0aCA7IGkrKyApXG5cdFx0e1xuXHRcdFx0ZmVhdHVyZU5vZGUgPSBudWxsO1xuXHRcdFx0Y09wdGlvbiA9IGFEb21baV07XG5cdFxuXHRcdFx0aWYgKCBjT3B0aW9uID09ICc8JyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIE5ldyBjb250YWluZXIgZGl2ICovXG5cdFx0XHRcdG5OZXdOb2RlID0gJCgnPGRpdi8+JylbMF07XG5cdFxuXHRcdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIGFwcGVuZCBhbiBpZCBhbmQvb3IgYSBjbGFzcyBuYW1lIHRvIHRoZSBjb250YWluZXIgKi9cblx0XHRcdFx0Y05leHQgPSBhRG9tW2krMV07XG5cdFx0XHRcdGlmICggY05leHQgPT0gXCInXCIgfHwgY05leHQgPT0gJ1wiJyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzQXR0ciA9IFwiXCI7XG5cdFx0XHRcdFx0aiA9IDI7XG5cdFx0XHRcdFx0d2hpbGUgKCBhRG9tW2kral0gIT0gY05leHQgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNBdHRyICs9IGFEb21baStqXTtcblx0XHRcdFx0XHRcdGorKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIFJlcGxhY2UgalF1ZXJ5IFVJIGNvbnN0YW50cyBAdG9kbyBkZXByZWNpYXRlZCAqL1xuXHRcdFx0XHRcdGlmICggc0F0dHIgPT0gXCJIXCIgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNBdHRyID0gY2xhc3Nlcy5zSlVJSGVhZGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggc0F0dHIgPT0gXCJGXCIgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNBdHRyID0gY2xhc3Nlcy5zSlVJRm9vdGVyO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogVGhlIGF0dHJpYnV0ZSBjYW4gYmUgaW4gdGhlIGZvcm1hdCBvZiBcIiNpZC5jbGFzc1wiLCBcIiNpZFwiIG9yIFwiY2xhc3NcIiBUaGlzIGxvZ2ljXG5cdFx0XHRcdFx0ICogYnJlYWtzIHRoZSBzdHJpbmcgaW50byBwYXJ0cyBhbmQgYXBwbGllcyB0aGVtIGFzIG5lZWRlZFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlmICggc0F0dHIuaW5kZXhPZignLicpICE9IC0xIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgYVNwbGl0ID0gc0F0dHIuc3BsaXQoJy4nKTtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmlkID0gYVNwbGl0WzBdLnN1YnN0cigxLCBhU3BsaXRbMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuY2xhc3NOYW1lID0gYVNwbGl0WzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggc0F0dHIuY2hhckF0KDApID09IFwiI1wiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IHNBdHRyLnN1YnN0cigxLCBzQXR0ci5sZW5ndGgtMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5jbGFzc05hbWUgPSBzQXR0cjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGkgKz0gajsgLyogTW92ZSBhbG9uZyB0aGUgcG9zaXRpb24gYXJyYXkgKi9cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aW5zZXJ0LmFwcGVuZCggbk5ld05vZGUgKTtcblx0XHRcdFx0aW5zZXJ0ID0gJChuTmV3Tm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnPicgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBFbmQgY29udGFpbmVyIGRpdiAqL1xuXHRcdFx0XHRpbnNlcnQgPSBpbnNlcnQucGFyZW50KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBAdG9kbyBNb3ZlIG9wdGlvbnMgaW50byB0aGVpciBvd24gcGx1Z2lucz9cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdsJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUgJiYgZmVhdHVyZXMuYkxlbmd0aENoYW5nZSApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIExlbmd0aCAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sTGVuZ3RoKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdmJyAmJiBmZWF0dXJlcy5iRmlsdGVyIClcblx0XHRcdHtcblx0XHRcdFx0LyogRmlsdGVyICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3InICYmIGZlYXR1cmVzLmJQcm9jZXNzaW5nIClcblx0XHRcdHtcblx0XHRcdFx0LyogcFJvY2Vzc2luZyAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAndCcgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBUYWJsZSAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sVGFibGUoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gICdpJyAmJiBmZWF0dXJlcy5iSW5mbyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEluZm8gKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbEluZm8oIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3AnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFBhZ2luYXRpb24gKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFBhZ2luYXRlKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBEYXRhVGFibGUuZXh0LmZlYXR1cmUubGVuZ3RoICE9PSAwIClcblx0XHRcdHtcblx0XHRcdFx0LyogUGx1Zy1pbiBmZWF0dXJlcyAqL1xuXHRcdFx0XHR2YXIgYW9GZWF0dXJlcyA9IERhdGFUYWJsZS5leHQuZmVhdHVyZTtcblx0XHRcdFx0Zm9yICggdmFyIGs9MCwga0xlbj1hb0ZlYXR1cmVzLmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIGNPcHRpb24gPT0gYW9GZWF0dXJlc1trXS5jRmVhdHVyZSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBhb0ZlYXR1cmVzW2tdLmZuSW5pdCggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvKiBBZGQgdG8gdGhlIDJEIGZlYXR1cmVzIGFycmF5ICovXG5cdFx0XHRpZiAoIGZlYXR1cmVOb2RlIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGFhbkZlYXR1cmVzID0gb1NldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcblx0XHRcdFx0aWYgKCAhIGFhbkZlYXR1cmVzW2NPcHRpb25dIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFhbkZlYXR1cmVzW2NPcHRpb25dID0gW107XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGFhbkZlYXR1cmVzW2NPcHRpb25dLnB1c2goIGZlYXR1cmVOb2RlICk7XG5cdFx0XHRcdGluc2VydC5hcHBlbmQoIGZlYXR1cmVOb2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBCdWlsdCBvdXIgRE9NIHN0cnVjdHVyZSAtIHJlcGxhY2UgdGhlIGhvbGRpbmcgZGl2IHdpdGggd2hhdCB3ZSB3YW50ICovXG5cdFx0aG9sZGluZy5yZXBsYWNlV2l0aCggaW5zZXJ0ICk7XG5cdFx0b1NldHRpbmdzLm5Ib2xkaW5nID0gbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIERPTSBzb3VyY2UgdG8gY3JlYXRlIHVwIGFuIGFycmF5IG9mIGhlYWRlciBjZWxscy4gVGhlIGlkZWEgaGVyZSBpcyB0b1xuXHQgKiBjcmVhdGUgYSBsYXlvdXQgZ3JpZCAoYXJyYXkpIG9mIHJvd3MgeCBjb2x1bW5zLCB3aGljaCBjb250YWlucyBhIHJlZmVyZW5jZVxuXHQgKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcblx0ICogYW55IGNvbHVtbiAvIHJvdyBjb3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGdyaWQgY29uc3RydWN0ZWRcblx0ICogIEBwYXJhbSBhcnJheSB7b2JqZWN0fSBhTGF5b3V0IEFycmF5IHRvIHN0b3JlIHRoZSBjYWxjdWxhdGVkIGxheW91dCBpblxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlciAoIGFMYXlvdXQsIG5UaGVhZCApXG5cdHtcblx0XHR2YXIgblRycyA9ICQoblRoZWFkKS5jaGlsZHJlbigndHInKTtcblx0XHR2YXIgblRyLCBuQ2VsbDtcblx0XHR2YXIgaSwgaywgbCwgaUxlbiwgakxlbiwgaUNvbFNoaWZ0ZWQsIGlDb2x1bW4sIGlDb2xzcGFuLCBpUm93c3Bhbjtcblx0XHR2YXIgYlVuaXF1ZTtcblx0XHR2YXIgZm5TaGlmdENvbCA9IGZ1bmN0aW9uICggYSwgaSwgaiApIHtcblx0XHRcdHZhciBrID0gYVtpXTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgga1tqXSApIHtcblx0XHRcdFx0aisrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGo7XG5cdFx0fTtcblx0XG5cdFx0YUxheW91dC5zcGxpY2UoIDAsIGFMYXlvdXQubGVuZ3RoICk7XG5cdFxuXHRcdC8qIFdlIGtub3cgaG93IG1hbnkgcm93cyB0aGVyZSBhcmUgaW4gdGhlIGxheW91dCAtIHNvIHByZXAgaXQgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49blRycy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQucHVzaCggW10gKTtcblx0XHR9XG5cdFxuXHRcdC8qIENhbGN1bGF0ZSBhIGxheW91dCBhcnJheSAqL1xuXHRcdGZvciAoIGk9MCwgaUxlbj1uVHJzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0blRyID0gblRyc1tpXTtcblx0XHRcdGlDb2x1bW4gPSAwO1xuXHRcblx0XHRcdC8qIEZvciBldmVyeSBjZWxsIGluIHRoZSByb3cuLi4gKi9cblx0XHRcdG5DZWxsID0gblRyLmZpcnN0Q2hpbGQ7XG5cdFx0XHR3aGlsZSAoIG5DZWxsICkge1xuXHRcdFx0XHRpZiAoIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJURFwiIHx8XG5cdFx0XHRcdCAgICAgbkNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSBcIlRIXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogR2V0IHRoZSBjb2wgYW5kIHJvd3NwYW4gYXR0cmlidXRlcyBmcm9tIHRoZSBET00gYW5kIHNhbml0aXNlIHRoZW0gKi9cblx0XHRcdFx0XHRpQ29sc3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpICogMTtcblx0XHRcdFx0XHRpUm93c3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcblx0XHRcdFx0XHRpQ29sc3BhbiA9ICghaUNvbHNwYW4gfHwgaUNvbHNwYW49PT0wIHx8IGlDb2xzcGFuPT09MSkgPyAxIDogaUNvbHNwYW47XG5cdFx0XHRcdFx0aVJvd3NwYW4gPSAoIWlSb3dzcGFuIHx8IGlSb3dzcGFuPT09MCB8fCBpUm93c3Bhbj09PTEpID8gMSA6IGlSb3dzcGFuO1xuXHRcblx0XHRcdFx0XHQvKiBUaGVyZSBtaWdodCBiZSBjb2xzcGFuIGNlbGxzIGFscmVhZHkgaW4gdGhpcyByb3csIHNvIHNoaWZ0IG91ciB0YXJnZXRcblx0XHRcdFx0XHQgKiBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlDb2xTaGlmdGVkID0gZm5TaGlmdENvbCggYUxheW91dCwgaSwgaUNvbHVtbiApO1xuXHRcblx0XHRcdFx0XHQvKiBDYWNoZSBjYWxjdWxhdGlvbiBmb3IgdW5pcXVlIGNvbHVtbnMgKi9cblx0XHRcdFx0XHRiVW5pcXVlID0gaUNvbHNwYW4gPT09IDEgPyB0cnVlIDogZmFsc2U7XG5cdFxuXHRcdFx0XHRcdC8qIElmIHRoZXJlIGlzIGNvbCAvIHJvd3NwYW4sIGNvcHkgdGhlIGluZm9ybWF0aW9uIGludG8gdGhlIGxheW91dCBncmlkICovXG5cdFx0XHRcdFx0Zm9yICggbD0wIDsgbDxpQ29sc3BhbiA7IGwrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Zm9yICggaz0wIDsgazxpUm93c3BhbiA7IGsrKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFMYXlvdXRbaStrXVtpQ29sU2hpZnRlZCtsXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcImNlbGxcIjogbkNlbGwsXG5cdFx0XHRcdFx0XHRcdFx0XCJ1bmlxdWVcIjogYlVuaXF1ZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRhTGF5b3V0W2kra10ublRyID0gblRyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRuQ2VsbCA9IG5DZWxsLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYW4gYXJyYXkgb2YgdW5pcXVlIHRoIGVsZW1lbnRzLCBvbmUgZm9yIGVhY2ggY29sdW1uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IG5IZWFkZXIgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGxheW91dCBmcm9tIHRoaXMgbm9kZSAtIG9wdGlvbmFsXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhTGF5b3V0IHRoZWFkL3Rmb290IGxheW91dCBmcm9tIF9mbkRldGVjdEhlYWRlciAtIG9wdGlvbmFsXG5cdCAqICBAcmV0dXJucyBhcnJheSB7bm9kZX0gYVJldHVybiBsaXN0IG9mIHVuaXF1ZSB0aCdzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFVuaXF1ZVRocyAoIG9TZXR0aW5ncywgbkhlYWRlciwgYUxheW91dCApXG5cdHtcblx0XHR2YXIgYVJldHVybiA9IFtdO1xuXHRcdGlmICggIWFMYXlvdXQgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQgPSBvU2V0dGluZ3MuYW9IZWFkZXI7XG5cdFx0XHRpZiAoIG5IZWFkZXIgKVxuXHRcdFx0e1xuXHRcdFx0XHRhTGF5b3V0ID0gW107XG5cdFx0XHRcdF9mbkRldGVjdEhlYWRlciggYUxheW91dCwgbkhlYWRlciApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hTGF5b3V0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj1hTGF5b3V0W2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggYUxheW91dFtpXVtqXS51bmlxdWUgJiZcblx0XHRcdFx0XHQgKCFhUmV0dXJuW2pdIHx8ICFvU2V0dGluZ3MuYlNvcnRDZWxsc1RvcCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YVJldHVybltqXSA9IGFMYXlvdXRbaV1bal0uY2VsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGFSZXR1cm47XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcblx0ICogcGFyYW1ldGVycyBjYW4gaGF2ZSBtdWx0aXBsZSBmb3JtcywgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIsIHJlcXVpcmVkIGJ5XG5cdCAqICAgICBEYXRhVGFibGVzIC0gbWF5IGJlIGF1Z21lbnRlZCBieSBkZXZlbG9wZXIgY2FsbGJhY2tzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkJ1aWxkQWpheCggb1NldHRpbmdzLCBkYXRhLCBmbiApXG5cdHtcblx0XHQvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LSwgYWxsb3cgZm5TZXJ2ZXJEYXRhIGFuZCBldmVudCB0byBtYW5pcHVsYXRlXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICdzZXJ2ZXJQYXJhbXMnLCBbZGF0YV0gKTtcblx0XG5cdFx0Ly8gQ29udmVydCB0byBvYmplY3QgYmFzZWQgZm9yIDEuMTArIGlmIHVzaW5nIHRoZSBvbGQgYXJyYXkgc2NoZW1lIHdoaWNoIGNhblxuXHRcdC8vIGNvbWUgZnJvbSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG9yIHNlcnZlclBhcmFtc1xuXHRcdGlmICggZGF0YSAmJiBBcnJheS5pc0FycmF5KGRhdGEpICkge1xuXHRcdFx0dmFyIHRtcCA9IHt9O1xuXHRcdFx0dmFyIHJicmFja2V0ID0gLyguKj8pXFxbXFxdJC87XG5cdFxuXHRcdFx0JC5lYWNoKCBkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0dmFyIG1hdGNoID0gdmFsLm5hbWUubWF0Y2gocmJyYWNrZXQpO1xuXHRcblx0XHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0IGZvciBhcnJheXNcblx0XHRcdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzBdO1xuXHRcblx0XHRcdFx0XHRpZiAoICEgdG1wWyBuYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHR0bXBbIG5hbWUgXSA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bXBbIG5hbWUgXS5wdXNoKCB2YWwudmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0bXBbdmFsLm5hbWVdID0gdmFsLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRkYXRhID0gdG1wO1xuXHRcdH1cblx0XG5cdFx0dmFyIGFqYXhEYXRhO1xuXHRcdHZhciBhamF4ID0gb1NldHRpbmdzLmFqYXg7XG5cdFx0dmFyIGluc3RhbmNlID0gb1NldHRpbmdzLm9JbnN0YW5jZTtcblx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0XHR2YXIgc3RhdHVzID0gb1NldHRpbmdzLmpxWGhyXG5cdFx0XHRcdD8gb1NldHRpbmdzLmpxWGhyLnN0YXR1c1xuXHRcdFx0XHQ6IG51bGw7XG5cdFxuXHRcdFx0aWYgKCBqc29uID09PSBudWxsIHx8ICh0eXBlb2Ygc3RhdHVzID09PSAnbnVtYmVyJyAmJiBzdGF0dXMgPT0gMjA0ICkgKSB7XG5cdFx0XHRcdGpzb24gPSB7fTtcblx0XHRcdFx0X2ZuQWpheERhdGFTcmMoIG9TZXR0aW5ncywganNvbiwgW10gKTtcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgZXJyb3IgPSBqc29uLmVycm9yIHx8IGpzb24uc0Vycm9yO1xuXHRcdFx0aWYgKCBlcnJvciApIHtcblx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsIGVycm9yICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0b1NldHRpbmdzLmpzb24gPSBqc29uO1xuXHRcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywganNvbiwgb1NldHRpbmdzLmpxWEhSXSApO1xuXHRcdFx0Zm4oIGpzb24gKTtcblx0XHR9O1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICYmIGFqYXguZGF0YSApXG5cdFx0e1xuXHRcdFx0YWpheERhdGEgPSBhamF4LmRhdGE7XG5cdFxuXHRcdFx0dmFyIG5ld0RhdGEgPSB0eXBlb2YgYWpheERhdGEgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHRhamF4RGF0YSggZGF0YSwgb1NldHRpbmdzICkgOiAgLy8gZm4gY2FuIG1hbmlwdWxhdGUgZGF0YSBvciByZXR1cm5cblx0XHRcdFx0YWpheERhdGE7ICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvYmplY3Qgb3IgYXJyYXkgdG8gbWVyZ2Vcblx0XG5cdFx0XHQvLyBJZiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgc29tZXRoaW5nLCB1c2UgdGhhdCBhbG9uZVxuXHRcdFx0ZGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXdEYXRhID9cblx0XHRcdFx0bmV3RGF0YSA6XG5cdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBkYXRhLCBuZXdEYXRhICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcblx0XHRcdC8vIGpRdWVyeSB0byBkbyBpdCBhZ2FpbiAoaXQgaXMgcmVzdG9yZWQgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24pXG5cdFx0XHRkZWxldGUgYWpheC5kYXRhO1xuXHRcdH1cblx0XG5cdFx0dmFyIGJhc2VBamF4ID0ge1xuXHRcdFx0XCJkYXRhXCI6IGRhdGEsXG5cdFx0XHRcInN1Y2Nlc3NcIjogY2FsbGJhY2ssXG5cdFx0XHRcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdFx0XCJjYWNoZVwiOiBmYWxzZSxcblx0XHRcdFwidHlwZVwiOiBvU2V0dGluZ3Muc1NlcnZlck1ldGhvZCxcblx0XHRcdFwiZXJyb3JcIjogZnVuY3Rpb24gKHhociwgZXJyb3IsIHRocm93bikge1xuXHRcdFx0XHR2YXIgcmV0ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBudWxsLCBvU2V0dGluZ3MuanFYSFJdICk7XG5cdFxuXHRcdFx0XHRpZiAoICQuaW5BcnJheSggdHJ1ZSwgcmV0ICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGlmICggZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiICkge1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdJbnZhbGlkIEpTT04gcmVzcG9uc2UnLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnQWpheCBlcnJvcicsIDcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0Ly8gU3RvcmUgdGhlIGRhdGEgc3VibWl0dGVkIGZvciB0aGUgQVBJXG5cdFx0b1NldHRpbmdzLm9BamF4RGF0YSA9IGRhdGE7XG5cdFxuXHRcdC8vIEFsbG93IHBsdWctaW5zIGFuZCBleHRlcm5hbCBwcm9jZXNzZXMgdG8gbW9kaWZ5IHRoZSBkYXRhXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdwcmVYaHInLCBbb1NldHRpbmdzLCBkYXRhXSApO1xuXHRcblx0XHRpZiAoIG9TZXR0aW5ncy5mblNlcnZlckRhdGEgKVxuXHRcdHtcblx0XHRcdC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmlsaXR5XG5cdFx0XHRvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhLmNhbGwoIGluc3RhbmNlLFxuXHRcdFx0XHRvU2V0dGluZ3Muc0FqYXhTb3VyY2UsXG5cdFx0XHRcdCQubWFwKCBkYXRhLCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gTmVlZCB0byBjb252ZXJ0IGJhY2sgdG8gMS45IHRyYWQgZm9ybWF0XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZToga2V5LCB2YWx1ZTogdmFsIH07XG5cdFx0XHRcdH0gKSxcblx0XHRcdFx0Y2FsbGJhY2ssXG5cdFx0XHRcdG9TZXR0aW5nc1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9TZXR0aW5ncy5zQWpheFNvdXJjZSB8fCB0eXBlb2YgYWpheCA9PT0gJ3N0cmluZycgKVxuXHRcdHtcblx0XHRcdC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmlsaXR5XG5cdFx0XHRvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoICQuZXh0ZW5kKCBiYXNlQWpheCwge1xuXHRcdFx0XHR1cmw6IGFqYXggfHwgb1NldHRpbmdzLnNBamF4U291cmNlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBhamF4ID09PSAnZnVuY3Rpb24nIClcblx0XHR7XG5cdFx0XHQvLyBJcyBhIGZ1bmN0aW9uIC0gbGV0IHRoZSBjYWxsZXIgZGVmaW5lIHdoYXQgbmVlZHMgdG8gYmUgZG9uZVxuXHRcdFx0b1NldHRpbmdzLmpxWEhSID0gYWpheC5jYWxsKCBpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT2JqZWN0IHRvIGV4dGVuZCB0aGUgYmFzZSBzZXR0aW5nc1xuXHRcdFx0b1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCAkLmV4dGVuZCggYmFzZUFqYXgsIGFqYXggKSApO1xuXHRcblx0XHRcdC8vIFJlc3RvcmUgZm9yIG5leHQgdGltZSBhcm91bmRcblx0XHRcdGFqYXguZGF0YSA9IGFqYXhEYXRhO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIHRhYmxlIHVzaW5nIGFuIEFqYXggY2FsbFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoIHNldHRpbmdzIClcblx0e1xuXHRcdHNldHRpbmdzLmlEcmF3Kys7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdF9mbkJ1aWxkQWpheChcblx0XHRcdHNldHRpbmdzLFxuXHRcdFx0X2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzICksXG5cdFx0XHRmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRcdF9mbkFqYXhVcGRhdGVEcmF3KCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnVpbGQgdXAgdGhlIHBhcmFtZXRlcnMgaW4gYW4gb2JqZWN0IG5lZWRlZCBmb3IgYSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdCAqIHJlcXVlc3QuIE5vdGUgdGhhdCB0aGlzIGlzIGJhc2ljYWxseSBkb25lIHR3aWNlLCBpcyBkaWZmZXJlbnQgd2F5cyAtIGEgbW9kZXJuXG5cdCAqIG1ldGhvZCB3aGljaCBpcyB1c2VkIGJ5IGRlZmF1bHQgaW4gRGF0YVRhYmxlcyAxLjEwIHdoaWNoIHVzZXMgb2JqZWN0cyBhbmRcblx0ICogYXJyYXlzLCBvciB0aGUgMS45LSBtZXRob2Qgd2l0aCBpcyBuYW1lIC8gdmFsdWUgcGFpcnMuIDEuOSBtZXRob2QgaXMgdXNlZCBpZlxuXHQgKiB0aGUgc0FqYXhTb3VyY2Ugb3B0aW9uIGlzIHVzZWQgaW4gdGhlIGluaXRpYWxpc2F0aW9uLCBvciB0aGUgbGVnYWN5QWpheFxuXHQgKiBvcHRpb24gaXMgc2V0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Jvb2x9IGJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0Y29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdFx0cHJlU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLFxuXHRcdFx0cHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxuXHRcdFx0aSwgZGF0YSA9IFtdLCBkYXRhUHJvcCwgY29sdW1uLCBjb2x1bW5TZWFyY2gsXG5cdFx0XHRzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICksXG5cdFx0XHRkaXNwbGF5U3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGRpc3BsYXlMZW5ndGggPSBmZWF0dXJlcy5iUGFnaW5hdGUgIT09IGZhbHNlID9cblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdFx0LTE7XG5cdFxuXHRcdHZhciBwYXJhbSA9IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRkYXRhLnB1c2goIHsgJ25hbWUnOiBuYW1lLCAndmFsdWUnOiB2YWx1ZSB9ICk7XG5cdFx0fTtcblx0XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGlibGUgbWV0aG9kXG5cdFx0cGFyYW0oICdzRWNobycsICAgICAgICAgIHNldHRpbmdzLmlEcmF3ICk7XG5cdFx0cGFyYW0oICdpQ29sdW1ucycsICAgICAgIGNvbHVtbkNvdW50ICk7XG5cdFx0cGFyYW0oICdzQ29sdW1ucycsICAgICAgIF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApLmpvaW4oJywnKSApO1xuXHRcdHBhcmFtKCAnaURpc3BsYXlTdGFydCcsICBkaXNwbGF5U3RhcnQgKTtcblx0XHRwYXJhbSggJ2lEaXNwbGF5TGVuZ3RoJywgZGlzcGxheUxlbmd0aCApO1xuXHRcblx0XHQvLyBEYXRhVGFibGVzIDEuMTArIG1ldGhvZFxuXHRcdHZhciBkID0ge1xuXHRcdFx0ZHJhdzogICAgc2V0dGluZ3MuaURyYXcsXG5cdFx0XHRjb2x1bW5zOiBbXSxcblx0XHRcdG9yZGVyOiAgIFtdLFxuXHRcdFx0c3RhcnQ6ICAgZGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuZ3RoOiAgZGlzcGxheUxlbmd0aCxcblx0XHRcdHNlYXJjaDogIHtcblx0XHRcdFx0dmFsdWU6IHByZVNlYXJjaC5zU2VhcmNoLFxuXHRcdFx0XHRyZWdleDogcHJlU2VhcmNoLmJSZWdleFxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGZvciAoIGk9MCA7IGk8Y29sdW1uQ291bnQgOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0Y29sdW1uU2VhcmNoID0gcHJlQ29sU2VhcmNoW2ldO1xuXHRcdFx0ZGF0YVByb3AgPSB0eXBlb2YgY29sdW1uLm1EYXRhPT1cImZ1bmN0aW9uXCIgPyAnZnVuY3Rpb24nIDogY29sdW1uLm1EYXRhIDtcblx0XG5cdFx0XHRkLmNvbHVtbnMucHVzaCgge1xuXHRcdFx0XHRkYXRhOiAgICAgICBkYXRhUHJvcCxcblx0XHRcdFx0bmFtZTogICAgICAgY29sdW1uLnNOYW1lLFxuXHRcdFx0XHRzZWFyY2hhYmxlOiBjb2x1bW4uYlNlYXJjaGFibGUsXG5cdFx0XHRcdG9yZGVyYWJsZTogIGNvbHVtbi5iU29ydGFibGUsXG5cdFx0XHRcdHNlYXJjaDogICAgIHtcblx0XHRcdFx0XHR2YWx1ZTogY29sdW1uU2VhcmNoLnNTZWFyY2gsXG5cdFx0XHRcdFx0cmVnZXg6IGNvbHVtblNlYXJjaC5iUmVnZXhcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHBhcmFtKCBcIm1EYXRhUHJvcF9cIitpLCBkYXRhUHJvcCApO1xuXHRcblx0XHRcdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0cGFyYW0oICdzU2VhcmNoXycraSwgICAgIGNvbHVtblNlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdHBhcmFtKCAnYlJlZ2V4XycraSwgICAgICBjb2x1bW5TZWFyY2guYlJlZ2V4ICk7XG5cdFx0XHRcdHBhcmFtKCAnYlNlYXJjaGFibGVfJytpLCBjb2x1bW4uYlNlYXJjaGFibGUgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRwYXJhbSggJ2JTb3J0YWJsZV8nK2ksIGNvbHVtbi5iU29ydGFibGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdHBhcmFtKCAnc1NlYXJjaCcsIHByZVNlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRwYXJhbSggJ2JSZWdleCcsIHByZVNlYXJjaC5iUmVnZXggKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHQkLmVhY2goIHNvcnQsIGZ1bmN0aW9uICggaSwgdmFsICkge1xuXHRcdFx0XHRkLm9yZGVyLnB1c2goIHsgY29sdW1uOiB2YWwuY29sLCBkaXI6IHZhbC5kaXIgfSApO1xuXHRcblx0XHRcdFx0cGFyYW0oICdpU29ydENvbF8nK2ksIHZhbC5jb2wgKTtcblx0XHRcdFx0cGFyYW0oICdzU29ydERpcl8nK2ksIHZhbC5kaXIgKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRwYXJhbSggJ2lTb3J0aW5nQ29scycsIHNvcnQubGVuZ3RoICk7XG5cdFx0fVxuXHRcblx0XHQvLyBJZiB0aGUgbGVnYWN5LmFqYXggcGFyYW1ldGVyIGlzIG51bGwsIHRoZW4gd2UgYXV0b21hdGljYWxseSBkZWNpZGUgd2hpY2hcblx0XHQvLyBmb3JtIHRvIHVzZSwgYmFzZWQgb24gc0FqYXhTb3VyY2Vcblx0XHR2YXIgbGVnYWN5ID0gRGF0YVRhYmxlLmV4dC5sZWdhY3kuYWpheDtcblx0XHRpZiAoIGxlZ2FjeSA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5zQWpheFNvdXJjZSA/IGRhdGEgOiBkO1xuXHRcdH1cblx0XG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBsZWdhY3kgaGFzIGJlZW4gc3BlY2lmaWVkIHRoZW4gd2UgdXNlIHRoYXQgdG8gZGVjaWRlIG9uIHRoZVxuXHRcdC8vIGZvcm1cblx0XHRyZXR1cm4gbGVnYWN5ID8gZGF0YSA6IGQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24ganNvbiBkYXRhIHJldHVybiBmcm9tIHRoZSBzZXJ2ZXIuXG5cdCAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXG5cdCAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsRGlzcGxheVJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcgKCBzZXR0aW5ncywganNvbiApXG5cdHtcblx0XHQvLyB2MS4xMCB1c2VzIGNhbWVsQ2FzZSB2YXJpYWJsZXMsIHdoaWxlIDEuOSB1c2VzIEh1bmdhcmlhbiBub3RhdGlvbi5cblx0XHQvLyBTdXBwb3J0IGJvdGhcblx0XHR2YXIgY29tcGF0ID0gZnVuY3Rpb24gKCBvbGQsIG1vZGVybiApIHtcblx0XHRcdHJldHVybiBqc29uW29sZF0gIT09IHVuZGVmaW5lZCA/IGpzb25bb2xkXSA6IGpzb25bbW9kZXJuXTtcblx0XHR9O1xuXHRcblx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdHZhciBkcmF3ICAgICAgICAgICAgPSBjb21wYXQoICdzRWNobycsICAgICAgICAgICAgICAgICdkcmF3JyApO1xuXHRcdHZhciByZWNvcmRzVG90YWwgICAgPSBjb21wYXQoICdpVG90YWxSZWNvcmRzJywgICAgICAgICdyZWNvcmRzVG90YWwnICk7XG5cdFx0dmFyIHJlY29yZHNGaWx0ZXJlZCA9IGNvbXBhdCggJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcgKTtcblx0XG5cdFx0aWYgKCBkcmF3ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBQcm90ZWN0IGFnYWluc3Qgb3V0IG9mIHNlcXVlbmNlIHJldHVybnNcblx0XHRcdGlmICggZHJhdyoxIDwgc2V0dGluZ3MuaURyYXcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNldHRpbmdzLmlEcmF3ID0gZHJhdyAqIDE7XG5cdFx0fVxuXHRcblx0XHQvLyBObyBkYXRhIGluIHJldHVybmVkIG9iamVjdCwgc28gcmF0aGVyIHRoYW4gYW4gYXJyYXksIHdlIHNob3cgYW4gZW1wdHkgdGFibGVcblx0XHRpZiAoICEgZGF0YSApIHtcblx0XHRcdGRhdGEgPSBbXTtcblx0XHR9XG5cdFxuXHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFx0c2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgICA9IHBhcnNlSW50KHJlY29yZHNUb3RhbCwgMTApO1xuXHRcdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSBwYXJzZUludChyZWNvcmRzRmlsdGVyZWQsIDEwKTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHRcdH1cblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XG5cdFx0X2ZuRHJhdyggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0aWYgKCAhIHNldHRpbmdzLl9iSW5pdENvbXBsZXRlICkge1xuXHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncywganNvbiApO1xuXHRcdH1cblx0XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBKU09OIGRhdGEgc291cmNlIHRvIHVzZSBmb3IgZHJhd2luZyBhIHRhYmxlLiBVc2luZ1xuXHQgKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXG5cdCAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxuXHQgKiAgQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGRhdGEgdG8gdXNlXG5cdCAqL1xuXHQgZnVuY3Rpb24gX2ZuQWpheERhdGFTcmMgKCBvU2V0dGluZ3MsIGpzb24sIHdyaXRlIClcblx0IHtcblx0XHR2YXIgZGF0YVNyYyA9ICQuaXNQbGFpbk9iamVjdCggb1NldHRpbmdzLmFqYXggKSAmJiBvU2V0dGluZ3MuYWpheC5kYXRhU3JjICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0b1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XG5cdFx0XHRvU2V0dGluZ3Muc0FqYXhEYXRhUHJvcDsgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0uXG5cdFxuXHRcdGlmICggISB3cml0ZSApIHtcblx0XHRcdGlmICggZGF0YVNyYyA9PT0gJ2RhdGEnICkge1xuXHRcdFx0XHQvLyBJZiB0aGUgZGVmYXVsdCwgdGhlbiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnQgdGhlIG9sZCBzdHlsZSwgYW5kIHNhZmVseSBpZ25vcmVcblx0XHRcdFx0Ly8gaXQgaWYgcG9zc2libGVcblx0XHRcdFx0cmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVNyY107XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGRhdGFTcmMgIT09IFwiXCIgP1xuXHRcdFx0XHRfZm5HZXRPYmplY3REYXRhRm4oIGRhdGFTcmMgKSgganNvbiApIDpcblx0XHRcdFx0anNvbjtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdF9mblNldE9iamVjdERhdGFGbiggZGF0YVNyYyApKCBqc29uLCB3cml0ZSApO1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIGZpbHRlcmluZyB0ZXh0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gRmlsdGVyIGNvbnRyb2wgZWxlbWVudFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbEZpbHRlciAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRhYmxlSWQgPSBzZXR0aW5ncy5zVGFibGVJZDtcblx0XHR2YXIgbGFuZ3VhZ2UgPSBzZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdFx0dmFyIHByZXZpb3VzU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcdHZhciBpbnB1dCA9ICc8aW5wdXQgdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiJytjbGFzc2VzLnNGaWx0ZXJJbnB1dCsnXCIvPic7XG5cdFxuXHRcdHZhciBzdHIgPSBsYW5ndWFnZS5zU2VhcmNoO1xuXHRcdHN0ciA9IHN0ci5tYXRjaCgvX0lOUFVUXy8pID9cblx0XHRcdHN0ci5yZXBsYWNlKCdfSU5QVVRfJywgaW5wdXQpIDpcblx0XHRcdHN0citpbnB1dDtcblx0XG5cdFx0dmFyIGZpbHRlciA9ICQoJzxkaXYvPicsIHtcblx0XHRcdFx0J2lkJzogISBmZWF0dXJlcy5mID8gdGFibGVJZCsnX2ZpbHRlcicgOiBudWxsLFxuXHRcdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNGaWx0ZXJcblx0XHRcdH0gKVxuXHRcdFx0LmFwcGVuZCggJCgnPGxhYmVsLz4nICkuYXBwZW5kKCBzdHIgKSApO1xuXHRcblx0XHR2YXIgc2VhcmNoRm4gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0LyogVXBkYXRlIGFsbCBvdGhlciBmaWx0ZXIgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSBuZXcgZGlzcGxheSAqL1xuXHRcdFx0dmFyIG4gPSBmZWF0dXJlcy5mO1xuXHRcdFx0dmFyIHZhbCA9ICF0aGlzLnZhbHVlID8gXCJcIiA6IHRoaXMudmFsdWU7IC8vIG1lbnRhbCBJRTggZml4IDotKFxuXHRcdFx0aWYocHJldmlvdXNTZWFyY2gucmV0dXJuICYmIGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXG5cdFx0XHRpZiAoIHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICkge1xuXHRcdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHtcblx0XHRcdFx0XHRcInNTZWFyY2hcIjogdmFsLFxuXHRcdFx0XHRcdFwiYlJlZ2V4XCI6IHByZXZpb3VzU2VhcmNoLmJSZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiBwcmV2aW91c1NlYXJjaC5iU21hcnQgLFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBwcmV2aW91c1NlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlLFxuXHRcdFx0XHRcdFwicmV0dXJuXCI6IHByZXZpb3VzU2VhcmNoLnJldHVyblxuXHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHQvLyBOZWVkIHRvIHJlZHJhdywgd2l0aG91dCByZXNvcnRpbmdcblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdHZhciBzZWFyY2hEZWxheSA9IHNldHRpbmdzLnNlYXJjaERlbGF5ICE9PSBudWxsID9cblx0XHRcdHNldHRpbmdzLnNlYXJjaERlbGF5IDpcblx0XHRcdF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT09ICdzc3AnID9cblx0XHRcdFx0NDAwIDpcblx0XHRcdFx0MDtcblx0XG5cdFx0dmFyIGpxRmlsdGVyID0gJCgnaW5wdXQnLCBmaWx0ZXIpXG5cdFx0XHQudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoIClcblx0XHRcdC5hdHRyKCAncGxhY2Vob2xkZXInLCBsYW5ndWFnZS5zU2VhcmNoUGxhY2Vob2xkZXIgKVxuXHRcdFx0Lm9uKFxuXHRcdFx0XHQna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXG5cdFx0XHRcdHNlYXJjaERlbGF5ID9cblx0XHRcdFx0XHRfZm5UaHJvdHRsZSggc2VhcmNoRm4sIHNlYXJjaERlbGF5ICkgOlxuXHRcdFx0XHRcdHNlYXJjaEZuXG5cdFx0XHQpXG5cdFx0XHQub24oICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBFZGdlIGZpeCEgRWRnZSAxNyBkb2VzIG5vdCB0cmlnZ2VyIGFueXRoaW5nIG90aGVyIHRoYW4gbW91c2UgZXZlbnRzIHdoZW4gY2xpY2tpbmdcblx0XHRcdFx0Ly8gb24gdGhlIGNsZWFyIGljb24gKEVkZ2UgYnVnIDE3NTg0NTE1KS4gVGhpcyBpcyBzYWZlIGluIG90aGVyIGJyb3dzZXJzIGFzIGBzZWFyY2hGbmBcblx0XHRcdFx0Ly8gY2hlY2tzIHRoZSB2YWx1ZSB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQuIEluIG90aGVyIGJyb3dzZXJzIGl0IHdvbid0IGhhdmUuXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZWFyY2hGbi5jYWxsKGpxRmlsdGVyWzBdLCBlKTtcblx0XHRcdFx0fSwgMTApO1xuXHRcdFx0fSApXG5cdFx0XHQub24oICdrZXlwcmVzcy5EVCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0LyogUHJldmVudCBmb3JtIHN1Ym1pc3Npb24gKi9cblx0XHRcdFx0aWYgKCBlLmtleUNvZGUgPT0gMTMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHRcdC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgdGFibGVJZCk7XG5cdFxuXHRcdC8vIFVwZGF0ZSB0aGUgaW5wdXQgZWxlbWVudHMgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIGZpbHRlcmVkXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnc2VhcmNoLmR0LkRUJywgZnVuY3Rpb24gKCBldiwgcyApIHtcblx0XHRcdGlmICggc2V0dGluZ3MgPT09IHMgKSB7XG5cdFx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLi4uXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCBqcUZpbHRlclswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCApIHtcblx0XHRcdFx0XHRcdGpxRmlsdGVyLnZhbCggcHJldmlvdXNTZWFyY2guc1NlYXJjaCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGZpbHRlclswXTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIHRhYmxlIHVzaW5nIGJvdGggdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGNvbHVtbiBiYXNlZCBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2VhcmNoIHNlYXJjaCBpbmZvcm1hdGlvblxuXHQgKiAgQHBhcmFtIHtpbnR9IFtpRm9yY2VdIGZvcmNlIGEgcmVzZWFyY2ggb2YgdGhlIG1hc3RlciBhcnJheSAoMSkgb3Igbm90ICh1bmRlZmluZWQgb3IgMClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ29tcGxldGUgKCBvU2V0dGluZ3MsIG9JbnB1dCwgaUZvcmNlIClcblx0e1xuXHRcdHZhciBvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdFx0dmFyIGFvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFx0dmFyIGZuU2F2ZUZpbHRlciA9IGZ1bmN0aW9uICggb0ZpbHRlciApIHtcblx0XHRcdC8qIFNhdmUgdGhlIGZpbHRlcmluZyB2YWx1ZXMgKi9cblx0XHRcdG9QcmV2U2VhcmNoLnNTZWFyY2ggPSBvRmlsdGVyLnNTZWFyY2g7XG5cdFx0XHRvUHJldlNlYXJjaC5iUmVnZXggPSBvRmlsdGVyLmJSZWdleDtcblx0XHRcdG9QcmV2U2VhcmNoLmJTbWFydCA9IG9GaWx0ZXIuYlNtYXJ0O1xuXHRcdFx0b1ByZXZTZWFyY2guYkNhc2VJbnNlbnNpdGl2ZSA9IG9GaWx0ZXIuYkNhc2VJbnNlbnNpdGl2ZTtcblx0XHRcdG9QcmV2U2VhcmNoLnJldHVybiA9IG9GaWx0ZXIucmV0dXJuO1xuXHRcdH07XG5cdFx0dmFyIGZuUmVnZXggPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBiRXNjYXBlUmVnZXggb3B0aW9uXG5cdFx0XHRyZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuXHRcdH07XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBBcyBwZXIgc29ydCAtIGNhbiB0aGlzIGJlIG1vdmVkIGludG8gYW4gZXZlbnQgaGFuZGxlcj9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdC8qIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmUgKi9cblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnIClcblx0XHR7XG5cdFx0XHQvKiBHbG9iYWwgZmlsdGVyICovXG5cdFx0XHRfZm5GaWx0ZXIoIG9TZXR0aW5ncywgb0lucHV0LnNTZWFyY2gsIGlGb3JjZSwgZm5SZWdleChvSW5wdXQpLCBvSW5wdXQuYlNtYXJ0LCBvSW5wdXQuYkNhc2VJbnNlbnNpdGl2ZSwgb0lucHV0LnJldHVybiApO1xuXHRcdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblx0XG5cdFx0XHQvKiBOb3cgZG8gdGhlIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlciAqL1xuXHRcdFx0Zm9yICggdmFyIGk9MCA7IGk8YW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkZpbHRlckNvbHVtbiggb1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxuXHRcdFx0XHRcdGFvUHJldlNlYXJjaFtpXS5iU21hcnQsIGFvUHJldlNlYXJjaFtpXS5iQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQ3VzdG9tIGZpbHRlcmluZyAqL1xuXHRcdFx0X2ZuRmlsdGVyQ3VzdG9tKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGZuU2F2ZUZpbHRlciggb0lucHV0ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cblx0XHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xuXHRcdHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XHR2YXIgcm93LCByb3dJZHg7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1maWx0ZXJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIHJvd3MgPSBbXTtcblx0XG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cm93SWR4ID0gZGlzcGxheVJvd3NbIGogXTtcblx0XHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0XG5cdFx0XHRcdGlmICggZmlsdGVyc1tpXSggc2V0dGluZ3MsIHJvdy5fYUZpbHRlckRhdGEsIHJvd0lkeCwgcm93Ll9hRGF0YSwgaiApICkge1xuXHRcdFx0XHRcdHJvd3MucHVzaCggcm93SWR4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0XHQvLyBleGlzdGluZyBhcnJheVxuXHRcdFx0ZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcblx0XHRcdCQubWVyZ2UoIGRpc3BsYXlSb3dzLCByb3dzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgb24gYSBwZXItY29sdW1uIGJhc2lzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIGNvbHVtbiB0byBmaWx0ZXJcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IHNlYXJjaCBzdHJpbmcgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCB1c2Ugc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZpbHRlckNvbHVtbiAoIHNldHRpbmdzLCBzZWFyY2hTdHIsIGNvbElkeCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKVxuXHR7XG5cdFx0aWYgKCBzZWFyY2hTdHIgPT09ICcnICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRhdGE7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdHZhciBkaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXHRcdHZhciBycFNlYXJjaCA9IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoU3RyLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wIDsgaTxkaXNwbGF5Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIGRpc3BsYXlbaV0gXS5fYUZpbHRlckRhdGFbIGNvbElkeCBdO1xuXHRcblx0XHRcdGlmICggcnBTZWFyY2gudGVzdCggZGF0YSApICkge1xuXHRcdFx0XHRvdXQucHVzaCggZGlzcGxheVtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gb3V0O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgZGF0YSB0YWJsZSBiYXNlZCBvbiB1c2VyIGlucHV0IGFuZCBkcmF3IHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGZpbHRlciBvblxuXHQgKiAgQHBhcmFtIHtpbnR9IGZvcmNlIG9wdGlvbmFsIC0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuXHQgKiAgQHBhcmFtIHtib29sfSByZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gc21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXIoIHNldHRpbmdzLCBpbnB1dCwgZm9yY2UsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlIClcblx0e1xuXHRcdHZhciBycFNlYXJjaCA9IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0dmFyIHByZXZTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2guc1NlYXJjaDtcblx0XHR2YXIgZGlzcGxheU1hc3RlciA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlcjtcblx0XHR2YXIgZGlzcGxheSwgaW52YWxpZGF0ZWQsIGk7XG5cdFx0dmFyIGZpbHRlcmVkID0gW107XG5cdFxuXHRcdC8vIE5lZWQgdG8gdGFrZSBhY2NvdW50IG9mIGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zIC0gYWx3YXlzIGZpbHRlclxuXHRcdGlmICggRGF0YVRhYmxlLmV4dC5zZWFyY2gubGVuZ3RoICE9PSAwICkge1xuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaWYgYW55IG9mIHRoZSByb3dzIHdlcmUgaW52YWxpZGF0ZWRcblx0XHRpbnZhbGlkYXRlZCA9IF9mbkZpbHRlckRhdGEoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIElmIHRoZSBpbnB1dCBpcyBibGFuayAtIHdlIGp1c3Qgd2FudCB0aGUgZnVsbCBkYXRhIHNldFxuXHRcdGlmICggaW5wdXQubGVuZ3RoIDw9IDAgKSB7XG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTmV3IHNlYXJjaCAtIHN0YXJ0IGZyb20gdGhlIG1hc3RlciBhcnJheVxuXHRcdFx0aWYgKCBpbnZhbGlkYXRlZCB8fFxuXHRcdFx0XHQgZm9yY2UgfHxcblx0XHRcdFx0IHJlZ2V4IHx8XG5cdFx0XHRcdCBwcmV2U2VhcmNoLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCB8fFxuXHRcdFx0XHQgaW5wdXQuaW5kZXhPZihwcmV2U2VhcmNoKSAhPT0gMCB8fFxuXHRcdFx0XHQgc2V0dGluZ3MuYlNvcnRlZCAvLyBPbiByZXNvcnQsIHRoZSBkaXNwbGF5IG1hc3RlciBuZWVkcyB0byBiZVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAvLyByZS1maWx0ZXJlZCBzaW5jZSBpbmRleGVzIHdpbGwgaGF2ZSBjaGFuZ2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlYXJjaCB0aGUgZGlzcGxheSBhcnJheVxuXHRcdFx0ZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGRpc3BsYXkubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJwU2VhcmNoLnRlc3QoIHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9zRmlsdGVyUm93ICkgKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQucHVzaCggZGlzcGxheVtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZmlsdGVyZWQ7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBzdWl0YWJsZSBmb3Igc2VhcmNoaW5nIGEgdGFibGVcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU2VhcmNoIHN0cmluZyB0byBzZWFyY2ggZm9yXG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJSZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlNtYXJ0IHBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7UmVnRXhwfSBjb25zdHJ1Y3RlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBzZWFyY2gsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlIClcblx0e1xuXHRcdHNlYXJjaCA9IHJlZ2V4ID9cblx0XHRcdHNlYXJjaCA6XG5cdFx0XHRfZm5Fc2NhcGVSZWdleCggc2VhcmNoICk7XG5cdFx0XG5cdFx0aWYgKCBzbWFydCApIHtcblx0XHRcdC8qIEZvciBzbWFydCBmaWx0ZXJpbmcgd2Ugd2FudCB0byBhbGxvdyB0aGUgc2VhcmNoIHRvIHdvcmsgcmVnYXJkbGVzcyBvZlxuXHRcdFx0ICogd29yZCBvcmRlci4gV2UgYWxzbyB3YW50IGRvdWJsZSBxdW90ZWQgdGV4dCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdvcmRcblx0XHRcdCAqIG9yZGVyIGlzIGltcG9ydGFudCAtIGEgbGEgZ29vZ2xlLiBTbyB0aGlzIGlzIHdoYXQgd2Ugd2FudCB0b1xuXHRcdFx0ICogZ2VuZXJhdGU6XG5cdFx0XHQgKiBcblx0XHRcdCAqIF4oPz0uKj9cXGJvbmVcXGIpKD89Lio/XFxidHdvIHRocmVlXFxiKSg/PS4qP1xcYmZvdXJcXGIpLiokXG5cdFx0XHQgKi9cblx0XHRcdHZhciBhID0gJC5tYXAoIHNlYXJjaC5tYXRjaCggL1wiW15cIl0rXCJ8W14gXSsvZyApIHx8IFsnJ10sIGZ1bmN0aW9uICggd29yZCApIHtcblx0XHRcdFx0aWYgKCB3b3JkLmNoYXJBdCgwKSA9PT0gJ1wiJyApIHtcblx0XHRcdFx0XHR2YXIgbSA9IHdvcmQubWF0Y2goIC9eXCIoLiopXCIkLyApO1xuXHRcdFx0XHRcdHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiB3b3JkLnJlcGxhY2UoJ1wiJywgJycpO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdHNlYXJjaCA9ICdeKD89Lio/JythLmpvaW4oICcpKD89Lio/JyApKycpLiokJztcblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgUmVnRXhwKCBzZWFyY2gsIGNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRXNjYXBlIGEgc3RyaW5nIHN1Y2ggdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNWYWwgc3RyaW5nIHRvIGVzY2FwZVxuXHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0dmFyIF9mbkVzY2FwZVJlZ2V4ID0gRGF0YVRhYmxlLnV0aWwuZXNjYXBlUmVnZXg7XG5cdFxuXHR2YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcblx0dmFyIF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA9IF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkO1xuXHRcblx0Ly8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxuXHRmdW5jdGlvbiBfZm5GaWx0ZXJEYXRhICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGNvbHVtbjtcblx0XHR2YXIgaSwgaiwgaWVuLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XG5cdFx0dmFyIHdhc0ludmFsaWRhdGVkID0gZmFsc2U7XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hRmlsdGVyRGF0YSApIHtcblx0XHRcdFx0ZmlsdGVyRGF0YSA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1ucy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2pdO1xuXHRcblx0XHRcdFx0XHRpZiAoIGNvbHVtbi5iU2VhcmNoYWJsZSApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBqLCAnZmlsdGVyJyApO1xuXHRcblx0XHRcdFx0XHRcdC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIDEuMTAgaXMgc3RyaW5nIGJhc2VkLiBJbiAxLjExIHRoaXNcblx0XHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXG5cdFx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGNlbGxEYXRhICE9PSAnc3RyaW5nJyAmJiBjZWxsRGF0YS50b1N0cmluZyApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gJyc7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBJZiBpdCBsb29rcyBsaWtlIHRoZXJlIGlzIGFuIEhUTUwgZW50aXR5IGluIHRoZSBzdHJpbmcsXG5cdFx0XHRcdFx0Ly8gYXR0ZW1wdCB0byBkZWNvZGUgaXQgc28gc29ydGluZyB3b3JrcyBhcyBleHBlY3RlZC4gTm90ZSB0aGF0XG5cdFx0XHRcdFx0Ly8gd2UgY291bGQgdXNlIGEgc2luZ2xlIGxpbmUgb2YgalF1ZXJ5IHRvIGRvIHRoaXMsIGJ1dCB0aGUgRE9NXG5cdFx0XHRcdFx0Ly8gbWV0aG9kIHVzZWQgaGVyZSBpcyBtdWNoIGZhc3RlciBodHRwOi8vanNwZXJmLmNvbS9odG1sLWRlY29kZVxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEuaW5kZXhPZiAmJiBjZWxsRGF0YS5pbmRleE9mKCcmJykgIT09IC0xICkge1xuXHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xuXHRcdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgOlxuXHRcdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJUZXh0O1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0aWYgKCBjZWxsRGF0YS5yZXBsYWNlICkge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS5yZXBsYWNlKC9bXFxyXFxuXFx1MjAyOF0vZywgJycpO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0ZmlsdGVyRGF0YS5wdXNoKCBjZWxsRGF0YSApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyb3cuX2FGaWx0ZXJEYXRhID0gZmlsdGVyRGF0YTtcblx0XHRcdFx0cm93Ll9zRmlsdGVyUm93ID0gZmlsdGVyRGF0YS5qb2luKCcgICcpO1xuXHRcdFx0XHR3YXNJbnZhbGlkYXRlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gd2FzSW52YWxpZGF0ZWQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBmcm9tIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4gbm90YXRpb24gdG8gY2FtZWxDYXNlIGZvciBleHRlcm5hbFxuXHQgKiBpbnRlcmFjdGlvblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxuXHQgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNlYXJjaFRvQ2FtZWwgKCBvYmogKVxuXHR7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlYXJjaDogICAgICAgICAgb2JqLnNTZWFyY2gsXG5cdFx0XHRzbWFydDogICAgICAgICAgIG9iai5iU21hcnQsXG5cdFx0XHRyZWdleDogICAgICAgICAgIG9iai5iUmVnZXgsXG5cdFx0XHRjYXNlSW5zZW5zaXRpdmU6IG9iai5iQ2FzZUluc2Vuc2l0aXZlXG5cdFx0fTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBmcm9tIGNhbWVsQ2FzZSBub3RhdGlvbiB0byB0aGUgaW50ZXJuYWwgSHVuZ2FyaWFuLiBXZSBjb3VsZCB1c2UgdGhlXG5cdCAqIEh1bmdhcmlhbiBjb252ZXJ0IGZ1bmN0aW9uIGhlcmUsIGJ1dCB0aGlzIGlzIGNsZWFuZXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGNvbnZlcnRcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IEludmVydGVkIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZWFyY2hUb0h1bmcgKCBvYmogKVxuXHR7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNTZWFyY2g6ICAgICAgICAgIG9iai5zZWFyY2gsXG5cdFx0XHRiU21hcnQ6ICAgICAgICAgICBvYmouc21hcnQsXG5cdFx0XHRiUmVnZXg6ICAgICAgICAgICBvYmoucmVnZXgsXG5cdFx0XHRiQ2FzZUluc2Vuc2l0aXZlOiBvYmouY2FzZUluc2Vuc2l0aXZlXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgaW5mbyBkaXNwbGF5XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gSW5mb3JtYXRpb24gZWxlbWVudFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbEluZm8gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHRpZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0bm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pLFxuXHRcdFx0biA9ICQoJzxkaXYvPicsIHtcblx0XHRcdFx0J2NsYXNzJzogc2V0dGluZ3Mub0NsYXNzZXMuc0luZm8sXG5cdFx0XHRcdCdpZCc6ICEgbm9kZXMgPyB0aWQrJ19pbmZvJyA6IG51bGxcblx0XHRcdH0gKTtcblx0XG5cdFx0aWYgKCAhIG5vZGVzICkge1xuXHRcdFx0Ly8gVXBkYXRlIGRpc3BsYXkgb24gZWFjaCBkcmF3XG5cdFx0XHRzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKCB7XG5cdFx0XHRcdFwiZm5cIjogX2ZuVXBkYXRlSW5mbyxcblx0XHRcdFx0XCJzTmFtZVwiOiBcImluZm9ybWF0aW9uXCJcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRuXG5cdFx0XHRcdC5hdHRyKCAncm9sZScsICdzdGF0dXMnIClcblx0XHRcdFx0LmF0dHIoICdhcmlhLWxpdmUnLCAncG9saXRlJyApO1xuXHRcblx0XHRcdC8vIFRhYmxlIGlzIGRlc2NyaWJlZCBieSBvdXIgaW5mbyBkaXZcblx0XHRcdCQoc2V0dGluZ3MublRhYmxlKS5hdHRyKCAnYXJpYS1kZXNjcmliZWRieScsIHRpZCsnX2luZm8nICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gblswXTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnRzIGluIHRoZSBkaXNwbGF5XG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVXBkYXRlSW5mbyAoIHNldHRpbmdzIClcblx0e1xuXHRcdC8qIFNob3cgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlICovXG5cdFx0dmFyIG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaTtcblx0XHRpZiAoIG5vZGVzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0bGFuZyAgPSBzZXR0aW5ncy5vTGFuZ3VhZ2UsXG5cdFx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0KzEsXG5cdFx0XHRlbmQgICA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdFx0bWF4ICAgPSBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdFx0dG90YWwgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0XHRvdXQgICA9IHRvdGFsID9cblx0XHRcdFx0bGFuZy5zSW5mbyA6XG5cdFx0XHRcdGxhbmcuc0luZm9FbXB0eTtcblx0XG5cdFx0aWYgKCB0b3RhbCAhPT0gbWF4ICkge1xuXHRcdFx0LyogUmVjb3JkIHNldCBhZnRlciBmaWx0ZXJpbmcgKi9cblx0XHRcdG91dCArPSAnICcgKyBsYW5nLnNJbmZvRmlsdGVyZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBDb252ZXJ0IHRoZSBtYWNyb3Ncblx0XHRvdXQgKz0gbGFuZy5zSW5mb1Bvc3RGaXg7XG5cdFx0b3V0ID0gX2ZuSW5mb01hY3Jvcyggc2V0dGluZ3MsIG91dCApO1xuXHRcblx0XHR2YXIgY2FsbGJhY2sgPSBsYW5nLmZuSW5mb0NhbGxiYWNrO1xuXHRcdGlmICggY2FsbGJhY2sgIT09IG51bGwgKSB7XG5cdFx0XHRvdXQgPSBjYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRcdHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBvdXRcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHQkKG5vZGVzKS5odG1sKCBvdXQgKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mbkluZm9NYWNyb3MgKCBzZXR0aW5ncywgc3RyIClcblx0e1xuXHRcdC8vIFdoZW4gaW5maW5pdGUgc2Nyb2xsaW5nLCB3ZSBhcmUgYWx3YXlzIHN0YXJ0aW5nIGF0IDEuIF9pRGlzcGxheVN0YXJ0IGlzIHVzZWQgb25seVxuXHRcdC8vIGludGVybmFsbHlcblx0XHR2YXJcblx0XHRcdGZvcm1hdHRlciAgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcixcblx0XHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCsxLFxuXHRcdFx0bGVuICAgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdHZpcyAgICAgICAgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMTtcblx0XG5cdFx0cmV0dXJuIHN0ci5cblx0XHRcdHJlcGxhY2UoL19TVEFSVF8vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzdGFydCApICkuXG5cdFx0XHRyZXBsYWNlKC9fRU5EXy9nLCAgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkgKSApLlxuXHRcdFx0cmVwbGFjZSgvX01BWF8vZywgICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkgKSApLlxuXHRcdFx0cmVwbGFjZSgvX1RPVEFMXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHZpcyApICkuXG5cdFx0XHRyZXBsYWNlKC9fUEFHRV8vZywgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbCggc3RhcnQgLyBsZW4gKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fUEFHRVNfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbCggdmlzIC8gbGVuICkgKSApO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Jbml0aWFsaXNlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGksIGlMZW4sIGlBamF4U3RhcnQ9c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQ7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsIGNvbHVtbjtcblx0XHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFx0dmFyIGRlZmVyTG9hZGluZyA9IHNldHRpbmdzLmJEZWZlckxvYWRpbmc7IC8vIHZhbHVlIG1vZGlmaWVkIGJ5IHRoZSBkcmF3XG5cdFxuXHRcdC8qIEVuc3VyZSB0aGF0IHRoZSB0YWJsZSBkYXRhIGlzIGZ1bGx5IGluaXRpYWxpc2VkICovXG5cdFx0aWYgKCAhIHNldHRpbmdzLmJJbml0aWFsaXNlZCApIHtcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7IF9mbkluaXRpYWxpc2UoIHNldHRpbmdzICk7IH0sIDIwMCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0LyogU2hvdyB0aGUgZGlzcGxheSBIVE1MIG9wdGlvbnMgKi9cblx0XHRfZm5BZGRPcHRpb25zSHRtbCggc2V0dGluZ3MgKTtcblx0XG5cdFx0LyogQnVpbGQgYW5kIGRyYXcgdGhlIGhlYWRlciAvIGZvb3RlciBmb3IgdGhlIHRhYmxlICovXG5cdFx0X2ZuQnVpbGRIZWFkKCBzZXR0aW5ncyApO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9IZWFkZXIgKTtcblx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyICk7XG5cdFxuXHRcdC8qIE9rYXkgdG8gc2hvdyB0aGF0IHNvbWV0aGluZyBpcyBnb2luZyBvbiBub3cgKi9cblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0LyogQ2FsY3VsYXRlIHNpemVzIGZvciBjb2x1bW5zICovXG5cdFx0aWYgKCBmZWF0dXJlcy5iQXV0b1dpZHRoICkge1xuXHRcdFx0X2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGggKSB7XG5cdFx0XHRcdGNvbHVtbi5uVGguc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29sdW1uLnNXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3ByZUluaXQnLCBbc2V0dGluZ3NdICk7XG5cdFxuXHRcdC8vIElmIHRoZXJlIGlzIGRlZmF1bHQgc29ydGluZyByZXF1aXJlZCAtIGxldCdzIGRvIGl0LiBUaGUgc29ydCBmdW5jdGlvblxuXHRcdC8vIHdpbGwgZG8gdGhlIGRyYXdpbmcgZm9yIHVzLiBPdGhlcndpc2Ugd2UgZHJhdyB0aGUgdGFibGUgcmVnYXJkbGVzcyBvZiB0aGVcblx0XHQvLyBBamF4IHNvdXJjZSAtIHRoaXMgYWxsb3dzIHRoZSB0YWJsZSB0byBsb29rIGluaXRpYWxpc2VkIGZvciBBamF4IHNvdXJjaW5nXG5cdFx0Ly8gZGF0YSAoc2hvdyAnbG9hZGluZycgbWVzc2FnZSBwb3NzaWJseSlcblx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgaW5pdCBjb21wbGV0ZSBpcyBkb25lIGJ5IF9mbkFqYXhVcGRhdGVEcmF3XG5cdFx0dmFyIGRhdGFTcmMgPSBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApO1xuXHRcdGlmICggZGF0YVNyYyAhPSAnc3NwJyB8fCBkZWZlckxvYWRpbmcgKSB7XG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBhbiBhamF4IHNvdXJjZSBsb2FkIHRoZSBkYXRhXG5cdFx0XHRpZiAoIGRhdGFTcmMgPT0gJ2FqYXgnICkge1xuXHRcdFx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCBbXSwgZnVuY3Rpb24oanNvbikge1xuXHRcdFx0XHRcdHZhciBhRGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcblx0XHRcdFx0XHQvLyBHb3QgdGhlIGRhdGEgLSBhZGQgaXQgdG8gdGhlIHRhYmxlXG5cdFx0XHRcdFx0Zm9yICggaT0wIDsgaTxhRGF0YS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgYURhdGFbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBpbml0IGRpc3BsYXkgZm9yIGNvb2tpZSBzYXZpbmcuIFdlJ3ZlIGFscmVhZHkgZG9uZVxuXHRcdFx0XHRcdC8vIGEgZmlsdGVyLCBhbmQgdGhlcmVmb3JlIGNsZWFyZWQgaXQgYmVmb3JlLiBTbyB3ZSBuZWVkIHRvIG1ha2Vcblx0XHRcdFx0XHQvLyBpdCBhcHBlYXIgJ2ZyZXNoJ1xuXHRcdFx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gaUFqYXhTdGFydDtcblx0XG5cdFx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHR9LCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbanNvbl0gSlNPTiBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCBjb21wbGV0ZWQgdGhlIHRhYmxlLCBpZiB1c2luZyBBamF4IHNvdXJjZVxuXHQgKiAgICB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcgKG9wdGlvbmFsKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Jbml0Q29tcGxldGUgKCBzZXR0aW5ncywganNvbiApXG5cdHtcblx0XHRzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA9IHRydWU7XG5cdFxuXHRcdC8vIFdoZW4gZGF0YSB3YXMgYWRkZWQgYWZ0ZXIgdGhlIGluaXRpYWxpc2F0aW9uIChkYXRhIG9yIEFqYXgpIHdlIG5lZWQgdG9cblx0XHQvLyBjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXppbmdcblx0XHRpZiAoIGpzb24gfHwgc2V0dGluZ3Mub0luaXQuYWFEYXRhICkge1xuXHRcdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3BsdWdpbi1pbml0JywgW3NldHRpbmdzLCBqc29uXSApO1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsICdpbml0JywgW3NldHRpbmdzLCBqc29uXSApO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuTGVuZ3RoQ2hhbmdlICggc2V0dGluZ3MsIHZhbCApXG5cdHtcblx0XHR2YXIgbGVuID0gcGFyc2VJbnQoIHZhbCwgMTAgKTtcblx0XHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggPSBsZW47XG5cdFxuXHRcdF9mbkxlbmd0aE92ZXJmbG93KCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBGaXJlIGxlbmd0aCBjaGFuZ2UgZXZlbnRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnbGVuZ3RoJywgW3NldHRpbmdzLCBsZW5dICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHVzZXIgZGlzcGxheSBsZW5ndGggY2hhbmdpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IERpc3BsYXkgbGVuZ3RoIGZlYXR1cmUgbm9kZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbExlbmd0aCAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0Y2xhc3NlcyAgPSBzZXR0aW5ncy5vQ2xhc3Nlcyxcblx0XHRcdHRhYmxlSWQgID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRtZW51ICAgICA9IHNldHRpbmdzLmFMZW5ndGhNZW51LFxuXHRcdFx0ZDIgICAgICAgPSBBcnJheS5pc0FycmF5KCBtZW51WzBdICksXG5cdFx0XHRsZW5ndGhzICA9IGQyID8gbWVudVswXSA6IG1lbnUsXG5cdFx0XHRsYW5ndWFnZSA9IGQyID8gbWVudVsxXSA6IG1lbnU7XG5cdFxuXHRcdHZhciBzZWxlY3QgPSAkKCc8c2VsZWN0Lz4nLCB7XG5cdFx0XHQnbmFtZSc6ICAgICAgICAgIHRhYmxlSWQrJ19sZW5ndGgnLFxuXHRcdFx0J2FyaWEtY29udHJvbHMnOiB0YWJsZUlkLFxuXHRcdFx0J2NsYXNzJzogICAgICAgICBjbGFzc2VzLnNMZW5ndGhTZWxlY3Rcblx0XHR9ICk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1sZW5ndGhzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0c2VsZWN0WzBdWyBpIF0gPSBuZXcgT3B0aW9uKFxuXHRcdFx0XHR0eXBlb2YgbGFuZ3VhZ2VbaV0gPT09ICdudW1iZXInID9cblx0XHRcdFx0XHRzZXR0aW5ncy5mbkZvcm1hdE51bWJlciggbGFuZ3VhZ2VbaV0gKSA6XG5cdFx0XHRcdFx0bGFuZ3VhZ2VbaV0sXG5cdFx0XHRcdGxlbmd0aHNbaV1cblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGl2ID0gJCgnPGRpdj48bGFiZWwvPjwvZGl2PicpLmFkZENsYXNzKCBjbGFzc2VzLnNMZW5ndGggKTtcblx0XHRpZiAoICEgc2V0dGluZ3MuYWFuRmVhdHVyZXMubCApIHtcblx0XHRcdGRpdlswXS5pZCA9IHRhYmxlSWQrJ19sZW5ndGgnO1xuXHRcdH1cblx0XG5cdFx0ZGl2LmNoaWxkcmVuKCkuYXBwZW5kKFxuXHRcdFx0c2V0dGluZ3Mub0xhbmd1YWdlLnNMZW5ndGhNZW51LnJlcGxhY2UoICdfTUVOVV8nLCBzZWxlY3RbMF0ub3V0ZXJIVE1MIClcblx0XHQpO1xuXHRcblx0XHQvLyBDYW4ndCB1c2UgYHNlbGVjdGAgdmFyaWFibGUgYXMgdXNlciBtaWdodCBwcm92aWRlIHRoZWlyIG93biBhbmQgdGhlXG5cdFx0Ly8gcmVmZXJlbmNlIGlzIGJyb2tlbiBieSB0aGUgdXNlIG9mIG91dGVySFRNTFxuXHRcdCQoJ3NlbGVjdCcsIGRpdilcblx0XHRcdC52YWwoIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCApXG5cdFx0XHQub24oICdjaGFuZ2UuRFQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdF9mbkxlbmd0aENoYW5nZSggc2V0dGluZ3MsICQodGhpcykudmFsKCkgKTtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0Ly8gVXBkYXRlIG5vZGUgdmFsdWUgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcyB0aGUgdGFibGUncyBsZW5ndGhcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdsZW5ndGguZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgbGVuKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzID09PSBzICkge1xuXHRcdFx0XHQkKCdzZWxlY3QnLCBkaXYpLnZhbCggbGVuICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gZGl2WzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIE5vdGUgdGhhdCBtb3N0IG9mIHRoZSBwYWdpbmcgbG9naWMgaXMgZG9uZSBpblxuXHQgKiBEYXRhVGFibGUuZXh0LnBhZ2VyXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBkZWZhdWx0IHBhZ2luYXRpb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBQYWdpbmF0aW9uIGZlYXR1cmUgbm9kZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFBhZ2luYXRlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0eXBlICAgPSBzZXR0aW5ncy5zUGFnaW5hdGlvblR5cGUsXG5cdFx0XHRwbHVnaW4gPSBEYXRhVGFibGUuZXh0LnBhZ2VyWyB0eXBlIF0sXG5cdFx0XHRtb2Rlcm4gPSB0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0cmVkcmF3ID0gZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fSxcblx0XHRcdG5vZGUgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcyggc2V0dGluZ3Mub0NsYXNzZXMuc1BhZ2luZyArIHR5cGUgKVswXSxcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cdFxuXHRcdGlmICggISBtb2Rlcm4gKSB7XG5cdFx0XHRwbHVnaW4uZm5Jbml0KCBzZXR0aW5ncywgbm9kZSwgcmVkcmF3ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBBZGQgYSBkcmF3IGNhbGxiYWNrIGZvciB0aGUgcGFnaW5hdGlvbiBvbiBmaXJzdCBpbnN0YW5jZSwgdG8gdXBkYXRlIHRoZSBwYWdpbmcgZGlzcGxheSAqL1xuXHRcdGlmICggISBmZWF0dXJlcy5wIClcblx0XHR7XG5cdFx0XHRub2RlLmlkID0gc2V0dGluZ3Muc1RhYmxlSWQrJ19wYWdpbmF0ZSc7XG5cdFxuXHRcdFx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCgge1xuXHRcdFx0XHRcImZuXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0XHRpZiAoIG1vZGVybiApIHtcblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdFx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRcdFx0XHRcdHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0XHRcdFx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xLFxuXHRcdFx0XHRcdFx0XHRwYWdlID0gYWxsID8gMCA6IE1hdGguY2VpbCggc3RhcnQgLyBsZW4gKSxcblx0XHRcdFx0XHRcdFx0cGFnZXMgPSBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XHRcdFx0XHRcdGJ1dHRvbnMgPSBwbHVnaW4ocGFnZSwgcGFnZXMpLFxuXHRcdFx0XHRcdFx0XHRpLCBpZW47XG5cdFxuXHRcdFx0XHRcdFx0Zm9yICggaT0wLCBpZW49ZmVhdHVyZXMucC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdFx0X2ZuUmVuZGVyZXIoIHNldHRpbmdzLCAncGFnZUJ1dHRvbicgKShcblx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncywgZmVhdHVyZXMucFtpXSwgaSwgYnV0dG9ucywgcGFnZSwgcGFnZXNcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwbHVnaW4uZm5VcGRhdGUoIHNldHRpbmdzLCByZWRyYXcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwic05hbWVcIjogXCJwYWdpbmF0aW9uXCJcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFsdGVyIHRoZSBkaXNwbGF5IHNldHRpbmdzIHRvIGNoYW5nZSB0aGUgcGFnZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IGFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLFxuXHQgKiAgICBcIm5leHRcIiBvciBcImxhc3RcIiBvciBwYWdlIG51bWJlciB0byBqdW1wIHRvIChpbnRlZ2VyKVxuXHQgKiAgQHBhcmFtIFtib29sXSByZWRyYXcgQXV0b21hdGljYWxseSBkcmF3IHRoZSB1cGRhdGUgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBwYWdlIGhhcyBjaGFuZ2VkLCBmYWxzZSAtIG5vIGNoYW5nZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5QYWdlQ2hhbmdlICggc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3IClcblx0e1xuXHRcdHZhclxuXHRcdFx0c3RhcnQgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW4gICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRyZWNvcmRzICAgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCk7XG5cdFxuXHRcdGlmICggcmVjb3JkcyA9PT0gMCB8fCBsZW4gPT09IC0xIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgYWN0aW9uID09PSBcIm51bWJlclwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IGFjdGlvbiAqIGxlbjtcblx0XG5cdFx0XHRpZiAoIHN0YXJ0ID4gcmVjb3JkcyApXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImZpcnN0XCIgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcInByZXZpb3VzXCIgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gbGVuID49IDAgP1xuXHRcdFx0XHRzdGFydCAtIGxlbiA6XG5cdFx0XHRcdDA7XG5cdFxuXHRcdFx0aWYgKCBzdGFydCA8IDAgKVxuXHRcdFx0e1xuXHRcdFx0ICBzdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJuZXh0XCIgKVxuXHRcdHtcblx0XHRcdGlmICggc3RhcnQgKyBsZW4gPCByZWNvcmRzIClcblx0XHRcdHtcblx0XHRcdFx0c3RhcnQgKz0gbGVuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwibGFzdFwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IE1hdGguZmxvb3IoIChyZWNvcmRzLTEpIC8gbGVuKSAqIGxlbjtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIithY3Rpb24sIDUgKTtcblx0XHR9XG5cdFxuXHRcdHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xuXHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG5cdFxuXHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwYWdlJywgW3NldHRpbmdzXSApO1xuXHRcblx0XHRcdGlmICggcmVkcmF3ICkge1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgcHJvY2Vzc2luZyBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBQcm9jZXNzaW5nIGVsZW1lbnRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0cmV0dXJuICQoJzxkaXYvPicsIHtcblx0XHRcdFx0J2lkJzogISBzZXR0aW5ncy5hYW5GZWF0dXJlcy5yID8gc2V0dGluZ3Muc1RhYmxlSWQrJ19wcm9jZXNzaW5nJyA6IG51bGwsXG5cdFx0XHRcdCdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNQcm9jZXNzaW5nXG5cdFx0XHR9IClcblx0XHRcdC5odG1sKCBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc1Byb2Nlc3NpbmcgKVxuXHRcdFx0Lmluc2VydEJlZm9yZSggc2V0dGluZ3MublRhYmxlIClbMF07XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGlzcGxheSBvciBoaWRlIHRoZSBwcm9jZXNzaW5nIGluZGljYXRvclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2Jvb2x9IHNob3cgU2hvdyB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3IgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblByb2Nlc3NpbmdEaXNwbGF5ICggc2V0dGluZ3MsIHNob3cgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0XHQkKHNldHRpbmdzLmFhbkZlYXR1cmVzLnIpLmNzcyggJ2Rpc3BsYXknLCBzaG93ID8gJ2Jsb2NrJyA6ICdub25lJyApO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3Byb2Nlc3NpbmcnLCBbc2V0dGluZ3MsIHNob3ddICk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGQgYW55IGNvbnRyb2wgZWxlbWVudHMgZm9yIHRoZSB0YWJsZSAtIHNwZWNpZmljYWxseSBzY3JvbGxpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IE5vZGUgdG8gYWRkIHRvIHRoZSBET01cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxUYWJsZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblx0XG5cdFx0Ly8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxuXHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcblx0XHRpZiAoIHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2Nyb2xsWCA9IHNjcm9sbC5zWDtcblx0XHR2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcblx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciBjYXB0aW9uID0gdGFibGUuY2hpbGRyZW4oJ2NhcHRpb24nKTtcblx0XHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcblx0XHR2YXIgaGVhZGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdFx0dmFyIGZvb3RlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHRcdHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcblx0XHR2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xuXHRcdHZhciBzaXplID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0cmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKCBzICk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAhIGZvb3Rlci5sZW5ndGggKSB7XG5cdFx0XHRmb290ZXIgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiBUaGUgSFRNTCBzdHJ1Y3R1cmUgdGhhdCB3ZSB3YW50IHRvIGdlbmVyYXRlIGluIHRoaXMgZnVuY3Rpb24gaXM6XG5cdFx0ICogIGRpdiAtIHNjcm9sbGVyXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcblx0XHQgKiAgICAgIGRpdiAtIHNjcm9sbCBoZWFkIGlubmVyXG5cdFx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcblx0XHQgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGJvZHlcblx0XHQgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcblx0XHQgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG5cdFx0ICogICAgICAgIHRib2R5IC0gdGJvZHlcblx0XHQgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxuXHRcdCAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcblx0XHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgZm9vdCB0YWJsZVxuXHRcdCAqICAgICAgICAgIHRmb290IC0gdGZvb3Rcblx0XHQgKi9cblx0XHR2YXIgc2Nyb2xsZXIgPSAkKCBfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbFdyYXBwZXIgfSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZCB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdFx0J2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGwuc1hJbm5lciB8fCAnMTAwJSdcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0aGVhZGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQuY3NzKCAnbWFyZ2luLWxlZnQnLCAwIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsQm9keSB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSggc2Nyb2xsWCApXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZCggdGFibGUgKVxuXHRcdFx0KTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRzY3JvbGxlci5hcHBlbmQoXG5cdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290IH0gKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdGZvb3RlckNsb25lXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKCBjYXB0aW9uU2lkZSA9PT0gJ2JvdHRvbScgPyBjYXB0aW9uIDogbnVsbCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdHZhciBjaGlsZHJlbiA9IHNjcm9sbGVyLmNoaWxkcmVuKCk7XG5cdFx0dmFyIHNjcm9sbEhlYWQgPSBjaGlsZHJlblswXTtcblx0XHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHRcdHZhciBzY3JvbGxGb290ID0gZm9vdGVyID8gY2hpbGRyZW5bMl0gOiBudWxsO1xuXHRcblx0XHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0XHRpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLm9uKCAnc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cdFxuXHRcdFx0XHRzY3JvbGxIZWFkLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcblx0XHRcdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsRm9vdC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0JChzY3JvbGxCb2R5KS5jc3MoJ21heC1oZWlnaHQnLCBzY3JvbGxZKTtcblx0XHRpZiAoISBzY3JvbGwuYkNvbGxhcHNlKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdFx0c2V0dGluZ3MublNjcm9sbEJvZHkgPSBzY3JvbGxCb2R5O1xuXHRcdHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblx0XG5cdFx0Ly8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xuXHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFwiZm5cIjogX2ZuU2Nyb2xsRHJhdyxcblx0XHRcdFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHNjcm9sbGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxuXHQgKiBhbGlnbm1lbnQuXG5cdCAqXG5cdCAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXG5cdCAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuXHQgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG5cdCAqICAgMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET01cblx0ICogICAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzIHRvIGFsaWduIHRoZSBjb2x1bW5zXG5cdCAqICAgNC4gQ2xlYW4gdXBcblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuXHRcdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0XHR2YXJcblx0XHRcdHNjcm9sbCAgICAgICAgID0gc2V0dGluZ3Mub1Njcm9sbCxcblx0XHRcdHNjcm9sbFggICAgICAgID0gc2Nyb2xsLnNYLFxuXHRcdFx0c2Nyb2xsWElubmVyICAgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdHNjcm9sbFkgICAgICAgID0gc2Nyb2xsLnNZLFxuXHRcdFx0YmFyV2lkdGggICAgICAgPSBzY3JvbGwuaUJhcldpZHRoLFxuXHRcdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRcdGRpdkhlYWRlclN0eWxlID0gZGl2SGVhZGVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXIgPSBkaXZIZWFkZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0XHRkaXZCb2R5ICAgICAgICA9ICQoZGl2Qm9keUVsKSxcblx0XHRcdGRpdkJvZHlTdHlsZSAgID0gZGl2Qm9keUVsLnN0eWxlLFxuXHRcdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRcdGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRcdGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHRcdHRhYmxlICAgICAgICAgID0gJChzZXR0aW5ncy5uVGFibGUpLFxuXHRcdFx0dGFibGVFbCAgICAgICAgPSB0YWJsZVswXSxcblx0XHRcdHRhYmxlU3R5bGUgICAgID0gdGFibGVFbC5zdHlsZSxcblx0XHRcdGZvb3RlciAgICAgICAgID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcblx0XHRcdGJyb3dzZXIgICAgICAgID0gc2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ICAgICAgICAgICA9IGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplLFxuXHRcdFx0ZHRIZWFkZXJDZWxscyAgPSBfcGx1Y2soIHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcgKSxcblx0XHRcdGhlYWRlclRyZ0VscywgZm9vdGVyVHJnRWxzLFxuXHRcdFx0aGVhZGVyU3JjRWxzLCBmb290ZXJTcmNFbHMsXG5cdFx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5LFxuXHRcdFx0aGVhZGVyV2lkdGhzPVtdLCBmb290ZXJXaWR0aHM9W10sXG5cdFx0XHRoZWFkZXJDb250ZW50PVtdLCBmb290ZXJDb250ZW50PVtdLFxuXHRcdFx0aWR4LCBjb3JyZWN0aW9uLCBzYW5pdHlXaWR0aCxcblx0XHRcdHplcm9PdXQgPSBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gblNpemVyLnN0eWxlO1xuXHRcdFx0XHRzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyVG9wV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gMDtcblx0XHRcdH07XG5cdFxuXHRcdC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cblx0XHQvLyBhZGp1c3QgdGhlIGNvbHVtbiBzaXplcyBhcyB0aGUgdGFibGUgd2lkdGggd2lsbCBoYXZlIGNoYW5nZWQgdG8gYWNjb3VudFxuXHRcdC8vIGZvciB0aGUgc2Nyb2xsYmFyXG5cdFx0dmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xuXHRcdFxuXHRcdGlmICggc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSBzY3JvbGxCYXJWaXMgJiYgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0XHRyZXR1cm47IC8vIGFkanVzdCBjb2x1bW4gc2l6aW5nIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHRcdCAqL1xuXHRcblx0XHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRmb290ZXJDb3B5ID0gZm9vdGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRcdFx0Zm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXG5cdFx0XHRmb290ZXJTcmNFbHMgPSBmb290ZXJDb3B5LmZpbmQoJ3RyJyk7XG5cdFx0fVxuXHRcblx0XHQvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxuXHRcdGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0aGVhZGVyVHJnRWxzID0gaGVhZGVyLmZpbmQoJ3RyJyk7IC8vIG9yaWdpbmFsIGhlYWRlciBpcyBpbiBpdHMgb3duIHRhYmxlXG5cdFx0aGVhZGVyU3JjRWxzID0gaGVhZGVyQ29weS5maW5kKCd0cicpO1xuXHRcdGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXG5cdFx0ICovXG5cdFxuXHRcdC8vIFJlbW92ZSBvbGQgc2l6aW5nIGFuZCBhcHBseSB0aGUgY2FsY3VsYXRlZCBjb2x1bW4gd2lkdGhzXG5cdFx0Ly8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxuXHRcdC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcblx0XHRpZiAoICEgc2Nyb2xsWCApXG5cdFx0e1xuXHRcdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdFx0ZGl2SGVhZGVyWzBdLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XG5cdFx0JC5lYWNoKCBfZm5HZXRVbmlxdWVUaHMoIHNldHRpbmdzLCBoZWFkZXJDb3B5ICksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0XHRpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGkgKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF0uc1dpZHRoO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0bi5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XHR9XG5cdFxuXHRcdC8vIFNpemUgdGhlIHRhYmxlIGFzIGEgd2hvbGVcblx0XHRzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgKSB7XG5cdFx0XHQvLyBObyB4IHNjcm9sbGluZ1xuXHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXHRcblx0XHRcdC8vIElFNyB3aWxsIG1ha2UgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSB3aGVuIDEwMCUgaW5jbHVkZSB0aGUgc2Nyb2xsYmFyXG5cdFx0XHQvLyAtIHdoaWNoIGlzIHNob3VsZG4ndC4gV2hlbiB0aGVyZSBpcyBhIHNjcm9sbGJhciB3ZSBuZWVkIHRvIHRha2UgdGhpc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50LlxuXHRcdFx0aWYgKCBpZTY3ICYmICh0YWJsZS5maW5kKCd0Ym9keScpLmhlaWdodCgpID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpXG5cdFx0XHQpIHtcblx0XHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZS5vdXRlcldpZHRoKCkgLSBiYXJXaWR0aCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuXHRcdFx0c2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzY3JvbGxYSW5uZXIgIT09IFwiXCIgKSB7XG5cdFx0XHQvLyBsZWdhY3kgeCBzY3JvbGwgaW5uZXIgaGFzIGJlZW4gZ2l2ZW4gLSB1c2UgaXRcblx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzY3JvbGxYSW5uZXIpO1xuXHRcblx0XHRcdC8vIFJlY2FsY3VsYXRlIHRoZSBzYW5pdHkgd2lkdGhcblx0XHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gSGlkZGVuIGhlYWRlciBzaG91bGQgaGF2ZSB6ZXJvIGhlaWdodCwgc28gcmVtb3ZlIHBhZGRpbmcgYW5kIGJvcmRlcnMuIFRoZW5cblx0XHQvLyBzZXQgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSByZWFsIGhlYWRlcnNcblx0XG5cdFx0Ly8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggemVyb091dCwgaGVhZGVyU3JjRWxzICk7XG5cdFxuXHRcdC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5TaXplcikge1xuXHRcdFx0dmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgP1xuXHRcdFx0XHR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuU2l6ZXIpLndpZHRoIDpcblx0XHRcdFx0X2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS53aWR0aCgpICk7XG5cdFxuXHRcdFx0aGVhZGVyQ29udGVudC5wdXNoKCBuU2l6ZXIuaW5uZXJIVE1MICk7XG5cdFx0XHRoZWFkZXJXaWR0aHMucHVzaCggc3R5bGUgKTtcblx0XHR9LCBoZWFkZXJTcmNFbHMgKTtcblx0XG5cdFx0Ly8gQXBwbHkgYWxsIHdpZHRocyBpbiBmaW5hbCBwYXNzXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuVG9TaXplLCBpKSB7XG5cdFx0XHRuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclRyZ0VscyApO1xuXHRcblx0XHQkKGhlYWRlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcblx0XHQvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xuXHRcdGlmICggZm9vdGVyIClcblx0XHR7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGZvb3RlclNyY0VscyApO1xuXHRcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHRcdGZvb3RlckNvbnRlbnQucHVzaCggblNpemVyLmlubmVySFRNTCApO1xuXHRcdFx0XHRmb290ZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdFx0fSwgZm9vdGVyU3JjRWxzICk7XG5cdFxuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuVG9TaXplLCBpKSB7XG5cdFx0XHRcdG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XG5cdFx0XHR9LCBmb290ZXJUcmdFbHMgKTtcblx0XG5cdFx0XHQkKGZvb3RlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMy4gQXBwbHkgdGhlIG1lYXN1cmVtZW50c1xuXHRcdCAqL1xuXHRcblx0XHQvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcblx0XHQvLyB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBzbyB0aGF0IHRoZSB3aWR0aCBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgYW5kIGJvZHlcblx0XHQvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcblx0XHQvLyB3aWR0aCB0byB3aGF0IHRoZXkgY3VycmVudGx5IGFyZVxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyLCBpKSB7XG5cdFx0XHRuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicraGVhZGVyQ29udGVudFtpXSsnPC9kaXY+Jztcblx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0blNpemVyLmNoaWxkTm9kZXNbMF0uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApXG5cdFx0e1xuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdFx0blNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIj4nK2Zvb3RlckNvbnRlbnRbaV0rJzwvZGl2Pic7XG5cdFx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcblx0XHQvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcblx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoIClcblx0XHR7XG5cdFx0XHQvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG5cdFx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XG5cdFx0XHRcdFx0c2FuaXR5V2lkdGgrYmFyV2lkdGggOlxuXHRcdFx0XHRcdHNhbml0eVdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cblx0XHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRcdGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvcnJlY3Rpb24gPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5cdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvcnJlY3Rpb24gKTtcblx0XHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogNC4gQ2xlYW4gdXBcblx0XHQgKi9cblx0XHRpZiAoICEgc2Nyb2xsWSApIHtcblx0XHRcdC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuXHRcdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHRcdCAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggaWU2NyApIHtcblx0XHRcdFx0ZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZUVsLm9mZnNldEhlaWdodCtiYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogRmluYWxseSBzZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlcyAqL1xuXHRcdHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XG5cdFx0Ly8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cblx0XHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdFx0dmFyIGJTY3JvbGxpbmcgPSB0YWJsZS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHRcdHZhciBwYWRkaW5nID0gJ3BhZGRpbmcnICsgKGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPyAnTGVmdCcgOiAnUmlnaHQnICk7XG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZVsgcGFkZGluZyBdID0gYlNjcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCI7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0ZGl2Rm9vdGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0XHRkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuXHRcdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLmluc2VydEJlZm9yZSggdGFibGUuY2hpbGRyZW4oJ3RoZWFkJykgKTtcblx0XG5cdFx0LyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXG5cdFx0ZGl2Qm9keS50cmlnZ2VyKCdzY3JvbGwnKTtcblx0XG5cdFx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdFx0Ly8gb25seSBpZiB3ZSBhcmVuJ3QgaG9sZGluZyB0aGUgcG9zaXRpb25cblx0XHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XG5cdCAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xuXHQgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXG5cdCAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oIGZuLCBhbjEsIGFuMiApXG5cdHtcblx0XHR2YXIgaW5kZXg9MCwgaT0wLCBpTGVuPWFuMS5sZW5ndGg7XG5cdFx0dmFyIG5Ob2RlMSwgbk5vZGUyO1xuXHRcblx0XHR3aGlsZSAoIGkgPCBpTGVuICkge1xuXHRcdFx0bk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XG5cdFx0XHRuTm9kZTIgPSBhbjIgPyBhbjJbaV0uZmlyc3RDaGlsZCA6IG51bGw7XG5cdFxuXHRcdFx0d2hpbGUgKCBuTm9kZTEgKSB7XG5cdFx0XHRcdGlmICggbk5vZGUxLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggYW4yICkge1xuXHRcdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgbk5vZGUyLCBpbmRleCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGZuKCBuTm9kZTEsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XG5cdFx0XHRcdG5Ob2RlMiA9IGFuMiA/IG5Ob2RlMi5uZXh0U2libGluZyA6IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHR2YXIgX19yZV9odG1sX3JlbW92ZSA9IC88Lio/Pi9nO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG5cdFx0XHRjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdHNjcm9sbCA9IG9TZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRcdHNjcm9sbFggPSBzY3JvbGwuc1gsXG5cdFx0XHRzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHR2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApLFxuXHRcdFx0aGVhZGVyQ2VsbHMgPSAkKCd0aCcsIG9TZXR0aW5ncy5uVEhlYWQpLFxuXHRcdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRcdHVzZXJJbnB1dHMgPSBmYWxzZSxcblx0XHRcdGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aCxcblx0XHRcdGJyb3dzZXIgPSBvU2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemU7XG5cdFxuXHRcdHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG5cdFx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHRcdHRhYmxlV2lkdGhBdHRyID0gc3R5bGVXaWR0aDtcblx0XHR9XG5cdFxuXHRcdC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuXHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXTtcblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGNvbHVtbi5zV2lkdGggPSBfZm5Db252ZXJ0VG9XaWR0aCggY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyICk7XG5cdFxuXHRcdFx0XHR1c2VySW5wdXRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgRE9NIGVxdWFscyB0aGUgbnVtYmVyIHRoYXQgd2UgaGF2ZSB0b1xuXHRcdCAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcblx0XHQgKiB0aGUgd2ViLSBicm93c2VyLiBObyBjdXN0b20gc2l6ZXMgY2FuIGJlIHNldCBpbiBvcmRlciBmb3IgdGhpcyB0byBoYXBwZW4sXG5cdFx0ICogbm9yIHNjcm9sbGluZyB1c2VkXG5cdFx0ICovXG5cdFx0aWYgKCBpZTY3IHx8ICEgdXNlcklucHV0cyAmJiAhIHNjcm9sbFggJiYgISBzY3JvbGxZICYmXG5cdFx0ICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSAmJlxuXHRcdCAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG5cdFx0KSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0XHR2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaSApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1sgY29sSWR4IF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdFx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdFx0XHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHRcdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0XHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG5cdFx0XHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXHRcblx0XHRcdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdFx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXHRcblx0XHRcdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0XHQvLyBmcm9tIHRoZSBjbG9uZWQgdGFibGUsIHNpbmNlIGlmIHNjcm9sbGluZyBpcyBhY3RpdmUsIHRoZSB0YWJsZSdzXG5cdFx0XHQvLyByZWFsIGhlYWRlciBhbmQgZm9vdGVyIGFyZSBjb250YWluZWQgaW4gZGlmZmVyZW50IHRhYmxlIHRhZ3Ncblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcdFx0dG1wVGFibGVcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpIClcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cdFxuXHRcdFx0Ly8gQXBwbHkgY3VzdG9tIHNpemluZyB0byB0aGUgY2xvbmVkIGhlYWRlclxuXHRcdFx0aGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncywgdG1wVGFibGUuZmluZCgndGhlYWQnKVswXSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcblx0XHRcdFx0aGVhZGVyQ2VsbHNbaV0uc3R5bGUud2lkdGggPSBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gbnVsbCAmJiBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gJycgP1xuXHRcdFx0XHRcdF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoT3JpZyApIDpcblx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdC8vIEZvciBzY3JvbGxYIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNvbHVtbiB3aWR0aCBvdGhlcndpc2UgdGhlXG5cdFx0XHRcdC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFggKSB7XG5cdFx0XHRcdFx0JCggaGVhZGVyQ2VsbHNbaV0gKS5hcHBlbmQoICQoJzxkaXYvPicpLmNzcygge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNvbHVtbi5zV2lkdGhPcmlnLFxuXHRcdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdFx0cGFkZGluZzogMCxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHRcdH0gKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcblx0XHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXHRcblx0XHRcdFx0XHQkKCBfZm5HZXRXaWRlc3ROb2RlKCBvU2V0dGluZ3MsIGNvbHVtbklkeCApIClcblx0XHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggY29sdW1uLnNDb250ZW50UGFkZGluZyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHRcdFx0Ly8gZHVwbGljYXRlZCBpbiB0aGUgZG9tIChyYWRpbyBlbGVtZW50cyBmb3IgZXhhbXBsZSlcblx0XHRcdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0XHRcdC8vIEEgaG9sZGluZyBlbGVtZW50IGlzIHVzZWQsIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG5cdFx0XHQvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuXHRcdFx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHRcdFx0Ly8gbmVlZGVkXG5cdFx0XHR2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKCBzY3JvbGxYIHx8IHNjcm9sbFkgP1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0e31cblx0XHRcdFx0KVxuXHRcdFx0XHQuYXBwZW5kKCB0bXBUYWJsZSApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyAoWCBvciBZKSB3ZSB3YW50IHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIGFzIFxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHRcdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRcdFx0aWYgKCBzY3JvbGxYICYmIHNjcm9sbFhJbm5lciApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0XHRcdHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cdFxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0XHRcdC8vIGNvbGxhcHNlXG5cdFx0XHRcdGlmICggdG1wVGFibGUud2lkdGgoKSA8IHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICYmIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlIC0gd2UgbmVlZCB0b1xuXHRcdFx0Ly8ga25vdyB0aGUgaW5uZXIgd2lkdGggKHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgb3RoZXIgdGFibGUnc1xuXHRcdFx0Ly8gY2VsbHMpIGFuZCB0aGUgb3V0ZXIgd2lkdGggc28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgZnVsbCB3aWR0aCBvZiB0aGVcblx0XHRcdC8vIHRhYmxlLiBUaGlzIGlzIHNhZmUgc2luY2UgRGF0YVRhYmxlcyByZXF1aXJlcyBhIHVuaXF1ZSBjZWxsIGZvciBlYWNoXG5cdFx0XHQvLyBjb2x1bW4sIGJ1dCBpZiBldmVyIGEgaGVhZGVyIGNhbiBzcGFuIG11bHRpcGxlIGNvbHVtbnMsIHRoaXMgd2lsbFxuXHRcdFx0Ly8gbmVlZCB0byBiZSBtb2RpZmllZC5cblx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0dmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcblx0XHRcdFx0dmFyIGJvcmRlciA9IGNlbGwub3V0ZXJXaWR0aCgpIC0gY2VsbC53aWR0aCgpO1xuXHRcblx0XHRcdFx0Ly8gVXNlIGdldEJvdW5kaW5nLi4uIHdoZXJlIHBvc3NpYmxlIChub3QgSUU4LSkgYmVjYXVzZSBpdCBjYW4gZ2l2ZVxuXHRcdFx0XHQvLyBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcblx0XHRcdFx0dmFyIGJvdW5kaW5nID0gYnJvd3Nlci5iQm91bmRpbmcgP1xuXHRcdFx0XHRcdE1hdGguY2VpbCggaGVhZGVyQ2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA6XG5cdFx0XHRcdFx0Y2VsbC5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdFx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdFx0XHQvLyBvZiB0aGUgdGFibGUgbWlnaHQgbm90IGVxdWFsIHRoZSB0b3RhbCBnaXZlbiBoZXJlIChJRSEpLlxuXHRcdFx0XHR0b3RhbCArPSBib3VuZGluZztcblx0XG5cdFx0XHRcdC8vIFdpZHRoIGZvciBlYWNoIGNvbHVtbiB0byB1c2Vcblx0XHRcdFx0Y29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyggYm91bmRpbmcgLSBib3JkZXIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXHRcblx0XHRcdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0XHRcdGhvbGRlci5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0XHQvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcblx0XHQvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxuXHRcdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRcdGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgISBvU2V0dGluZ3MuX3Jlc3pFdnQgKSB7XG5cdFx0XHR2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytvU2V0dGluZ3Muc0luc3RhbmNlLCBfZm5UaHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fTtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXG5cdFx0XHQvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuXHRcdFx0aWYgKCBpZTY3ICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBiaW5kUmVzaXplLCAxMDAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YmluZFJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWQgZm9yXG5cdCAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgQHBhcmFtIHtpbnR9IFtmcmVxPTIwMF0gY2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHR2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBhIENTUyB1bml0IHdpZHRoIHRvIHBpeGVscyAoZS5nLiAyZW0pXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gd2lkdGggd2lkdGggdG8gYmUgY29udmVydGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IHBhcmVudCBwYXJlbnQgdG8gZ2V0IHRoZSB3aXRoIGZvciAocmVxdWlyZWQgZm9yIHJlbGF0aXZlIHdpZHRocykgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbnZlcnRUb1dpZHRoICggd2lkdGgsIHBhcmVudCApXG5cdHtcblx0XHRpZiAoICEgd2lkdGggKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFxuXHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoICd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCB3aWR0aCApIClcblx0XHRcdC5hcHBlbmRUbyggcGFyZW50IHx8IGRvY3VtZW50LmJvZHkgKTtcblx0XG5cdFx0dmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XG5cdFx0bi5yZW1vdmUoKTtcblx0XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZGVzdCBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgaWR4IF07XG5cdFx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHRcdCQoJzx0ZC8+JykuaHRtbCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknICkgKVswXSA6XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbElkeCBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoIHNldHRpbmdzLCBjb2xJZHggKVxuXHR7XG5cdFx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdFx0cyA9IHMucmVwbGFjZSggX19yZV9odG1sX3JlbW92ZSwgJycgKTtcblx0XHRcdHMgPSBzLnJlcGxhY2UoIC8mbmJzcDsvZywgJyAnICk7XG5cdFxuXHRcdFx0aWYgKCBzLmxlbmd0aCA+IG1heCApIHtcblx0XHRcdFx0bWF4ID0gcy5sZW5ndGg7XG5cdFx0XHRcdG1heElkeCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbWF4SWR4O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlIHdpdGggY3NzIHVuaXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU3RyaW5nVG9Dc3MoIHMgKVxuXHR7XG5cdFx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuICcwcHgnO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB0eXBlb2YgcyA9PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHRcdCcwcHgnIDpcblx0XHRcdFx0cysncHgnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaXQgaGFzIGEgdW5pdCBjaGFyYWN0ZXIgYWxyZWFkeVxuXHRcdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdFx0cysncHgnIDpcblx0XHRcdHM7XG5cdH1cblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEZsYXR0ZW4gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGlMZW4sIGssIGtMZW4sXG5cdFx0XHRhU29ydCA9IFtdLFxuXHRcdFx0YWlPcmlnID0gW10sXG5cdFx0XHRhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG5cdFx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdFx0Zml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoIGZpeGVkICksXG5cdFx0XHRuZXN0ZWRTb3J0ID0gW10sXG5cdFx0XHRhZGQgPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRcdGlmICggYS5sZW5ndGggJiYgISBBcnJheS5pc0FycmF5KCBhWzBdICkgKSB7XG5cdFx0XHRcdFx0Ly8gMUQgYXJyYXlcblx0XHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2goIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyAyRCBhcnJheVxuXHRcdFx0XHRcdCQubWVyZ2UoIG5lc3RlZFNvcnQsIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0Ly8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxuXHRcdC8vIHNwZWNpZmllZFxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggZml4ZWQgKSApIHtcblx0XHRcdGFkZCggZml4ZWQgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZml4ZWRPYmogJiYgZml4ZWQucHJlICkge1xuXHRcdFx0YWRkKCBmaXhlZC5wcmUgKTtcblx0XHR9XG5cdFxuXHRcdGFkZCggc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cdFxuXHRcdGlmIChmaXhlZE9iaiAmJiBmaXhlZC5wb3N0ICkge1xuXHRcdFx0YWRkKCBmaXhlZC5wb3N0ICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAgOyBpPG5lc3RlZFNvcnQubGVuZ3RoIDsgaSsrIClcblx0XHR7XG5cdFx0XHRzcmNDb2wgPSBuZXN0ZWRTb3J0W2ldWzBdO1xuXHRcdFx0YURhdGFTb3J0ID0gYW9Db2x1bW5zWyBzcmNDb2wgXS5hRGF0YVNvcnQ7XG5cdFxuXHRcdFx0Zm9yICggaz0wLCBrTGVuPWFEYXRhU29ydC5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpQ29sID0gYURhdGFTb3J0W2tdO1xuXHRcdFx0XHRzVHlwZSA9IGFvQ29sdW1uc1sgaUNvbCBdLnNUeXBlIHx8ICdzdHJpbmcnO1xuXHRcblx0XHRcdFx0aWYgKCBuZXN0ZWRTb3J0W2ldLl9pZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRuZXN0ZWRTb3J0W2ldLl9pZHggPSAkLmluQXJyYXkoIG5lc3RlZFNvcnRbaV1bMV0sIGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YVNvcnQucHVzaCgge1xuXHRcdFx0XHRcdHNyYzogICAgICAgc3JjQ29sLFxuXHRcdFx0XHRcdGNvbDogICAgICAgaUNvbCxcblx0XHRcdFx0XHRkaXI6ICAgICAgIG5lc3RlZFNvcnRbaV1bMV0sXG5cdFx0XHRcdFx0aW5kZXg6ICAgICBuZXN0ZWRTb3J0W2ldLl9pZHgsXG5cdFx0XHRcdFx0dHlwZTogICAgICBzVHlwZSxcblx0XHRcdFx0XHRmb3JtYXR0ZXI6IERhdGFUYWJsZS5leHQudHlwZS5vcmRlclsgc1R5cGUrXCItcHJlXCIgXVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gYVNvcnQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqICBAdG9kbyBUaGlzIHJlYWxseSBuZWVkcyBzcGxpdCB1cCFcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnQgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sXG5cdFx0XHRzRGF0YVR5cGUsIG5UaCxcblx0XHRcdGFpT3JpZyA9IFtdLFxuXHRcdFx0b0V4dFNvcnQgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsXG5cdFx0XHRhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhLFxuXHRcdFx0YW9Db2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGFEYXRhU29ydCwgZGF0YSwgaUNvbCwgc1R5cGUsIG9Tb3J0LFxuXHRcdFx0Zm9ybWF0dGVycyA9IDAsXG5cdFx0XHRzb3J0Q29sLFxuXHRcdFx0ZGlzcGxheU1hc3RlciA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsXG5cdFx0XHRhU29ydDtcblx0XG5cdFx0Ly8gUmVzb2x2ZSBhbnkgY29sdW1uIHR5cGVzIHRoYXQgYXJlIHVua25vd24gZHVlIHRvIGFkZGl0aW9uIG9yIGludmFsaWRhdGlvblxuXHRcdC8vIEB0b2RvIENhbiB0aGlzIGJlIG1vdmVkIGludG8gYSAnZGF0YS1yZWFkeScgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlblxuXHRcdC8vICAgZGF0YSBpcyBnb2luZyB0byBiZSB1c2VkIGluIHRoZSB0YWJsZT9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1hU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNvcnRDb2wgPSBhU29ydFtpXTtcblx0XG5cdFx0XHQvLyBUcmFjayBpZiB3ZSBjYW4gdXNlIHRoZSBmYXN0IHNvcnQgYWxnb3JpdGhtXG5cdFx0XHRpZiAoIHNvcnRDb2wuZm9ybWF0dGVyICkge1xuXHRcdFx0XHRmb3JtYXR0ZXJzKys7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTG9hZCB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBzb3J0LCBmb3IgZWFjaCBjZWxsXG5cdFx0XHRfZm5Tb3J0RGF0YSggb1NldHRpbmdzLCBzb3J0Q29sLmNvbCApO1xuXHRcdH1cblx0XG5cdFx0LyogTm8gc29ydGluZyByZXF1aXJlZCBpZiBzZXJ2ZXItc2lkZSBvciBubyBzb3J0aW5nIGFycmF5ICovXG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDAgKVxuXHRcdHtcblx0XHRcdC8vIENyZWF0ZSBhIHZhbHVlIC0ga2V5IGFycmF5IG9mIHRoZSBjdXJyZW50IHJvdyBwb3NpdGlvbnMgc3VjaCB0aGF0IHdlIGNhbiB1c2UgdGhlaXJcblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gZHVyaW5nIHRoZSBzb3J0LCBpZiB2YWx1ZXMgbWF0Y2gsIGluIG9yZGVyIHRvIHBlcmZvcm0gc3RhYmxlIHNvcnRpbmdcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1kaXNwbGF5TWFzdGVyLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0YWlPcmlnWyBkaXNwbGF5TWFzdGVyW2ldIF0gPSBpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8qIERvIHRoZSBzb3J0IC0gaGVyZSB3ZSB3YW50IG11bHRpLWNvbHVtbiBzb3J0aW5nIGJhc2VkIG9uIGEgZ2l2ZW4gZGF0YSBzb3VyY2UgKGNvbHVtbilcblx0XHRcdCAqIGFuZCBzb3J0aW5nIGZ1bmN0aW9uIChmcm9tIG9Tb3J0KSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBJdCdzIHJlYXNvbmFibHkgY29tcGxleCB0b1xuXHRcdFx0ICogZm9sbG93IG9uIGl0J3Mgb3duLCBidXQgdGhpcyBpcyB3aGF0IHdlIHdhbnQgKGV4YW1wbGUgdHdvIGNvbHVtbiBzb3J0aW5nKTpcblx0XHRcdCAqICBmbkxvY2FsU29ydGluZyA9IGZ1bmN0aW9uKGEsYil7XG5cdFx0XHQgKiAgICB2YXIgaVRlc3Q7XG5cdFx0XHQgKiAgICBpVGVzdCA9IG9Tb3J0WydzdHJpbmctYXNjJ10oJ2RhdGExMScsICdkYXRhMTInKTtcblx0XHRcdCAqICAgICAgaWYgKGlUZXN0ICE9PSAwKVxuXHRcdFx0ICogICAgICAgIHJldHVybiBpVGVzdDtcblx0XHRcdCAqICAgIGlUZXN0ID0gb1NvcnRbJ251bWVyaWMtZGVzYyddKCdkYXRhMjEnLCAnZGF0YTIyJyk7XG5cdFx0XHQgKiAgICBpZiAoaVRlc3QgIT09IDApXG5cdFx0XHQgKiAgICAgIHJldHVybiBpVGVzdDtcblx0XHRcdCAqICAgIHJldHVybiBvU29ydFsnbnVtZXJpYy1hc2MnXSggYWlPcmlnW2FdLCBhaU9yaWdbYl0gKTtcblx0XHRcdCAqICB9XG5cdFx0XHQgKiBCYXNpY2FsbHkgd2UgaGF2ZSBhIHRlc3QgZm9yIGVhY2ggc29ydGluZyBjb2x1bW4sIGlmIHRoZSBkYXRhIGluIHRoYXQgY29sdW1uIGlzIGVxdWFsLFxuXHRcdFx0ICogdGVzdCB0aGUgbmV4dCBjb2x1bW4uIElmIGFsbCBjb2x1bW5zIG1hdGNoLCB0aGVuIHdlIHVzZSBhIG51bWVyaWMgc29ydCBvbiB0aGUgcm93XG5cdFx0XHQgKiBwb3NpdGlvbnMgaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgdG8gcHJvdmlkZSBhIHN0YWJsZSBzb3J0LlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgLSBJIGtub3cgaXQgc2VlbXMgZXhjZXNzaXZlIHRvIGhhdmUgdHdvIHNvcnRpbmcgbWV0aG9kcywgYnV0IHRoZSBmaXJzdCBpcyBhcm91bmRcblx0XHRcdCAqIDE1JSBmYXN0ZXIsIHNvIHRoZSBzZWNvbmQgaXMgb25seSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNvcnRpbmdcblx0XHRcdCAqIG1ldGhvZHMgd2hpY2ggZG8gbm90IGhhdmUgYSBwcmUtc29ydCBmb3JtYXR0aW5nIGZ1bmN0aW9uLlxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIGZvcm1hdHRlcnMgPT09IGFTb3J0Lmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gQWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uc1xuXHRcdFx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHgsIHksIGssIHRlc3QsIHNvcnQsXG5cdFx0XHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cdFxuXHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXHRcblx0XHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblx0XG5cdFx0XHRcdFx0XHR0ZXN0ID0geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvcnQuZGlyID09PSAnYXNjJyA/IHRlc3QgOiAtdGVzdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIERlcHJlY2lhdGVkIC0gcmVtb3ZlIGluIDEuMTEgKHByb3ZpZGluZyBhIHBsdWctaW4gb3B0aW9uKVxuXHRcdFx0XHQvLyBOb3QgYWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIG1ldGhvZHMsIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGVpciBzb3J0aW5nXG5cdFx0XHRcdC8vIG1ldGhvZHMuXG5cdFx0XHRcdGRpc3BsYXlNYXN0ZXIuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0eCwgeSwgaywgbCwgdGVzdCwgc29ydCwgZm4sXG5cdFx0XHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cdFxuXHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXHRcblx0XHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblx0XG5cdFx0XHRcdFx0XHRmbiA9IG9FeHRTb3J0WyBzb3J0LnR5cGUrXCItXCIrc29ydC5kaXIgXSB8fCBvRXh0U29ydFsgXCJzdHJpbmctXCIrc29ydC5kaXIgXTtcblx0XHRcdFx0XHRcdHRlc3QgPSBmbiggeCwgeSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0ZXN0ICE9PSAwICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB0aGF0IHdlIGhhdmUgc29ydGVkIHRoZSBkYXRhICovXG5cdFx0b1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEFyaWEgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgbGFiZWw7XG5cdFx0dmFyIG5leHRTb3J0O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHRcdHZhciBvQXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYTtcblx0XG5cdFx0Ly8gQVJJQSBhdHRyaWJ1dGVzIC0gbmVlZCB0byBsb29wIGFsbCBjb2x1bW5zLCB0byB1cGRhdGUgYWxsIChyZW1vdmluZyBvbGRcblx0XHQvLyBhdHRyaWJ1dGVzIGFzIG5lZWRlZClcblx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgY29sID0gY29sdW1uc1tpXTtcblx0XHRcdHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuXHRcdFx0dmFyIHNUaXRsZSA9IGNvbC5hcmlhVGl0bGUgfHwgY29sLnNUaXRsZS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApO1xuXHRcdFx0dmFyIHRoID0gY29sLm5UaDtcblx0XG5cdFx0XHQvLyBJRTcgaXMgdGhyb3dpbmcgYW4gZXJyb3Igd2hlbiBzZXR0aW5nIHRoZXNlIHByb3BlcnRpZXMgd2l0aCBqUXVlcnknc1xuXHRcdFx0Ly8gYXR0cigpIGFuZCByZW1vdmVBdHRyKCkgbWV0aG9kcy4uLlxuXHRcdFx0dGgucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNvcnQnKTtcblx0XG5cdFx0XHQvKiBJbiBBUklBIG9ubHkgdGhlIGZpcnN0IHNvcnRpbmcgY29sdW1uIGNhbiBiZSBtYXJrZWQgYXMgc29ydGluZyAtIG5vIG11bHRpLXNvcnQgb3B0aW9uICovXG5cdFx0XHRpZiAoIGNvbC5iU29ydGFibGUgKSB7XG5cdFx0XHRcdGlmICggYVNvcnQubGVuZ3RoID4gMCAmJiBhU29ydFswXS5jb2wgPT0gaSApIHtcblx0XHRcdFx0XHR0aC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc29ydCcsIGFTb3J0WzBdLmRpcj09XCJhc2NcIiA/IFwiYXNjZW5kaW5nXCIgOiBcImRlc2NlbmRpbmdcIiApO1xuXHRcdFx0XHRcdG5leHRTb3J0ID0gYXNTb3J0aW5nWyBhU29ydFswXS5pbmRleCsxIF0gfHwgYXNTb3J0aW5nWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG5leHRTb3J0ID0gYXNTb3J0aW5nWzBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRsYWJlbCA9IHNUaXRsZSArICggbmV4dFNvcnQgPT09IFwiYXNjXCIgP1xuXHRcdFx0XHRcdG9BcmlhLnNTb3J0QXNjZW5kaW5nIDpcblx0XHRcdFx0XHRvQXJpYS5zU29ydERlc2NlbmRpbmdcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsYWJlbCA9IHNUaXRsZTtcblx0XHRcdH1cblx0XG5cdFx0XHR0aC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIHJ1biBvbiB1c2VyIHNvcnQgcmVxdWVzdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IFthcHBlbmQ9ZmFsc2VdIEFwcGVuZCB0aGUgcmVxdWVzdGVkIHNvcnQgdG8gdGhlIGV4aXN0aW5nXG5cdCAqICAgIHNvcnQgaWYgdHJ1ZSAoaS5lLiBtdWx0aS1jb2x1bW4gc29ydClcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydExpc3RlbmVyICggc2V0dGluZ3MsIGNvbElkeCwgYXBwZW5kLCBjYWxsYmFjayApXG5cdHtcblx0XHR2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xJZHggXTtcblx0XHR2YXIgc29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZztcblx0XHR2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcblx0XHR2YXIgbmV4dFNvcnRJZHg7XG5cdFx0dmFyIG5leHQgPSBmdW5jdGlvbiAoIGEsIG92ZXJmbG93ICkge1xuXHRcdFx0dmFyIGlkeCA9IGEuX2lkeDtcblx0XHRcdGlmICggaWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGlkeCA9ICQuaW5BcnJheSggYVsxXSwgYXNTb3J0aW5nICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGlkeCsxIDwgYXNTb3J0aW5nLmxlbmd0aCA/XG5cdFx0XHRcdGlkeCsxIDpcblx0XHRcdFx0b3ZlcmZsb3cgP1xuXHRcdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRcdDA7XG5cdFx0fTtcblx0XG5cdFx0Ly8gQ29udmVydCB0byAyRCBhcnJheSBpZiBuZWVkZWRcblx0XHRpZiAoIHR5cGVvZiBzb3J0aW5nWzBdID09PSAnbnVtYmVyJyApIHtcblx0XHRcdHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmcgPSBbIHNvcnRpbmcgXTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIGFwcGVuZGluZyB0aGUgc29ydCB0aGVuIHdlIGFyZSBtdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdGlmICggYXBwZW5kICYmIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydE11bHRpICkge1xuXHRcdFx0Ly8gQXJlIHdlIGFscmVhZHkgZG9pbmcgc29tZSBraW5kIG9mIHNvcnQgb24gdGhpcyBjb2x1bW4/XG5cdFx0XHR2YXIgc29ydElkeCA9ICQuaW5BcnJheSggY29sSWR4LCBfcGx1Y2soc29ydGluZywgJzAnKSApO1xuXHRcblx0XHRcdGlmICggc29ydElkeCAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIFllcywgbW9kaWZ5IHRoZSBzb3J0XG5cdFx0XHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1tzb3J0SWR4XSwgdHJ1ZSApO1xuXHRcblx0XHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRuZXh0U29ydElkeCA9IDA7IC8vIGNhbid0IHJlbW92ZSBzb3J0aW5nIGNvbXBsZXRlbHlcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRzb3J0aW5nLnNwbGljZSggc29ydElkeCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNvcnRpbmdbc29ydElkeF1bMV0gPSBhc1NvcnRpbmdbIG5leHRTb3J0SWR4IF07XG5cdFx0XHRcdFx0c29ydGluZ1tzb3J0SWR4XS5faWR4ID0gbmV4dFNvcnRJZHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldFxuXHRcdFx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBhc1NvcnRpbmdbMF0sIDAgXSApO1xuXHRcdFx0XHRzb3J0aW5nW3NvcnRpbmcubGVuZ3RoLTFdLl9pZHggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggc29ydGluZy5sZW5ndGggJiYgc29ydGluZ1swXVswXSA9PSBjb2xJZHggKSB7XG5cdFx0XHQvLyBTaW5nbGUgY29sdW1uIC0gYWxyZWFkeSBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1swXSApO1xuXHRcblx0XHRcdHNvcnRpbmcubGVuZ3RoID0gMTtcblx0XHRcdHNvcnRpbmdbMF1bMV0gPSBhc1NvcnRpbmdbIG5leHRTb3J0SWR4IF07XG5cdFx0XHRzb3J0aW5nWzBdLl9pZHggPSBuZXh0U29ydElkeDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBTaW5nbGUgY29sdW1uIC0gc29ydCBvbmx5IG9uIHRoaXMgY29sdW1uXG5cdFx0XHRzb3J0aW5nLmxlbmd0aCA9IDA7XG5cdFx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBhc1NvcnRpbmdbMF0gXSApO1xuXHRcdFx0c29ydGluZ1swXS5faWR4ID0gMDtcblx0XHR9XG5cdFxuXHRcdC8vIFJ1biB0aGUgc29ydCBieSBjYWxsaW5nIGEgZnVsbCByZWRyYXdcblx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIGNhbGxiYWNrIHVzZWQgZm9yIGFzeW5jIHVzZXIgaW50ZXJhY3Rpb25cblx0XHRpZiAoIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Y2FsbGJhY2soIHNldHRpbmdzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEF0dGFjaCBhIHNvcnQgaGFuZGxlciAoY2xpY2spIHRvIGEgbm9kZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnRBdHRhY2hMaXN0ZW5lciAoIHNldHRpbmdzLCBhdHRhY2hUbywgY29sSWR4LCBjYWxsYmFjayApXG5cdHtcblx0XHR2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xJZHggXTtcblx0XG5cdFx0X2ZuQmluZEFjdGlvbiggYXR0YWNoVG8sIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0LyogSWYgdGhlIGNvbHVtbiBpcyBub3Qgc29ydGFibGUgLSBkb24ndCB0byBhbnl0aGluZyAqL1xuXHRcdFx0aWYgKCBjb2wuYlNvcnRhYmxlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIElmIHByb2Nlc3NpbmcgaXMgZW5hYmxlZCB1c2UgYSB0aW1lb3V0IHRvIGFsbG93IHRoZSBwcm9jZXNzaW5nXG5cdFx0XHQvLyBkaXNwbGF5IHRvIGJlIHNob3duIC0gb3RoZXJ3aXNlIHRvIGl0IHN5bmNocm9ub3VzbHlcblx0XHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nICkge1xuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF9mblNvcnRMaXN0ZW5lciggc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2sgKTtcblx0XG5cdFx0XHRcdFx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZywgdGhlIGRyYXcgY2FsbGJhY2sgd2lsbCByZW1vdmUgdGhlXG5cdFx0XHRcdFx0Ly8gcHJvY2Vzc2luZyBkaXNwbGF5XG5cdFx0XHRcdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApICE9PSAnc3NwJyApIHtcblx0XHRcdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDAgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5Tb3J0TGlzdGVuZXIoIHNldHRpbmdzLCBjb2xJZHgsIGUuc2hpZnRLZXksIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgc29ydGluZyBjbGFzc2VzIG9uIHRhYmxlJ3MgYm9keSwgTm90ZTogaXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgZnVuY3Rpb25cblx0ICogd2hlbiBiU29ydCBhbmQgYlNvcnRDbGFzc2VzIGFyZSBmYWxzZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0aW5nQ2xhc3Nlcyggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIG9sZFNvcnQgPSBzZXR0aW5ncy5hTGFzdFNvcnQ7XG5cdFx0dmFyIHNvcnRDbGFzcyA9IHNldHRpbmdzLm9DbGFzc2VzLnNTb3J0Q29sdW1uO1xuXHRcdHZhciBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICk7XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdHZhciBpLCBpZW4sIGNvbElkeDtcblx0XG5cdFx0aWYgKCBmZWF0dXJlcy5iU29ydCAmJiBmZWF0dXJlcy5iU29ydENsYXNzZXMgKSB7XG5cdFx0XHQvLyBSZW1vdmUgb2xkIHNvcnRpbmcgY2xhc3Nlc1xuXHRcdFx0Zm9yICggaT0wLCBpZW49b2xkU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y29sSWR4ID0gb2xkU29ydFtpXS5zcmM7XG5cdFxuXHRcdFx0XHQvLyBSZW1vdmUgY29sdW1uIHNvcnRpbmdcblx0XHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggc29ydENsYXNzICsgKGk8MiA/IGkrMSA6IDMpICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQWRkIG5ldyBjb2x1bW4gc29ydGluZ1xuXHRcdFx0Zm9yICggaT0wLCBpZW49c29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y29sSWR4ID0gc29ydFtpXS5zcmM7XG5cdFxuXHRcdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2xJZHggKSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLmFMYXN0U29ydCA9IHNvcnQ7XG5cdH1cblx0XG5cdFxuXHQvLyBHZXQgdGhlIGRhdGEgdG8gc29ydCBhIGNvbHVtbiwgYmUgaXQgZnJvbSBjYWNoZSwgZnJlc2ggKHBvcHVsYXRpbmcgdGhlXG5cdC8vIGNhY2hlKSwgb3IgZnJvbSBhIHNvcnQgZm9ybWF0dGVyXG5cdGZ1bmN0aW9uIF9mblNvcnREYXRhKCBzZXR0aW5ncywgaWR4IClcblx0e1xuXHRcdC8vIEN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uIC0gcHJvdmlkZWQgYnkgdGhlIHNvcnQgZGF0YSB0eXBlXG5cdFx0dmFyIGNvbHVtbiA9IHNldHRpbmdzLmFvQ29sdW1uc1sgaWR4IF07XG5cdFx0dmFyIGN1c3RvbVNvcnQgPSBEYXRhVGFibGUuZXh0Lm9yZGVyWyBjb2x1bW4uc1NvcnREYXRhVHlwZSBdO1xuXHRcdHZhciBjdXN0b21EYXRhO1xuXHRcblx0XHRpZiAoIGN1c3RvbVNvcnQgKSB7XG5cdFx0XHRjdXN0b21EYXRhID0gY3VzdG9tU29ydC5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBpZHgsXG5cdFx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgaWR4IClcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHQvLyBVc2UgLyBwb3B1bGF0ZSBjYWNoZVxuXHRcdHZhciByb3csIGNlbGxEYXRhO1xuXHRcdHZhciBmb3JtYXR0ZXIgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbIGNvbHVtbi5zVHlwZStcIi1wcmVcIiBdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhW2ldO1xuXHRcblx0XHRcdGlmICggISByb3cuX2FTb3J0RGF0YSApIHtcblx0XHRcdFx0cm93Ll9hU29ydERhdGEgPSBbXTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hU29ydERhdGFbaWR4XSB8fCBjdXN0b21Tb3J0ICkge1xuXHRcdFx0XHRjZWxsRGF0YSA9IGN1c3RvbVNvcnQgP1xuXHRcdFx0XHRcdGN1c3RvbURhdGFbaV0gOiAvLyBJZiB0aGVyZSB3YXMgYSBjdXN0b20gc29ydCBmdW5jdGlvbiwgdXNlIGRhdGEgZnJvbSB0aGVyZVxuXHRcdFx0XHRcdF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaSwgaWR4LCAnc29ydCcgKTtcblx0XG5cdFx0XHRcdHJvdy5fYVNvcnREYXRhWyBpZHggXSA9IGZvcm1hdHRlciA/XG5cdFx0XHRcdFx0Zm9ybWF0dGVyKCBjZWxsRGF0YSApIDpcblx0XHRcdFx0XHRjZWxsRGF0YTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNhdmUgdGhlIHN0YXRlIG9mIGEgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2F2ZVN0YXRlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBTdG9yZSB0aGUgaW50ZXJlc3RpbmcgdmFyaWFibGVzICovXG5cdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0dGltZTogICAgK25ldyBEYXRlKCksXG5cdFx0XHRzdGFydDogICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbmd0aDogIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdG9yZGVyOiAgICQuZXh0ZW5kKCB0cnVlLCBbXSwgc2V0dGluZ3MuYWFTb3J0aW5nICksXG5cdFx0XHRzZWFyY2g6ICBfZm5TZWFyY2hUb0NhbWVsKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKSxcblx0XHRcdGNvbHVtbnM6ICQubWFwKCBzZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggY29sLCBpICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZpc2libGU6IGNvbC5iVmlzaWJsZSxcblx0XHRcdFx0XHRzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSApXG5cdFx0XHRcdH07XG5cdFx0XHR9IClcblx0XHR9O1xuXHRcblx0XHRzZXR0aW5ncy5vU2F2ZWRTdGF0ZSA9IHN0YXRlO1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIiwgJ3N0YXRlU2F2ZVBhcmFtcycsIFtzZXR0aW5ncywgc3RhdGVdICk7XG5cdFx0XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSAmJiAhc2V0dGluZ3MuYkRlc3Ryb3lpbmcgKVxuXHRcdHtcblx0XHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgc3RhdGUgKTtcblx0XHR9XHRcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGxvYWQgYSBzYXZlZCB0YWJsZSBzdGF0ZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9Jbml0IERhdGFUYWJsZXMgaW5pdCBvYmplY3Qgc28gd2UgY2FuIG92ZXJyaWRlIHNldHRpbmdzXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Mb2FkU3RhdGUgKCBzZXR0aW5ncywgb0luaXQsIGNhbGxiYWNrIClcblx0e1xuXHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSApIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgbG9hZGVkID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdF9mbkltcGxlbWVudFN0YXRlKHNldHRpbmdzLCBzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdH1cblx0XG5cdFx0dmFyIHN0YXRlID0gc2V0dGluZ3MuZm5TdGF0ZUxvYWRDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBsb2FkZWQgKTtcblx0XG5cdFx0aWYgKCBzdGF0ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0X2ZuSW1wbGVtZW50U3RhdGUoIHNldHRpbmdzLCBzdGF0ZSwgY2FsbGJhY2sgKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbG9hZGVkIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG5cdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfZm5JbXBsZW1lbnRTdGF0ZSAoIHNldHRpbmdzLCBzLCBjYWxsYmFjaykge1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSB0cnVlO1xuXHRcblx0XHQvLyBXaGVuIFN0YXRlUmVzdG9yZSB3YXMgaW50cm9kdWNlZCB0aGUgc3RhdGUgY291bGQgbm93IGJlIGltcGxlbWVudGVkIGF0IGFueSB0aW1lXG5cdFx0Ly8gTm90IGp1c3QgaW5pdGlhbGlzYXRpb24uIFRvIGRvIHRoaXMgYW4gYXBpIGluc3RhbmNlIGlzIHJlcXVpcmVkIGluIHNvbWUgcGxhY2VzXG5cdFx0dmFyIGFwaSA9IHNldHRpbmdzLl9iSW5pdENvbXBsZXRlID8gbmV3IERhdGFUYWJsZS5BcGkoc2V0dGluZ3MpIDogbnVsbDtcblx0XG5cdFx0aWYgKCAhIHMgfHwgISBzLnRpbWUgKSB7XG5cdFx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdC8vIEFsbG93IGN1c3RvbSBhbmQgcGx1Zy1pbiBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvIGFsdGVyIHRoZSBzYXZlZCBkYXRhIHNldCBhbmRcblx0XHQvLyBjYW5jZWxsaW5nIG9mIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXG5cdFx0dmFyIGFiU3RhdGVMb2FkID0gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc10gKTtcblx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFiU3RhdGVMb2FkICkgIT09IC0xICkge1xuXHRcdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvLyBSZWplY3Qgb2xkIGRhdGFcblx0XHR2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcblx0XHRpZiAoIGR1cmF0aW9uID4gMCAmJiBzLnRpbWUgPCArbmV3IERhdGUoKSAtIChkdXJhdGlvbioxMDAwKSApIHtcblx0XHRcdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0Ly8gTnVtYmVyIG9mIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIC0gYWxsIGJldHMgYXJlIG9mZiwgbm8gcmVzdG9yZSBvZiBzZXR0aW5nc1xuXHRcdGlmICggcy5jb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoICE9PSBzLmNvbHVtbnMubGVuZ3RoICkge1xuXHRcdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcblx0XHRzZXR0aW5ncy5vTG9hZGVkU3RhdGUgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHMgKTtcblx0XG5cdFx0Ly8gUmVzdG9yZSBrZXkgZmVhdHVyZXMgLSB0b2RvIC0gZm9yIDEuMTEgdGhpcyBuZWVkcyB0byBiZSBkb25lIGJ5XG5cdFx0Ly8gc3Vic2NyaWJlZCBldmVudHNcblx0XHRpZiAoIHMuc3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICAgID0gcy5zdGFydDtcblx0XHRcdGlmKGFwaSA9PT0gbnVsbCkge1xuXHRcdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IHMuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggcy5sZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCAgID0gcy5sZW5ndGg7XG5cdFx0fVxuXHRcblx0XHQvLyBPcmRlclxuXHRcdGlmICggcy5vcmRlciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG5cdFx0XHQkLmVhY2goIHMub3JkZXIsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcucHVzaCggY29sWzBdID49IGNvbHVtbnMubGVuZ3RoID9cblx0XHRcdFx0XHRbIDAsIGNvbFsxXSBdIDpcblx0XHRcdFx0XHRjb2xcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdC8vIFNlYXJjaFxuXHRcdGlmICggcy5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIF9mblNlYXJjaFRvSHVuZyggcy5zZWFyY2ggKSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29sdW1uc1xuXHRcdGlmICggcy5jb2x1bW5zICkge1xuXHRcdFx0Zm9yICggaT0wLCBpZW49cy5jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR2YXIgY29sID0gcy5jb2x1bW5zW2ldO1xuXHRcblx0XHRcdFx0Ly8gVmlzaWJpbGl0eVxuXHRcdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGFwaSBpcyBkZWZpbmVkLCB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQgc28gd2UgbmVlZCB0byB1c2UgaXQgcmF0aGVyIHRoYW4gaW50ZXJuYWwgc2V0dGluZ3Ncblx0XHRcdFx0XHRpZiAoYXBpKSB7XG5cdFx0XHRcdFx0XHQvLyBEb24ndCByZWRyYXcgdGhlIGNvbHVtbnMgb24gZXZlcnkgaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCwgd2Ugd2lsbCBkbyB0aGlzIGF0IHRoZSBlbmQgaW5zdGVhZFxuXHRcdFx0XHRcdFx0YXBpLmNvbHVtbihpKS52aXNpYmxlKGNvbC52aXNpYmxlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29sdW1uc1tpXS5iVmlzaWJsZSA9IGNvbC52aXNpYmxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gU2VhcmNoXG5cdFx0XHRcdGlmICggY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0sIF9mblNlYXJjaFRvSHVuZyggY29sLnNlYXJjaCApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIGFwaSBpcyBkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBhZGp1c3QgdGhlIGNvbHVtbnMgb25jZSB0aGUgdmlzaWJpbGl0eSBoYXMgYmVlbiBjaGFuZ2VkXG5cdFx0XHRpZiAoYXBpKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsICdzdGF0ZUxvYWRlZCcsIFtzZXR0aW5ncywgc10gKTtcblx0XHRjYWxsYmFjaygpO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlXG5cdCAqICBAcGFyYW0ge25vZGV9IHRhYmxlIHRhYmxlIHdlIGFyZSB1c2luZyBhcyBhIGRhdGFUYWJsZVxuXHQgKiAgQHJldHVybnMge29iamVjdH0gU2V0dGluZ3Mgb2JqZWN0IC0gb3IgbnVsbCBpZiBub3QgZm91bmRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2V0dGluZ3NGcm9tTm9kZSAoIHRhYmxlIClcblx0e1xuXHRcdHZhciBzZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCB0YWJsZSwgX3BsdWNrKCBzZXR0aW5ncywgJ25UYWJsZScgKSApO1xuXHRcblx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/XG5cdFx0XHRzZXR0aW5nc1sgaWR4IF0gOlxuXHRcdFx0bnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBMb2cgYW4gZXJyb3IgbWVzc2FnZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gbGV2ZWwgbG9nIGVycm9yIG1lc3NhZ2VzLCBvciBkaXNwbGF5IHRoZW0gdG8gdGhlIHVzZXJcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBtc2cgZXJyb3IgbWVzc2FnZVxuXHQgKiAgQHBhcmFtIHtpbnR9IHRuIFRlY2huaWNhbCBub3RlIGlkIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTG9nKCBzZXR0aW5ncywgbGV2ZWwsIG1zZywgdG4gKVxuXHR7XG5cdFx0bXNnID0gJ0RhdGFUYWJsZXMgd2FybmluZzogJytcblx0XHRcdChzZXR0aW5ncyA/ICd0YWJsZSBpZD0nK3NldHRpbmdzLnNUYWJsZUlkKycgLSAnIDogJycpK21zZztcblx0XG5cdFx0aWYgKCB0biApIHtcblx0XHRcdG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcrXG5cdFx0XHQnaHR0cDovL2RhdGF0YWJsZXMubmV0L3RuLycrdG47XG5cdFx0fVxuXHRcblx0XHRpZiAoICEgbGV2ZWwgICkge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHJlIDEuMTBcblx0XHRcdHZhciBleHQgPSBEYXRhVGFibGUuZXh0O1xuXHRcdFx0dmFyIHR5cGUgPSBleHQuc0Vyck1vZGUgfHwgZXh0LmVyck1vZGU7XG5cdFxuXHRcdFx0aWYgKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2Vycm9yJywgWyBzZXR0aW5ncywgdG4sIG1zZyBdICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCB0eXBlID09ICdhbGVydCcgKSB7XG5cdFx0XHRcdGFsZXJ0KCBtc2cgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09ICd0aHJvdycgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHR5cGUoIHNldHRpbmdzLCB0biwgbXNnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyApIHtcblx0XHRcdGNvbnNvbGUubG9nKCBtc2cgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogU2VlIGlmIGEgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiBvbmUgb2JqZWN0LCBpZiBzbyBhc3NpZ24gaXQgdG8gdGhlIG90aGVyIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHJldCB0YXJnZXQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIHNvdXJjZSBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHByb3BlcnR5XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW21hcHBlZE5hbWVdIG5hbWUgdG8gbWFwIHRvbyAtIG9wdGlvbmFsLCBuYW1lIHVzZWQgaWYgbm90IGdpdmVuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbk1hcCggcmV0LCBzcmMsIG5hbWUsIG1hcHBlZE5hbWUgKVxuXHR7XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHQkLmVhY2goIG5hbWUsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWxbMF0sIHZhbFsxXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdF9mbk1hcCggcmV0LCBzcmMsIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBtYXBwZWROYW1lID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRtYXBwZWROYW1lID0gbmFtZTtcblx0XHR9XG5cdFxuXHRcdGlmICggc3JjW25hbWVdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXRbbWFwcGVkTmFtZV0gPSBzcmNbbmFtZV07XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEV4dGVuZCBvYmplY3RzIC0gdmVyeSBzaW1pbGFyIHRvIGpRdWVyeS5leHRlbmQsIGJ1dCBkZWVwIGNvcHkgb2JqZWN0cywgYW5kXG5cdCAqIHNoYWxsb3cgY29weSBhcnJheXMuIFRoZSByZWFzb24gd2UgbmVlZCB0byBkbyB0aGlzLCBpcyB0aGF0IHdlIGRvbid0IHdhbnQgdG9cblx0ICogZGVlcCBjb3B5IGFycmF5IGluaXQgdmFsdWVzIChzdWNoIGFzIGFhU29ydGluZykgc2luY2UgdGhlIGRldiB3b3VsZG4ndCBiZVxuXHQgKiBhYmxlIHRvIG92ZXJyaWRlIHRoZW0sIGJ1dCB3ZSBkbyB3YW50IHRvIGRlZXAgY29weSBhcnJheXMuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb3V0IE9iamVjdCB0byBleHRlbmRcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBleHRlbmRlciBPYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIGFwcGxpZWQgdG9cblx0ICogICAgICBvdXRcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtSZWZzIElmIHRydWUsIHRoZW4gYXJyYXlzIHdpbGwgYmUgc2xpY2VkIHRvIHRha2UgYW5cblx0ICogICAgICBpbmRlcGVuZGVudCBjb3B5IHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgYGRhdGFgIG9yIGBhYURhdGFgIHBhcmFtZXRlcnNcblx0ICogICAgICBpZiB0aGV5IGFyZSBwcmVzZW50LiBUaGlzIGlzIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNvbGxlY3Rpb24gdG9cblx0ICogICAgICBEYXRhVGFibGVzIGFuZCBoYXZlIHRoYXQgdXNlZCBhcyB5b3VyIGRhdGEgc291cmNlIHdpdGhvdXQgYnJlYWtpbmcgdGhlXG5cdCAqICAgICAgcmVmZXJlbmNlc1xuXHQgKiAgQHJldHVybnMge29iamVjdH0gb3V0IFJlZmVyZW5jZSwganVzdCBmb3IgY29udmVuaWVuY2UgLSBvdXQgPT09IHRoZSByZXR1cm4uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICogIEB0b2RvIFRoaXMgZG9lc24ndCB0YWtlIGFjY291bnQgb2YgYXJyYXlzIGluc2lkZSB0aGUgZGVlcCBjb3BpZWQgb2JqZWN0cy5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkV4dGVuZCggb3V0LCBleHRlbmRlciwgYnJlYWtSZWZzIClcblx0e1xuXHRcdHZhciB2YWw7XG5cdFxuXHRcdGZvciAoIHZhciBwcm9wIGluIGV4dGVuZGVyICkge1xuXHRcdFx0aWYgKCBleHRlbmRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSApIHtcblx0XHRcdFx0dmFsID0gZXh0ZW5kZXJbcHJvcF07XG5cdFxuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgKSB7XG5cdFx0XHRcdFx0aWYgKCAhICQuaXNQbGFpbk9iamVjdCggb3V0W3Byb3BdICkgKSB7XG5cdFx0XHRcdFx0XHRvdXRbcHJvcF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG91dFtwcm9wXSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgQXJyYXkuaXNBcnJheSh2YWwpICkge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHZhbC5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCaW5kIGFuIGV2ZW50IGhhbmRlcnMgdG8gYWxsb3cgYSBjbGljayBvciByZXR1cm4ga2V5IHRvIGFjdGl2YXRlIHRoZSBjYWxsYmFjay5cblx0ICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXG5cdCAqIHNhbWUgZWZmZWN0IGFzIGEgY2xpY2ssIGlmIHRoZSBlbGVtZW50IGhhcyBmb2N1cy5cblx0ICogIEBwYXJhbSB7ZWxlbWVudH0gbiBFbGVtZW50IHRvIGJpbmQgdGhlIGFjdGlvbiB0b1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9EYXRhIERhdGEgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CaW5kQWN0aW9uKCBuLCBvRGF0YSwgZm4gKVxuXHR7XG5cdFx0JChuKVxuXHRcdFx0Lm9uKCAnY2xpY2suRFQnLCBvRGF0YSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHQkKG4pLnRyaWdnZXIoJ2JsdXInKTsgLy8gUmVtb3ZlIGZvY3VzIG91dGxpbmUgZm9yIG1vdXNlIHVzZXJzXG5cdFx0XHRcdFx0Zm4oZSk7XG5cdFx0XHRcdH0gKVxuXHRcdFx0Lm9uKCAna2V5cHJlc3MuRFQnLCBvRGF0YSwgZnVuY3Rpb24gKGUpe1xuXHRcdFx0XHRcdGlmICggZS53aGljaCA9PT0gMTMgKSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRmbihlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKVxuXHRcdFx0Lm9uKCAnc2VsZWN0c3RhcnQuRFQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0LyogVGFrZSB0aGUgYnJ1dGFsIGFwcHJvYWNoIHRvIGNhbmNlbGxpbmcgdGV4dCBzZWxlY3Rpb24gKi9cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uLiBFYXNpbHkgYWxsb3dzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgYWRkZWQgdG9cblx0ICogYW4gYXJyYXkgc3RvcmUgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgY2FuIHRoZW4gYWxsIGJlIGNhbGxlZCB0b2dldGhlci5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU3RvcmUgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpbiBvU2V0dGluZ3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBiYWNrXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc05hbWUgSWRlbnRpZnlpbmcgbmFtZSBmb3IgdGhlIGNhbGxiYWNrIChpLmUuIGEgbGFiZWwpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsIHNTdG9yZSwgZm4sIHNOYW1lIClcblx0e1xuXHRcdGlmICggZm4gKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5nc1tzU3RvcmVdLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBmbixcblx0XHRcdFx0XCJzTmFtZVwiOiBzTmFtZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGaXJlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgdHJpZ2dlciBldmVudHMuIE5vdGUgdGhhdCB0aGUgbG9vcCBvdmVyIHRoZVxuXHQgKiBjYWxsYmFjayBhcnJheSBzdG9yZSBpcyBkb25lIGJhY2t3YXJkcyEgRnVydGhlciBub3RlIHRoYXQgeW91IGRvIG5vdCB3YW50IHRvXG5cdCAqIGZpcmUgb2ZmIHRyaWdnZXJzIGluIHRpbWUgc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyAoZm9yIGV4YW1wbGUgY2VsbCBjcmVhdGlvbilcblx0ICogYXMgaXRzIHNsb3cuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBjYWxsYmFja0FyciBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluXG5cdCAqICAgICAgb1NldHRpbmdzXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGpRdWVyeSBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlci4gSWZcblx0ICogICAgICBudWxsIG5vIHRyaWdnZXIgaXMgZmlyZWRcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIC9cblx0ICogICAgICB0cmlnZ2VyXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIGNhbGxiYWNrQXJyLCBldmVudE5hbWUsIGFyZ3MgKVxuXHR7XG5cdFx0dmFyIHJldCA9IFtdO1xuXHRcblx0XHRpZiAoIGNhbGxiYWNrQXJyICkge1xuXHRcdFx0cmV0ID0gJC5tYXAoIHNldHRpbmdzW2NhbGxiYWNrQXJyXS5zbGljZSgpLnJldmVyc2UoKSwgZnVuY3Rpb24gKHZhbCwgaSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLmZuLmFwcGx5KCBzZXR0aW5ncy5vSW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZXZlbnROYW1lICE9PSBudWxsICkge1xuXHRcdFx0dmFyIGUgPSAkLkV2ZW50KCBldmVudE5hbWUrJy5kdCcgKTtcblx0XG5cdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkudHJpZ2dlciggZSwgYXJncyApO1xuXHRcblx0XHRcdHJldC5wdXNoKCBlLnJlc3VsdCApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mbkxlbmd0aE92ZXJmbG93ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0ZW5kID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRsZW4gPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGg7XG5cdFxuXHRcdC8qIElmIHdlIGhhdmUgc3BhY2UgdG8gc2hvdyBleHRyYSByb3dzIChiYWNraW5nIHVwIGZyb20gdGhlIGVuZCBwb2ludCAtIHRoZW4gZG8gc28gKi9cblx0XHRpZiAoIHN0YXJ0ID49IGVuZCApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBlbmQgLSBsZW47XG5cdFx0fVxuXHRcblx0XHQvLyBLZWVwIHRoZSBzdGFydCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdHN0YXJ0IC09IChzdGFydCAlIGxlbik7XG5cdFxuXHRcdGlmICggbGVuID09PSAtMSB8fCBzdGFydCA8IDAgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5SZW5kZXJlciggc2V0dGluZ3MsIHR5cGUgKVxuXHR7XG5cdFx0dmFyIHJlbmRlcmVyID0gc2V0dGluZ3MucmVuZGVyZXI7XG5cdFx0dmFyIGhvc3QgPSBEYXRhVGFibGUuZXh0LnJlbmRlcmVyW3R5cGVdO1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVuZGVyZXIgKSAmJiByZW5kZXJlclt0eXBlXSApIHtcblx0XHRcdC8vIFNwZWNpZmljIHJlbmRlcmVyIGZvciB0aGlzIHR5cGUuIElmIGF2YWlsYWJsZSB1c2UgaXQsIG90aGVyd2lzZSB1c2Vcblx0XHRcdC8vIHRoZSBkZWZhdWx0LlxuXHRcdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiByZW5kZXJlciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHVzZSB0aGUgZGVmYXVsdFxuXHRcdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJdIHx8IGhvc3QuXztcblx0XHR9XG5cdFxuXHRcdC8vIFVzZSB0aGUgZGVmYXVsdFxuXHRcdHJldHVybiBob3N0Ll87XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZWN0IHRoZSBkYXRhIHNvdXJjZSBiZWluZyB1c2VkIGZvciB0aGUgdGFibGUuIFVzZWQgdG8gc2ltcGxpZnkgdGhlIGNvZGVcblx0ICogYSBsaXR0bGUgKGFqYXgpIGFuZCB0byBtYWtlIGl0IGNvbXByZXNzIGEgbGl0dGxlIHNtYWxsZXIuXG5cdCAqXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IERhdGEgc291cmNlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRhdGFTb3VyY2UgKCBzZXR0aW5ncyApXG5cdHtcblx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iU2VydmVyU2lkZSApIHtcblx0XHRcdHJldHVybiAnc3NwJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNldHRpbmdzLmFqYXggfHwgc2V0dGluZ3Muc0FqYXhTb3VyY2UgKSB7XG5cdFx0XHRyZXR1cm4gJ2FqYXgnO1xuXHRcdH1cblx0XHRyZXR1cm4gJ2RvbSc7XG5cdH1cblx0XG5cblx0XG5cdFxuXHQvKipcblx0ICogQ29tcHV0ZWQgc3RydWN0dXJlIG9mIHRoZSBEYXRhVGFibGVzIEFQSSwgZGVmaW5lZCBieSB0aGUgb3B0aW9ucyBwYXNzZWQgdG9cblx0ICogYERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoKWAgd2hlbiBidWlsZGluZyB0aGUgQVBJLlxuXHQgKlxuXHQgKiBUaGUgc3RydWN0dXJlIGlzIGJ1aWx0IGluIG9yZGVyIHRvIHNwZWVkIGNyZWF0aW9uIGFuZCBleHRlbnNpb24gb2YgdGhlIEFwaVxuXHQgKiBvYmplY3RzIHNpbmNlIHRoZSBleHRlbnNpb25zIGFyZSBlZmZlY3RpdmVseSBwcmUtcGFyc2VkLlxuXHQgKlxuXHQgKiBUaGUgYXJyYXkgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlLCB3aGVyZSB0aGlzXG5cdCAqIGJhc2UgYXJyYXkgcmVwcmVzZW50cyB0aGUgQXBpIHByb3RvdHlwZSBiYXNlOlxuXHQgKlxuXHQgKiAgICAgW1xuXHQgKiAgICAgICB7XG5cdCAqICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG5cdCAqICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcblx0ICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG5cdCAqICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcblx0ICogICAgICAgfSxcblx0ICogICAgICAge1xuXHQgKiAgICAgICAgIG5hbWU6ICAgICAncm93J1xuXHQgKiAgICAgICAgIHZhbDogICAgICAge30sXG5cdCAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQgKiAgICAgICAgIHByb3BFeHQ6ICAgW1xuXHQgKiAgICAgICAgICAge1xuXHQgKiAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuXHQgKiAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuXHQgKiAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG5cdCAqICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuXHQgKiAgICAgICAgICAgfSxcblx0ICogICAgICAgICAgIC4uLlxuXHQgKiAgICAgICAgIF1cblx0ICogICAgICAgfVxuXHQgKiAgICAgXVxuXHQgKlxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfX2FwaVN0cnVjdCA9IFtdO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBgQXJyYXkucHJvdG90eXBlYCByZWZlcmVuY2UuXG5cdCAqXG5cdCAqIEB0eXBlIG9iamVjdFxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX19hcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBBYnN0cmFjdGlvbiBmb3IgYGNvbnRleHRgIHBhcmFtZXRlciBvZiB0aGUgYEFwaWAgY29uc3RydWN0b3IgdG8gYWxsb3cgaXQgdG9cblx0ICogdGFrZSBzZXZlcmFsIGRpZmZlcmVudCBmb3JtcyBmb3IgZWFzZSBvZiB1c2UuXG5cdCAqXG5cdCAqIEVhY2ggb2YgdGhlIGlucHV0IHBhcmFtZXRlciB0eXBlcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIERhdGFUYWJsZXMgc2V0dGluZ3Ncblx0ICogb2JqZWN0IHdoZXJlIHBvc3NpYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd8bm9kZXxqUXVlcnl8b2JqZWN0fSBtaXhlZCBEYXRhVGFibGUgaWRlbnRpZmllci4gQ2FuIGJlIG9uZVxuXHQgKiAgIG9mOlxuXHQgKlxuXHQgKiAgICogYHN0cmluZ2AgLSBqUXVlcnkgc2VsZWN0b3IuIEFueSBEYXRhVGFibGVzJyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3Jcblx0ICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXG5cdCAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cblx0ICogICAqIGBqUXVlcnlgIC0gQSBqUXVlcnkgb2JqZWN0IG9mIGBUQUJMRWAgbm9kZXMuXG5cdCAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICAgKiBgRGF0YVRhYmxlcy5BcGlgIC0gQVBJIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge2FycmF5fG51bGx9IE1hdGNoaW5nIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy4gYG51bGxgIG9yXG5cdCAqICAgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgaWYgbm8gbWF0Y2hpbmcgRGF0YVRhYmxlIGlzIGZvdW5kLlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX3RvU2V0dGluZ3MgPSBmdW5jdGlvbiAoIG1peGVkIClcblx0e1xuXHRcdHZhciBpZHgsIGpxO1xuXHRcdHZhciBzZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0XHR2YXIgdGFibGVzID0gJC5tYXAoIHNldHRpbmdzLCBmdW5jdGlvbiAoZWwsIGkpIHtcblx0XHRcdHJldHVybiBlbC5uVGFibGU7XG5cdFx0fSApO1xuXHRcblx0XHRpZiAoICEgbWl4ZWQgKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtaXhlZC5uVGFibGUgJiYgbWl4ZWQub0FwaSApIHtcblx0XHRcdC8vIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRyZXR1cm4gWyBtaXhlZCBdO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQubm9kZU5hbWUgJiYgbWl4ZWQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYmxlJyApIHtcblx0XHRcdC8vIFRhYmxlIG5vZGVcblx0XHRcdGlkeCA9ICQuaW5BcnJheSggbWl4ZWQsIHRhYmxlcyApO1xuXHRcdFx0cmV0dXJuIGlkeCAhPT0gLTEgPyBbIHNldHRpbmdzW2lkeF0gXSA6IG51bGw7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtaXhlZCAmJiB0eXBlb2YgbWl4ZWQuc2V0dGluZ3MgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRyZXR1cm4gbWl4ZWQuc2V0dGluZ3MoKS50b0FycmF5KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbWl4ZWQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0Ly8galF1ZXJ5IHNlbGVjdG9yXG5cdFx0XHRqcSA9ICQobWl4ZWQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQgaW5zdGFuY2VvZiAkICkge1xuXHRcdFx0Ly8galF1ZXJ5IG9iamVjdCAoYWxzbyBEYXRhVGFibGVzIGluc3RhbmNlKVxuXHRcdFx0anEgPSBtaXhlZDtcblx0XHR9XG5cdFxuXHRcdGlmICgganEgKSB7XG5cdFx0XHRyZXR1cm4ganEubWFwKCBmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGlkeCA9ICQuaW5BcnJheSggdGhpcywgdGFibGVzICk7XG5cdFx0XHRcdHJldHVybiBpZHggIT09IC0xID8gc2V0dGluZ3NbaWR4XSA6IG51bGw7XG5cdFx0XHR9ICkudG9BcnJheSgpO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBBUEkgY2xhc3MgLSB1c2VkIHRvIGNvbnRyb2wgYW5kIGludGVyZmFjZSB3aXRoICBvbmUgb3IgbW9yZVxuXHQgKiBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcy5cblx0ICpcblx0ICogVGhlIEFQSSBjbGFzcyBpcyBoZWF2aWx5IGJhc2VkIG9uIGpRdWVyeSwgcHJlc2VudGluZyBhIGNoYWluYWJsZSBpbnRlcmZhY2Vcblx0ICogdGhhdCB5b3UgY2FuIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRhYmxlcy4gRWFjaCBpbnN0YW5jZSBvZiB0aGUgQVBJIGNsYXNzIGhhc1xuXHQgKiBhIFwiY29udGV4dFwiIC0gaS5lLiB0aGUgdGFibGVzIHRoYXQgaXQgd2lsbCBvcGVyYXRlIG9uLiBUaGlzIGNvdWxkIGJlIGEgc2luZ2xlXG5cdCAqIHRhYmxlLCBhbGwgdGFibGVzIG9uIGEgcGFnZSBvciBhIHN1Yi1zZXQgdGhlcmVvZi5cblx0ICpcblx0ICogQWRkaXRpb25hbGx5IHRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYWxsb3cgeW91IHRvIGVhc2lseSB3b3JrIHdpdGggdGhlIGRhdGEgaW5cblx0ICogdGhlIHRhYmxlcywgcmV0cmlldmluZyBhbmQgbWFuaXB1bGF0aW5nIGl0IGFzIHJlcXVpcmVkLiBUaGlzIGlzIGRvbmUgYnlcblx0ICogcHJlc2VudGluZyB0aGUgQVBJIGNsYXNzIGFzIGFuIGFycmF5IGxpa2UgaW50ZXJmYWNlLiBUaGUgY29udGVudHMgb2YgdGhlXG5cdCAqIGFycmF5IGRlcGVuZCB1cG9uIHRoZSBhY3Rpb25zIHJlcXVlc3RlZCBieSBlYWNoIG1ldGhvZCAoZm9yIGV4YW1wbGVcblx0ICogYHJvd3MoKS5ub2RlcygpYCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBub2Rlcywgd2hpbGUgYHJvd3MoKS5kYXRhKClgIHdpbGxcblx0ICogcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgYXJyYXlzIGRlcGVuZGluZyB1cG9uIHlvdXIgdGFibGUnc1xuXHQgKiBjb25maWd1cmF0aW9uKS4gVGhlIEFQSSBvYmplY3QgaGFzIGEgbnVtYmVyIG9mIGFycmF5IGxpa2UgbWV0aG9kcyAoYHB1c2hgLFxuXHQgKiBgcG9wYCwgYHJldmVyc2VgIGV0YykgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIChgZWFjaGAsIGBwbHVja2AsXG5cdCAqIGB1bmlxdWVgIGV0YykgdG8gYXNzaXN0IHlvdXIgd29ya2luZyB3aXRoIHRoZSBkYXRhIGhlbGQgaW4gYSB0YWJsZS5cblx0ICpcblx0ICogTW9zdCBtZXRob2RzICh0aG9zZSB3aGljaCByZXR1cm4gYW4gQXBpIGluc3RhbmNlKSBhcmUgY2hhaW5hYmxlLCB3aGljaCBtZWFuc1xuXHQgKiB0aGUgcmV0dXJuIGZyb20gYSBtZXRob2QgY2FsbCBhbHNvIGhhcyBhbGwgb2YgdGhlIG1ldGhvZHMgYXZhaWxhYmxlIHRoYXQgdGhlXG5cdCAqIHRvcCBsZXZlbCBvYmplY3QgaGFkLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvIGNhbGxzIGFyZSBlcXVpdmFsZW50OlxuXHQgKlxuXHQgKiAgICAgLy8gTm90IGNoYWluZWRcblx0ICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApO1xuXHQgKiAgICAgYXBpLmRyYXcoKTtcblx0ICpcblx0ICogICAgIC8vIENoYWluZWRcblx0ICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApLmRyYXcoKTtcblx0ICpcblx0ICogQGNsYXNzIERhdGFUYWJsZS5BcGlcblx0ICogQHBhcmFtIHthcnJheXxvYmplY3R8c3RyaW5nfGpRdWVyeX0gY29udGV4dCBEYXRhVGFibGUgaWRlbnRpZmllci4gVGhpcyBpc1xuXHQgKiAgIHVzZWQgdG8gZGVmaW5lIHdoaWNoIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzIHRoaXMgQVBJIHdpbGwgb3BlcmF0ZSBvbi5cblx0ICogICBDYW4gYmUgb25lIG9mOlxuXHQgKlxuXHQgKiAgICogYHN0cmluZ2AgLSBqUXVlcnkgc2VsZWN0b3IuIEFueSBEYXRhVGFibGVzJyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3Jcblx0ICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXG5cdCAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cblx0ICogICAqIGBqUXVlcnlgIC0gQSBqUXVlcnkgb2JqZWN0IG9mIGBUQUJMRWAgbm9kZXMuXG5cdCAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqIEBwYXJhbSB7YXJyYXl9IFtkYXRhXSBEYXRhIHRvIGluaXRpYWxpc2UgdGhlIEFwaSBpbnN0YW5jZSB3aXRoLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIERpcmVjdCBpbml0aWFsaXNhdGlvbiBkdXJpbmcgRGF0YVRhYmxlcyBjb25zdHJ1Y3Rpb25cblx0ICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5EYXRhVGFibGUoKTtcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBJbml0aWFsaXNhdGlvbiB1c2luZyBhIERhdGFUYWJsZXMgalF1ZXJ5IG9iamVjdFxuXHQgKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmFwaSgpO1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIEluaXRpYWxpc2F0aW9uIGFzIGEgY29uc3RydWN0b3Jcblx0ICogICB2YXIgYXBpID0gbmV3ICQuZm4uRGF0YVRhYmxlLkFwaSggJ3RhYmxlLmRhdGFUYWJsZScgKTtcblx0ICovXG5cdF9BcGkgPSBmdW5jdGlvbiAoIGNvbnRleHQsIGRhdGEgKVxuXHR7XG5cdFx0aWYgKCAhICh0aGlzIGluc3RhbmNlb2YgX0FwaSkgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIGNvbnRleHQsIGRhdGEgKTtcblx0XHR9XG5cdFxuXHRcdHZhciBzZXR0aW5ncyA9IFtdO1xuXHRcdHZhciBjdHhTZXR0aW5ncyA9IGZ1bmN0aW9uICggbyApIHtcblx0XHRcdHZhciBhID0gX3RvU2V0dGluZ3MoIG8gKTtcblx0XHRcdGlmICggYSApIHtcblx0XHRcdFx0c2V0dGluZ3MucHVzaC5hcHBseSggc2V0dGluZ3MsIGEgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGNvbnRleHQgKSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dFtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGN0eFNldHRpbmdzKCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcblx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdHRoaXMuY29udGV4dCA9IF91bmlxdWUoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIEluaXRpYWwgZGF0YVxuXHRcdGlmICggZGF0YSApIHtcblx0XHRcdCQubWVyZ2UoIHRoaXMsIGRhdGEgKTtcblx0XHR9XG5cdFxuXHRcdC8vIHNlbGVjdG9yXG5cdFx0dGhpcy5zZWxlY3RvciA9IHtcblx0XHRcdHJvd3M6IG51bGwsXG5cdFx0XHRjb2xzOiBudWxsLFxuXHRcdFx0b3B0czogbnVsbFxuXHRcdH07XG5cdFxuXHRcdF9BcGkuZXh0ZW5kKCB0aGlzLCB0aGlzLCBfX2FwaVN0cnVjdCApO1xuXHR9O1xuXHRcblx0RGF0YVRhYmxlLkFwaSA9IF9BcGk7XG5cdFxuXHQvLyBEb24ndCBkZXN0cm95IHRoZSBleGlzdGluZyBwcm90b3R5cGUsIGp1c3QgZXh0ZW5kIGl0LiBSZXF1aXJlZCBmb3IgalF1ZXJ5IDInc1xuXHQvLyBpc1BsYWluT2JqZWN0LlxuXHQkLmV4dGVuZCggX0FwaS5wcm90b3R5cGUsIHtcblx0XHRhbnk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY291bnQoKSAhPT0gMDtcblx0XHR9LFxuXHRcblx0XG5cdFx0Y29uY2F0OiAgX19hcnJheVByb3RvLmNvbmNhdCxcblx0XG5cdFxuXHRcdGNvbnRleHQ6IFtdLCAvLyBhcnJheSBvZiB0YWJsZSBzZXR0aW5ncyBvYmplY3RzXG5cdFxuXHRcblx0XHRjb3VudDogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGF0dGVuKCkubGVuZ3RoO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRlYWNoOiBmdW5jdGlvbiAoIGZuIClcblx0XHR7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbjsgaSsrICkge1xuXHRcdFx0XHRmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGVxOiBmdW5jdGlvbiAoIGlkeCApXG5cdFx0e1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XG5cdFx0XHRcdG5ldyBfQXBpKCBjdHhbaWR4XSwgdGhpc1tpZHhdICkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uICggZm4gKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFxuXHRcdFx0aWYgKCBfX2FycmF5UHJvdG8uZmlsdGVyICkge1xuXHRcdFx0XHRhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGksIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggdGhpc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGZsYXR0ZW46IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhLmNvbmNhdC5hcHBseSggYSwgdGhpcy50b0FycmF5KCkgKSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRqb2luOiAgICBfX2FycmF5UHJvdG8uam9pbixcblx0XG5cdFxuXHRcdGluZGV4T2Y6IF9fYXJyYXlQcm90by5pbmRleE9mIHx8IGZ1bmN0aW9uIChvYmosIHN0YXJ0KVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBpPShzdGFydCB8fCAwKSwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggdGhpc1tpXSA9PT0gb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSxcblx0XG5cdFx0aXRlcmF0b3I6IGZ1bmN0aW9uICggZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldyApIHtcblx0XHRcdHZhclxuXHRcdFx0XHRhID0gW10sIHJldCxcblx0XHRcdFx0aSwgaWVuLCBqLCBqZW4sXG5cdFx0XHRcdGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdHJvd3MsIGl0ZW1zLCBpdGVtLFxuXHRcdFx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cdFxuXHRcdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRcdGlmICggdHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRhbHdheXNOZXcgPSBmbjtcblx0XHRcdFx0Zm4gPSB0eXBlO1xuXHRcdFx0XHR0eXBlID0gZmxhdHRlbjtcblx0XHRcdFx0ZmxhdHRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHZhciBhcGlJbnN0ID0gbmV3IF9BcGkoIGNvbnRleHRbaV0gKTtcblx0XG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3RhYmxlJyApIHtcblx0XHRcdFx0XHRyZXQgPSBmbi5jYWxsKCBhcGlJbnN0LCBjb250ZXh0W2ldLCBpICk7XG5cdFxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2NvbHVtbnMnIHx8IHR5cGUgPT09ICdyb3dzJyApIHtcblx0XHRcdFx0XHQvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXG5cdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgdGhpc1tpXSwgaSApO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW4nIHx8IHR5cGUgPT09ICdjb2x1bW4tcm93cycgfHwgdHlwZSA9PT0gJ3JvdycgfHwgdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRcdC8vIGNvbHVtbnMgYW5kIHJvd3Mgc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlLlxuXHRcdFx0XHRcdC8vICd0aGlzJyBpcyBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyBmb3IgZWFjaCBjb250ZXh0XG5cdFx0XHRcdFx0aXRlbXMgPSB0aGlzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjb2x1bW4tcm93cycgKSB7XG5cdFx0XHRcdFx0XHRyb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBjb250ZXh0W2ldLCBzZWxlY3Rvci5vcHRzICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmb3IgKCBqPTAsIGplbj1pdGVtcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdGl0ZW0gPSBpdGVtc1tqXTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbS5yb3csIGl0ZW0uY29sdW1uLCBpLCBqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbSwgaSwgaiwgcm93cyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBhLmxlbmd0aCB8fCBhbHdheXNOZXcgKSB7XG5cdFx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggY29udGV4dCwgZmxhdHRlbiA/IGEuY29uY2F0LmFwcGx5KCBbXSwgYSApIDogYSApO1xuXHRcdFx0XHR2YXIgYXBpU2VsZWN0b3IgPSBhcGkuc2VsZWN0b3I7XG5cdFx0XHRcdGFwaVNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvci5yb3dzO1xuXHRcdFx0XHRhcGlTZWxlY3Rvci5jb2xzID0gc2VsZWN0b3IuY29scztcblx0XHRcdFx0YXBpU2VsZWN0b3Iub3B0cyA9IHNlbGVjdG9yLm9wdHM7XG5cdFx0XHRcdHJldHVybiBhcGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcblx0XG5cdFx0bGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0XHR7XG5cdFx0XHQvLyBCaXQgY2hlZWt5Li4uXG5cdFx0XHRyZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KCB0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0bGVuZ3RoOiAgMCxcblx0XG5cdFxuXHRcdG1hcDogZnVuY3Rpb24gKCBmbiApXG5cdFx0e1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0XHRpZiAoIF9fYXJyYXlQcm90by5tYXAgKSB7XG5cdFx0XHRcdGEgPSBfX2FycmF5UHJvdG8ubWFwLmNhbGwoIHRoaXMsIGZuLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcnMgd2l0aG91dCBFTUNBLTI1Mi01IChKUyAxLjYpXG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGEucHVzaCggZm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRwbHVjazogZnVuY3Rpb24gKCBwcm9wIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggZWwgKSB7XG5cdFx0XHRcdHJldHVybiBlbFsgcHJvcCBdO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cdFxuXHRcdHBvcDogICAgIF9fYXJyYXlQcm90by5wb3AsXG5cdFxuXHRcblx0XHRwdXNoOiAgICBfX2FycmF5UHJvdG8ucHVzaCxcblx0XG5cdFxuXHRcdC8vIERvZXMgbm90IHJldHVybiBhbiBBUEkgaW5zdGFuY2Vcblx0XHRyZWR1Y2U6IF9fYXJyYXlQcm90by5yZWR1Y2UgfHwgZnVuY3Rpb24gKCBmbiwgaW5pdCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblJlZHVjZSggdGhpcywgZm4sIGluaXQsIDAsIHRoaXMubGVuZ3RoLCAxICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHJlZHVjZVJpZ2h0OiBfX2FycmF5UHJvdG8ucmVkdWNlUmlnaHQgfHwgZnVuY3Rpb24gKCBmbiwgaW5pdCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblJlZHVjZSggdGhpcywgZm4sIGluaXQsIHRoaXMubGVuZ3RoLTEsIC0xLCAtMSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRyZXZlcnNlOiBfX2FycmF5UHJvdG8ucmV2ZXJzZSxcblx0XG5cdFxuXHRcdC8vIE9iamVjdCB3aXRoIHJvd3MsIGNvbHVtbnMgYW5kIG9wdHNcblx0XHRzZWxlY3RvcjogbnVsbCxcblx0XG5cdFxuXHRcdHNoaWZ0OiAgIF9fYXJyYXlQcm90by5zaGlmdCxcblx0XG5cdFxuXHRcdHNsaWNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRzb3J0OiAgICBfX2FycmF5UHJvdG8uc29ydCwgLy8gPyBuYW1lIC0gb3JkZXI/XG5cdFxuXHRcblx0XHRzcGxpY2U6ICBfX2FycmF5UHJvdG8uc3BsaWNlLFxuXHRcblx0XG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX19hcnJheVByb3RvLnNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dG8kOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiAkKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHRvSlF1ZXJ5OiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiAkKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHVuaXF1ZTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgX3VuaXF1ZSh0aGlzKSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR1bnNoaWZ0OiBfX2FycmF5UHJvdG8udW5zaGlmdFxuXHR9ICk7XG5cdFxuXHRcblx0X0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoIHNjb3BlLCBvYmosIGV4dCApXG5cdHtcblx0XHQvLyBPbmx5IGV4dGVuZCBBUEkgaW5zdGFuY2VzIGFuZCBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgQVBJXG5cdFx0aWYgKCAhIGV4dC5sZW5ndGggfHwgISBvYmogfHwgKCAhIChvYmogaW5zdGFuY2VvZiBfQXBpKSAmJiAhIG9iai5fX2R0X3dyYXBwZXIgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0aSwgaWVuLFxuXHRcdFx0c3RydWN0LFxuXHRcdFx0bWV0aG9kU2NvcGluZyA9IGZ1bmN0aW9uICggc2NvcGUsIGZuLCBzdHJ1YyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgcmV0ID0gZm4uYXBwbHkoIHNjb3BlLCBhcmd1bWVudHMgKTtcblx0XG5cdFx0XHRcdFx0Ly8gTWV0aG9kIGV4dGVuc2lvblxuXHRcdFx0XHRcdF9BcGkuZXh0ZW5kKCByZXQsIHJldCwgc3RydWMubWV0aG9kRXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPWV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHN0cnVjdCA9IGV4dFtpXTtcblx0XG5cdFx0XHQvLyBWYWx1ZVxuXHRcdFx0b2JqWyBzdHJ1Y3QubmFtZSBdID0gc3RydWN0LnR5cGUgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHRtZXRob2RTY29waW5nKCBzY29wZSwgc3RydWN0LnZhbCwgc3RydWN0ICkgOlxuXHRcdFx0XHRzdHJ1Y3QudHlwZSA9PT0gJ29iamVjdCcgP1xuXHRcdFx0XHRcdHt9IDpcblx0XHRcdFx0XHRzdHJ1Y3QudmFsO1xuXHRcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xuXHRcblx0XHRcdC8vIFByb3BlcnR5IGV4dGVuc2lvblxuXHRcdFx0X0FwaS5leHRlbmQoIHNjb3BlLCBvYmpbIHN0cnVjdC5uYW1lIF0sIHN0cnVjdC5wcm9wRXh0ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8vIEB0b2RvIC0gSXMgdGhlcmUgbmVlZCBmb3IgYW4gYXVnbWVudCBmdW5jdGlvbj9cblx0Ly8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcblx0Ly8ge1xuXHQvLyBcdC8vIEZpbmQgc3JjIG9iamVjdCBpbiB0aGUgc3RydWN0dXJlIGZyb20gdGhlIG5hbWVcblx0Ly8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFxuXHQvLyBcdF9BcGkuZXh0ZW5kKCBpbnN0LCBvYmogKTtcblx0Ly8gfTtcblx0XG5cdFxuXHQvLyAgICAgW1xuXHQvLyAgICAgICB7XG5cdC8vICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG5cdC8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcblx0Ly8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG5cdC8vICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcblx0Ly8gICAgICAgfSxcblx0Ly8gICAgICAge1xuXHQvLyAgICAgICAgIG5hbWU6ICAgICAncm93J1xuXHQvLyAgICAgICAgIHZhbDogICAgICAge30sXG5cdC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQvLyAgICAgICAgIHByb3BFeHQ6ICAgW1xuXHQvLyAgICAgICAgICAge1xuXHQvLyAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuXHQvLyAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuXHQvLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG5cdC8vICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuXHQvLyAgICAgICAgICAgfSxcblx0Ly8gICAgICAgICAgIC4uLlxuXHQvLyAgICAgICAgIF1cblx0Ly8gICAgICAgfVxuXHQvLyAgICAgXVxuXHRcblx0X0FwaS5yZWdpc3RlciA9IF9hcGlfcmVnaXN0ZXIgPSBmdW5jdGlvbiAoIG5hbWUsIHZhbCApXG5cdHtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1uYW1lLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRfQXBpLnJlZ2lzdGVyKCBuYW1lW2pdLCB2YWwgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0aSwgaWVuLFxuXHRcdFx0aGVpciA9IG5hbWUuc3BsaXQoJy4nKSxcblx0XHRcdHN0cnVjdCA9IF9fYXBpU3RydWN0LFxuXHRcdFx0a2V5LCBtZXRob2Q7XG5cdFxuXHRcdHZhciBmaW5kID0gZnVuY3Rpb24gKCBzcmMsIG5hbWUgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c3JjLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNyY1tpXS5uYW1lID09PSBuYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPWhlaXIubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRtZXRob2QgPSBoZWlyW2ldLmluZGV4T2YoJygpJykgIT09IC0xO1xuXHRcdFx0a2V5ID0gbWV0aG9kID9cblx0XHRcdFx0aGVpcltpXS5yZXBsYWNlKCcoKScsICcnKSA6XG5cdFx0XHRcdGhlaXJbaV07XG5cdFxuXHRcdFx0dmFyIHNyYyA9IGZpbmQoIHN0cnVjdCwga2V5ICk7XG5cdFx0XHRpZiAoICEgc3JjICkge1xuXHRcdFx0XHRzcmMgPSB7XG5cdFx0XHRcdFx0bmFtZTogICAgICBrZXksXG5cdFx0XHRcdFx0dmFsOiAgICAgICB7fSxcblx0XHRcdFx0XHRtZXRob2RFeHQ6IFtdLFxuXHRcdFx0XHRcdHByb3BFeHQ6ICAgW10sXG5cdFx0XHRcdFx0dHlwZTogICAgICAnb2JqZWN0J1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzdHJ1Y3QucHVzaCggc3JjICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBpID09PSBpZW4tMSApIHtcblx0XHRcdFx0c3JjLnZhbCA9IHZhbDtcblx0XHRcdFx0c3JjLnR5cGUgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0XHQnZnVuY3Rpb24nIDpcblx0XHRcdFx0XHQkLmlzUGxhaW5PYmplY3QoIHZhbCApID9cblx0XHRcdFx0XHRcdCdvYmplY3QnIDpcblx0XHRcdFx0XHRcdCdvdGhlcic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c3RydWN0ID0gbWV0aG9kID9cblx0XHRcdFx0XHRzcmMubWV0aG9kRXh0IDpcblx0XHRcdFx0XHRzcmMucHJvcEV4dDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRfQXBpLnJlZ2lzdGVyUGx1cmFsID0gX2FwaV9yZWdpc3RlclBsdXJhbCA9IGZ1bmN0aW9uICggcGx1cmFsTmFtZSwgc2luZ3VsYXJOYW1lLCB2YWwgKSB7XG5cdFx0X0FwaS5yZWdpc3RlciggcGx1cmFsTmFtZSwgdmFsICk7XG5cdFxuXHRcdF9BcGkucmVnaXN0ZXIoIHNpbmd1bGFyTmFtZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJldCA9IHZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0aWYgKCByZXQgPT09IHRoaXMgKSB7XG5cdFx0XHRcdC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByZXQgaW5zdGFuY2VvZiBfQXBpICkge1xuXHRcdFx0XHQvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRcdC8vIGluIHRoZSByZXR1cm5lZCBhcnJheSBmb3IgdGhlIHNpbmd1bGFyIHJlc3VsdC5cblx0XHRcdFx0cmV0dXJuIHJldC5sZW5ndGggP1xuXHRcdFx0XHRcdEFycmF5LmlzQXJyYXkoIHJldFswXSApID9cblx0XHRcdFx0XHRcdG5ldyBfQXBpKCByZXQuY29udGV4dCwgcmV0WzBdICkgOiAvLyBBcnJheSByZXN1bHRzIGFyZSAnZW5oYW5jZWQnXG5cdFx0XHRcdFx0XHRyZXRbMF0gOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBOb24tQVBJIHJldHVybiAtIGp1c3QgZmlyZSBpdCBiYWNrXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogU2VsZWN0b3IgZm9yIEhUTUwgdGFibGVzLiBBcHBseSB0aGUgZ2l2ZW4gc2VsZWN0b3IgdG8gdGhlIGdpdmUgYXJyYXkgb2Zcblx0ICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcgb3IgaW50ZWdlclxuXHQgKiBAcGFyYW0gIHthcnJheX0gQXJyYXkgb2YgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzIHRvIGJlIGZpbHRlcmVkXG5cdCAqIEByZXR1cm4ge2FycmF5fVxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX190YWJsZV9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIGEgKVxuXHR7XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KHNlbGVjdG9yKSApIHtcblx0XHRcdHJldHVybiAkLm1hcCggc2VsZWN0b3IsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBfX3RhYmxlX3NlbGVjdG9yKGl0ZW0sIGEpO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gSW50ZWdlciBpcyB1c2VkIHRvIHBpY2sgb3V0IGEgdGFibGUgYnkgaW5kZXhcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRyZXR1cm4gWyBhWyBzZWxlY3RvciBdIF07XG5cdFx0fVxuXHRcblx0XHQvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xuXHRcdHZhciBub2RlcyA9ICQubWFwKCBhLCBmdW5jdGlvbiAoZWwsIGkpIHtcblx0XHRcdHJldHVybiBlbC5uVGFibGU7XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gJChub2Rlcylcblx0XHRcdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHRcdC5tYXAoIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdC8vIE5lZWQgdG8gdHJhbnNsYXRlIGJhY2sgZnJvbSB0aGUgdGFibGUgbm9kZSB0byB0aGUgc2V0dGluZ3Ncblx0XHRcdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggdGhpcywgbm9kZXMgKTtcblx0XHRcdFx0cmV0dXJuIGFbIGlkeCBdO1xuXHRcdFx0fSApXG5cdFx0XHQudG9BcnJheSgpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogQ29udGV4dCBzZWxlY3RvciBmb3IgdGhlIEFQSSdzIGNvbnRleHQgKGkuZS4gdGhlIHRhYmxlcyB0aGUgQVBJIGluc3RhbmNlXG5cdCAqIHJlZmVycyB0by5cblx0ICpcblx0ICogQG5hbWUgICAgRGF0YVRhYmxlLkFwaSN0YWJsZXNcblx0ICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW3NlbGVjdG9yXSBTZWxlY3RvciB0byBwaWNrIHdoaWNoIHRhYmxlcyB0aGUgaXRlcmF0b3Jcblx0ICogICBzaG91bGQgb3BlcmF0ZSBvbi4gSWYgbm90IGdpdmVuLCBhbGwgdGFibGVzIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYXJlXG5cdCAqICAgdXNlZC4gVGhpcyBjYW4gYmUgZ2l2ZW4gYXMgYSBqUXVlcnkgc2VsZWN0b3IgKGZvciBleGFtcGxlIGAnOmd0KDApJ2ApIHRvXG5cdCAqICAgc2VsZWN0IG11bHRpcGxlIHRhYmxlcyBvciBhcyBhbiBpbnRlZ2VyIHRvIHNlbGVjdCBhIHNpbmdsZSB0YWJsZS5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZS5BcGl9IFJldHVybnMgYSBuZXcgQVBJIGluc3RhbmNlIGlmIGEgc2VsZWN0b3IgaXMgZ2l2ZW4uXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAndGFibGVzKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuXHRcdC8vIEEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQgaWYgdGhlcmUgd2FzIGEgc2VsZWN0b3Igc3BlY2lmaWVkXG5cdFx0cmV0dXJuIHNlbGVjdG9yICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0b3IgIT09IG51bGwgP1xuXHRcdFx0bmV3IF9BcGkoIF9fdGFibGVfc2VsZWN0b3IoIHNlbGVjdG9yLCB0aGlzLmNvbnRleHQgKSApIDpcblx0XHRcdHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAndGFibGUoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHRhYmxlcyA9IHRoaXMudGFibGVzKCBzZWxlY3RvciApO1xuXHRcdHZhciBjdHggPSB0YWJsZXMuY29udGV4dDtcblx0XG5cdFx0Ly8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IG1hdGNoZWQgdGFibGVcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/XG5cdFx0XHRuZXcgX0FwaSggY3R4WzBdICkgOlxuXHRcdFx0dGFibGVzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLm5vZGVzKCknLCAndGFibGUoKS5ub2RlKCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRhYmxlO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ib2R5KCknLCAndGFibGUoKS5ib2R5KCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRCb2R5O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5oZWFkZXIoKScsICd0YWJsZSgpLmhlYWRlcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5USGVhZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuZm9vdGVyKCknLCAndGFibGUoKS5mb290ZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVEZvb3Q7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UYWJsZVdyYXBwZXI7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2RyYXcoKScsIGZ1bmN0aW9uICggcGFnaW5nICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCBwYWdpbmcgPT09ICdwYWdlJyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwYWdpbmcgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHBhZ2luZyA9IHBhZ2luZyA9PT0gJ2Z1bGwtaG9sZCcgP1xuXHRcdFx0XHRcdFx0ZmFsc2UgOlxuXHRcdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgcGFnaW5nPT09ZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBwYWdlIGluZGV4LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQpXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBhdHRlbXB0IHRvIHNob3cgYSBwYWdlIHdoaWNoIGRvZXMgbm90IGV4aXN0LCBEYXRhVGFibGVzIHdpbGxcblx0ICogbm90IHRocm93IGFuIGVycm9yLCBidXQgcmF0aGVyIHJlc2V0IHRoZSBwYWdpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcnxzdHJpbmd9IGFjdGlvbiBUaGUgcGFnaW5nIGFjdGlvbiB0byB0YWtlLiBUaGlzIGNhbiBiZSBvbmUgb2Y6XG5cdCAqICAqIGBpbnRlZ2VyYCAtIFRoZSBwYWdlIGluZGV4IHRvIGp1bXAgdG9cblx0ICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcblx0ICogICAgKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlLlxuXHQgKiAgICAqIGBuZXh0YCAtIEp1bXAgdG8gdGhlIG5leHQgcGFnZVxuXHQgKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2Vcblx0ICogICAgKiBgbGFzdGAgLSBKdW1wIHRvIHRoZSBsYXN0IHBhZ2UuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UoKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWdlLmluZm8oKS5wYWdlOyAvLyBub3QgYW4gZXhwZW5zaXZlIGNhbGxcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGFjdGlvbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQYWdpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBJZiB5b3UgcmVxdWlyZSBwYWdpbmcgaW5mb3JtYXRpb24gZm9yIGFub3RoZXIgdGFibGUsIHVzZSB0aGUgYHRhYmxlKClgIG1ldGhvZFxuXHQgKiB3aXRoIGEgc3VpdGFibGUgc2VsZWN0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHNldDpcblx0ICogICogYHBhZ2VgIC0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkIC0gaS5lLiB0aGUgZmlyc3QgcGFnZSBpcyBgMGApXG5cdCAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcblx0ICogICogYHN0YXJ0YCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBmaXJzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuXHQgKiAgKiBgZW5kYCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBsYXN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXG5cdCAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcblx0ICogICAgKyBsZW5ndGggPSBlbmRgLCBidXQgdGhpcyBpcyBub3QgYWx3YXlzIHRydWUsIGZvciBleGFtcGxlIGlmIHRoZXJlIGFyZVxuXHQgKiAgICBvbmx5IDIgcmVjb3JkcyB0byBzaG93IG9uIHRoZSBmaW5hbCBwYWdlLCB3aXRoIGEgbGVuZ3RoIG9mIDEwLlxuXHQgKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXG5cdCAqICAqIGByZWNvcmRzRGlzcGxheWAgLSBEYXRhIHNldCBsZW5ndGggb25jZSB0aGUgY3VycmVudCBmaWx0ZXJpbmcgY3JpdGVyaW9uXG5cdCAqICAgIGFyZSBhcHBsaWVkLlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UuaW5mbygpJywgZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdFx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0c2V0dGluZ3MgICA9IHRoaXMuY29udGV4dFswXSxcblx0XHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlID8gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDogLTEsXG5cdFx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRcInBhZ2VcIjogICAgICAgICAgIGFsbCA/IDAgOiBNYXRoLmZsb29yKCBzdGFydCAvIGxlbiApLFxuXHRcdFx0XCJwYWdlc1wiOiAgICAgICAgICBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XHRcInN0YXJ0XCI6ICAgICAgICAgIHN0YXJ0LFxuXHRcdFx0XCJlbmRcIjogICAgICAgICAgICBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcdFwibGVuZ3RoXCI6ICAgICAgICAgbGVuLFxuXHRcdFx0XCJyZWNvcmRzVG90YWxcIjogICBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdFx0XCJyZWNvcmRzRGlzcGxheVwiOiB2aXNSZWNvcmRzLFxuXHRcdFx0XCJzZXJ2ZXJTaWRlXCI6ICAgICBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09PSAnc3NwJ1xuXHRcdH07XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgbGVuZ3RoLiBOb3RlIGAtMWAgaW5kaWNhdGVzIHRoYXQgYWxsIHJlY29yZHNcblx0ICogICBhcmUgdG8gYmUgc2hvd24uXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gUGFnZSBsZW5ndGggdG8gc2V0LiBVc2UgYC0xYCB0byBzaG93IGFsbCByZWNvcmRzLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlLmxlbigpJywgZnVuY3Rpb24gKCBsZW4gKSB7XG5cdFx0Ly8gTm90ZSB0aGF0IHdlIGNhbid0IGNhbGwgdGhpcyBmdW5jdGlvbiAnbGVuZ3RoKCknIGJlY2F1c2UgYGxlbmd0aGBcblx0XHQvLyBpcyBhIEphdmFzY3JpcHQgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHdoaWNoIGRlZmluZXMgaG93IG1hbnkgYXJndW1lbnRzXG5cdFx0Ly8gdGhlIGZ1bmN0aW9uIGV4cGVjdHMuXG5cdFx0aWYgKCBsZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0dGhpcy5jb250ZXh0WzBdLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UsIHNldCB0aGUgcGFnZSBsZW5ndGhcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkxlbmd0aENoYW5nZSggc2V0dGluZ3MsIGxlbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19yZWxvYWQgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBob2xkUG9zaXRpb24sIGNhbGxiYWNrICkge1xuXHRcdC8vIFVzZSB0aGUgZHJhdyBldmVudCB0byB0cmlnZ2VyIGEgY2FsbGJhY2tcblx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdGFwaS5vbmUoICdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjYWxsYmFjayggYXBpLmFqYXguanNvbigpICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT0gJ3NzcCcgKSB7XG5cdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHQvLyBDYW5jZWwgYW4gZXhpc3RpbmcgcmVxdWVzdFxuXHRcdFx0dmFyIHhociA9IHNldHRpbmdzLmpxWEhSO1xuXHRcdFx0aWYgKCB4aHIgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQgKSB7XG5cdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFRyaWdnZXIgeGhyXG5cdFx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCBbXSwgZnVuY3Rpb24oIGpzb24gKSB7XG5cdFx0XHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIGxhc3QgQWpheCByZXF1ZXN0IHRoYXQgRGF0YVRhYmxlcyBtYWRlIHRvIHRoZVxuXHQgKiBzZXJ2ZXIuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIEpTT04gZnJvbSB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnRcblx0ICogY29udGV4dC5cblx0ICpcblx0ICogQHJldHVybiB7b2JqZWN0fSBKU09OIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4Lmpzb24oKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGN0eFswXS5qc29uO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBzdWJtaXR0ZWQgaW4gdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5wYXJhbXMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGN0eFswXS5vQWpheERhdGE7XG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmUtZHJhdyB0aGUgdGFibGUgd2hlbiB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcblx0ICogICBwb3NpdGlvbi4gQSBmdWxsIHJlLXNvcnQgYW5kIHJlLWZpbHRlciBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIG1ldGhvZCBpc1xuXHQgKiAgIGNhbGxlZCwgd2hpY2ggaXMgd2h5IHRoZSBwYWdpbmF0aW9uIHJlc2V0IGlzIHRoZSBkZWZhdWx0IGFjdGlvbi5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5yZWxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHRcdF9fcmVsb2FkKCBzZXR0aW5ncywgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3Rcblx0ICogdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcblx0ICogY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCknLCBmdW5jdGlvbiAoIHVybCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRpZiAoIGN0eC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRjdHggPSBjdHhbMF07XG5cdFxuXHRcdFx0cmV0dXJuIGN0eC5hamF4ID9cblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCBjdHguYWpheCApID9cblx0XHRcdFx0XHRjdHguYWpheC51cmwgOlxuXHRcdFx0XHRcdGN0eC5hamF4IDpcblx0XHRcdFx0Y3R4LnNBamF4U291cmNlO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggc2V0dGluZ3MuYWpheCApICkge1xuXHRcdFx0XHRzZXR0aW5ncy5hamF4LnVybCA9IHVybDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZXR0aW5ncy5hamF4ID0gdXJsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm8gbmVlZCB0byBjb25zaWRlciBzQWpheFNvdXJjZSBoZXJlIHNpbmNlIERhdGFUYWJsZXMgZ2l2ZXMgcHJpb3JpdHlcblx0XHRcdC8vIHRvIGBhamF4YCBvdmVyIGBzQWpheFNvdXJjZWAuIFNvIHNldHRpbmcgYGFqYXhgIGhlcmUsIHJlbmRlcnMgYW55XG5cdFx0XHQvLyB2YWx1ZSBvZiBgc0FqYXhTb3VyY2VgIHJlZHVuZGFudC5cblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcblx0ICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXG5cdCAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyBgYWpheC5yZWxvYWQoKWAgYnV0IGlzIHByb3ZpZGVkIGZvclxuXHQgKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCkubG9hZCgpJywgZnVuY3Rpb24gKCBjYWxsYmFjaywgcmVzZXRQYWdpbmcgKSB7XG5cdFx0Ly8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcblx0XHQvLyB1cmwgY2hhbmdlXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0X19yZWxvYWQoIGN0eCwgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0XG5cdHZhciBfc2VsZWN0b3JfcnVuID0gZnVuY3Rpb24gKCB0eXBlLCBzZWxlY3Rvciwgc2VsZWN0Rm4sIHNldHRpbmdzLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0b3V0ID0gW10sIHJlcyxcblx0XHRcdGEsIGksIGllbiwgaiwgamVuLFxuXHRcdFx0c2VsZWN0b3JUeXBlID0gdHlwZW9mIHNlbGVjdG9yO1xuXHRcblx0XHQvLyBDYW4ndCBqdXN0IGNoZWNrIGZvciBpc0FycmF5IGhlcmUsIGFzIGFuIEFQSSBvciBqUXVlcnkgaW5zdGFuY2UgbWlnaHQgYmVcblx0XHQvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xuXHRcdGlmICggISBzZWxlY3RvciB8fCBzZWxlY3RvclR5cGUgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBzZWxlY3Rvci5sZW5ndGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gWyBzZWxlY3RvciBdO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpZW49c2VsZWN0b3IubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHQvLyBPbmx5IHNwbGl0IG9uIHNpbXBsZSBzdHJpbmdzIC0gY29tcGxleCBleHByZXNzaW9ucyB3aWxsIGJlIGpRdWVyeSBzZWxlY3RvcnNcblx0XHRcdGEgPSBzZWxlY3RvcltpXSAmJiBzZWxlY3RvcltpXS5zcGxpdCAmJiAhIHNlbGVjdG9yW2ldLm1hdGNoKC9bXFxbXFwoOl0vKSA/XG5cdFx0XHRcdHNlbGVjdG9yW2ldLnNwbGl0KCcsJykgOlxuXHRcdFx0XHRbIHNlbGVjdG9yW2ldIF07XG5cdFxuXHRcdFx0Zm9yICggaj0wLCBqZW49YS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cmVzID0gc2VsZWN0Rm4oIHR5cGVvZiBhW2pdID09PSAnc3RyaW5nJyA/IChhW2pdKS50cmltKCkgOiBhW2pdICk7XG5cdFxuXHRcdFx0XHRpZiAoIHJlcyAmJiByZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdG91dCA9IG91dC5jb25jYXQoIHJlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBzZWxlY3RvciBleHRlbnNpb25zXG5cdFx0dmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbIHR5cGUgXTtcblx0XHRpZiAoIGV4dC5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdG91dCA9IGV4dFtpXSggc2V0dGluZ3MsIG9wdHMsIG91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIF91bmlxdWUoIG91dCApO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3Jfb3B0cyA9IGZ1bmN0aW9uICggb3B0cyApXG5cdHtcblx0XHRpZiAoICEgb3B0cyApIHtcblx0XHRcdG9wdHMgPSB7fTtcblx0XHR9XG5cdFxuXHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciAxLjktIHdoaWNoIHVzZWQgdGhlIHRlcm1pbm9sb2d5IGZpbHRlciByYXRoZXJcblx0XHQvLyB0aGFuIHNlYXJjaFxuXHRcdGlmICggb3B0cy5maWx0ZXIgJiYgb3B0cy5zZWFyY2ggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9wdHMuc2VhcmNoID0gb3B0cy5maWx0ZXI7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gJC5leHRlbmQoIHtcblx0XHRcdHNlYXJjaDogJ25vbmUnLFxuXHRcdFx0b3JkZXI6ICdjdXJyZW50Jyxcblx0XHRcdHBhZ2U6ICdhbGwnXG5cdFx0fSwgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3JfZmlyc3QgPSBmdW5jdGlvbiAoIGluc3QgKVxuXHR7XG5cdFx0Ly8gUmVkdWNlIHRoZSBBUEkgaW5zdGFuY2UgdG8gdGhlIGZpcnN0IGl0ZW0gZm91bmRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49aW5zdC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggaW5zdFtpXS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHQvLyBBc3NpZ24gdGhlIGZpcnN0IGVsZW1lbnQgdG8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGluc3RhbmNlXG5cdFx0XHRcdC8vIGFuZCB0cnVuY2F0ZSB0aGUgaW5zdGFuY2UgYW5kIGNvbnRleHRcblx0XHRcdFx0aW5zdFswXSA9IGluc3RbaV07XG5cdFx0XHRcdGluc3RbMF0ubGVuZ3RoID0gMTtcblx0XHRcdFx0aW5zdC5sZW5ndGggPSAxO1xuXHRcdFx0XHRpbnN0LmNvbnRleHQgPSBbIGluc3QuY29udGV4dFtpXSBdO1xuXHRcblx0XHRcdFx0cmV0dXJuIGluc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBOb3QgZm91bmQgLSByZXR1cm4gYW4gZW1wdHkgaW5zdGFuY2Vcblx0XHRpbnN0Lmxlbmd0aCA9IDA7XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sIHRtcCwgYT1bXSxcblx0XHRcdGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcblx0XHRcdGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdFxuXHRcdHZhclxuXHRcdFx0c2VhcmNoID0gb3B0cy5zZWFyY2gsICAvLyBub25lLCBhcHBsaWVkLCByZW1vdmVkXG5cdFx0XHRvcmRlciAgPSBvcHRzLm9yZGVyLCAgIC8vIGFwcGxpZWQsIGN1cnJlbnQsIGluZGV4IChvcmlnaW5hbCAtIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkpXG5cdFx0XHRwYWdlICAgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxuXHRcblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT0gJ3NzcCcgKSB7XG5cdFx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG1vZGUsIG1vc3Qgb3B0aW9ucyBhcmUgaXJyZWxldmFudCBzaW5jZVxuXHRcdFx0Ly8gcm93cyBub3Qgc2hvd24gZG9uJ3QgZXhpc3QgYW5kIHRoZSBpbmRleCBvcmRlciBpcyB0aGUgYXBwbGllZCBvcmRlclxuXHRcdFx0Ly8gUmVtb3ZlZCBpcyBhIHNwZWNpYWwgY2FzZSAtIGZvciBjb25zaXN0ZW5jeSBqdXN0IHJldHVybiBhbiBlbXB0eVxuXHRcdFx0Ly8gYXJyYXlcblx0XHRcdHJldHVybiBzZWFyY2ggPT09ICdyZW1vdmVkJyA/XG5cdFx0XHRcdFtdIDpcblx0XHRcdFx0X3JhbmdlKCAwLCBkaXNwbGF5TWFzdGVyLmxlbmd0aCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA9PSAnY3VycmVudCcgKSB7XG5cdFx0XHQvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpbHRlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xuXHRcdFx0Ly8gZmFpcmx5IHNlbnNlbGVzcyBvdGhlcndpc2UsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBvcmRlciBhbmQgc2VhcmNoIGFjdHVhbGx5XG5cdFx0XHQvLyBhcmVcblx0XHRcdGZvciAoIGk9c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsIGllbj1zZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRhLnB1c2goIGRpc3BsYXlGaWx0ZXJlZFtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggb3JkZXIgPT0gJ2N1cnJlbnQnIHx8IG9yZGVyID09ICdhcHBsaWVkJyApIHtcblx0XHRcdGlmICggc2VhcmNoID09ICdub25lJykge1xuXHRcdFx0XHRhID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlYXJjaCA9PSAnYXBwbGllZCcgKSB7XG5cdFx0XHRcdGEgPSBkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWFyY2ggPT0gJ3JlbW92ZWQnICkge1xuXHRcdFx0XHQvLyBPKG4rbSkgc29sdXRpb24gYnkgY3JlYXRpbmcgYSBoYXNoIG1hcFxuXHRcdFx0XHR2YXIgZGlzcGxheUZpbHRlcmVkTWFwID0ge307XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGlzcGxheUZpbHRlcmVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGRpc3BsYXlGaWx0ZXJlZE1hcFtkaXNwbGF5RmlsdGVyZWRbaV1dID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YSA9ICQubWFwKCBkaXNwbGF5TWFzdGVyLCBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0XHRyZXR1cm4gISBkaXNwbGF5RmlsdGVyZWRNYXAuaGFzT3duUHJvcGVydHkoZWwpID9cblx0XHRcdFx0XHRcdGVsIDpcblx0XHRcdFx0XHRcdG51bGw7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyID09ICdpbmRleCcgfHwgb3JkZXIgPT0gJ29yaWdpbmFsJyApIHtcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzZWFyY2ggPT0gJ25vbmUnICkge1xuXHRcdFx0XHRcdGEucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyAvLyBhcHBsaWVkIHwgcmVtb3ZlZFxuXHRcdFx0XHRcdHRtcCA9ICQuaW5BcnJheSggaSwgZGlzcGxheUZpbHRlcmVkICk7XG5cdFxuXHRcdFx0XHRcdGlmICgodG1wID09PSAtMSAmJiBzZWFyY2ggPT0gJ3JlbW92ZWQnKSB8fFxuXHRcdFx0XHRcdFx0KHRtcCA+PSAwICAgJiYgc2VhcmNoID09ICdhcHBsaWVkJykgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGEucHVzaCggaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGE7XG5cdH07XG5cdFxuXHRcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIFJvd3Ncblx0ICpcblx0ICoge30gICAgICAgICAgLSBubyBzZWxlY3RvciAtIHVzZSBhbGwgYXZhaWxhYmxlIHJvd3Ncblx0ICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XG5cdCAqIHtub2RlfSAgICAgIC0gVFIgbm9kZVxuXHQgKiB7c3RyaW5nfSAgICAtIGpRdWVyeSBzZWxlY3RvciB0byBhcHBseSB0byB0aGUgVFIgZWxlbWVudHNcblx0ICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xuXHQgKlxuXHQgKi9cblx0dmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxuXHR7XG5cdFx0dmFyIHJvd3M7XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggc2VsICkge1xuXHRcdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHNlbCApO1xuXHRcdFx0dmFyIGksIGllbjtcblx0XHRcdHZhciBhb0RhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFxuXHRcdFx0Ly8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcblx0XHRcdC8vIGFsbCByZWNvcmRzLCBzbyBubyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbmRleCBpcyBpbiB0aGVyZSwgc2luY2UgaXRcblx0XHRcdC8vIG11c3QgYmUgLSBkZXYgZXJyb3IgaWYgdGhlIGluZGV4IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgISBvcHRzICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoICEgcm93cyApIHtcblx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCAmJiAkLmluQXJyYXkoIHNlbEludCwgcm93cyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBpbnRlZ2VyXG5cdFx0XHRcdHJldHVybiBbIHNlbEludCBdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHVuZGVmaW5lZCB8fCBzZWwgPT09ICcnICkge1xuXHRcdFx0XHQvLyBTZWxlY3RvciAtIG5vbmVcblx0XHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBmdW5jdGlvblxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gJC5tYXAoIHJvd3MsIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHR2YXIgcm93ID0gYW9EYXRhWyBpZHggXTtcblx0XHRcdFx0XHRyZXR1cm4gc2VsKCBpZHgsIHJvdy5fYURhdGEsIHJvdy5uVHIgKSA/IGlkeCA6IG51bGw7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIG5vZGVcblx0XHRcdGlmICggc2VsLm5vZGVOYW1lICkge1xuXHRcdFx0XHR2YXIgcm93SWR4ID0gc2VsLl9EVF9Sb3dJbmRleDsgIC8vIFByb3BlcnR5IGFkZGVkIGJ5IERUIGZvciBmYXN0IGxvb2t1cFxuXHRcdFx0XHR2YXIgY2VsbElkeCA9IHNlbC5fRFRfQ2VsbEluZGV4O1xuXHRcblx0XHRcdFx0aWYgKCByb3dJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcm93IGlzIGFjdHVhbGx5IHN0aWxsIHByZXNlbnQgaW4gdGhlIHRhYmxlXG5cdFx0XHRcdFx0cmV0dXJuIGFvRGF0YVsgcm93SWR4IF0gJiYgYW9EYXRhWyByb3dJZHggXS5uVHIgPT09IHNlbCA/XG5cdFx0XHRcdFx0XHRbIHJvd0lkeCBdIDpcblx0XHRcdFx0XHRcdFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBjZWxsSWR4ICkge1xuXHRcdFx0XHRcdHJldHVybiBhb0RhdGFbIGNlbGxJZHgucm93IF0gJiYgYW9EYXRhWyBjZWxsSWR4LnJvdyBdLm5UciA9PT0gc2VsLnBhcmVudE5vZGUgP1xuXHRcdFx0XHRcdFx0WyBjZWxsSWR4LnJvdyBdIDpcblx0XHRcdFx0XHRcdFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBob3N0ID0gJChzZWwpLmNsb3Nlc3QoJypbZGF0YS1kdC1yb3ddJyk7XG5cdFx0XHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0XHRcdFsgaG9zdC5kYXRhKCdkdC1yb3cnKSBdIDpcblx0XHRcdFx0XHRcdFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSUQgc2VsZWN0b3IuIFdhbnQgdG8gYWx3YXlzIGJlIGFibGUgdG8gc2VsZWN0IHJvd3MgYnkgaWQsIHJlZ2FyZGxlc3Ncblx0XHRcdC8vIG9mIGlmIHRoZSB0ciBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3Igbm90LCBzbyBjYW4ndCByZWx5IHVwb25cblx0XHRcdC8vIGpRdWVyeSBoZXJlIC0gaGVuY2UgYSBjdXN0b20gaW1wbGVtZW50YXRpb24uIFRoaXMgZG9lcyBub3QgbWF0Y2hcblx0XHRcdC8vIFNpenpsZSdzIGZhc3Qgc2VsZWN0b3Igb3IgSFRNTDQgLSBpbiBIVE1MNSB0aGUgSUQgY2FuIGJlIGFueXRoaW5nLFxuXHRcdFx0Ly8gYnV0IHRvIHNlbGVjdCBpdCB1c2luZyBhIENTUyBzZWxlY3RvciBlbmdpbmUgKGxpa2UgU2l6emxlIG9yXG5cdFx0XHQvLyBxdWVyeVNlbGVjdCkgaXQgd291bGQgbmVlZCB0byBuZWVkIHRvIGJlIGVzY2FwZWQgZm9yIHNvbWUgY2hhcmFjdGVycy5cblx0XHRcdC8vIERhdGFUYWJsZXMgc2ltcGxpZmllcyB0aGlzIGZvciByb3cgc2VsZWN0b3JzIHNpbmNlIHlvdSBjYW4gc2VsZWN0XG5cdFx0XHQvLyBvbmx5IGEgcm93LiBBICMgaW5kaWNhdGVzIGFuIGlkIGFueSBhbnl0aGluZyB0aGF0IGZvbGxvd3MgaXMgdGhlIGlkIC1cblx0XHRcdC8vIHVuZXNjYXBlZC5cblx0XHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ3N0cmluZycgJiYgc2VsLmNoYXJBdCgwKSA9PT0gJyMnICkge1xuXHRcdFx0XHQvLyBnZXQgcm93IGluZGV4IGZyb20gaWRcblx0XHRcdFx0dmFyIHJvd09iaiA9IHNldHRpbmdzLmFJZHNbIHNlbC5yZXBsYWNlKCAvXiMvLCAnJyApIF07XG5cdFx0XHRcdGlmICggcm93T2JqICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsgcm93T2JqLmlkeCBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBuZWVkIHRvIGZhbGwgdGhyb3VnaCB0byBqUXVlcnkgaW4gY2FzZSB0aGVyZSBpcyBET00gaWQgdGhhdFxuXHRcdFx0XHQvLyBtYXRjaGVzXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEdldCBub2RlcyBpbiB0aGUgb3JkZXIgZnJvbSB0aGUgYHJvd3NgIGFycmF5IHdpdGggbnVsbCB2YWx1ZXMgcmVtb3ZlZFxuXHRcdFx0dmFyIG5vZGVzID0gX3JlbW92ZUVtcHR5KFxuXHRcdFx0XHRfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ25UcicgKVxuXHRcdFx0KTtcblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXG5cdFx0XHQvLyBBcyBqUXVlcnkncyAuZmlsdGVyKCkgYWxsb3dzIGpRdWVyeSBvYmplY3RzIHRvIGJlIHBhc3NlZCBpbiBmaWx0ZXIsXG5cdFx0XHQvLyBpdCBhbHNvIGFsbG93cyBhcnJheXMsIHNvIHRoaXMgd2lsbCBjb3BlIHdpdGggYWxsIHRocmVlIG9wdGlvbnNcblx0XHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0XHQuZmlsdGVyKCBzZWwgKVxuXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX0RUX1Jvd0luZGV4O1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cdH07XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0Ly8gYXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9ICcnO1xuXHRcdH1cblx0XHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KCBzZWxlY3RvciApICkge1xuXHRcdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFxuXHRcdG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyggb3B0cyApO1xuXHRcblx0XHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX19yb3dfc2VsZWN0b3IoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApO1xuXHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gV2FudCBhcmd1bWVudCBzaGlmdGluZyBoZXJlIGFuZCBpbiBfX3Jvd19zZWxlY3Rvcj9cblx0XHRpbnN0LnNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvcjtcblx0XHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXHRcblx0XHRyZXR1cm4gaW5zdDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MoKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF0ublRyIHx8IHVuZGVmaW5lZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCB0cnVlLCAncm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdfYURhdGEnICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmNhY2hlKCknLCAncm93KCkuY2FjaGUoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRcdHZhciByID0gc2V0dGluZ3MuYW9EYXRhWyByb3cgXTtcblx0XHRcdHJldHVybiB0eXBlID09PSAnc2VhcmNoJyA/IHIuX2FGaWx0ZXJEYXRhIDogci5fYVNvcnREYXRhO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pbnZhbGlkYXRlKCknLCAncm93KCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHRyZXR1cm4gcm93O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pZHMoKScsICdyb3coKS5pZCgpJywgZnVuY3Rpb24gKCBoYXNoICkge1xuXHRcdHZhciBhID0gW107XG5cdFx0dmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdC8vIGBpdGVyYXRvcmAgd2lsbCBkcm9wIHVuZGVmaW5lZCB2YWx1ZXMsIGJ1dCBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0aGVtXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGhpc1tpXS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0dmFyIGlkID0gY29udGV4dFtpXS5yb3dJZEZuKCBjb250ZXh0W2ldLmFvRGF0YVsgdGhpc1tpXVtqXSBdLl9hRGF0YSApO1xuXHRcdFx0XHRhLnB1c2goIChoYXNoID09PSB0cnVlID8gJyMnIDogJycgKSsgaWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgYSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XG5cdFx0dGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgdGhhdElkeCApIHtcblx0XHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdFx0dmFyIHJvd0RhdGEgPSBkYXRhWyByb3cgXTtcblx0XHRcdHZhciBpLCBpZW4sIGosIGplbjtcblx0XHRcdHZhciBsb29wUm93LCBsb29wQ2VsbHM7XG5cdFxuXHRcdFx0ZGF0YS5zcGxpY2UoIHJvdywgMSApO1xuXHRcblx0XHRcdC8vIFVwZGF0ZSB0aGUgY2FjaGVkIGluZGV4ZXNcblx0XHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGxvb3BSb3cgPSBkYXRhW2ldO1xuXHRcdFx0XHRsb29wQ2VsbHMgPSBsb29wUm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0XHQvLyBSb3dzXG5cdFx0XHRcdGlmICggbG9vcFJvdy5uVHIgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0bG9vcFJvdy5uVHIuX0RUX1Jvd0luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gQ2VsbHNcblx0XHRcdFx0aWYgKCBsb29wQ2VsbHMgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Zm9yICggaj0wLCBqZW49bG9vcENlbGxzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0bG9vcENlbGxzW2pdLl9EVF9DZWxsSW5kZXgucm93ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHRcdF9mbkRlbGV0ZUluZGV4KCBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsIHJvdyApO1xuXHRcdFx0X2ZuRGVsZXRlSW5kZXgoIHNldHRpbmdzLmFpRGlzcGxheSwgcm93ICk7XG5cdFx0XHRfZm5EZWxldGVJbmRleCggdGhhdFsgdGhhdElkeCBdLCByb3csIGZhbHNlICk7IC8vIG1haW50YWluIGxvY2FsIGluZGV4ZXNcblx0XG5cdFx0XHQvLyBGb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0YWJsZXMgLSBzdWJ0cmFjdCB0aGUgZGVsZXRlZCByb3cgZnJvbSB0aGUgY291bnRcblx0XHRcdGlmICggc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA+IDAgKSB7XG5cdFx0XHRcdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXktLTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXG5cdFx0XHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHQvLyBSZW1vdmUgdGhlIHJvdydzIElEIHJlZmVyZW5jZSBpZiB0aGVyZSBpcyBvbmVcblx0XHRcdHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oIHJvd0RhdGEuX2FEYXRhICk7XG5cdFx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5hSWRzWyBpZCBdO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHNldHRpbmdzLmFvRGF0YVtpXS5pZHggPSBpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cy5hZGQoKScsIGZ1bmN0aW9uICggcm93cyApIHtcblx0XHR2YXIgbmV3Um93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHZhciByb3csIGksIGllbjtcblx0XHRcdFx0dmFyIG91dCA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0LnB1c2goIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHNvIHJvd3MoKS5ub2RlcygpIGV0YyBjYW4gYmUgdXNlZFxuXHRcdHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKCAtMSApO1xuXHRcdG1vZFJvd3MucG9wKCk7XG5cdFx0JC5tZXJnZSggbW9kUm93cywgbmV3Um93cyApO1xuXHRcblx0XHRyZXR1cm4gbW9kUm93cztcblx0fSApO1xuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3JvdygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLnJvd3MoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBHZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9hRGF0YSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF07XG5cdFx0cm93Ll9hRGF0YSA9IGRhdGE7XG5cdFxuXHRcdC8vIElmIHRoZSBET00gaGFzIGFuIGlkLCBhbmQgdGhlIGRhdGEgc291cmNlIGlzIGFuIGFycmF5XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhICkgJiYgcm93Lm5UciAmJiByb3cublRyLmlkICkge1xuXHRcdFx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBjdHhbMF0ucm93SWQgKSggZGF0YSwgcm93Lm5Uci5pZCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gQXV0b21hdGljYWxseSBpbnZhbGlkYXRlXG5cdFx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCB0aGlzWzBdLCAnZGF0YScgKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93KCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5uVHIgfHwgbnVsbCA6XG5cdFx0XHRudWxsO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvdy5hZGQoKScsIGZ1bmN0aW9uICggcm93ICkge1xuXHRcdC8vIEFsbG93IGEgalF1ZXJ5IG9iamVjdCB0byBiZSBwYXNzZWQgaW4gLSBvbmx5IGEgc2luZ2xlIHJvdyBpcyBhZGRlZCBmcm9tXG5cdFx0Ly8gaXQgdGhvdWdoIC0gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuXHRcdGlmICggcm93IGluc3RhbmNlb2YgJCAmJiByb3cubGVuZ3RoICkge1xuXHRcdFx0cm93ID0gcm93WzBdO1xuXHRcdH1cblx0XG5cdFx0dmFyIHJvd3MgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCByb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicgKSB7XG5cdFx0XHRcdHJldHVybiBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKTtcblx0XHR9ICk7XG5cdFxuXHRcdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCB3aXRoIHRoZSBuZXdseSBhZGRlZCByb3cgc2VsZWN0ZWRcblx0XHRyZXR1cm4gdGhpcy5yb3coIHJvd3NbMF0gKTtcblx0fSApO1xuXHRcblx0XG5cdCQoZG9jdW1lbnQpLm9uKCdwbHVnaW4taW5pdC5kdCcsIGZ1bmN0aW9uIChlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBjb250ZXh0ICk7XG5cdFx0YXBpLm9uKCAnc3RhdGVTYXZlUGFyYW1zJywgZnVuY3Rpb24gKCBlLCBzZXR0aW5ncywgZGF0YSApIHtcblx0XHRcdHZhciBpbmRleGVzID0gYXBpLnJvd3MoKS5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVtpZHhdLl9kZXRhaWxzU2hvdyA/IGlkeCA6IHVuZGVmaW5lZDtcblx0XHRcdH0pO1xuXHRcblx0XHRcdGRhdGEuY2hpbGRSb3dzID0gYXBpLnJvd3MoIGluZGV4ZXMgKS5pZHMoIHRydWUgKS50b0FycmF5KCk7XG5cdFx0fSlcblx0XG5cdFx0dmFyIGxvYWRlZCA9IGFwaS5zdGF0ZS5sb2FkZWQoKTtcblx0XG5cdFx0aWYgKCBsb2FkZWQgJiYgbG9hZGVkLmNoaWxkUm93cyApIHtcblx0XHRcdGFwaS5yb3dzKCBsb2FkZWQuY2hpbGRSb3dzICkuZXZlcnkoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBjb250ZXh0LCBudWxsLCAncmVxdWVzdENoaWxkJywgWyB0aGlzIF0gKVxuXHRcdFx0fSlcblx0XHR9XG5cdH0pXG5cdFxuXHR2YXIgX19kZXRhaWxzX2FkZCA9IGZ1bmN0aW9uICggY3R4LCByb3csIGRhdGEsIGtsYXNzIClcblx0e1xuXHRcdC8vIENvbnZlcnQgdG8gYXJyYXkgb2YgVFIgZWxlbWVudHNcblx0XHR2YXIgcm93cyA9IFtdO1xuXHRcdHZhciBhZGRSb3cgPSBmdW5jdGlvbiAoIHIsIGsgKSB7XG5cdFx0XHQvLyBSZWN1cnNpb24gdG8gYWxsb3cgZm9yIGFycmF5cyBvZiBqUXVlcnkgb2JqZWN0c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCByICkgfHwgciBpbnN0YW5jZW9mICQgKSB7XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGFkZFJvdyggcltpXSwgayApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBJZiB3ZSBnZXQgYSBUUiBlbGVtZW50LCB0aGVuIGp1c3QgYWRkIGl0IGRpcmVjdGx5IC0gdXAgdG8gdGhlIGRldlxuXHRcdFx0Ly8gdG8gYWRkIHRoZSBjb3JyZWN0IG51bWJlciBvZiBjb2x1bW5zIGV0Y1xuXHRcdFx0aWYgKCByLm5vZGVOYW1lICYmIHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJyApIHtcblx0XHRcdFx0cm93cy5wdXNoKCByICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGNyZWF0ZSBhIHJvdyB3aXRoIGEgd3JhcHBlclxuXHRcdFx0XHR2YXIgY3JlYXRlZCA9ICQoJzx0cj48dGQ+PC90ZD48L3RyPicpLmFkZENsYXNzKCBrICk7XG5cdFx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGsgKVxuXHRcdFx0XHRcdC5odG1sKCByIClcblx0XHRcdFx0XHRbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXHRcblx0XHRcdFx0cm93cy5wdXNoKCBjcmVhdGVkWzBdICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0YWRkUm93KCBkYXRhLCBrbGFzcyApO1xuXHRcblx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5kZXRhY2goKTtcblx0XHR9XG5cdFxuXHRcdHJvdy5fZGV0YWlscyA9ICQocm93cyk7XG5cdFxuXHRcdC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXG5cdFx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKCBhcGksIGlkeCApXG5cdHtcblx0XHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXSBdO1xuXHRcblx0XHRcdGlmICggcm93ICYmIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzLnJlbW92ZSgpO1xuXHRcblx0XHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cm93Ll9kZXRhaWxzID0gdW5kZWZpbmVkO1xuXHRcdFx0XHQkKCByb3cublRyICkucmVtb3ZlQ2xhc3MoICdkdC1oYXNDaGlsZCcgKTtcblx0XHRcdFx0X2ZuU2F2ZVN0YXRlKCBjdHhbMF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19kaXNwbGF5ID0gZnVuY3Rpb24gKCBhcGksIHNob3cgKSB7XG5cdFx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggJiYgYXBpLmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBhcGlbMF0gXTtcblx0XG5cdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHNob3c7XG5cdFxuXHRcdFx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdFx0JCggcm93Lm5UciApLmFkZENsYXNzKCAnZHQtaGFzQ2hpbGQnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHRcdFx0XHRcdCQoIHJvdy5uVHIgKS5yZW1vdmVDbGFzcyggJ2R0LWhhc0NoaWxkJyApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIGN0eFswXSwgbnVsbCwgJ2NoaWxkUm93JywgWyBzaG93LCBhcGkucm93KCBhcGlbMF0gKSBdIClcblx0XG5cdFx0XHRcdF9fZGV0YWlsc19ldmVudHMoIGN0eFswXSApO1xuXHRcdFx0XHRfZm5TYXZlU3RhdGUoIGN0eFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX2V2ZW50cyA9IGZ1bmN0aW9uICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHRcdHZhciBuYW1lc3BhY2UgPSAnLmR0LkRUX2RldGFpbHMnO1xuXHRcdHZhciBkcmF3RXZlbnQgPSAnZHJhdycrbmFtZXNwYWNlO1xuXHRcdHZhciBjb2x2aXNFdmVudCA9ICdjb2x1bW4tdmlzaWJpbGl0eScrbmFtZXNwYWNlO1xuXHRcdHZhciBkZXN0cm95RXZlbnQgPSAnZGVzdHJveScrbmFtZXNwYWNlO1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcblx0XHRhcGkub2ZmKCBkcmF3RXZlbnQgKycgJysgY29sdmlzRXZlbnQgKycgJysgZGVzdHJveUV2ZW50ICk7XG5cdFxuXHRcdGlmICggX3BsdWNrKCBkYXRhLCAnX2RldGFpbHMnICkubGVuZ3RoID4gMCApIHtcblx0XHRcdC8vIE9uIGVhY2ggZHJhdywgaW5zZXJ0IHRoZSByZXF1aXJlZCBlbGVtZW50cyBpbnRvIHRoZSBkb2N1bWVudFxuXHRcdFx0YXBpLm9uKCBkcmF3RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhcGkucm93cygge3BhZ2U6J2N1cnJlbnQnfSApLmVxKDApLmVhY2goIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHQvLyBJbnRlcm5hbCBkYXRhIGdyYWJcblx0XHRcdFx0XHR2YXIgcm93ID0gZGF0YVsgaWR4IF07XG5cdFxuXHRcdFx0XHRcdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRcdFx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdC8vIENvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZSAtIHVwZGF0ZSB0aGUgY29sc3BhblxuXHRcdFx0YXBpLm9uKCBjb2x2aXNFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHgsIGlkeCwgdmlzICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcblx0XHRcdFx0Ly8gYSBjb2xzcGFuKVxuXHRcdFx0XHR2YXIgcm93LCB2aXNpYmxlID0gX2ZuVmlzYmxlQ29sdW1ucyggY3R4ICk7XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSBkYXRhW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRcdHJvdy5fZGV0YWlscy5jaGlsZHJlbigndGRbY29sc3Bhbl0nKS5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdC8vIFRhYmxlIGRlc3Ryb3llZCAtIG51a2UgYW55IGNoaWxkIHJvd3Ncblx0XHRcdGFwaS5vbiggZGVzdHJveUV2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhW2ldLl9kZXRhaWxzICkge1xuXHRcdFx0XHRcdFx0X19kZXRhaWxzX3JlbW92ZSggYXBpLCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0Ly8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxuXHR2YXIgX2VtcCA9ICcnO1xuXHR2YXIgX2NoaWxkX29iaiA9IF9lbXArJ3JvdygpLmNoaWxkJztcblx0dmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqKycoKSc7XG5cdFxuXHQvLyBkYXRhIGNhbiBiZTpcblx0Ly8gIHRyXG5cdC8vICBzdHJpbmdcblx0Ly8gIGpRdWVyeSBvciBhcnJheSBvZiBhbnkgb2YgdGhlIGFib3ZlXG5cdF9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9tdGgsIGZ1bmN0aW9uICggZGF0YSwga2xhc3MgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XHRlbHNlIGlmICggZGF0YSA9PT0gdHJ1ZSApIHtcblx0XHRcdC8vIHNob3dcblx0XHRcdHRoaXMuY2hpbGQuc2hvdygpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggZGF0YSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyByZW1vdmVcblx0XHRcdF9fZGV0YWlsc19yZW1vdmUoIHRoaXMgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0XHQvLyBzZXRcblx0XHRcdF9fZGV0YWlsc19hZGQoIGN0eFswXSwgY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLCBkYXRhLCBrbGFzcyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLnNob3coKScsXG5cdFx0X2NoaWxkX210aCsnLnNob3coKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXHRdLCBmdW5jdGlvbiAoIHNob3cgKSB7ICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfZGlzcGxheSggdGhpcywgdHJ1ZSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5oaWRlKCknLFxuXHRcdF9jaGlsZF9tdGgrJy5oaWRlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCkgeyAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLnJlbW92ZSgpJyxcblx0XHRfY2hpbGRfbXRoKycucmVtb3ZlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBfY2hpbGRfb2JqKycuaXNTaG93bigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCApIHtcblx0XHRcdC8vIF9kZXRhaWxzU2hvd24gYXMgZmFsc2Ugb3IgdW5kZWZpbmVkIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHJldHVybiBmYWxzZVxuXHRcdFx0cmV0dXJuIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1Nob3cgfHwgZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogQ29sdW1uc1xuXHQgKlxuXHQgKiB7aW50ZWdlcn0gICAgICAgICAgIC0gY29sdW1uIGluZGV4ICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuXHQgKiBcIntpbnRlZ2VyfTp2aXNJZHhcIiAgLSB2aXNpYmxlIGNvbHVtbiBpbmRleCAoaS5lLiB0cmFuc2xhdGUgdG8gY29sdW1uIGluZGV4KSAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG5cdCAqIFwie2ludGVnZXJ9OnZpc2libGVcIiAtIGFsaWFzIGZvciB7aW50ZWdlcn06dmlzSWR4ICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcblx0ICogXCJ7c3RyaW5nfTpuYW1lXCIgICAgIC0gY29sdW1uIG5hbWVcblx0ICogXCJ7c3RyaW5nfVwiICAgICAgICAgIC0galF1ZXJ5IHNlbGVjdG9yIG9uIGNvbHVtbiBoZWFkZXIgbm9kZXNcblx0ICpcblx0ICovXG5cdFxuXHQvLyBjYW4gYmUgYW4gYXJyYXkgb2YgdGhlc2UgaXRlbXMsIGNvbW1hIHNlcGFyYXRlZCBsaXN0LCBvciBhbiBhcnJheSBvZiBjb21tYVxuXHQvLyBzZXBhcmF0ZWQgbGlzdHNcblx0XG5cdHZhciBfX3JlX2NvbHVtbl9zZWxlY3RvciA9IC9eKFteOl0rKToobmFtZXx2aXNJZHh8dmlzaWJsZSkkLztcblx0XG5cdFxuXHQvLyByMSBhbmQgcjIgYXJlIHJlZHVuZGFudCAtIGJ1dCBpdCBtZWFucyB0aGF0IHRoZSBwYXJhbWV0ZXJzIG1hdGNoIGZvciB0aGVcblx0Ly8gaXRlcmF0b3IgY2FsbGJhY2sgaW4gY29sdW1ucygpLmRhdGEoKVxuXHR2YXIgX19jb2x1bW5EYXRhID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MgKSB7XG5cdFx0dmFyIGEgPSBbXTtcblx0XHRmb3IgKCB2YXIgcm93PTAsIGllbj1yb3dzLmxlbmd0aCA7IHJvdzxpZW4gOyByb3crKyApIHtcblx0XHRcdGEucHVzaCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdG5hbWVzID0gX3BsdWNrKCBjb2x1bW5zLCAnc05hbWUnICksXG5cdFx0XHRub2RlcyA9IF9wbHVjayggY29sdW1ucywgJ25UaCcgKTtcblx0XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzICk7XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdGlmICggcyA9PT0gJycgKSB7XG5cdFx0XHRcdHJldHVybiBfcmFuZ2UoIGNvbHVtbnMubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBbIHNlbEludCA+PSAwID9cblx0XHRcdFx0XHRzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcblx0XHRcdFx0XHRjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgPSBmdW5jdGlvblxuXHRcdFx0aWYgKCB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFxuXHRcdFx0XHRyZXR1cm4gJC5tYXAoIGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRcdHJldHVybiBzKFxuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyApLFxuXHRcdFx0XHRcdFx0XHRub2Rlc1sgaWR4IF1cblx0XHRcdFx0XHRcdCkgPyBpZHggOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxuXHRcdFx0dmFyIG1hdGNoID0gdHlwZW9mIHMgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0cy5tYXRjaCggX19yZV9jb2x1bW5fc2VsZWN0b3IgKSA6XG5cdFx0XHRcdCcnO1xuXHRcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdHN3aXRjaCggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0Y2FzZSAndmlzSWR4Jzpcblx0XHRcdFx0XHRjYXNlICd2aXNpYmxlJzpcblx0XHRcdFx0XHRcdHZhciBpZHggPSBwYXJzZUludCggbWF0Y2hbMV0sIDEwICk7XG5cdFx0XHRcdFx0XHQvLyBWaXNpYmxlIGluZGV4IGdpdmVuLCBjb252ZXJ0IHRvIGNvbHVtbiBpbmRleFxuXHRcdFx0XHRcdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDb3VudGluZyBmcm9tIHRoZSByaWdodFxuXHRcdFx0XHRcdFx0XHR2YXIgdmlzQ29sdW1ucyA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoY29sLGkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sLmJWaXNpYmxlID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgdmlzQ29sdW1uc1sgdmlzQ29sdW1ucy5sZW5ndGggKyBpZHggXSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgbGVmdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIHNldHRpbmdzLCBpZHggKSBdO1xuXHRcblx0XHRcdFx0XHRjYXNlICduYW1lJzpcblx0XHRcdFx0XHRcdC8vIG1hdGNoIGJ5IG5hbWUuIGBuYW1lc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0XHRcdFx0cmV0dXJuICQubWFwKCBuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgPT09IG1hdGNoWzFdID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBDZWxsIGluIHRoZSB0YWJsZSBib2R5XG5cdFx0XHRpZiAoIHMubm9kZU5hbWUgJiYgcy5fRFRfQ2VsbEluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzLl9EVF9DZWxsSW5kZXguY29sdW1uIF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBUSCBlbGVtZW50cyBmb3IgdGhlIGNvbHVtbnNcblx0XHRcdHZhciBqcVJlc3VsdCA9ICQoIG5vZGVzIClcblx0XHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHRcdC5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KCB0aGlzLCBub2RlcyApOyAvLyBgbm9kZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFxuXHRcdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGEgbm9kZSB3aGljaCBtaWdodCBoYXZlIGEgYGR0LWNvbHVtbmAgZGF0YSBhdHRyaWJ1dGUsIG9yIGJlXG5cdFx0XHQvLyBhIGNoaWxkIG9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0dmFyIGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1jb2x1bW5dJyk7XG5cdFx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0XHRbIGhvc3QuZGF0YSgnZHQtY29sdW1uJykgXSA6XG5cdFx0XHRcdFtdO1xuXHRcdH07XG5cdFxuXHRcdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY29sdW1uJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX19zZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApIHtcblx0XHR2YXJcblx0XHRcdGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRjb2wgID0gY29sc1sgY29sdW1uIF0sXG5cdFx0XHRkYXRhID0gc2V0dGluZ3MuYW9EYXRhLFxuXHRcdFx0cm93LCBjZWxscywgaSwgaWVuLCB0cjtcblx0XG5cdFx0Ly8gR2V0XG5cdFx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjb2wuYlZpc2libGU7XG5cdFx0fVxuXHRcblx0XHQvLyBTZXRcblx0XHQvLyBObyBjaGFuZ2Vcblx0XHRpZiAoIGNvbC5iVmlzaWJsZSA9PT0gdmlzICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB2aXMgKSB7XG5cdFx0XHQvLyBJbnNlcnQgY29sdW1uXG5cdFx0XHQvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxuXHRcdFx0dmFyIGluc2VydEJlZm9yZSA9ICQuaW5BcnJheSggdHJ1ZSwgX3BsdWNrKGNvbHMsICdiVmlzaWJsZScpLCBjb2x1bW4rMSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHRyID0gZGF0YVtpXS5uVHI7XG5cdFx0XHRcdGNlbGxzID0gZGF0YVtpXS5hbkNlbGxzO1xuXHRcblx0XHRcdFx0aWYgKCB0ciApIHtcblx0XHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgY2FuIGFjdCBsaWtlIGFwcGVuZENoaWxkIGlmIDJuZCBhcmcgaXMgbnVsbFxuXHRcdFx0XHRcdHRyLmluc2VydEJlZm9yZSggY2VsbHNbIGNvbHVtbiBdLCBjZWxsc1sgaW5zZXJ0QmVmb3JlIF0gfHwgbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIGNvbHVtblxuXHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sdW1uICkgKS5kZXRhY2goKTtcblx0XHR9XG5cdFxuXHRcdC8vIENvbW1vbiBhY3Rpb25zXG5cdFx0Y29sLmJWaXNpYmxlID0gdmlzO1xuXHR9O1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcblx0XHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblx0XG5cdFx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cblx0XHRpbnN0LnNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvcjtcblx0XHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXHRcblx0XHRyZXR1cm4gaW5zdDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5oZWFkZXIoKScsICdjb2x1bW4oKS5oZWFkZXIoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRoO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5mb290ZXIoKScsICdjb2x1bW4oKS5mb290ZXIoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRmO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhKCknLCAnY29sdW1uKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhU3JjKCknLCAnY29sdW1uKCkuZGF0YVNyYygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm1EYXRhO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5jYWNoZSgpJywgJ2NvbHVtbigpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cyxcblx0XHRcdFx0dHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJywgY29sdW1uXG5cdFx0XHQpO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5ub2RlcygpJywgJ2NvbHVtbigpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4gKSA7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAoIHZpcywgY2FsYyApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2x1bW4gXS5iVmlzaWJsZTtcblx0XHRcdH0gLy8gZWxzZVxuXHRcdFx0X19zZXRDb2x1bW5WaXMoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApO1xuXHRcdH0gKTtcblx0XG5cdFx0Ly8gR3JvdXAgdGhlIGNvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZXNcblx0XHRpZiAoIHZpcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0Ly8gUmVkcmF3IHRoZSBoZWFkZXIgYWZ0ZXIgY2hhbmdlc1xuXHRcdFx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0XHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XHRcblx0XHRcdFx0Ly8gVXBkYXRlIGNvbHNwYW4gZm9yIG5vIHJlY29yZHMgZGlzcGxheS4gQ2hpbGQgcm93cyBhbmQgZXh0ZW5zaW9ucyB3aWxsIHVzZSB0aGVpciBvd25cblx0XHRcdFx0Ly8gbGlzdGVuZXJzIHRvIGRvIHRoaXMgLSBvbmx5IG5lZWQgdG8gdXBkYXRlIHRoZSBlbXB0eSB0YWJsZSBpdGVtIGhlcmVcblx0XHRcdFx0aWYgKCAhIHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0JChzZXR0aW5ncy5uVEJvZHkpLmZpbmQoJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIF9mblZpc2JsZUNvbHVtbnMoc2V0dGluZ3MpKTtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRfZm5TYXZlU3RhdGUoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHQvLyBTZWNvbmQgbG9vcCBvbmNlIHRoZSBmaXJzdCBpcyBkb25lIGZvciBldmVudHNcblx0XHRcdFx0dGhhdC5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjXSApO1xuXHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHRpZiAoIGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjICkge1xuXHRcdFx0XHRcdHRoYXQuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmV0O1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHR5cGUgPT09ICd2aXNpYmxlJyA/XG5cdFx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICkgOlxuXHRcdFx0XHRjb2x1bW47XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1ucy5hZGp1c3QoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW4uaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSwgaWR4ICkge1xuXHRcdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCApIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdFxuXHRcdFx0aWYgKCB0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnICkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIGN0eCwgaWR4ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBjdHgsIGlkeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NvbHVtbigpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNvbHVtbnMoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0dmFyIF9fY2VsbF9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcdHZhciBjZWxscyA9IF9yZW1vdmVFbXB0eSggX3BsdWNrX29yZGVyKCBkYXRhLCByb3dzLCAnYW5DZWxscycgKSApO1xuXHRcdHZhciBhbGxDZWxscyA9ICQoX2ZsYXR0ZW4oIFtdLCBjZWxscyApKTtcblx0XHR2YXIgcm93O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcblx0XHR2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xuXHRcblx0XHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0dmFyIGZuU2VsZWN0b3IgPSB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJztcblx0XG5cdFx0XHRpZiAoIHMgPT09IG51bGwgfHwgcyA9PT0gdW5kZWZpbmVkIHx8IGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdC8vIEFsbCBjZWxscyBhbmQgZnVuY3Rpb24gc2VsZWN0b3JzXG5cdFx0XHRcdGEgPSBbXTtcblx0XG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0cm93ID0gcm93c1tpXTtcblx0XG5cdFx0XHRcdFx0Zm9yICggaj0wIDsgajxjb2x1bW5zIDsgaisrICkge1xuXHRcdFx0XHRcdFx0byA9IHtcblx0XHRcdFx0XHRcdFx0cm93OiByb3csXG5cdFx0XHRcdFx0XHRcdGNvbHVtbjogalxuXHRcdFx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cblx0XHRcdFx0XHRcdFx0aG9zdCA9IGRhdGFbIHJvdyBdO1xuXHRcblx0XHRcdFx0XHRcdFx0aWYgKCBzKCBvLCBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBqKSwgaG9zdC5hbkNlbGxzID8gaG9zdC5hbkNlbGxzW2pdIDogbnVsbCApICkge1xuXHRcdFx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHMgKSApIHtcblx0XHRcdFx0Ly8gVmFsaWQgY2VsbCBpbmRleCBhbmQgaXRzIGluIHRoZSBhcnJheSBvZiBzZWxlY3RhYmxlIHJvd3Ncblx0XHRcdFx0cmV0dXJuIHMuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgcy5yb3cgIT09IHVuZGVmaW5lZCAmJiAkLmluQXJyYXkoIHMucm93LCByb3dzICkgIT09IC0xID9cblx0XHRcdFx0XHRbc10gOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXG5cdFx0XHR2YXIganFSZXN1bHQgPSBhbGxDZWxsc1xuXHRcdFx0XHQuZmlsdGVyKCBzIClcblx0XHRcdFx0Lm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgLy8gdXNlIGEgbmV3IG9iamVjdCwgaW4gY2FzZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlc1xuXHRcdFx0XHRcdFx0cm93OiAgICBlbC5fRFRfQ2VsbEluZGV4LnJvdyxcblx0XHRcdFx0XHRcdGNvbHVtbjogZWwuX0RUX0NlbGxJbmRleC5jb2x1bW5cblx0IFx0XHRcdFx0fTtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFxuXHRcdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBpcyBhIG5vZGUsIGFuZCB0aGVyZSBpcyBvbmUgbGFzdCBvcHRpb24gLSB0aGVcblx0XHRcdC8vIGVsZW1lbnQgbWlnaHQgYmUgYSBjaGlsZCBvZiBhbiBlbGVtZW50IHdoaWNoIGhhcyBkdC1yb3cgYW5kIGR0LWNvbHVtblxuXHRcdFx0Ly8gZGF0YSBhdHRyaWJ1dGVzXG5cdFx0XHRob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0WyB7XG5cdFx0XHRcdFx0cm93OiBob3N0LmRhdGEoJ2R0LXJvdycpLFxuXHRcdFx0XHRcdGNvbHVtbjogaG9zdC5kYXRhKCdkdC1jb2x1bW4nKVxuXHRcdFx0XHR9IF0gOlxuXHRcdFx0XHRbXTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NlbGwnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCByb3dTZWxlY3RvciApICkge1xuXHRcdFx0Ly8gSW5kZXhlc1xuXHRcdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0b3B0cyA9IHJvd1NlbGVjdG9yO1xuXHRcdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRcdGNvbHVtblNlbGVjdG9yID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGNvbHVtblNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcblx0XHQvLyBDZWxsIHNlbGVjdG9yXG5cdFx0aWYgKCBjb2x1bW5TZWxlY3RvciA9PT0gbnVsbCB8fCBjb2x1bW5TZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHJldHVybiBfX2NlbGxfc2VsZWN0b3IoIHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMoIG9wdHMgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gVGhlIGRlZmF1bHQgYnVpbHQgaW4gb3B0aW9ucyBuZWVkIHRvIGFwcGx5IHRvIHJvdyBhbmQgY29sdW1uc1xuXHRcdHZhciBpbnRlcm5hbE9wdHMgPSBvcHRzID8ge1xuXHRcdFx0cGFnZTogb3B0cy5wYWdlLFxuXHRcdFx0b3JkZXI6IG9wdHMub3JkZXIsXG5cdFx0XHRzZWFyY2g6IG9wdHMuc2VhcmNoXG5cdFx0fSA6IHt9O1xuXHRcblx0XHQvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3Jcblx0XHR2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucyggY29sdW1uU2VsZWN0b3IsIGludGVybmFsT3B0cyApO1xuXHRcdHZhciByb3dzID0gdGhpcy5yb3dzKCByb3dTZWxlY3RvciwgaW50ZXJuYWxPcHRzICk7XG5cdFx0dmFyIGksIGllbiwgaiwgamVuO1xuXHRcblx0XHR2YXIgY2VsbHNOb09wdHMgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3NbaWR4XS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1uc1tpZHhdLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdGEucHVzaCgge1xuXHRcdFx0XHRcdFx0cm93OiAgICByb3dzW2lkeF1baV0sXG5cdFx0XHRcdFx0XHRjb2x1bW46IGNvbHVtbnNbaWR4XVtqXVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBhO1xuXHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gVGhlcmUgaXMgY3VycmVudGx5IG9ubHkgb25lIGV4dGVuc2lvbiB3aGljaCB1c2VzIGEgY2VsbCBzZWxlY3RvciBleHRlbnNpb25cblx0XHQvLyBJdCBpcyBhIF9tYWpvcl8gcGVyZm9ybWFuY2UgZHJhZyB0byBydW4gdGhpcyBpZiBpdCBpc24ndCBuZWVkZWQsIHNvIHRoaXMgaXNcblx0XHQvLyBhbiBleHRlbnNpb24gc3BlY2lmaWMgY2hlY2sgYXQgdGhlIG1vbWVudFxuXHRcdHZhciBjZWxscyA9IG9wdHMgJiYgb3B0cy5zZWxlY3RlZCA/XG5cdFx0XHR0aGlzLmNlbGxzKCBjZWxsc05vT3B0cywgb3B0cyApIDpcblx0XHRcdGNlbGxzTm9PcHRzO1xuXHRcblx0XHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRcdGNvbHM6IGNvbHVtblNlbGVjdG9yLFxuXHRcdFx0cm93czogcm93U2VsZWN0b3IsXG5cdFx0XHRvcHRzOiBvcHRzXG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gY2VsbHM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5ub2RlcygpJywgJ2NlbGwoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFxuXHRcdFx0cmV0dXJuIGRhdGEgJiYgZGF0YS5hbkNlbGxzID9cblx0XHRcdFx0ZGF0YS5hbkNlbGxzWyBjb2x1bW4gXSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3csIGNvbHVtbiApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmNhY2hlKCknLCAnY2VsbCgpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YSc7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF1bIHR5cGUgXVsgY29sdW1uIF07XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkucmVuZGVyKCknLCAnY2VsbCgpLnJlbmRlcigpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUgKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5pbmRleGVzKCknLCAnY2VsbCgpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0Y29sdW1uOiBjb2x1bW4sXG5cdFx0XHRcdGNvbHVtblZpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uIClcblx0XHRcdH07XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW52YWxpZGF0ZSgpJywgJ2NlbGwoKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxsKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNlbGxzKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGwoKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHR2YXIgY2VsbCA9IHRoaXNbMF07XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gR2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiBjZWxsLmxlbmd0aCA/XG5cdFx0XHRcdF9mbkdldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiApIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2V0XG5cdFx0X2ZuU2V0Q2VsbERhdGEoIGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uLCBkYXRhICk7XG5cdFx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbiApO1xuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgb3JkZXJpbmcgKHNvcnRpbmcpIHRoYXQgaGFzIGJlZW4gYXBwbGllZCB0byB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHthcnJheX0gMkQgYXJyYXkgY29udGFpbmluZyB0aGUgc29ydGluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG5cdCAqICAgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gRWFjaCBlbGVtZW50IGluIHRoZSBwYXJlbnQgYXJyYXkgcmVwcmVzZW50c1xuXHQgKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG5cdCAqICAgMiBpbm5lciBhcnJheXMpLiBUaGUgaW5uZXIgYXJyYXlzIG1heSBoYXZlIDIgb3IgMyBlbGVtZW50cy4gVGhlIGZpcnN0IGlzXG5cdCAqICAgdGhlIGNvbHVtbiBpbmRleCB0aGF0IHRoZSBzb3J0aW5nIGNvbmRpdGlvbiBhcHBsaWVzIHRvLCB0aGUgc2Vjb25kIGlzIHRoZVxuXHQgKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcblx0ICogICBpbmRleCBvZiB0aGUgc29ydGluZyBvcmRlciBmcm9tIHRoZSBgY29sdW1uLnNvcnRpbmdgIGluaXRpYWxpc2F0aW9uIGFycmF5LlxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IG9yZGVyIENvbHVtbiBpbmRleCB0byBzb3J0IHVwb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDFEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cblx0ICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDJEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIoKScsIGZ1bmN0aW9uICggb3JkZXIsIGRpciApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLmFhU29ydGluZyA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdGlmICggdHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJyApIHtcblx0XHRcdC8vIFNpbXBsZSBjb2x1bW4gLyBkaXJlY3Rpb24gcGFzc2VkIGluXG5cdFx0XHRvcmRlciA9IFsgWyBvcmRlciwgZGlyIF0gXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyLmxlbmd0aCAmJiAhIEFycmF5LmlzQXJyYXkoIG9yZGVyWzBdICkgKSB7XG5cdFx0XHQvLyBBcmd1bWVudHMgcGFzc2VkIGluIChsaXN0IG9mIDFEIGFycmF5cylcblx0XHRcdG9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHQvLyBvdGhlcndpc2UgYSAyRCBhcnJheSB3YXMgcGFzc2VkIGluXG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gb3JkZXIuc2xpY2UoKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuXHQgKlxuXHQgKiBAcGFyYW0ge25vZGV8alF1ZXJ5fHN0cmluZ30gbm9kZSBJZGVudGlmaWVyIGZvciB0aGUgZWxlbWVudChzKSB0byBhdHRhY2ggdGhlXG5cdCAqICAgbGlzdGVuZXIgdG8uIFRoaXMgY2FuIHRha2UgdGhlIGZvcm0gb2YgYSBzaW5nbGUgRE9NIG5vZGUsIGEgalF1ZXJ5XG5cdCAqICAgY29sbGVjdGlvbiBvZiBub2RlcyBvciBhIGpRdWVyeSBzZWxlY3RvciB3aGljaCB3aWxsIGlkZW50aWZ5IHRoZSBub2RlKHMpLlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IGNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdvcmRlci5saXN0ZW5lcigpJywgZnVuY3Rpb24gKCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKCBzZXR0aW5ncywgbm9kZSwgY29sdW1uLCBjYWxsYmFjayApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdvcmRlci5maXhlZCgpJywgZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0aWYgKCAhIHNldCApIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFx0XHR2YXIgZml4ZWQgPSBjdHgubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFhU29ydGluZ0ZpeGVkIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcblx0XHRcdHJldHVybiBBcnJheS5pc0FycmF5KCBmaXhlZCApID9cblx0XHRcdFx0eyBwcmU6IGZpeGVkIH0gOlxuXHRcdFx0XHRmaXhlZDtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHNldCApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIE9yZGVyIGJ5IHRoZSBzZWxlY3RlZCBjb2x1bW4ocylcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdCdjb2x1bW5zKCkub3JkZXIoKScsXG5cdFx0J2NvbHVtbigpLm9yZGVyKCknXG5cdF0sIGZ1bmN0aW9uICggZGlyICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGkgKSB7XG5cdFx0XHR2YXIgc29ydCA9IFtdO1xuXHRcblx0XHRcdCQuZWFjaCggdGhhdFtpXSwgZnVuY3Rpb24gKGosIGNvbCkge1xuXHRcdFx0XHRzb3J0LnB1c2goIFsgY29sLCBkaXIgXSApO1xuXHRcdFx0fSApO1xuXHRcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IHNvcnQ7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzZWFyY2goKScsIGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggaW5wdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGdldFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xuXHRcdFx0XHRjdHhbMF0ub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2ggOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBzZXRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgJC5leHRlbmQoIHt9LCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIHtcblx0XHRcdFx0XCJzU2VhcmNoXCI6IGlucHV0K1wiXCIsXG5cdFx0XHRcdFwiYlJlZ2V4XCI6ICByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXG5cdFx0XHRcdFwiYlNtYXJ0XCI6ICBzbWFydCA9PT0gbnVsbCA/IHRydWUgIDogc21hcnQsXG5cdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHR9ICksIDEgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKFxuXHRcdCdjb2x1bW5zKCkuc2VhcmNoKCknLFxuXHRcdCdjb2x1bW4oKS5zZWFyY2goKScsXG5cdFx0ZnVuY3Rpb24gKCBpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdFx0dmFyIHByZVNlYXJjaCA9IHNldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0XG5cdFx0XHRcdGlmICggaW5wdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBnZXRcblx0XHRcdFx0XHRyZXR1cm4gcHJlU2VhcmNoWyBjb2x1bW4gXS5zU2VhcmNoO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBzZXRcblx0XHRcdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0JC5leHRlbmQoIHByZVNlYXJjaFsgY29sdW1uIF0sIHtcblx0XHRcdFx0XHRcInNTZWFyY2hcIjogaW5wdXQrXCJcIixcblx0XHRcdFx0XHRcImJSZWdleFwiOiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRcdFwiYlNtYXJ0XCI6ICBzbWFydCA9PT0gbnVsbCA/IHRydWUgIDogc21hcnQsXG5cdFx0XHRcdFx0XCJiQ2FzZUluc2Vuc2l0aXZlXCI6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cblx0XHRcdFx0fSApO1xuXHRcblx0XHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIDEgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdCk7XG5cdFxuXHQvKlxuXHQgKiBTdGF0ZSBBUEkgbWV0aG9kc1xuXHQgKi9cblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cblx0XHRcdHRoaXMuY29udGV4dFswXS5vU2F2ZWRTdGF0ZSA6XG5cdFx0XHRudWxsO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlLmNsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHQvLyBTYXZlIGFuIGVtcHR5IG9iamVjdFxuXHRcdFx0c2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCB7fSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5sb2FkZWQoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub0xvYWRlZFN0YXRlIDpcblx0XHRcdG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUuc2F2ZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmdcblx0ICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG5cdCAqXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLlxuXHQgKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cblx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG9cblx0ICogICAgdGhlIHJlcXVpcmVkIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90XG5cdCAqICAgIHN1aXRhYmxlXG5cdCAqICBAc3RhdGljXG5cdCAqICBAZHRvcHQgQVBJLVN0YXRpY1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgYWxlcnQoICQuZm4uZGF0YVRhYmxlLnZlcnNpb25DaGVjayggJzEuOS4wJyApICk7XG5cdCAqL1xuXHREYXRhVGFibGUudmVyc2lvbkNoZWNrID0gRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrID0gZnVuY3Rpb24oIHZlcnNpb24gKVxuXHR7XG5cdFx0dmFyIGFUaGlzID0gRGF0YVRhYmxlLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHR2YXIgYVRoYXQgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGlUaGlzLCBpVGhhdDtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hVGhhdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRpVGhpcyA9IHBhcnNlSW50KCBhVGhpc1tpXSwgMTAgKSB8fCAwO1xuXHRcdFx0aVRoYXQgPSBwYXJzZUludCggYVRoYXRbaV0sIDEwICkgfHwgMDtcblx0XG5cdFx0XHQvLyBQYXJ0cyBhcmUgdGhlIHNhbWUsIGtlZXAgY29tcGFyaW5nXG5cdFx0XHRpZiAoaVRoaXMgPT09IGlUaGF0KSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFBhcnRzIGFyZSBkaWZmZXJlbnQsIHJldHVybiBpbW1lZGlhdGVseVxuXHRcdFx0cmV0dXJuIGlUaGlzID4gaVRoYXQ7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBgPHRhYmxlPmAgbm9kZSBpcyBhIERhdGFUYWJsZSB0YWJsZSBhbHJlYWR5IG9yIG5vdC5cblx0ICpcblx0ICogIEBwYXJhbSB7bm9kZXxqcXVlcnl8c3RyaW5nfSB0YWJsZSBUYWJsZSBub2RlLCBqUXVlcnkgb2JqZWN0IG9yIGpRdWVyeVxuXHQgKiAgICAgIHNlbGVjdG9yIGZvciB0aGUgdGFibGUgdG8gdGVzdC4gTm90ZSB0aGF0IGlmIG1vcmUgdGhhbiBtb3JlIHRoYW4gb25lXG5cdCAqICAgICAgdGFibGUgaXMgcGFzc2VkIG9uLCBvbmx5IHRoZSBmaXJzdCB3aWxsIGJlIGNoZWNrZWRcblx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIHRoZSB0YWJsZSBnaXZlbiBpcyBhIERhdGFUYWJsZSwgb3IgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqICBAc3RhdGljXG5cdCAqICBAZHRvcHQgQVBJLVN0YXRpY1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgaWYgKCAhICQuZm4uRGF0YVRhYmxlLmlzRGF0YVRhYmxlKCAnI2V4YW1wbGUnICkgKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgfVxuXHQgKi9cblx0RGF0YVRhYmxlLmlzRGF0YVRhYmxlID0gRGF0YVRhYmxlLmZuSXNEYXRhVGFibGUgPSBmdW5jdGlvbiAoIHRhYmxlIClcblx0e1xuXHRcdHZhciB0ID0gJCh0YWJsZSkuZ2V0KDApO1xuXHRcdHZhciBpcyA9IGZhbHNlO1xuXHRcblx0XHRpZiAoIHRhYmxlIGluc3RhbmNlb2YgRGF0YVRhYmxlLkFwaSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XG5cdFx0JC5lYWNoKCBEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChpLCBvKSB7XG5cdFx0XHR2YXIgaGVhZCA9IG8ublNjcm9sbEhlYWQgPyAkKCd0YWJsZScsIG8ublNjcm9sbEhlYWQpWzBdIDogbnVsbDtcblx0XHRcdHZhciBmb290ID0gby5uU2Nyb2xsRm9vdCA/ICQoJ3RhYmxlJywgby5uU2Nyb2xsRm9vdClbMF0gOiBudWxsO1xuXHRcblx0XHRcdGlmICggby5uVGFibGUgPT09IHQgfHwgaGVhZCA9PT0gdCB8fCBmb290ID09PSB0ICkge1xuXHRcdFx0XHRpcyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gaXM7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCBhbGwgRGF0YVRhYmxlIHRhYmxlcyB0aGF0IGhhdmUgYmVlbiBpbml0aWFsaXNlZCAtIG9wdGlvbmFsbHkgeW91IGNhblxuXHQgKiBzZWxlY3QgdG8gZ2V0IG9ubHkgY3VycmVudGx5IHZpc2libGUgdGFibGVzLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbdmlzaWJsZT1mYWxzZV0gRmxhZyB0byBpbmRpY2F0ZSBpZiB5b3Ugd2FudCBhbGwgKGRlZmF1bHQpXG5cdCAqICAgIG9yIHZpc2libGUgdGFibGVzIG9ubHkuXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGB0YWJsZWAgbm9kZXMgKG5vdCBEYXRhVGFibGUgaW5zdGFuY2VzKSB3aGljaCBhcmVcblx0ICogICAgRGF0YVRhYmxlc1xuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQuZWFjaCggJC5mbi5kYXRhVGFibGUudGFibGVzKHRydWUpLCBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgJCh0YWJsZSkuRGF0YVRhYmxlKCkuY29sdW1ucy5hZGp1c3QoKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0RGF0YVRhYmxlLnRhYmxlcyA9IERhdGFUYWJsZS5mblRhYmxlcyA9IGZ1bmN0aW9uICggdmlzaWJsZSApXG5cdHtcblx0XHR2YXIgYXBpID0gZmFsc2U7XG5cdFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2aXNpYmxlICkgKSB7XG5cdFx0XHRhcGkgPSB2aXNpYmxlLmFwaTtcblx0XHRcdHZpc2libGUgPSB2aXNpYmxlLnZpc2libGU7XG5cdFx0fVxuXHRcblx0XHR2YXIgYSA9ICQubWFwKCBEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRpZiAoICF2aXNpYmxlIHx8ICh2aXNpYmxlICYmICQoby5uVGFibGUpLmlzKCc6dmlzaWJsZScpKSApIHtcblx0XHRcdFx0cmV0dXJuIG8ublRhYmxlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGFwaSA/XG5cdFx0XHRuZXcgX0FwaSggYSApIDpcblx0XHRcdGE7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuIG5vdGF0aW9uLiBUaGlzIGlzIG1hZGUgcHVibGljXG5cdCAqIGZvciB0aGUgZXh0ZW5zaW9ucyB0byBwcm92aWRlIHRoZSBzYW1lIGFiaWxpdHkgYXMgRGF0YVRhYmxlcyBjb3JlIHRvIGFjY2VwdFxuXHQgKiBlaXRoZXIgdGhlIDEuOSBzdHlsZSBIdW5nYXJpYW4gbm90YXRpb24sIG9yIHRoZSAxLjEwKyBzdHlsZSBjYW1lbENhc2Vcblx0ICogcGFyYW1ldGVycy5cblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuXHQgKiAgICBtYXBwZWQuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG5cdCAqICAgIEh1bmdhcmlhbiB2YWx1ZSBpbiB0aGUgYHVzZXJgIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBPdGhlcndpc2UgdGhleVxuXHQgKiAgICB3b24ndCBiZS5cblx0ICovXG5cdERhdGFUYWJsZS5jYW1lbFRvSHVuZ2FyaWFuID0gX2ZuQ2FtZWxUb0h1bmdhcmlhbjtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnJCgpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHR2YXJcblx0XHRcdHJvd3MgICA9IHRoaXMucm93cyggb3B0cyApLm5vZGVzKCksIC8vIEdldCBhbGwgcm93c1xuXHRcdFx0anFSb3dzID0gJChyb3dzKTtcblx0XG5cdFx0cmV0dXJuICQoIFtdLmNvbmNhdChcblx0XHRcdGpxUm93cy5maWx0ZXIoIHNlbGVjdG9yICkudG9BcnJheSgpLFxuXHRcdFx0anFSb3dzLmZpbmQoIHNlbGVjdG9yICkudG9BcnJheSgpXG5cdFx0KSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8galF1ZXJ5IGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIHRoZSB0YWJsZXNcblx0JC5lYWNoKCBbICdvbicsICdvbmUnLCAnb2ZmJyBdLCBmdW5jdGlvbiAoaSwga2V5KSB7XG5cdFx0X2FwaV9yZWdpc3Rlcigga2V5KycoKScsIGZ1bmN0aW9uICggLyogZXZlbnQsIGhhbmRsZXIgKi8gKSB7XG5cdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFxuXHRcdFx0Ly8gQWRkIHRoZSBgZHRgIG5hbWVzcGFjZSBhdXRvbWF0aWNhbGx5IGlmIGl0IGlzbid0IGFscmVhZHkgcHJlc2VudFxuXHRcdFx0YXJnc1swXSA9ICQubWFwKCBhcmdzWzBdLnNwbGl0KCAvXFxzLyApLCBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRcdHJldHVybiAhIGUubWF0Y2goL1xcLmR0XFxiLykgP1xuXHRcdFx0XHRcdGUrJy5kdCcgOlxuXHRcdFx0XHRcdGU7XG5cdFx0XHRcdH0gKS5qb2luKCAnICcgKTtcblx0XG5cdFx0XHR2YXIgaW5zdCA9ICQoIHRoaXMudGFibGVzKCkubm9kZXMoKSApO1xuXHRcdFx0aW5zdFtrZXldLmFwcGx5KCBpbnN0LCBhcmdzICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMuY29udGV4dCApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2luaXQoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcdHJldHVybiBjdHgubGVuZ3RoID8gY3R4WzBdLm9Jbml0IDogbnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdkYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdfYURhdGEnICk7XG5cdFx0fSApLmZsYXR0ZW4oKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdkZXN0cm95KCknLCBmdW5jdGlvbiAoIHJlbW92ZSApIHtcblx0XHRyZW1vdmUgPSByZW1vdmUgfHwgZmFsc2U7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIG9yaWcgICAgICA9IHNldHRpbmdzLm5UYWJsZVdyYXBwZXIucGFyZW50Tm9kZTtcblx0XHRcdHZhciBjbGFzc2VzICAgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdHZhciB0YWJsZSAgICAgPSBzZXR0aW5ncy5uVGFibGU7XG5cdFx0XHR2YXIgdGJvZHkgICAgID0gc2V0dGluZ3MublRCb2R5O1xuXHRcdFx0dmFyIHRoZWFkICAgICA9IHNldHRpbmdzLm5USGVhZDtcblx0XHRcdHZhciB0Zm9vdCAgICAgPSBzZXR0aW5ncy5uVEZvb3Q7XG5cdFx0XHR2YXIganFUYWJsZSAgID0gJCh0YWJsZSk7XG5cdFx0XHR2YXIganFUYm9keSAgID0gJCh0Ym9keSk7XG5cdFx0XHR2YXIganFXcmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcblx0XHRcdHZhciByb3dzICAgICAgPSAkLm1hcCggc2V0dGluZ3MuYW9EYXRhLCBmdW5jdGlvbiAocikgeyByZXR1cm4gci5uVHI7IH0gKTtcblx0XHRcdHZhciBpLCBpZW47XG5cdFxuXHRcdFx0Ly8gRmxhZyB0byBub3RlIHRoYXQgdGhlIHRhYmxlIGlzIGN1cnJlbnRseSBiZWluZyBkZXN0cm95ZWQgLSBubyBhY3Rpb25cblx0XHRcdC8vIHNob3VsZCBiZSB0YWtlblxuXHRcdFx0c2V0dGluZ3MuYkRlc3Ryb3lpbmcgPSB0cnVlO1xuXHRcblx0XHRcdC8vIEZpcmUgb2ZmIHRoZSBkZXN0cm95IGNhbGxiYWNrcyBmb3IgcGx1Zy1pbnMgZXRjXG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvRGVzdHJveUNhbGxiYWNrXCIsIFwiZGVzdHJveVwiLCBbc2V0dGluZ3NdICk7XG5cdFxuXHRcdFx0Ly8gSWYgbm90IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQsIG1ha2UgYWxsIGNvbHVtbnMgdmlzaWJsZVxuXHRcdFx0aWYgKCAhIHJlbW92ZSApIHtcblx0XHRcdFx0bmV3IF9BcGkoIHNldHRpbmdzICkuY29sdW1ucygpLnZpc2libGUoIHRydWUgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBCbGl0eiBhbGwgYERUYCBuYW1lc3BhY2VkIGV2ZW50cyAodGhlc2UgYXJlIGludGVybmFsIGV2ZW50cywgdGhlXG5cdFx0XHQvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXG5cdFx0XHQvLyBmb3IgcmVtb3ZpbmcgdGhlbVxuXHRcdFx0anFXcmFwcGVyLm9mZignLkRUJykuZmluZCgnOm5vdCh0Ym9keSAqKScpLm9mZignLkRUJyk7XG5cdFx0XHQkKHdpbmRvdykub2ZmKCcuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UpO1xuXHRcblx0XHRcdC8vIFdoZW4gc2Nyb2xsaW5nIHdlIGhhZCB0byBicmVhayB0aGUgdGFibGUgdXAgLSByZXN0b3JlIGl0XG5cdFx0XHRpZiAoIHRhYmxlICE9IHRoZWFkLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuZGV0YWNoKCk7XG5cdFx0XHRcdGpxVGFibGUuYXBwZW5kKCB0aGVhZCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggdGZvb3QgJiYgdGFibGUgIT0gdGZvb3QucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0anFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcblx0XHRcdFx0anFUYWJsZS5hcHBlbmQoIHRmb290ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCA9IFtdO1xuXHRcdFx0X2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0JCggcm93cyApLnJlbW92ZUNsYXNzKCBzZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXMuam9pbignICcpICk7XG5cdFxuXHRcdFx0JCgndGgsIHRkJywgdGhlYWQpLnJlbW92ZUNsYXNzKCBjbGFzc2VzLnNTb3J0YWJsZSsnICcrXG5cdFx0XHRcdGNsYXNzZXMuc1NvcnRhYmxlQXNjKycgJytjbGFzc2VzLnNTb3J0YWJsZURlc2MrJyAnK2NsYXNzZXMuc1NvcnRhYmxlTm9uZVxuXHRcdFx0KTtcblx0XG5cdFx0XHQvLyBBZGQgdGhlIFRSIGVsZW1lbnRzIGJhY2sgaW50byB0aGUgdGFibGUgaW4gdGhlaXIgb3JpZ2luYWwgb3JkZXJcblx0XHRcdGpxVGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0XHRcdGpxVGJvZHkuYXBwZW5kKCByb3dzICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBEYXRhVGFibGVzIGdlbmVyYXRlZCBub2RlcywgZXZlbnRzIGFuZCBjbGFzc2VzXG5cdFx0XHR2YXIgcmVtb3ZlZE1ldGhvZCA9IHJlbW92ZSA/ICdyZW1vdmUnIDogJ2RldGFjaCc7XG5cdFx0XHRqcVRhYmxlWyByZW1vdmVkTWV0aG9kIF0oKTtcblx0XHRcdGpxV3JhcHBlclsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFxuXHRcdFx0Ly8gSWYgd2UgbmVlZCB0byByZWF0dGFjaCB0aGUgdGFibGUgdG8gdGhlIGRvY3VtZW50XG5cdFx0XHRpZiAoICEgcmVtb3ZlICYmIG9yaWcgKSB7XG5cdFx0XHRcdC8vIGluc2VydEJlZm9yZSBhY3RzIGxpa2UgYXBwZW5kQ2hpbGQgaWYgIWFyZ1sxXVxuXHRcdFx0XHRvcmlnLmluc2VydEJlZm9yZSggdGFibGUsIHNldHRpbmdzLm5UYWJsZVJlaW5zZXJ0QmVmb3JlICk7XG5cdFxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgdGFibGUgLSB3YXMgcmVhZCBmcm9tIHRoZSBzdHlsZSBwcm9wZXJ0eSxcblx0XHRcdFx0Ly8gc28gd2UgY2FuIHJlc3RvcmUgZGlyZWN0bHkgdG8gdGhhdFxuXHRcdFx0XHRqcVRhYmxlXG5cdFx0XHRcdFx0LmNzcyggJ3dpZHRoJywgc2V0dGluZ3Muc0Rlc3Ryb3lXaWR0aCApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjbGFzc2VzLnNUYWJsZSApO1xuXHRcblx0XHRcdFx0Ly8gSWYgdGhlIHdlcmUgb3JpZ2luYWxseSBzdHJpcGUgY2xhc3NlcyAtIHRoZW4gd2UgYWRkIHRoZW0gYmFjayBoZXJlLlxuXHRcdFx0XHQvLyBOb3RlIHRoaXMgaXMgbm90IGZvb2wgcHJvb2YgKGZvciBleGFtcGxlIGlmIG5vdCBhbGwgcm93cyBoYWQgc3RyaXBlXG5cdFx0XHRcdC8vIGNsYXNzZXMgLSBidXQgaXQncyBhIGdvb2QgZWZmb3J0IHdpdGhvdXQgZ2V0dGluZyBjYXJyaWVkIGF3YXlcblx0XHRcdFx0aWVuID0gc2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcy5sZW5ndGg7XG5cdFxuXHRcdFx0XHRpZiAoIGllbiApIHtcblx0XHRcdFx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZWFjaCggZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoIHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXNbaSAlIGllbl0gKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvKiBSZW1vdmUgdGhlIHNldHRpbmdzIG9iamVjdCBmcm9tIHRoZSBzZXR0aW5ncyBhcnJheSAqL1xuXHRcdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggc2V0dGluZ3MsIERhdGFUYWJsZS5zZXR0aW5ncyApO1xuXHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHREYXRhVGFibGUuc2V0dGluZ3Muc3BsaWNlKCBpZHgsIDEgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBBZGQgdGhlIGBldmVyeSgpYCBtZXRob2QgZm9yIHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzIGluIGEgY29tcGFjdCBmb3JtXG5cdCQuZWFjaCggWyAnY29sdW1uJywgJ3JvdycsICdjZWxsJyBdLCBmdW5jdGlvbiAoIGksIHR5cGUgKSB7XG5cdFx0X2FwaV9yZWdpc3RlciggdHlwZSsncygpLmV2ZXJ5KCknLCBmdW5jdGlvbiAoIGZuICkge1xuXHRcdFx0dmFyIG9wdHMgPSB0aGlzLnNlbGVjdG9yLm9wdHM7XG5cdFx0XHR2YXIgYXBpID0gdGhpcztcblx0XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggdHlwZSwgZnVuY3Rpb24gKCBzZXR0aW5ncywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCApIHtcblx0XHRcdFx0Ly8gUm93cyBhbmQgY29sdW1uczpcblx0XHRcdFx0Ly8gIGFyZzEgLSBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMiAtIHRhYmxlIGNvdW50ZXJcblx0XHRcdFx0Ly8gIGFyZzMgLSBsb29wIGNvdW50ZXJcblx0XHRcdFx0Ly8gIGFyZzQgLSB1bmRlZmluZWRcblx0XHRcdFx0Ly8gQ2VsbHM6XG5cdFx0XHRcdC8vICBhcmcxIC0gcm93IGluZGV4XG5cdFx0XHRcdC8vICBhcmcyIC0gY29sdW1uIGluZGV4XG5cdFx0XHRcdC8vICBhcmczIC0gdGFibGUgY291bnRlclxuXHRcdFx0XHQvLyAgYXJnNCAtIGxvb3AgY291bnRlclxuXHRcdFx0XHRmbi5jYWxsKFxuXHRcdFx0XHRcdGFwaVsgdHlwZSBdKFxuXHRcdFx0XHRcdFx0YXJnMSxcblx0XHRcdFx0XHRcdHR5cGU9PT0nY2VsbCcgPyBhcmcyIDogb3B0cyxcblx0XHRcdFx0XHRcdHR5cGU9PT0nY2VsbCcgPyBvcHRzIDogdW5kZWZpbmVkXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRhcmcxLCBhcmcyLCBhcmczLCBhcmc0XG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gaTE4biBtZXRob2QgZm9yIGV4dGVuc2lvbnMgdG8gYmUgYWJsZSB0byB1c2UgdGhlIGxhbmd1YWdlIG9iamVjdCBmcm9tIHRoZVxuXHQvLyBEYXRhVGFibGVcblx0X2FwaV9yZWdpc3RlciggJ2kxOG4oKScsIGZ1bmN0aW9uICggdG9rZW4sIGRlZiwgcGx1cmFsICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdFx0dmFyIHJlc29sdmVkID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCB0b2tlbiApKCBjdHgub0xhbmd1YWdlICk7XG5cdFxuXHRcdGlmICggcmVzb2x2ZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJlc29sdmVkID0gZGVmO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBwbHVyYWwgIT09IHVuZGVmaW5lZCAmJiAkLmlzUGxhaW5PYmplY3QoIHJlc29sdmVkICkgKSB7XG5cdFx0XHRyZXNvbHZlZCA9IHJlc29sdmVkWyBwbHVyYWwgXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cmVzb2x2ZWRbIHBsdXJhbCBdIDpcblx0XHRcdFx0cmVzb2x2ZWQuXztcblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXNvbHZlZC5yZXBsYWNlKCAnJWQnLCBwbHVyYWwgKTsgLy8gbmI6IHBsdXJhbCBtaWdodCBiZSB1bmRlZmluZWQsXG5cdH0gKTtcblx0LyoqXG5cdCAqIFZlcnNpb24gc3RyaW5nIGZvciBwbHVnLWlucyB0byBjaGVjayBjb21wYXRpYmlsaXR5LiBBbGxvd2VkIGZvcm1hdCBpc1xuXHQgKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcblx0ICogb25seSBmb3Igbm9uLXJlbGVhc2UgYnVpbGRzLiBTZWUgaHR0cDovL3NlbXZlci5vcmcvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBWZXJzaW9uIG51bWJlclxuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb24gPSBcIjEuMTEuM1wiO1xuXG5cdC8qKlxuXHQgKiBQcml2YXRlIGRhdGEgc3RvcmUsIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBzZXR0aW5ncyBvYmplY3RzIHRoYXQgYXJlXG5cdCAqIGNyZWF0ZWQgZm9yIHRoZSB0YWJsZXMgb24gYSBnaXZlbiBwYWdlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuc2V0dGluZ3NgIG9iamVjdCBpcyBhbGlhc2VkIHRvXG5cdCAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCB0aHJvdWdoIHdoaWNoIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmRcblx0ICogbWFuaXB1bGF0ZWQsIG9yIGBqUXVlcnkuZm4uZGF0YVRhYmxlLnNldHRpbmdzYC5cblx0ICogIEBtZW1iZXJcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdERhdGFUYWJsZS5zZXR0aW5ncyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBPYmplY3QgbW9kZWxzIGNvbnRhaW5lciwgZm9yIHRoZSB2YXJpb3VzIG1vZGVscyB0aGF0IERhdGFUYWJsZXMgaGFzXG5cdCAqIGF2YWlsYWJsZSB0byBpdC4gVGhlc2UgbW9kZWxzIGRlZmluZSB0aGUgb2JqZWN0cyB0aGF0IGFyZSB1c2VkIHRvIGhvbGRcblx0ICogdGhlIGFjdGl2ZSBzdGF0ZSBhbmQgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFibGUuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzID0ge307XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxuXHQgKiBzZWFyY2ggaW5mb3JtYXRpb24gZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXJzLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoID0ge1xuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGZpbHRlcmluZyBzaG91bGQgYmUgY2FzZSBpbnNlbnNpdGl2ZSBvciBub3Rcblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0XCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHRydWUsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFwcGxpZWQgc2VhcmNoIHRlcm1cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKi9cblx0XHRcInNTZWFyY2hcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgc2VhcmNoIHRlcm0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGFcblx0XHQgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcblx0XHQgKiByZWdleCBjaGFyYWN0ZXJzIGVzY2FwZWQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJSZWdleFwiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIGlzIHRvIHVzZSBpdHMgc21hcnQgZmlsdGVyaW5nIG9yIG5vdC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0XCJiU21hcnRcIjogdHJ1ZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZWFyY2ggd2hlblxuXHRcdCAqIHRoZSByZXR1cm4ga2V5IGlzIHByZXNzZWQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcInJldHVyblwiOiBmYWxzZVxuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIGVhY2ggaW5kaXZpZHVhbCByb3cuIFRoaXMgaXMgdGhlIG9iamVjdCBmb3JtYXQgdXNlZCBmb3IgdGhlIHNldHRpbmdzXG5cdCAqIGFvRGF0YSBhcnJheS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub1JvdyA9IHtcblx0XHQvKipcblx0XHQgKiBUUiBlbGVtZW50IGZvciB0aGUgcm93XG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIFREIGVsZW1lbnRzIGZvciBlYWNoIHJvdy4gVGhpcyBpcyBudWxsIHVudGlsIHRoZSByb3cgaGFzIGJlZW5cblx0XHQgKiBjcmVhdGVkLlxuXHRcdCAqICBAdHlwZSBhcnJheSBub2Rlc1xuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW5DZWxsc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBEYXRhIG9iamVjdCBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdy4gVGhpcyBpcyBlaXRoZXJcblx0XHQgKiBhbiBhcnJheSBpZiB1c2luZyB0aGUgdHJhZGl0aW9uYWwgZm9ybSBvZiBEYXRhVGFibGVzLCBvciBhbiBvYmplY3QgaWZcblx0XHQgKiB1c2luZyBtRGF0YSBvcHRpb25zLiBUaGUgZXhhY3QgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgcGFzc2VkIGluXG5cdFx0ICogZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSwgb3Igd2lsbCBiZSBhbiBhcnJheSBpZiB1c2luZyBET00gYSBkYXRhXG5cdFx0ICogc291cmNlLlxuXHRcdCAqICBAdHlwZSBhcnJheXxvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcIl9hRGF0YVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcblx0XHQgKiBudW1iZXIgb2YgY29sdW1ucyAoYWx0aG91Z2ggZWFjaCBpbmRleCBpcyBnZW5lcmF0ZWQgb25seSBhcyBpdCBpc1xuXHRcdCAqIG5lZWRlZCksIGFuZCBob2xkcyB0aGUgZGF0YSB0aGF0IGlzIHVzZWQgZm9yIHNvcnRpbmcgZWFjaCBjb2x1bW4gaW4gdGhlXG5cdFx0ICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcblx0XHQgKiB0aGUgZm9ybWF0dGluZyBvZiB0aGUgc29ydCBkYXRhIG5lZWQgYmUgZG9uZSBvbmx5IG9uY2UgZm9yIGVhY2ggY2VsbFxuXHRcdCAqIHBlciBzb3J0LiBUaGlzIGFycmF5IHNob3VsZCBub3QgYmUgcmVhZCBmcm9tIG9yIHdyaXR0ZW4gdG8gYnkgYW55dGhpbmdcblx0XHQgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYVNvcnREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlciBjZWxsIGZpbHRlcmluZyBkYXRhIGNhY2hlLiBBcyBwZXIgdGhlIHNvcnQgZGF0YSBjYWNoZSwgdXNlZCB0b1xuXHRcdCAqIGluY3JlYXNlIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgZmlsdGVyaW5nIGluIERhdGFUYWJsZXNcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2FGaWx0ZXJEYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlcmluZyBkYXRhIGNhY2hlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBjZWxsIGZpbHRlcmluZyBjYWNoZSwgYnV0XG5cdFx0ICogaW4gdGhpcyBjYXNlIGEgc3RyaW5nIHJhdGhlciB0aGFuIGFuIGFycmF5LiBUaGlzIGlzIGVhc2lseSBjb21wdXRlZCB3aXRoXG5cdFx0ICogYSBqb2luIG9uIGBfYUZpbHRlckRhdGFgLCBidXQgaXMgcHJvdmlkZWQgYXMgYSBjYWNoZSBzbyB0aGUgam9pbiBpc24ndFxuXHRcdCAqIG5lZWRlZCBvbiBldmVyeSBzZWFyY2ggKG1lbW9yeSB0cmFkZWQgZm9yIHBlcmZvcm1hbmNlKVxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfc0ZpbHRlclJvd1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWNoZSBvZiB0aGUgY2xhc3MgbmFtZSB0aGF0IERhdGFUYWJsZXMgaGFzIGFwcGxpZWQgdG8gdGhlIHJvdywgc28gd2Vcblx0XHQgKiBjYW4gcXVpY2tseSBsb29rIGF0IHRoaXMgdmFyaWFibGUgcmF0aGVyIHRoYW4gbmVlZGluZyB0byBkbyBhIERPTSBjaGVja1xuXHRcdCAqIG9uIGNsYXNzTmFtZSBmb3IgdGhlIG5UciBwcm9wZXJ0eS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9zUm93U3RyaXBlXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlbm90ZSBpZiB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2Ugd2FzIGZyb20gdGhlIERPTSwgb3IgdGhlIGRhdGEgc291cmNlXG5cdFx0ICogb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yIGludmFsaWRhdGluZyBkYXRhLCBzbyBEYXRhVGFibGVzIGNhblxuXHRcdCAqIGF1dG9tYXRpY2FsbHkgcmVhZCBkYXRhIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSwgdW5sZXNzIHVuaW5zdHJ1Y3RlZFxuXHRcdCAqIG90aGVyd2lzZS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcInNyY1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRleCBpbiB0aGUgYW9EYXRhIGFycmF5LiBUaGlzIHNhdmVzIGFuIGluZGV4T2YgbG9va3VwIHdoZW4gd2UgaGF2ZSB0aGVcblx0XHQgKiBvYmplY3QsIGJ1dCB3YW50IHRvIGtub3cgdGhlIGluZGV4XG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgLTFcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcImlkeFwiOiAtMVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb2JqZWN0IGluIERhdGFUYWJsZXMuIFRoaXMgb2JqZWN0XG5cdCAqIGlzIGhlbGQgaW4gdGhlIHNldHRpbmdzIGFvQ29sdW1ucyBhcnJheSBhbmQgY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvbiB0aGF0XG5cdCAqIERhdGFUYWJsZXMgbmVlZHMgYWJvdXQgZWFjaCBpbmRpdmlkdWFsIGNvbHVtbi5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59XG5cdCAqIGJ1dCB0aGlzIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuXG5cdCAqIEl0IHNob3VsZCBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGRcblx0ICogYmUgZG9uZSB0aHJvdWdoIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uID0ge1xuXHRcdC8qKlxuXHRcdCAqIENvbHVtbiBpbmRleC4gVGhpcyBjb3VsZCBiZSB3b3JrZWQgb3V0IG9uLXRoZS1mbHkgd2l0aCAkLmluQXJyYXksIGJ1dCBpdFxuXHRcdCAqIGlzIGZhc3RlciB0byBqdXN0IGhvbGQgaXQgYXMgYSB2YXJpYWJsZVxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImlkeFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2YgdGhlIGNvbHVtbnMgdGhhdCBzb3J0aW5nIHNob3VsZCBvY2N1ciBvbiB3aGVuIHRoaXMgY29sdW1uXG5cdFx0ICogaXMgc29ydGVkLiBUaGF0IHRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXkgYWxsb3dzIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdFx0ICogdG8gYmUgZGVmaW5lZCBmb3IgYSBjb2x1bW4gKGZvciBleGFtcGxlIGZpcnN0IG5hbWUgLyBsYXN0IG5hbWUgY29sdW1uc1xuXHRcdCAqIHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzKS4gVGhlIHZhbHVlcyBhcmUgaW50ZWdlcnMgcG9pbnRpbmcgdG8gdGhlXG5cdFx0ICogY29sdW1ucyB0byBiZSBzb3J0ZWQgb24gKHR5cGljYWxseSBpdCB3aWxsIGJlIGEgc2luZ2xlIGludGVnZXIgcG9pbnRpbmdcblx0XHQgKiBhdCBpdHNlbGYsIGJ1dCB0aGF0IGRvZXNuJ3QgbmVlZCB0byBiZSB0aGUgY2FzZSkuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICovXG5cdFx0XCJhRGF0YVNvcnRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIHRoZSBzb3J0aW5nIGRpcmVjdGlvbnMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgY29sdW1uLCBpbiBzZXF1ZW5jZVxuXHRcdCAqIGFzIHRoZSBjb2x1bW4gaXMgcmVwZWF0ZWRseSBzb3J0ZWQgdXBvbiAtIGkuZS4gdGhlIGZpcnN0IHZhbHVlIGlzIHVzZWRcblx0XHQgKiBhcyB0aGUgc29ydGluZyBkaXJlY3Rpb24gd2hlbiB0aGUgY29sdW1uIGlmIGZpcnN0IHNvcnRlZCAoY2xpY2tlZCBvbikuXG5cdFx0ICogU29ydCBpdCBhZ2FpbiAoY2xpY2sgYWdhaW4pIGFuZCBpdCB3aWxsIG1vdmUgb24gdG8gdGhlIG5leHQgaW5kZXguXG5cdFx0ICogUmVwZWF0IHVudGlsIGxvb3AuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICovXG5cdFx0XCJhc1NvcnRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNlYXJjaGFibGUsIGFuZCB0aHVzIHNob3VsZCBiZSBpbmNsdWRlZFxuXHRcdCAqIGluIHRoZSBmaWx0ZXJpbmcgb3Igbm90LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU2VhcmNoYWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc29ydGFibGUgb3Igbm90LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU29ydGFibGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlZpc2libGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgZm9yIG1hbnVhbCB0eXBlIGFzc2lnbm1lbnQgdXNpbmcgdGhlIGBjb2x1bW4udHlwZWAgb3B0aW9uLiBUaGlzXG5cdFx0ICogaXMgaGVsZCBpbiBzdG9yZSBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSB0aGUgY29sdW1uJ3MgYHNUeXBlYCBwcm9wZXJ0eS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9zTWFudWFsVHlwZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIEhUTUw1IGRhdGEgYXR0cmlidXRlcyBzaG91bGQgYmUgdXNlZCBhcyB0aGUgZGF0YVxuXHRcdCAqIHNvdXJjZSBmb3IgZmlsdGVyaW5nIG9yIHNvcnRpbmcuIFRydWUgaXMgZWl0aGVyIGFyZS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2JBdHRyU3JjXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcblx0XHQgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXG5cdFx0ICogYWxsb3dpbmcgeW91IHRvIG1vZGlmeSB0aGUgRE9NIGVsZW1lbnQgKGFkZCBiYWNrZ3JvdW5kIGNvbG91ciBmb3IgZXhhbXBsZSkgd2hlbiB0aGVcblx0XHQgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtlbGVtZW50fSBuVGQgVGhlIFREIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG5cdFx0ICogIEBwYXJhbSB7Kn0gc0RhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gaVJvdyBUaGUgcm93IGluZGV4IGZvciB0aGUgYW9EYXRhIGRhdGEgc3RvcmVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbiB0byBnZXQgZGF0YSBmcm9tIGEgY2VsbCBpbiBhIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0XHQgKiBhY2Nlc3MgZGF0YSBkaXJlY3RseSB0aHJvdWdoIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdFx0ICogdGhlIG1ldGhvZCBhdHRhY2hlZCB0byB0aGlzIHByb3BlcnR5LiBJdCBhbGxvd3MgbURhdGEgdG8gZnVuY3Rpb24gYXNcblx0XHQgKiByZXF1aXJlZC4gVGhpcyBmdW5jdGlvbiBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIGJ5IHRoZSBjb2x1bW5cblx0XHQgKiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGFycmF5L29iamVjdCBmb3IgdGhlIGFycmF5XG5cdFx0ICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc1NwZWNpZmljIFRoZSBzcGVjaWZpYyBkYXRhIHR5cGUgeW91IHdhbnQgdG8gZ2V0IC1cblx0XHQgKiAgICAnZGlzcGxheScsICd0eXBlJyAnZmlsdGVyJyAnc29ydCdcblx0XHQgKiAgQHJldHVybnMgeyp9IFRoZSBkYXRhIGZvciB0aGUgY2VsbCBmcm9tIHRoZSBnaXZlbiByb3cncyBkYXRhXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImZuR2V0RGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbiB0byBzZXQgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XG5cdFx0ICogc2V0IHRoZSBkYXRhIGRpcmVjdGx5IHRvIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdFx0ICogdGhpcyBtZXRob2QuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhcyByZXF1aXJlZC4gVGhpcyBmdW5jdGlvblxuXHRcdCAqIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtbiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGFycmF5L29iamVjdCBmb3IgdGhlIGFycmF5XG5cdFx0ICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxuXHRcdCAqICBAcGFyYW0geyp9IHNWYWx1ZSBWYWx1ZSB0byBzZXRcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5TZXREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHRvIHJlYWQgdGhlIHZhbHVlIGZvciB0aGUgY2VsbHMgaW4gdGhlIGNvbHVtbiBmcm9tIHRoZSBkYXRhXG5cdFx0ICogc291cmNlIGFycmF5IC8gb2JqZWN0LiBJZiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IGNvbnRlbnQgaXMgdXNlZCwgaWYgYVxuXHRcdCAqIGZ1bmN0aW9uIGlzIGdpdmVuIHRoZW4gdGhlIHJldHVybiBmcm9tIHRoZSBmdW5jdGlvbiBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvbnxpbnR8c3RyaW5nfG51bGxcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwibURhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFydG5lciBwcm9wZXJ0eSB0byBtRGF0YSB3aGljaCBpcyB1c2VkIChvbmx5IHdoZW4gZGVmaW5lZCkgdG8gZ2V0XG5cdFx0ICogdGhlIGRhdGEgLSBpLmUuIGl0IGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBtRGF0YSwgYnV0IHdpdGhvdXQgdGhlXG5cdFx0ICogJ3NldCcgb3B0aW9uLCBhbmQgYWxzbyB0aGUgZGF0YSBmZWQgdG8gaXQgaXMgdGhlIHJlc3VsdCBmcm9tIG1EYXRhLlxuXHRcdCAqIFRoaXMgaXMgdGhlIHJlbmRlcmluZyBtZXRob2QgdG8gbWF0Y2ggdGhlIGRhdGEgbWV0aG9kIG9mIG1EYXRhLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvbnxpbnR8c3RyaW5nfG51bGxcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwibVJlbmRlclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgaGVhZGVyIFRIL1REIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uIC0gdGhpcyBpcyB3aGF0IHRoZSBzb3J0aW5nXG5cdFx0ICogbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gKGlmIHNvcnRpbmcgaXMgZW5hYmxlZC4pXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRoXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBmb290ZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gKGlmIHRoZXJlIGlzIG9uZSkuIE5vdCB1c2VkXG5cdFx0ICogaW4gRGF0YVRhYmxlcyBhcyBzdWNoLCBidXQgY2FuIGJlIHVzZWQgZm9yIHBsdWctaW5zIHRvIHJlZmVyZW5jZSB0aGVcblx0XHQgKiBmb290ZXIgZm9yIGVhY2ggY29sdW1uLlxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UZlwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY2xhc3MgdG8gYXBwbHkgdG8gYWxsIFREIGVsZW1lbnRzIGluIHRoZSB0YWJsZSdzIFRCT0RZIGZvciB0aGUgY29sdW1uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzQ2xhc3NcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuXHRcdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0XHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0XHQgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuXHRcdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0XHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdFx0ICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuXHRcdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic0NvbnRlbnRQYWRkaW5nXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHRcdCAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBtRGF0YVxuXHRcdCAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzRGVmYXVsdENvbnRlbnRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTmFtZSBmb3IgdGhlIGNvbHVtbiwgYWxsb3dpbmcgcmVmZXJlbmNlIHRvIHRoZSBjb2x1bW4gYnkgbmFtZSBhcyB3ZWxsIGFzXG5cdFx0ICogYnkgaW5kZXggKG5lZWRzIGEgbG9va3VwIHRvIHdvcmsgYnkgbmFtZSkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic05hbWVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ3VzdG9tIHNvcnRpbmcgZGF0YSB0eXBlIC0gZGVmaW5lcyB3aGljaCBvZiB0aGUgYXZhaWxhYmxlIHBsdWctaW5zIGluXG5cdFx0ICogYWZuU29ydERhdGEgdGhlIGN1c3RvbSBzb3J0aW5nIHdpbGwgdXNlIC0gaWYgYW55IGlzIGRlZmluZWQuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBzdGRcblx0XHQgKi9cblx0XHRcInNTb3J0RGF0YVR5cGVcIjogJ3N0ZCcsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtblxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1NvcnRpbmdDbGFzc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgZWxlbWVudCB3aGVuIHNvcnRpbmcgb24gdGhpcyBjb2x1bW4gLVxuXHRcdCAqIHdoZW4galF1ZXJ5IFVJIHRoZW1pbmcgaXMgdXNlZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNTb3J0aW5nQ2xhc3NKVUlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVGl0bGUgb2YgdGhlIGNvbHVtbiAtIHdoYXQgaXMgc2VlbiBpbiB0aGUgVEggZWxlbWVudCAoblRoKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzVGl0bGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ29sdW1uIHNvcnRpbmcgYW5kIGZpbHRlcmluZyB0eXBlXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzVHlwZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzV2lkdGhcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogV2lkdGggb2YgdGhlIGNvbHVtbiB3aGVuIGl0IHdhcyBmaXJzdCBcImVuY291bnRlcmVkXCJcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNXaWR0aE9yaWdcIjogbnVsbFxuXHR9O1xuXHRcblx0XG5cdC8qXG5cdCAqIERldmVsb3BlciBub3RlOiBUaGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGJlbG93IGFyZSBnaXZlbiBpbiBIdW5nYXJpYW5cblx0ICogbm90YXRpb24sIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGludGVyZmFjZSBmb3IgRGF0YVRhYmxlcyBwcmlvciB0byB2MS4xMCwgaG93ZXZlclxuXHQgKiBmcm9tIHYxLjEwIG9ud2FyZHMgdGhlIHByaW1hcnkgaW50ZXJmYWNlIGlzIGNhbWVsIGNhc2UuIEluIG9yZGVyIHRvIGF2b2lkXG5cdCAqIGJyZWFraW5nIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHV0dGVybHkgd2l0aCB0aGlzIGNoYW5nZSwgdGhlIEh1bmdhcmlhblxuXHQgKiB2ZXJzaW9uIGlzIHN0aWxsLCBpbnRlcm5hbGx5IHRoZSBwcmltYXJ5IGludGVyZmFjZSwgYnV0IGlzIGlzIG5vdCBkb2N1bWVudGVkXG5cdCAqIC0gaGVuY2UgdGhlIEBuYW1lIHRhZ3MgaW4gZWFjaCBkb2MgY29tbWVudC4gVGhpcyBhbGxvd3MgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uXG5cdCAqIHRvIGNyZWF0ZSBhIG1hcCBmcm9tIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbCBjYXNlIChnb2luZyB0aGUgb3RoZXIgZGlyZWN0aW9uXG5cdCAqIHdvdWxkIHJlcXVpcmUgZWFjaCBwcm9wZXJ0eSB0byBiZSBsaXN0ZWQsIHdoaWNoIHdvdWxkIGFkZCBhcm91bmQgM0sgdG8gdGhlIHNpemVcblx0ICogb2YgRGF0YVRhYmxlcywgd2hpbGUgdGhpcyBtZXRob2QgaXMgYWJvdXQgYSAwLjVLIGhpdCkuXG5cdCAqXG5cdCAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcblx0ICogY29tcGxldGVseSwgYnV0IHRoYXQgaXMgYSBtYXNzaXZlIGFtb3VudCBvZiB3b3JrIGFuZCB3aWxsIGJyZWFrIGN1cnJlbnRcblx0ICogaW5zdGFsbHMgKHRoZXJlZm9yZSBpcyBvbi1ob2xkIHVudGlsIHYyKS5cblx0ICovXG5cdFxuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXG5cdCAqIHRpbWUuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUuZGVmYXVsdHMgPSB7XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG5cdFx0ICogd2lsbCBiZSB1c2VkIGluIHByZWZlcmVuY2UgdG8gYW55IGRhdGEgd2hpY2ggaXMgYWxyZWFkeSBpbiB0aGUgRE9NLiBUaGlzIGlzXG5cdFx0ICogcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIHRhYmxlcyBwdXJlbHkgaW4gSmF2YXNjcmlwdCwgZm9yXG5cdFx0ICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRhdGFcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGEgMkQgYXJyYXkgZGF0YSBzb3VyY2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkYXRhXCI6IFtcblx0XHQgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNC4wJywgJ1dpbiA5NSsnLCA0LCAnWCddLFxuXHRcdCAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA1LjAnLCAnV2luIDk1KycsIDUsICdDJ10sXG5cdFx0ICogICAgICAgIF0sXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiRW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJCcm93c2VyXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiVmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiR3JhZGVcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFzIGEgZGF0YSBzb3VyY2UgKGBkYXRhYClcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkYXRhXCI6IFtcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJicm93c2VyXCI6ICBcIkludGVybmV0IEV4cGxvcmVyIDQuMFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcblx0XHQgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNCxcblx0XHQgKiAgICAgICAgICAgIFwiZ3JhZGVcIjogICAgXCJYXCJcblx0XHQgKiAgICAgICAgICB9LFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG5cdFx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNS4wXCIsXG5cdFx0ICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxuXHRcdCAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA1LFxuXHRcdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIkNcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXSxcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiwgICBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiwgIFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIsIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIsICBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiLCAgICBcImRhdGFcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFhRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgb3JkZXJpbmcgaXMgZW5hYmxlZCwgdGhlbiBEYXRhVGFibGVzIHdpbGwgcGVyZm9ybSBhIGZpcnN0IHBhc3Mgc29ydCBvblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uLiBZb3UgY2FuIGRlZmluZSB3aGljaCBjb2x1bW4ocykgdGhlIHNvcnQgaXMgcGVyZm9ybWVkXG5cdFx0ICogdXBvbiwgYW5kIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiwgd2l0aCB0aGlzIHZhcmlhYmxlLiBUaGUgYHNvcnRpbmdgIGFycmF5XG5cdFx0ICogc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgZm9yIGVhY2ggY29sdW1uIHRvIGJlIHNvcnRlZCBpbml0aWFsbHkgY29udGFpbmluZ1xuXHRcdCAqIHRoZSBjb2x1bW4ncyBpbmRleCBhbmQgYSBkaXJlY3Rpb24gc3RyaW5nICgnYXNjJyBvciAnZGVzYycpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbWzAsJ2FzYyddXVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBTb3J0IGJ5IDNyZCBjb2x1bW4gZmlyc3QsIGFuZCB0aGVuIDR0aCBjb2x1bW5cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyXCI6IFtbMiwnYXNjJ10sIFszLCdkZXNjJ11dXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgLy8gTm8gaW5pdGlhbCBzb3J0aW5nXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlclwiOiBbXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ1wiOiBbWzAsJ2FzYyddXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcGFyYW1ldGVyIGlzIGJhc2ljYWxseSBpZGVudGljYWwgdG8gdGhlIGBzb3J0aW5nYCBwYXJhbWV0ZXIsIGJ1dFxuXHRcdCAqIGNhbm5vdCBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgdGFibGUuIFdoYXQgdGhpcyBtZWFuc1xuXHRcdCAqIGlzIHRoYXQgeW91IGNvdWxkIGhhdmUgYSBjb2x1bW4gKHZpc2libGUgb3IgaGlkZGVuKSB3aGljaCB0aGUgc29ydGluZ1xuXHRcdCAqIHdpbGwgYWx3YXlzIGJlIGZvcmNlZCBvbiBmaXJzdCAtIGFueSBzb3J0aW5nIGFmdGVyIHRoYXQgKGZyb20gdGhlIHVzZXIpXG5cdFx0ICogd2lsbCB0aGVuIGJlIHBlcmZvcm1lZCBhcyByZXF1aXJlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBncm91cGluZyByb3dzXG5cdFx0ICogdG9nZXRoZXIuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckZpeGVkXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyRml4ZWRcIjogW1swLCdhc2MnXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXG5cdFx0ICogQWpheCBzb3VyY2UuIFRoaXMgb3B0aW9uIGRlZmluZXMgaG93IHRoYXQgQWpheCBjYWxsIGlzIG1hZGUgYW5kIHdoZXJlIHRvLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXG5cdFx0ICogaG93IGl0IGlzIGRlZmluZWQuIFRoZXNlIGFyZTpcblx0XHQgKlxuXHRcdCAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cblx0XHQgKiAqIGBvYmplY3RgIC0gRGVmaW5lIHByb3BlcnRpZXMgZm9yIGBqUXVlcnkuYWpheGAuXG5cdFx0ICogKiBgZnVuY3Rpb25gIC0gQ3VzdG9tIGRhdGEgZ2V0IGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiBgc3RyaW5nYFxuXHRcdCAqIC0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhIHN0cmluZywgdGhlIGBhamF4YCBwcm9wZXJ0eSBzaW1wbHkgZGVmaW5lcyB0aGUgVVJMIGZyb20gd2hpY2hcblx0XHQgKiBEYXRhVGFibGVzIHdpbGwgbG9hZCBkYXRhLlxuXHRcdCAqXG5cdFx0ICogYG9iamVjdGBcblx0XHQgKiAtLS0tLS0tLVxuXHRcdCAqXG5cdFx0ICogQXMgYW4gb2JqZWN0LCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgb2JqZWN0IGFyZSBwYXNzZWQgdG9cblx0XHQgKiBbalF1ZXJ5LmFqYXhdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxuXHRcdCAqIG9mIHRoZSBBamF4IHJlcXVlc3QuIERhdGFUYWJsZXMgaGFzIGEgbnVtYmVyIG9mIGRlZmF1bHQgcGFyYW1ldGVycyB3aGljaFxuXHRcdCAqIHlvdSBjYW4gb3ZlcnJpZGUgdXNpbmcgdGhpcyBvcHRpb24uIFBsZWFzZSByZWZlciB0byB0aGUgalF1ZXJ5XG5cdFx0ICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcblx0XHQgKiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgaW4gRGF0YVRhYmxlcyBvclxuXHRcdCAqIHJlcXVpcmUgc3BlY2lhbCBjb25zaWRlcmF0aW9uOlxuXHRcdCAqXG5cdFx0ICogKiBgZGF0YWAgLSBBcyB3aXRoIGpRdWVyeSwgYGRhdGFgIGNhbiBiZSBwcm92aWRlZCBhcyBhbiBvYmplY3QsIGJ1dCBpdFxuXHRcdCAqICAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgdGhlIGRhdGEgRGF0YVRhYmxlcyBzZW5kc1xuXHRcdCAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXG5cdFx0ICogICBwYXJhbWV0ZXJzIHdpdGggdGhlIHZhbHVlcyB0aGF0IERhdGFUYWJsZXMgaGFzIHJlYWRpZWQgZm9yIHNlbmRpbmcuIEFuXG5cdFx0ICogICBvYmplY3QgbWF5IGJlIHJldHVybmVkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIERhdGFUYWJsZXNcblx0XHQgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXG5cdFx0ICogICBub3QgcmV0dXJuIGFueXRoaW5nIGZyb20gdGhlIGZ1bmN0aW9uLiBUaGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyUGFyYW1zYFxuXHRcdCAqICAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAqIGBkYXRhU3JjYCAtIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yXG5cdFx0ICogICBgYWFEYXRhYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YVxuXHRcdCAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXG5cdFx0ICogICBhbGxvd3MgdGhhdCBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZFxuXHRcdCAqICAgb2JqZWN0IG5vdGF0aW9uIHRvIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZywgb3Jcblx0XHQgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXG5cdFx0ICogICB0aGUgSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIsIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBhc1xuXHRcdCAqICAgcmVxdWlyZWQsIHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGJlaW5nIHRoYXQgdXNlZCBieSBEYXRhVGFibGVzIGFzIHRoZVxuXHRcdCAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBzdXBlcnNlZGVzIGBzQWpheERhdGFQcm9wYCBmcm9tXG5cdFx0ICogICBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAqIGBzdWNjZXNzYCAtIFNob3VsZCBub3QgYmUgb3ZlcnJpZGRlbiBpdCBpcyB1c2VkIGludGVybmFsbHkgaW5cblx0XHQgKiAgIERhdGFUYWJsZXMuIFRvIG1hbmlwdWxhdGUgLyB0cmFuc2Zvcm0gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHNlcnZlclxuXHRcdCAqICAgdXNlIGBhamF4LmRhdGFTcmNgLCBvciB1c2UgYGFqYXhgIGFzIGEgZnVuY3Rpb24gKHNlZSBiZWxvdykuXG5cdFx0ICpcblx0XHQgKiBgZnVuY3Rpb25gXG5cdFx0ICogLS0tLS0tLS0tLVxuXHRcdCAqXG5cdFx0ICogQXMgYSBmdW5jdGlvbiwgbWFraW5nIHRoZSBBamF4IGNhbGwgaXMgbGVmdCB1cCB0byB5b3Vyc2VsZiBhbGxvd2luZ1xuXHRcdCAqIGNvbXBsZXRlIGNvbnRyb2wgb2YgdGhlIEFqYXggcmVxdWVzdC4gSW5kZWVkLCBpZiBkZXNpcmVkLCBhIG1ldGhvZCBvdGhlclxuXHRcdCAqIHRoYW4gQWpheCBjb3VsZCBiZSB1c2VkIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSwgc3VjaCBhcyBXZWIgc3RvcmFnZVxuXHRcdCAqIG9yIGFuIEFJUiBkYXRhYmFzZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbiBpcyBnaXZlbiBmb3VyIHBhcmFtZXRlcnMgYW5kIG5vIHJldHVybiBpcyByZXF1aXJlZC4gVGhlXG5cdFx0ICogcGFyYW1ldGVycyBhcmU6XG5cdFx0ICpcblx0XHQgKiAxLiBfb2JqZWN0XyAtIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXG5cdFx0ICogMi4gX2Z1bmN0aW9uXyAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgbXVzdCBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXF1aXJlZFxuXHRcdCAqICAgIGRhdGEgaGFzIGJlZW4gb2J0YWluZWQuIFRoYXQgZGF0YSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrXG5cdFx0ICogICAgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXG5cdFx0ICogMy4gX29iamVjdF8gLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIHRhYmxlXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlckRhdGFgIGZyb20gRGF0YVRhYmxlcyAxLjktLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xvYmplY3R8ZnVuY3Rpb25cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhcblx0XHQgKiAgQHNpbmNlIDEuMTAuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXguXG5cdFx0ICogICAvLyBOb3RlIERhdGFUYWJsZXMgZXhwZWN0cyBkYXRhIGluIHRoZSBmb3JtIGB7IGRhdGE6IFsgLi4uZGF0YS4uLiBdIH1gIGJ5IGRlZmF1bHQpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IFwiZGF0YS5qc29uXCJcblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gY2hhbmdlXG5cdFx0ICogICAvLyBgZGF0YWAgdG8gYHRhYmxlRGF0YWAgKGkuZS4gYHsgdGFibGVEYXRhOiBbIC4uLmRhdGEuLi4gXSB9YClcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFTcmNcIjogXCJ0YWJsZURhdGFcIlxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheCwgdXNpbmcgYGRhdGFTcmNgIHRvIHJlYWQgZGF0YVxuXHRcdCAqICAgLy8gZnJvbSBhIHBsYWluIGFycmF5IHJhdGhlciB0aGFuIGFuIGFycmF5IGluIGFuIG9iamVjdFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBcIlwiXG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBNYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciAtIGFkZCBhIGxpbmsgdG8gZGF0YVxuXHRcdCAqICAgLy8gKG5vdGUgdGhpcyBjYW4sIHNob3VsZCwgYmUgZG9uZSB1c2luZyBgcmVuZGVyYCBmb3IgdGhlIGNvbHVtbiAtIHRoaXNcblx0XHQgKiAgIC8vIGlzIGp1c3QgYSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdGhlIGRhdGEgY2FuIGJlIG1hbmlwdWxhdGVkKS5cblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFTcmNcIjogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdCAqICAgICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0ICogICAgICAgICAgIGpzb25baV1bMF0gPSAnPGEgaHJlZj1cIi9tZXNzYWdlLycranNvbltpXVswXSsnPlZpZXcgbWVzc2FnZTwvYT4nO1xuXHRcdCAqICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgcmV0dXJuIGpzb247XG5cdFx0ICogICAgICAgfVxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gQWRkIGRhdGEgdG8gdGhlIHJlcXVlc3Rcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdCAqICAgICAgICAgcmV0dXJuIHtcblx0XHQgKiAgICAgICAgICAgXCJleHRyYV9zZWFyY2hcIjogJCgnI2V4dHJhJykudmFsKClcblx0XHQgKiAgICAgICAgIH07XG5cdFx0ICogICAgICAgfVxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gU2VuZCByZXF1ZXN0IGFzIFBPU1Rcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcInR5cGVcIjogXCJQT1NUXCJcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSAoY291bGQgaW50ZXJmYWNlIHdpdGggYSBmb3JtIGZvclxuXHRcdCAqICAgLy8gYWRkaW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyByb3dzKS5cblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHNldHRpbmdzKSB7XG5cdFx0ICogICAgICAgY2FsbGJhY2soXG5cdFx0ICogICAgICAgICBKU09OLnBhcnNlKCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGF0YVRhYmxlc0RhdGEnKSApXG5cdFx0ICogICAgICAgKTtcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWpheFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byByZWFkaWx5IHNwZWNpZnkgdGhlIGVudHJpZXMgaW4gdGhlIGxlbmd0aCBkcm9wXG5cdFx0ICogZG93biBtZW51IHRoYXQgRGF0YVRhYmxlcyBzaG93cyB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC4gSXQgY2FuIGJlXG5cdFx0ICogZWl0aGVyIGEgMUQgYXJyYXkgb2Ygb3B0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGJvdGggdGhlIGRpc3BsYXllZFxuXHRcdCAqIG9wdGlvbiBhbmQgdGhlIHZhbHVlLCBvciBhIDJEIGFycmF5IHdoaWNoIHdpbGwgdXNlIHRoZSBhcnJheSBpbiB0aGUgZmlyc3Rcblx0XHQgKiBwb3NpdGlvbiBhcyB0aGUgdmFsdWUsIGFuZCB0aGUgYXJyYXkgaW4gdGhlIHNlY29uZCBwb3NpdGlvbiBhcyB0aGVcblx0XHQgKiBkaXNwbGF5ZWQgb3B0aW9ucyAodXNlZnVsIGZvciBsYW5ndWFnZSBzdHJpbmdzIHN1Y2ggYXMgJ0FsbCcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHRoZSBgcGFnZUxlbmd0aGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGVcblx0XHQgKiBmaXJzdCB2YWx1ZSBnaXZlbiBpbiB0aGlzIGFycmF5LCB1bmxlc3MgYHBhZ2VMZW5ndGhgIGlzIGFsc28gcHJvdmlkZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFsgMTAsIDI1LCA1MCwgMTAwIF1cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhNZW51XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxlbmd0aE1lbnVcIjogW1sxMCwgMjUsIDUwLCAtMV0sIFsxMCwgMjUsIDUwLCBcIkFsbFwiXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBbIDEwLCAyNSwgNTAsIDEwMCBdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxuXHRcdCAqIGRldGFpbHMgYWJvdXQgdGhlIHdheSBpbmRpdmlkdWFsIGNvbHVtbnMgYmVoYXZlLiBGb3IgYSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xuXHRcdCAqIGRlZmluZSB5b3VyIGNvbHVtbnMsIHlvdSBtdXN0IGhhdmUgYW4gZW50cnkgaW4gdGhlIGFycmF5IGZvciBldmVyeSBzaW5nbGVcblx0XHQgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcblx0XHQgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5cblx0XHQgKi9cblx0XHRcImFvQ29sdW1uc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBWZXJ5IHNpbWlsYXIgdG8gYGNvbHVtbnNgLCBgY29sdW1uRGVmc2AgYWxsb3dzIHlvdSB0byB0YXJnZXQgYSBzcGVjaWZpY1xuXHRcdCAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2Zcblx0XHQgKiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFRoaXMgYWxsb3dzIGdyZWF0IGZsZXhpYmlsaXR5IHdoZW4gY3JlYXRpbmdcblx0XHQgKiB0YWJsZXMsIGFzIHRoZSBgY29sdW1uRGVmc2AgYXJyYXlzIGNhbiBiZSBvZiBhbnkgbGVuZ3RoLCB0YXJnZXRpbmcgdGhlXG5cdFx0ICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXG5cdFx0ICogb3B0aW9ucyBhdmFpbGFibGU6IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufSwgYnV0IGl0IF9tdXN0X1xuXHRcdCAqIGhhdmUgYHRhcmdldHNgIGRlZmluZWQgaW4gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBWYWx1ZXMgaW4gdGhlIGB0YXJnZXRzYFxuXHRcdCAqIGFycmF5IG1heSBiZTpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmEgc3RyaW5nIC0gY2xhc3MgbmFtZSB3aWxsIGJlIG1hdGNoZWQgb24gdGhlIFRIIGZvciB0aGUgY29sdW1uPC9saT5cblx0XHQgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxuXHRcdCAqICAgICA8bGk+YSBuZWdhdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIHJpZ2h0PC9saT5cblx0XHQgKiAgICAgPGxpPnRoZSBzdHJpbmcgXCJfYWxsXCIgLSBhbGwgY29sdW1ucyAoaS5lLiBhc3NpZ24gYSBkZWZhdWx0KTwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbkRlZnNcblx0XHQgKi9cblx0XHRcImFvQ29sdW1uRGVmc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQmFzaWNhbGx5IHRoZSBzYW1lIGFzIGBzZWFyY2hgLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGNvbHVtblxuXHRcdCAqIGZpbHRlcmluZyBzdGF0ZSBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLiBUaGUgYXJyYXkgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplXG5cdFx0ICogYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zLCBhbmQgZWFjaCBlbGVtZW50IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJhbWV0ZXJzXG5cdFx0ICogYHNlYXJjaGAgYW5kIGBlc2NhcGVSZWdleGAgKHRoZSBsYXR0ZXIgaXMgb3B0aW9uYWwpLiAnbnVsbCcgaXMgYWxzb1xuXHRcdCAqIGFjY2VwdGVkIGFuZCB0aGUgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoQ29sc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hDb2xzXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hcIjogXCJNeSBmaWx0ZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIl5bMC05XVwiLCBcImVzY2FwZVJlZ2V4XCI6IGZhbHNlIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYW9TZWFyY2hDb2xzXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgQ1NTIGNsYXNzZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBkaXNwbGF5ZWQgcm93cy4gVGhpc1xuXHRcdCAqIGFycmF5IG1heSBiZSBvZiBhbnkgbGVuZ3RoLCBhbmQgRGF0YVRhYmxlcyB3aWxsIGFwcGx5IGVhY2ggY2xhc3Ncblx0XHQgKiBzZXF1ZW50aWFsbHksIGxvb3Bpbmcgd2hlbiByZXF1aXJlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5XaWxsIHRha2UgdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IHRoZSBgb0NsYXNzZXMuc3RyaXBlKmBcblx0XHQgKiAgICBvcHRpb25zPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0cmlwZUNsYXNzZXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RyaXBlQ2xhc3Nlc1wiOiBbICdzdHJpcDEnLCAnc3RyaXAyJywgJ3N0cmlwMycgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxuXHRcdCAqIGFzIGFuIG9wdGltaXNhdGlvbiAoaXQgdGFrZXMgc29tZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGhzKSBpZiB0aGVcblx0XHQgKiB0YWJsZXMgd2lkdGhzIGFyZSBwYXNzZWQgaW4gdXNpbmcgYGNvbHVtbnNgLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmF1dG9XaWR0aFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYXV0b1dpZHRoXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkF1dG9XaWR0aFwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3Vcblx0XHQgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cblx0XHQgKiB0cnVlLCB3aWxsIGNhdXNlIERhdGFUYWJsZXMgdG8gZGVmZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSB0YWJsZSBlbGVtZW50cyBmb3Jcblx0XHQgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxuXHRcdCAqIHRpbWUuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyUmVuZGVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJzb3VyY2VzL2FycmF5cy50eHRcIixcblx0XHQgKiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkRlZmVyUmVuZGVyXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZSBhIERhdGFUYWJsZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmVwbGFjZSBpdCB3aXRoXG5cdFx0ICogb25lIHdoaWNoIGhhcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbmV3IGluaXRpYWxpc2F0aW9uIG9iamVjdCBwYXNzZWQuIElmIG5vXG5cdFx0ICogdGFibGUgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsIHRoZW4gdGhlIG5ldyBEYXRhVGFibGUgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhc1xuXHRcdCAqIHBlciBub3JtYWwuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVzdHJveVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvbWUgdGltZSBsYXRlci4uLi5cblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZmlsdGVyXCI6IGZhbHNlLFxuXHRcdCAqICAgICAgICBcImRlc3Ryb3lcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJEZXN0cm95XCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9mIGRhdGEuIEZpbHRlcmluZyBpbiBEYXRhVGFibGVzIGlzIFwic21hcnRcIiBpblxuXHRcdCAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcblx0XHQgKiB3aWxsIG1hdGNoIGEgcm93IGNvbnRhaW5pbmcgdGhvc2Ugd29yZHMsIGV2ZW4gaWYgbm90IGluIHRoZSBvcmRlciB0aGF0IHdhc1xuXHRcdCAqIHNwZWNpZmllZCAodGhpcyBhbGxvdyBtYXRjaGluZyBhY3Jvc3MgbXVsdGlwbGUgY29sdW1ucykuIE5vdGUgdGhhdCBpZiB5b3Vcblx0XHQgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcblx0XHQgKiBkZWZhdWx0IGZpbHRlcmluZyBpbnB1dCBib3ggYW5kIHJldGFpbiBmaWx0ZXJpbmcgYWJpbGl0aWVzLCBwbGVhc2UgdXNlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5kb219LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaGluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkZpbHRlclwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGRpc3BsYXkuIFRoaXMgc2hvd3MgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCB0aGUgZGF0YSB0aGF0IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBpbmNsdWRpbmcgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCBmaWx0ZXJlZCBkYXRhIGlmIHRoYXQgYWN0aW9uIGlzIGJlaW5nIHBlcmZvcm1lZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJpbmZvXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkluZm9cIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyB0aGUgZW5kIHVzZXIgdG8gc2VsZWN0IHRoZSBzaXplIG9mIGEgZm9ybWF0dGVkIHBhZ2UgZnJvbSBhIHNlbGVjdFxuXHRcdCAqIG1lbnUgKHNpemVzIGFyZSAxMCwgMjUsIDUwIGFuZCAxMDApLiBSZXF1aXJlcyBwYWdpbmF0aW9uIChgcGFnaW5hdGVgKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhDaGFuZ2Vcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxlbmd0aENoYW5nZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHBhZ2luYXRpb24uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiUGFnaW5hdGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIGEgJ3Byb2Nlc3NpbmcnIGluZGljYXRvciB3aGVuIHRoZSB0YWJsZSBpc1xuXHRcdCAqIGJlaW5nIHByb2Nlc3NlZCAoZS5nLiBhIHNvcnQpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHRhYmxlcyB3aXRoXG5cdFx0ICogbGFyZ2UgYW1vdW50cyBvZiBkYXRhIHdoZXJlIGl0IGNhbiB0YWtlIGEgbm90aWNlYWJsZSBhbW91bnQgb2YgdGltZSB0byBzb3J0XG5cdFx0ICogdGhlIGVudHJpZXMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByb2Nlc3Npbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInByb2Nlc3NpbmdcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJQcm9jZXNzaW5nXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0cmlldmUgdGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIE5vdGUgdGhhdCBpZiB0aGVcblx0XHQgKiB0YWJsZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkLCB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlIERhdGFUYWJsZXNcblx0XHQgKiB0byBzaW1wbHkgcmV0dXJuIHRoZSBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNldCB1cCAtIGl0IHdpbGwgbm90IHRha2Vcblx0XHQgKiBhY2NvdW50IG9mIGFueSBjaGFuZ2VzIHlvdSBtaWdodCBoYXZlIG1hZGUgdG8gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdFxuXHRcdCAqIHBhc3NlZCB0byBEYXRhVGFibGVzIChzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaXMgYW4gYWNrbm93bGVkZ2VtZW50XG5cdFx0ICogdGhhdCB5b3UgdW5kZXJzdGFuZCB0aGlzKS4gYGRlc3Ryb3lgIGNhbiBiZSB1c2VkIHRvIHJlaW5pdGlhbGlzZSBhIHRhYmxlIGlmXG5cdFx0ICogeW91IG5lZWQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmV0cmlldmVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIGluaXRUYWJsZSgpO1xuXHRcdCAqICAgICAgdGFibGVBY3Rpb25zKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgZnVuY3Rpb24gaW5pdFRhYmxlICgpXG5cdFx0ICogICAge1xuXHRcdCAqICAgICAgcmV0dXJuICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXG5cdFx0ICogICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH1cblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIHRhYmxlQWN0aW9ucyAoKVxuXHRcdCAqICAgIHtcblx0XHQgKiAgICAgIHZhciB0YWJsZSA9IGluaXRUYWJsZSgpO1xuXHRcdCAqICAgICAgLy8gcGVyZm9ybSBBUEkgb3BlcmF0aW9ucyB3aXRoIG9UYWJsZVxuXHRcdCAqICAgIH1cblx0XHQgKi9cblx0XHRcImJSZXRyaWV2ZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdmVydGljYWwgKHkpIHNjcm9sbGluZyBpcyBlbmFibGVkLCBEYXRhVGFibGVzIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZlxuXHRcdCAqIHRoZSB0YWJsZSdzIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBoZWlnaHQgYXQgYWxsIHRpbWVzICh1c2VmdWwgZm9yIGxheW91dCkuXG5cdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gbG9vayBvZGQgd2hlbiBmaWx0ZXJpbmcgZGF0YSBkb3duIHRvIGEgc21hbGwgZGF0YSBzZXQsXG5cdFx0ICogYW5kIHRoZSBmb290ZXIgaXMgbGVmdCBcImZsb2F0aW5nXCIgZnVydGhlciBkb3duLiBUaGlzIHBhcmFtZXRlciAod2hlblxuXHRcdCAqIGVuYWJsZWQpIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBjb2xsYXBzZSB0aGUgdGFibGUncyB2aWV3cG9ydCBkb3duIHdoZW5cblx0XHQgKiB0aGUgcmVzdWx0IHNldCB3aWxsIGZpdCB3aXRoaW4gdGhlIGdpdmVuIFkgaGVpZ2h0LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbENvbGxhcHNlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBcIixcblx0XHQgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNjcm9sbENvbGxhcHNlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ29uZmlndXJlIERhdGFUYWJsZXMgdG8gdXNlIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxuXHRcdCAqIHNvdXJjZSB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEgZm9yIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclNpZGVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwieGhyLnBocFwiXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNlcnZlclNpZGVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzb3J0aW5nIG9mIGNvbHVtbnMuIFNvcnRpbmcgb2YgaW5kaXZpZHVhbCBjb2x1bW5zIGNhbiBiZVxuXHRcdCAqIGRpc2FibGVkIGJ5IHRoZSBgc29ydGFibGVgIG9wdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJpbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNwbGF5IERhdGFUYWJsZXMnIGFiaWxpdHkgdG8gc29ydCBtdWx0aXBsZSBjb2x1bW5zIGF0IHRoZVxuXHRcdCAqIHNhbWUgdGltZSAoYWN0aXZhdGVkIGJ5IHNoaWZ0LWNsaWNrIGJ5IHRoZSB1c2VyKS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyTXVsdGlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIERpc2FibGUgbXVsdGlwbGUgY29sdW1uIHNvcnRpbmcgYWJpbGl0eVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyTXVsdGlcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydE11bHRpXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgY29udHJvbCBvdmVyIHdoZXRoZXIgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRoZSB0b3AgKHRydWUpIHVuaXF1ZVxuXHRcdCAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxuXHRcdCAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgY29tcGxleCBoZWFkZXJzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2VsbHNUb3Bcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJDZWxsc1RvcFwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRDZWxsc1RvcFwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxuXHRcdCAqIGBzb3J0aW5nXFxfM2AgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBzb3J0ZWQgb24uIFRoaXMgaXNcblx0XHQgKiBwcmVzZW50ZWQgYXMgYSBmZWF0dXJlIHN3aXRjaCBhcyBpdCBjYW4gaW5jcmVhc2UgcHJvY2Vzc2luZyB0aW1lICh3aGlsZVxuXHRcdCAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXG5cdFx0ICogdHVybiB0aGlzIG9mZi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNsYXNzZXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyQ2xhc3Nlc1wiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxuXHRcdCAqIHVzZWQgdG8gc2F2ZSB0YWJsZSBkaXNwbGF5IGluZm9ybWF0aW9uIHN1Y2ggYXMgcGFnaW5hdGlvbiBpbmZvcm1hdGlvbixcblx0XHQgKiBkaXNwbGF5IGxlbmd0aCwgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLiBBcyBzdWNoIHdoZW4gdGhlIGVuZCB1c2VyIHJlbG9hZHNcblx0XHQgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxuXHRcdCAqXG5cdFx0ICogRHVlIHRvIHRoZSB1c2Ugb2YgYGxvY2FsU3RvcmFnZWAgdGhlIGRlZmF1bHQgc3RhdGUgc2F2aW5nIGlzIG5vdCBzdXBwb3J0ZWRcblx0XHQgKiBpbiBJRTYgb3IgNy4gSWYgc3RhdGUgc2F2aW5nIGlzIHJlcXVpcmVkIGluIHRob3NlIGJyb3dzZXJzLCB1c2Vcblx0XHQgKiBgc3RhdGVTYXZlQ2FsbGJhY2tgIHRvIHByb3ZpZGUgYSBzdG9yYWdlIHNvbHV0aW9uIHN1Y2ggYXMgY29va2llcy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTdGF0ZVNhdmVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXG5cdFx0ICogZWxlbWVudHMgaGF2ZSBiZWVuIGluc2VydGVkKSwgb3IgcmVnaXN0ZXJlZCBpZiB1c2luZyBhIERPTSBzb3VyY2UsIGFsbG93aW5nXG5cdFx0ICogbWFuaXB1bGF0aW9uIG9mIHRoZSBUUiBlbGVtZW50IChhZGRpbmcgY2xhc3NlcyBldGMpLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoaXMgcm93IGluIHRoZSBpbnRlcm5hbCBhb0RhdGEgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jcmVhdGVkUm93XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHRcdCAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXG5cdFx0ICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiIClcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHRcdCAqIGR5bmFtaWNhbGx5IG1vZGlmeSBhbnkgYXNwZWN0IHlvdSB3YW50IGFib3V0IHRoZSBjcmVhdGVkIERPTS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZHJhd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyByZWRyYXduIHRoZSB0YWJsZScgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuRHJhd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJZGVudGljYWwgdG8gZm5IZWFkZXJDYWxsYmFjaygpIGJ1dCBmb3IgdGhlIHRhYmxlIGZvb3RlciB0aGlzIGZ1bmN0aW9uXG5cdFx0ICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gZm9vdCBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGZvb3RlclxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7YXJyYXkgaW50fSBkaXNwbGF5IEluZGV4IGFycmF5IHRvIHRyYW5zbGF0ZSB0aGUgdmlzdWFsIHBvc2l0aW9uXG5cdFx0ICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvb3RlckNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImZvb3RlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCB0Zm9vdCwgZGF0YSwgc3RhcnQsIGVuZCwgZGlzcGxheSApIHtcblx0XHQgKiAgICAgICAgICB0Zm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIlN0YXJ0aW5nIGluZGV4IGlzIFwiK3N0YXJ0O1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJmbkZvb3RlckNhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcblx0XHQgKiAoaS5lLiBcIlNob3dpbmcgMSB0byAxMCBvZiA1NyBlbnRyaWVzXCIpIERhdGFUYWJsZXMgd2lsbCByZW5kZXIgbGFyZ2UgbnVtYmVyc1xuXHRcdCAqIHRvIGhhdmUgYSBjb21tYSBzZXBhcmF0b3IgZm9yIHRoZSAndGhvdXNhbmRzJyB1bml0cyAoZS5nLiAxIG1pbGxpb24gaXNcblx0XHQgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcblx0XHQgKiBmdW5jdGlvbiB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBEYXRhVGFibGVzIHVzZXMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHRvRm9ybWF0IG51bWJlciB0byBiZSBmb3JtYXR0ZWRcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHN0cmluZyBmb3IgRGF0YVRhYmxlcyB0byBzaG93IHRoZSBudW1iZXJcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5mb3JtYXROdW1iZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEZvcm1hdCBhIG51bWJlciB1c2luZyBhIHNpbmdsZSBxdW90ZSBmb3IgdGhlIHNlcGFyYXRvciAobm90ZSB0aGF0XG5cdFx0ICogICAgLy8gdGhpcyBjYW4gYWxzbyBiZSBkb25lIHdpdGggdGhlIGxhbmd1YWdlLnRob3VzYW5kcyBvcHRpb24pXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmb3JtYXROdW1iZXJcIjogZnVuY3Rpb24gKCB0b0Zvcm1hdCApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdCAqICAgICAgICAgICAgL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiJ1wiXG5cdFx0ICogICAgICAgICAgKTtcblx0XHQgKiAgICAgICAgfTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdFx0cmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdFx0L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csXG5cdFx0XHRcdHRoaXMub0xhbmd1YWdlLnNUaG91c2FuZHNcblx0XHRcdCk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0XHQgKiBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGhlYWRlciByb3cuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGFuZFxuXHRcdCAqIGRpc3BsYXkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBoZWFkIFwiVFJcIiBlbGVtZW50IGZvciB0aGUgaGVhZGVyXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXG5cdFx0ICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0XHQgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaGVhZGVyQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZmhlYWRlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCBoZWFkLCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHRcdCAqICAgICAgICAgIGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoJylbMF0uaW5uZXJIVE1MID0gXCJEaXNwbGF5aW5nIFwiKyhlbmQtc3RhcnQpK1wiIHJlY29yZHNcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiZm5IZWFkZXJDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG5cdFx0ICogc3RhdGUgb2YgdGhlIHRhYmxlLiBBbHRob3VnaCB0aGUgaW50ZXJuYXRpb25hbGlzYXRpb24gb3B0aW9ucyBwcmVzZW50ZWQgYnlcblx0XHQgKiBEYXRhVGFibGVzIGFyZSBxdWl0ZSBjYXBhYmxlIG9mIGRlYWxpbmcgd2l0aCBtb3N0IGN1c3RvbWlzYXRpb25zLCB0aGVyZSBtYXlcblx0XHQgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXG5cdFx0ICogYWxsb3dzIHlvdSB0byBkbyBleGFjdGx5IHRoYXQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IFN0YXJ0aW5nIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgRW5kIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBtYXggVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRhYmxlIChyZWdhcmRsZXNzIG9mXG5cdFx0ICogICAgZmlsdGVyaW5nKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gdG90YWwgVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHByZSBUaGUgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBoYXMgZm9ybWF0dGVkIHVzaW5nIGl0J3Ncblx0XHQgKiAgICBvd24gcnVsZXNcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgXCJpbmZvQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBwcmUgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiBzdGFydCArXCIgdG8gXCIrIGVuZDtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGVkIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLiBOb3JtYWxseSBEYXRhVGFibGVzIHdpbGxcblx0XHQgKiBpbml0aWFsaXNlIHNlcXVlbnRpYWxseSBhbmQgdGhlcmUgd2lsbCBiZSBubyBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uLFxuXHRcdCAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cblx0XHQgKiBzaW5jZSB0aGF0IGlzIG9idGFpbmVkIHVzaW5nIGFuIGFzeW5jIFhIUiBjYWxsLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIEpTT04gb2JqZWN0IHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIC0gb25seVxuXHRcdCAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluaXRDb21wbGV0ZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJpbml0Q29tcGxldGVcIjogZnVuY3Rpb24oc2V0dGluZ3MsIGpzb24pIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIGZpbmlzaGVkIGl0cyBpbml0aWFsaXNhdGlvbi4nICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImZuSW5pdENvbXBsZXRlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsZWQgYXQgdGhlIHZlcnkgc3RhcnQgb2YgZWFjaCB0YWJsZSBkcmF3IGFuZCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXG5cdFx0ICogZHJhdyBieSByZXR1cm5pbmcgZmFsc2UsIGFueSBvdGhlciByZXR1cm4gKGluY2x1ZGluZyB1bmRlZmluZWQpIHJlc3VsdHMgaW5cblx0XHQgKiB0aGUgZnVsbCBkcmF3IG9jY3VycmluZykuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2lsbCBjYW5jZWwgdGhlIGRyYXcsIGFueXRoaW5nIGVsc2UgKGluY2x1ZGluZyBub1xuXHRcdCAqICAgIHJldHVybikgd2lsbCBhbGxvdyBpdCB0byBjb21wbGV0ZS5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wcmVEcmF3Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicHJlRHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgICBpZiAoICQoJyN0ZXN0JykudmFsKCkgPT0gMSApIHtcblx0XHQgKiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblByZURyYXdDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvICdwb3N0IHByb2Nlc3MnIGVhY2ggcm93IGFmdGVyIGl0IGhhdmUgYmVlblxuXHRcdCAqIGdlbmVyYXRlZCBmb3IgZWFjaCB0YWJsZSBkcmF3LCBidXQgYmVmb3JlIGl0IGlzIHJlbmRlcmVkIG9uIHNjcmVlbi4gVGhpc1xuXHRcdCAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSByb3cgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IHJvd1xuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4IFRoZSBkaXNwbGF5IGluZGV4IGZvciB0aGUgY3VycmVudCB0YWJsZSBkcmF3XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkaXNwbGF5SW5kZXhGdWxsIFRoZSBpbmRleCBvZiB0aGUgZGF0YSBpbiB0aGUgZnVsbCBsaXN0IG9mXG5cdFx0ICogICAgcm93cyAoYWZ0ZXIgZmlsdGVyaW5nKVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInJvd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCByb3csIGRhdGEsIGRpc3BsYXlJbmRleCwgZGlzcGxheUluZGV4RnVsbCApIHtcblx0XHQgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xuXHRcdCAqICAgICAgICAgIGlmICggZGF0YVs0XSA9PSBcIkFcIiApIHtcblx0XHQgKiAgICAgICAgICAgICQoJ3RkOmVxKDQpJywgcm93KS5odG1sKCAnPGI+QTwvYj4nICk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5Sb3dDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBvYnRhaW5zXG5cdFx0ICogdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyIHNvIHNvbWV0aGluZyBtb3JlIHN1aXRhYmxlIGZvciB5b3VyIGFwcGxpY2F0aW9uLlxuXHRcdCAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCB1c2UgUE9TVCBkYXRhLCBvciBwdWxsIGluZm9ybWF0aW9uIGZyb20gYSBHZWFycyBvclxuXHRcdCAqIEFJUiBkYXRhYmFzZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gc291cmNlIEhUVFAgc291cmNlIHRvIG9idGFpbiB0aGUgZGF0YSBmcm9tIChgYWpheGApXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgQSBrZXkvdmFsdWUgcGFpciBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSB0byBzZW5kXG5cdFx0ICogICAgdG8gdGhlIHNlcnZlclxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbiBvZiB0aGUgZGF0YSBnZXRcblx0XHQgKiAgICBwcm9jZXNzIHRoYXQgd2lsbCBkcmF3IHRoZSBkYXRhIG9uIHRoZSBwYWdlLlxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyRGF0YVxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwiZm5TZXJ2ZXJEYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiAgSXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIHNlbmQgZXh0cmEgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gbWFraW5nIGFuIEFqYXhcblx0XHQgKiByZXF1ZXN0IC0gZm9yIGV4YW1wbGUgY3VzdG9tIGZpbHRlcmluZyBpbmZvcm1hdGlvbiwgYW5kIHRoaXMgY2FsbGJhY2tcblx0XHQgKiBmdW5jdGlvbiBtYWtlcyBpdCB0cml2aWFsIHRvIHNlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIHNlcnZlci4gVGhlXG5cdFx0ICogcGFzc2VkIGluIHBhcmFtZXRlciBpcyB0aGUgZGF0YSBzZXQgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieVxuXHRcdCAqIERhdGFUYWJsZXMsIGFuZCB5b3UgY2FuIGFkZCB0byB0aGlzIG9yIG1vZGlmeSBpdCBhcyB5b3UgcmVxdWlyZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIGFycmF5IChhcnJheSBvZiBvYmplY3RzIHdoaWNoIGFyZSBuYW1lL3ZhbHVlXG5cdFx0ICogICAgcGFpcnMpIHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnkgRGF0YVRhYmxlcyBhbmQgd2lsbCBiZSBzZW50IHRvIHRoZVxuXHRcdCAqICAgIHNlcnZlci4gSW4gdGhlIGNhc2Ugb2YgQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogICAgdGhpcyB3aWxsIGJlIGFuIGVtcHR5IGFycmF5LCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGVyZSB3aWxsIGJlIGFcblx0XHQgKiAgICBzaWduaWZpY2FudCBudW1iZXIgb2YgcGFyYW1ldGVycyFcblx0XHQgKiAgQHJldHVybnMge3VuZGVmaW5lZH0gRW5zdXJlIHRoYXQgeW91IG1vZGlmeSB0aGUgZGF0YSBhcnJheSBwYXNzZWQgaW4sXG5cdFx0ICogICAgYXMgdGhpcyBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlLlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcImZuU2VydmVyUGFyYW1zXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBMb2FkIHRoZSB0YWJsZSBzdGF0ZS4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gZGVmaW5lIGZyb20gd2hlcmUsIGFuZCBob3csIHRoZVxuXHRcdCAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcblx0XHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgY2FuIGJlIGV4ZWN1dGVkIHdoZW4gZG9uZS4gSXRcblx0XHQgKiAgICBzaG91bGQgYmUgcGFzc2VkIHRoZSBsb2FkZWQgc3RhdGUgb2JqZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtvYmplY3R9IFRoZSBEYXRhVGFibGVzIHN0YXRlIG9iamVjdCB0byBiZSBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGNhbGxiYWNrKSB7XG5cdFx0ICogICAgICAgICAgJC5hamF4KCB7XG5cdFx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9sb2FkXCIsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdCAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0ICogICAgICAgICAgICAgIGNhbGxiYWNrKCBqc29uICk7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoXG5cdFx0XHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5nZXRJdGVtKFxuXHRcdFx0XHRcdFx0J0RhdGFUYWJsZXNfJytzZXR0aW5ncy5zSW5zdGFuY2UrJ18nK2xvY2F0aW9uLnBhdGhuYW1lXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIHByaW9yIHRvIGxvYWRpbmcgdGhhdCBzdGF0ZS5cblx0XHQgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZCBkYXRhLCBidXRcblx0XHQgKiBwcmlvciB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzYXZlZCBzdGF0ZS4gTm90ZSB0aGF0IGZvclxuXHRcdCAqIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZCB1c2UgdGhlIGBzdGF0ZUxvYWRQYXJhbXNgIGV2ZW50IHRvIGxvYWQgcGFyYW1ldGVycyBmb3Jcblx0XHQgKiBhIHBsdWctaW4uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgbG9hZGVkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkUGFyYW1zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSZW1vdmUgYSBzYXZlZCBmaWx0ZXIsIHNvIGZpbHRlcmluZyBpcyBuZXZlciBsb2FkZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZFBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBEaXNhbGxvdyBzdGF0ZSBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVMb2FkUGFyYW1zXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSB0aGUgc3RhdGUgc2F2aW5nIG1ldGhvZFxuXHRcdCAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCB3YXMgbG9hZGVkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgYW4gYWxlcnQgd2l0aCB0aGUgZmlsdGVyaW5nIHZhbHVlIHRoYXQgd2FzIHNhdmVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRlZFwiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ1NhdmVkIGZpbHRlciB3YXM6ICcrZGF0YS5vU2VhcmNoLnNTZWFyY2ggKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVMb2FkZWRcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNhdmUgdGhlIHRhYmxlIHN0YXRlLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gZGVmaW5lIHdoZXJlIGFuZCBob3cgdGhlIHN0YXRlXG5cdFx0ICogaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZSBpcyBzdG9yZWQgQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgdXNlIGBsb2NhbFN0b3JhZ2VgXG5cdFx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICAvLyBTZW5kIGFuIEFqYXggcmVxdWVzdCB0byB0aGUgc2VydmVyIHdpdGggdGhlIHN0YXRlIG9iamVjdFxuXHRcdCAqICAgICAgICAgICQuYWpheCgge1xuXHRcdCAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfc2F2ZVwiLFxuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGEsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdCAqICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCJcblx0XHQgKiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmdW5jdGlvbiAoKSB7fVxuXHRcdCAqICAgICAgICAgIH0gKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncywgZGF0YSApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuc2V0SXRlbShcblx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWUsXG5cdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoIGRhdGEgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc3RhdGUgdG8gYmUgc2F2ZWQuIENhbGxlZCB3aGVuIHRoZSB0YWJsZVxuXHRcdCAqIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIGFsbG93cyBtb2RpZmljYXRpb24gb2Zcblx0XHQgKiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdCBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yXG5cdFx0ICogb3RoZXIgc3RhdGUgcHJvcGVydGllcyBvciBtb2RpZmljYXRpb24uIE5vdGUgdGhhdCBmb3IgcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkXG5cdFx0ICogdXNlIHRoZSBgc3RhdGVTYXZlUGFyYW1zYCBldmVudCB0byBzYXZlIHBhcmFtZXRlcnMgZm9yIGEgcGx1Zy1pbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIHNhdmVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgZGF0YS5vU2VhcmNoLnNTZWFyY2ggPSBcIlwiO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZVNhdmVQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIER1cmF0aW9uIGZvciB3aGljaCB0aGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb24gaXMgY29uc2lkZXJlZCB2YWxpZC4gQWZ0ZXIgdGhpcyBwZXJpb2Rcblx0XHQgKiBoYXMgZWxhcHNlZCB0aGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgZGVmYXVsdC5cblx0XHQgKiBWYWx1ZSBpcyBnaXZlbiBpbiBzZWNvbmRzLlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgNzIwMCA8aT4oMiBob3Vycyk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlRHVyYXRpb25cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVEdXJhdGlvblwiOiA2MCo2MCoyNDsgLy8gMSBkYXlcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsIG5vdCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIGZvciB0aGUgZmlyc3Rcblx0XHQgKiBwYWdlIGRyYXcgLSByYXRoZXIgaXQgd2lsbCB1c2UgdGhlIGRhdGEgYWxyZWFkeSBvbiB0aGUgcGFnZSAobm8gc29ydGluZyBldGNcblx0XHQgKiB3aWxsIGJlIGFwcGxpZWQgdG8gaXQpLCB0aHVzIHNhdmluZyBvbiBhbiBYSFIgYXQgbG9hZCB0aW1lLiBgZGVmZXJMb2FkaW5nYFxuXHRcdCAqIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBkZWZlcnJlZCBsb2FkaW5nIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgYWxzbyB1c2VkXG5cdFx0ICogdG8gdGVsbCBEYXRhVGFibGVzIGhvdyBtYW55IHJlY29yZHMgdGhlcmUgYXJlIGluIHRoZSBmdWxsIHRhYmxlIChhbGxvd2luZ1xuXHRcdCAqIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGFuZCBwYWdpbmF0aW9uIHRvIGJlIGRpc3BsYXllZCBjb3JyZWN0bHkpLiBJbiB0aGUgY2FzZVxuXHRcdCAqIHdoZXJlIGEgZmlsdGVyaW5nIGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIG9uIGluaXRpYWwgbG9hZCwgdGhpcyBjYW4gYmVcblx0XHQgKiBpbmRpY2F0ZWQgYnkgZ2l2aW5nIHRoZSBwYXJhbWV0ZXIgYXMgYW4gYXJyYXksIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzXG5cdFx0ICogdGhlIG51bWJlciBvZiByZWNvcmRzIGF2YWlsYWJsZSBhZnRlciBmaWx0ZXJpbmcgYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGVcblx0XHQgKiBudW1iZXIgb2YgcmVjb3JkcyB3aXRob3V0IGZpbHRlcmluZyAoYWxsb3dpbmcgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnRcblx0XHQgKiB0byBiZSBzaG93biBjb3JyZWN0bHkpLlxuXHRcdCAqICBAdHlwZSBpbnQgfCBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyTG9hZGluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gNTcgcmVjb3JkcyBhdmFpbGFibGUgaW4gdGhlIHRhYmxlLCBubyBmaWx0ZXJpbmcgYXBwbGllZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxuXHRcdCAqICAgICAgICBcImRlZmVyTG9hZGluZ1wiOiA1N1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIDU3IHJlY29yZHMgYWZ0ZXIgZmlsdGVyaW5nLCAxMDAgd2l0aG91dCBmaWx0ZXJpbmcgKGFuIGluaXRpYWwgZmlsdGVyIGFwcGxpZWQpXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdFx0ICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IFsgNTcsIDEwMCBdLFxuXHRcdCAqICAgICAgICBcInNlYXJjaFwiOiB7XG5cdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJteV9maWx0ZXJcIlxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiaURlZmVyTG9hZGluZ1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSBvbiBhIHNpbmdsZSBwYWdlIHdoZW4gdXNpbmcgcGFnaW5hdGlvbi4gSWZcblx0XHQgKiBmZWF0dXJlIGVuYWJsZWQgKGBsZW5ndGhDaGFuZ2VgKSB0aGVuIHRoZSBlbmQgdXNlciB3aWxsIGJlIGFibGUgdG8gb3ZlcnJpZGVcblx0XHQgKiB0aGlzIHRvIGEgY3VzdG9tIHNldHRpbmcgdXNpbmcgYSBwb3AtdXAgbWVudS5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDEwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2VMZW5ndGhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicGFnZUxlbmd0aFwiOiA1MFxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBkYXRhIGRpc3BsYXkgd2hlbiB1c2luZyBEYXRhVGFibGVzIHdpdGhcblx0XHQgKiBwYWdpbmF0aW9uLiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiByZWNvcmRzLCByYXRoZXIgdGhhblxuXHRcdCAqIHRoZSBwYWdlIG51bWJlciwgc28gaWYgeW91IGhhdmUgMTAgcmVjb3JkcyBwZXIgcGFnZSBhbmQgd2FudCB0byBzdGFydCBvblxuXHRcdCAqIHRoZSB0aGlyZCBwYWdlLCBpdCBzaG91bGQgYmUgXCIyMFwiLlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kaXNwbGF5U3RhcnRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZGlzcGxheVN0YXJ0XCI6IDIwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJpRGlzcGxheVN0YXJ0XCI6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgYWxsb3dzIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIChzb3J0aW5nLCBwYWdpbmcsXG5cdFx0ICogYW5kIGZpbHRlcmluZykgYnkgYWRkaW5nIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUgdG8gdGhlIHJlcXVpcmVkIGVsZW1lbnRzLiBUaGlzXG5cdFx0ICogYWxsb3dzIHlvdSB0byB0YWIgdGhyb3VnaCB0aGUgY29udHJvbHMgYW5kIHByZXNzIHRoZSBlbnRlciBrZXkgdG8gYWN0aXZhdGUgdGhlbS5cblx0XHQgKiBUaGUgdGFiaW5kZXggaXMgZGVmYXVsdCAwLCBtZWFuaW5nIHRoYXQgdGhlIHRhYiBmb2xsb3dzIHRoZSBmbG93IG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKiBZb3UgY2FuIG92ZXJydWxlIHRoaXMgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaWYgeW91IHdpc2guIFVzZSBhIHZhbHVlIG9mIC0xIHRvXG5cdFx0ICogZGlzYWJsZSBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy50YWJJbmRleFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJ0YWJJbmRleFwiOiAxXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiaVRhYkluZGV4XCI6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzc2VzIHRoYXQgRGF0YVRhYmxlcyBhc3NpZ25zIHRvIHRoZSB2YXJpb3VzIGNvbXBvbmVudHMgYW5kIGZlYXR1cmVzXG5cdFx0ICogdGhhdCBpdCBhZGRzIHRvIHRoZSBIVE1MIHRhYmxlLiBUaGlzIGFsbG93cyBjbGFzc2VzIHRvIGJlIGNvbmZpZ3VyZWRcblx0XHQgKiBkdXJpbmcgaW5pdGlhbGlzYXRpb24gaW4gYWRkaXRpb24gdG8gdGhyb3VnaCB0aGUgc3RhdGljXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQub1N0ZENsYXNzZXN9IG9iamVjdCkuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNsYXNzZXNcblx0XHQgKi9cblx0XHRcIm9DbGFzc2VzXCI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsIHN0cmluZ3MgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW4gdGhlIHVzZXIgaW50ZXJmYWNlIHRoYXQgaXQgY3JlYXRlc1xuXHRcdCAqIGFyZSBkZWZpbmVkIGluIHRoaXMgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gbW9kaWZpZWQgdGhlbSBpbmRpdmlkdWFsbHkgb3Jcblx0XHQgKiBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlbSBhbGwgYXMgcmVxdWlyZWQuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlXG5cdFx0ICovXG5cdFx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdHJpbmdzIHRoYXQgYXJlIHVzZWQgZm9yIFdBSS1BUklBIGxhYmVscyBhbmQgY29udHJvbHMgb25seSAodGhlc2UgYXJlIG5vdFxuXHRcdFx0ICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xuXHRcdFx0ICogbXVzdCBiZSBpbnRlcm5hdGlvbmFsaXNlZCBhcyB3ZWxsKS5cblx0XHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWFcblx0XHRcdCAqL1xuXHRcdFx0XCJvQXJpYVwiOiB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIG1heSBiZVxuXHRcdFx0XHQgKiBzb3J0ZWQgYXNjZW5kaW5nIGJ5IGFjdGl2aW5nIHRoZSBjb2x1bW4gKGNsaWNrIG9yIHJldHVybiB3aGVuIGZvY3VzZWQpLlxuXHRcdFx0XHQgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaXMgcHJlZml4ZWQgdG8gdGhpcyBzdHJpbmcuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IDogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhLnNvcnRBc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwiYXJpYVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJzb3J0QXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgYXNjZW5kaW5nXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzU29ydEFzY2VuZGluZ1wiOiBcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXCIsXG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcblx0XHRcdFx0ICogc29ydGVkIGRlc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG5cdFx0XHRcdCAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydERlc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwiYXJpYVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJzb3J0RGVzY2VuZGluZ1wiOiBcIiAtIGNsaWNrL3JldHVybiB0byBzb3J0IGRlc2NlbmRpbmdcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNTb3J0RGVzY2VuZGluZ1wiOiBcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gZGVzY2VuZGluZ1wiXG5cdFx0XHR9LFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUGFnaW5hdGlvbiBzdHJpbmcgdXNlZCBieSBEYXRhVGFibGVzIGZvciB0aGUgYnVpbHQtaW4gcGFnaW5hdGlvblxuXHRcdFx0ICogY29udHJvbCB0eXBlcy5cblx0XHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlXG5cdFx0XHQgKi9cblx0XHRcdFwib1BhZ2luYXRlXCI6IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG5cdFx0XHRcdCAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBmaXJzdCBwYWdlLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBGaXJzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUuZmlyc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwiZmlyc3RcIjogXCJGaXJzdCBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzRmlyc3RcIjogXCJGaXJzdFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxuXHRcdFx0XHQgKiBidXR0b24gdG8gdGFrZSB0aGUgdXNlciB0byB0aGUgbGFzdCBwYWdlLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBMYXN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5sYXN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcImxhc3RcIjogXCJMYXN0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNMYXN0XCI6IFwiTGFzdFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICduZXh0JyBwYWdpbmF0aW9uIGJ1dHRvbiAodG8gdGFrZSB0aGUgdXNlciB0byB0aGVcblx0XHRcdFx0ICogbmV4dCBwYWdlKS5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgTmV4dFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUubmV4dFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJuZXh0XCI6IFwiTmV4dCBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzTmV4dFwiOiBcIk5leHRcIixcblx0XG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2UgZm9yIHRoZSAncHJldmlvdXMnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvXG5cdFx0XHRcdCAqIHRoZSBwcmV2aW91cyBwYWdlKS5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgUHJldmlvdXNcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLnByZXZpb3VzXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInByZXZpb3VzXCI6IFwiUHJldmlvdXMgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic1ByZXZpb3VzXCI6IFwiUHJldmlvdXNcIlxuXHRcdFx0fSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgc3RyaW5nIGlzIHNob3duIGluIHByZWZlcmVuY2UgdG8gYHplcm9SZWNvcmRzYCB3aGVuIHRoZSB0YWJsZSBpc1xuXHRcdFx0ICogZW1wdHkgb2YgZGF0YSAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLiBOb3RlIHRoYXQgdGhpcyBpcyBhbiBvcHRpb25hbFxuXHRcdFx0ICogcGFyYW1ldGVyIC0gaWYgaXQgaXMgbm90IGdpdmVuLCB0aGUgdmFsdWUgb2YgYHplcm9SZWNvcmRzYCB3aWxsIGJlIHVzZWRcblx0XHRcdCAqIGluc3RlYWQgKGVpdGhlciB0aGUgZGVmYXVsdCBvciBnaXZlbiB2YWx1ZSkuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmVtcHR5VGFibGVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiZW1wdHlUYWJsZVwiOiBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzRW1wdHlUYWJsZVwiOiBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBzdHJpbmcgZ2l2ZXMgaW5mb3JtYXRpb24gdG8gdGhlIGVuZCB1c2VyIGFib3V0IHRoZSBpbmZvcm1hdGlvblxuXHRcdFx0ICogdGhhdCBpcyBjdXJyZW50IG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UuIFRoZSBmb2xsb3dpbmcgdG9rZW5zIGNhbiBiZVxuXHRcdFx0ICogdXNlZCBpbiB0aGUgc3RyaW5nIGFuZCB3aWxsIGJlIGR5bmFtaWNhbGx5IHJlcGxhY2VkIGFzIHRoZSB0YWJsZVxuXHRcdFx0ICogZGlzcGxheSB1cGRhdGVzLiBUaGlzIHRva2VucyBjYW4gYmUgcGxhY2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmcsIG9yXG5cdFx0XHQgKiByZW1vdmVkIGFzIG5lZWRlZCBieSB0aGUgbGFuZ3VhZ2UgcmVxdWlyZXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgXFxfU1RBUlRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgZmlyc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRcdCAqICogYFxcX0VORFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBsYXN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG5cdFx0XHQgKiAqIGBcXF9UT1RBTFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgYWZ0ZXIgZmlsdGVyaW5nXG5cdFx0XHQgKiAqIGBcXF9NQVhcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIHdpdGhvdXQgZmlsdGVyaW5nXG5cdFx0XHQgKiAqIGBcXF9QQUdFXFxfYCAtIEN1cnJlbnQgcGFnZSBudW1iZXJcblx0XHRcdCAqICogYFxcX1BBR0VTXFxfYCAtIFRvdGFsIG51bWJlciBvZiBwYWdlcyBvZiBkYXRhIGluIHRoZSB0YWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9cIjogXCJTaG93aW5nIHBhZ2UgX1BBR0VfIG9mIF9QQUdFU19cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvXCI6IFwiU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1wiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERpc3BsYXkgaW5mb3JtYXRpb24gc3RyaW5nIGZvciB3aGVuIHRoZSB0YWJsZSBpcyBlbXB0eS4gVHlwaWNhbGx5IHRoZVxuXHRcdFx0ICogZm9ybWF0IG9mIHRoaXMgc3RyaW5nIHNob3VsZCBtYXRjaCBgaW5mb2AuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvRW1wdHlcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb0VtcHR5XCI6IFwiTm8gZW50cmllcyB0byBzaG93XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzSW5mb0VtcHR5XCI6IFwiU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiBhIHVzZXIgZmlsdGVycyB0aGUgaW5mb3JtYXRpb24gaW4gYSB0YWJsZSwgdGhpcyBzdHJpbmcgaXMgYXBwZW5kZWRcblx0XHRcdCAqIHRvIHRoZSBpbmZvcm1hdGlvbiAoYGluZm9gKSB0byBnaXZlIGFuIGlkZWEgb2YgaG93IHN0cm9uZyB0aGUgZmlsdGVyaW5nXG5cdFx0XHQgKiBpcy4gVGhlIHZhcmlhYmxlIF9NQVhfIGlzIGR5bmFtaWNhbGx5IHVwZGF0ZWQuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgZW50cmllcylcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9GaWx0ZXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvRmlsdGVyZWRcIjogXCIgLSBmaWx0ZXJpbmcgZnJvbSBfTUFYXyByZWNvcmRzXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzSW5mb0ZpbHRlcmVkXCI6IFwiKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgZW50cmllcylcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJZiBjYW4gYmUgdXNlZnVsIHRvIGFwcGVuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgaW5mbyBzdHJpbmcgYXQgdGltZXMsXG5cdFx0XHQgKiBhbmQgdGhpcyB2YXJpYWJsZSBkb2VzIGV4YWN0bHkgdGhhdC4gVGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGFwcGVuZGVkIHRvXG5cdFx0XHQgKiB0aGUgYGluZm9gIChgaW5mb0VtcHR5YCBhbmQgYGluZm9GaWx0ZXJlZGAgaW4gd2hhdGV2ZXIgY29tYmluYXRpb24gdGhleSBhcmVcblx0XHRcdCAqIGJlaW5nIHVzZWQpIGF0IGFsbCB0aW1lcy5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvUG9zdEZpeFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvUG9zdEZpeFwiOiBcIkFsbCByZWNvcmRzIHNob3duIGFyZSBkZXJpdmVkIGZyb20gcmVhbCBpbmZvcm1hdGlvbi5cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvUG9zdEZpeFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgZGVjaW1hbCBwbGFjZSBvcGVyYXRvciBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3RoZXJcblx0XHRcdCAqIGxhbmd1YWdlIG9wdGlvbnMgc2luY2UgRGF0YVRhYmxlcyBkb2Vzbid0IG91dHB1dCBmbG9hdGluZyBwb2ludFxuXHRcdFx0ICogbnVtYmVycywgc28gaXQgd29uJ3QgZXZlciB1c2UgdGhpcyBmb3IgZGlzcGxheSBvZiBhIG51bWJlci4gUmF0aGVyLFxuXHRcdFx0ICogd2hhdCB0aGlzIHBhcmFtZXRlciBkb2VzIGlzIG1vZGlmeSB0aGUgc29ydCBtZXRob2RzIG9mIHRoZSB0YWJsZSBzb1xuXHRcdFx0ICogdGhhdCBudW1iZXJzIHdoaWNoIGFyZSBpbiBhIGZvcm1hdCB3aGljaCBoYXMgYSBjaGFyYWN0ZXIgb3RoZXIgdGhhblxuXHRcdFx0ICogYSBwZXJpb2QgKGAuYCkgYXMgYSBkZWNpbWFsIHBsYWNlIHdpbGwgYmUgc29ydGVkIG51bWVyaWNhbGx5LlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBudW1iZXJzIHdpdGggZGlmZmVyZW50IGRlY2ltYWwgcGxhY2VzIGNhbm5vdCBiZSBzaG93biBpblxuXHRcdFx0ICogdGhlIHNhbWUgdGFibGUgYW5kIHN0aWxsIGJlIHNvcnRhYmxlLCB0aGUgdGFibGUgbXVzdCBiZSBjb25zaXN0ZW50LlxuXHRcdFx0ICogSG93ZXZlciwgbXVsdGlwbGUgZGlmZmVyZW50IHRhYmxlcyBvbiB0aGUgcGFnZSBjYW4gdXNlIGRpZmZlcmVudFxuXHRcdFx0ICogZGVjaW1hbCBwbGFjZSBjaGFyYWN0ZXJzLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZGVjaW1hbFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJkZWNpbWFsXCI6IFwiLFwiXG5cdFx0XHQgKiAgICAgICAgICBcInRob3VzYW5kc1wiOiBcIi5cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNEZWNpbWFsXCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGF0YVRhYmxlcyBoYXMgYSBidWlsZCBpbiBudW1iZXIgZm9ybWF0dGVyIChgZm9ybWF0TnVtYmVyYCkgd2hpY2ggaXNcblx0XHRcdCAqIHVzZWQgdG8gZm9ybWF0IGxhcmdlIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUgaW5mb3JtYXRpb24uXG5cdFx0XHQgKiBCeSBkZWZhdWx0IGEgY29tbWEgaXMgdXNlZCwgYnV0IHRoaXMgY2FuIGJlIHRyaXZpYWxseSBjaGFuZ2VkIHRvIGFueVxuXHRcdFx0ICogY2hhcmFjdGVyIHlvdSB3aXNoIHdpdGggdGhpcyBwYXJhbWV0ZXIuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgLFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudGhvdXNhbmRzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInRob3VzYW5kc1wiOiBcIidcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNUaG91c2FuZHNcIjogXCIsXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGV0YWlsIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIGRyb3AgZG93biBtZW51IGZvciB0aGVcblx0XHRcdCAqIHBhZ2luYXRpb24gbGVuZ3RoIG9wdGlvbiBpcyBjaGFuZ2VkLiBUaGUgJ19NRU5VXycgdmFyaWFibGUgaXMgcmVwbGFjZWRcblx0XHRcdCAqIHdpdGggYSBkZWZhdWx0IHNlbGVjdCBsaXN0IG9mIDEwLCAyNSwgNTAgYW5kIDEwMCwgYW5kIGNhbiBiZSByZXBsYWNlZFxuXHRcdFx0ICogd2l0aCBhIGN1c3RvbSBzZWxlY3QgYm94IGlmIHJlcXVpcmVkLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNob3cgX01FTlVfIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmxlbmd0aE1lbnVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIExhbmd1YWdlIGNoYW5nZSBvbmx5XG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogXCJEaXNwbGF5IF9NRU5VXyByZWNvcmRzXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIExhbmd1YWdlIGFuZCBvcHRpb25zIGNoYW5nZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6ICdEaXNwbGF5IDxzZWxlY3Q+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIxMFwiPjEwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIyMFwiPjIwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIzMFwiPjMwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI0MFwiPjQwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI1MFwiPjUwPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCItMVwiPkFsbDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8L3NlbGVjdD4gcmVjb3Jkcydcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzTGVuZ3RoTWVudVwiOiBcIlNob3cgX01FTlVfIGVudHJpZXNcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIHVzaW5nIEFqYXggc291cmNlZCBkYXRhIGFuZCBkdXJpbmcgdGhlIGZpcnN0IGRyYXcgd2hlbiBEYXRhVGFibGVzIGlzXG5cdFx0XHQgKiBnYXRoZXJpbmcgdGhlIGRhdGEsIHRoaXMgbWVzc2FnZSBpcyBzaG93biBpbiBhbiBlbXB0eSByb3cgaW4gdGhlIHRhYmxlIHRvXG5cdFx0XHQgKiBpbmRpY2F0ZSB0byB0aGUgZW5kIHVzZXIgdGhlIHRoZSBkYXRhIGlzIGJlaW5nIGxvYWRlZC4gTm90ZSB0aGF0IHRoaXNcblx0XHRcdCAqIHBhcmFtZXRlciBpcyBub3QgdXNlZCB3aGVuIGxvYWRpbmcgZGF0YSBieSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCBqdXN0XG5cdFx0XHQgKiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTG9hZGluZy4uLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubG9hZGluZ1JlY29yZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwibG9hZGluZ1JlY29yZHNcIjogXCJQbGVhc2Ugd2FpdCAtIGxvYWRpbmcuLi5cIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNMb2FkaW5nUmVjb3Jkc1wiOiBcIkxvYWRpbmcuLi5cIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWJsZSBpcyBwcm9jZXNzaW5nIGEgdXNlciBhY3Rpb25cblx0XHRcdCAqICh1c3VhbGx5IGEgc29ydCBjb21tYW5kIG9yIHNpbWlsYXIpLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFByb2Nlc3NpbmcuLi5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnByb2Nlc3Npbmdcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwicHJvY2Vzc2luZ1wiOiBcIkRhdGFUYWJsZXMgaXMgY3VycmVudGx5IGJ1c3lcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNQcm9jZXNzaW5nXCI6IFwiUHJvY2Vzc2luZy4uLlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERldGFpbHMgdGhlIGFjdGlvbnMgdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW50byB0aGVcblx0XHRcdCAqIGZpbHRlcmluZyBpbnB1dCB0ZXh0IGJveC4gVGhlIHZhcmlhYmxlIFwiX0lOUFVUX1wiLCBpZiB1c2VkIGluIHRoZSBzdHJpbmcsXG5cdFx0XHQgKiBpcyByZXBsYWNlZCB3aXRoIHRoZSBIVE1MIHRleHQgYm94IGZvciB0aGUgZmlsdGVyaW5nIGlucHV0IGFsbG93aW5nXG5cdFx0XHQgKiBjb250cm9sIG92ZXIgd2hlcmUgaXQgYXBwZWFycyBpbiB0aGUgc3RyaW5nLiBJZiBcIl9JTlBVVF9cIiBpcyBub3QgZ2l2ZW5cblx0XHRcdCAqIHRoZW4gdGhlIGlucHV0IGJveCBpcyBhcHBlbmRlZCB0byB0aGUgc3RyaW5nIGF1dG9tYXRpY2FsbHkuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2VhcmNoOlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBJbnB1dCB0ZXh0IGJveCB3aWxsIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQgYXV0b21hdGljYWxseVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJGaWx0ZXIgcmVjb3JkczpcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gU3BlY2lmeSB3aGVyZSB0aGUgZmlsdGVyIHNob3VsZCBhcHBlYXJcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiQXBwbHkgZmlsdGVyIF9JTlBVVF8gdG8gdGFibGVcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNTZWFyY2hcIjogXCJTZWFyY2g6XCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXNzaWduIGEgYHBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgdG8gdGhlIHNlYXJjaCBgaW5wdXRgIGVsZW1lbnRcblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFBsYWNlaG9sZGVyXG5cdFx0XHQgKi9cblx0XHRcdFwic1NlYXJjaFBsYWNlaG9sZGVyXCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQWxsIG9mIHRoZSBsYW5ndWFnZSBpbmZvcm1hdGlvbiBjYW4gYmUgc3RvcmVkIGluIGEgZmlsZSBvbiB0aGVcblx0XHRcdCAqIHNlcnZlci1zaWRlLCB3aGljaCBEYXRhVGFibGVzIHdpbGwgbG9vayB1cCBpZiB0aGlzIHBhcmFtZXRlciBpcyBwYXNzZWQuXG5cdFx0XHQgKiBJdCBtdXN0IHN0b3JlIHRoZSBVUkwgb2YgdGhlIGxhbmd1YWdlIGZpbGUsIHdoaWNoIGlzIGluIGEgSlNPTiBmb3JtYXQsXG5cdFx0XHQgKiBhbmQgdGhlIG9iamVjdCBoYXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb0xhbmd1YWdlIG9iamVjdCBpbiB0aGVcblx0XHRcdCAqIGluaXRpYWxpc2VyIG9iamVjdCAoaS5lLiB0aGUgYWJvdmUgcGFyYW1ldGVycykuIFBsZWFzZSByZWZlciB0byBvbmUgb2Zcblx0XHRcdCAqIHRoZSBleGFtcGxlIGxhbmd1YWdlIGZpbGVzIHRvIHNlZSBob3cgdGhpcyB3b3JrcyBpbiBhY3Rpb24uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnVybFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnNwcnltZWRpYS5jby51ay9kYXRhVGFibGVzL2xhbmcudHh0XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzVXJsXCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGV4dCBzaG93biBpbnNpZGUgdGhlIHRhYmxlIHJlY29yZHMgd2hlbiB0aGUgaXMgbm8gaW5mb3JtYXRpb24gdG8gYmVcblx0XHRcdCAqIGRpc3BsYXllZCBhZnRlciBmaWx0ZXJpbmcuIGBlbXB0eVRhYmxlYCBpcyBzaG93biB3aGVuIHRoZXJlIGlzIHNpbXBseSBub1xuXHRcdFx0ICogaW5mb3JtYXRpb24gaW4gdGhlIHRhYmxlIGF0IGFsbCAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IE5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnplcm9SZWNvcmRzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInplcm9SZWNvcmRzXCI6IFwiTm8gcmVjb3JkcyB0byBkaXNwbGF5XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzWmVyb1JlY29yZHNcIjogXCJObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXCJcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBoYXZlIGRlZmluZSB0aGUgZ2xvYmFsIGZpbHRlcmluZyBzdGF0ZSBhdFxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIHRpbWUuIEFzIGFuIG9iamVjdCB0aGUgYHNlYXJjaGAgcGFyYW1ldGVyIG11c3QgYmVcblx0XHQgKiBkZWZpbmVkLCBidXQgYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBXaGVuIGByZWdleGAgaXMgdHJ1ZSxcblx0XHQgKiB0aGUgc2VhcmNoIHN0cmluZyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHdoZW4gZmFsc2Vcblx0XHQgKiAoZGVmYXVsdCkgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgc3RyYWlnaHQgc3RyaW5nLiBXaGVuIGBzbWFydGBcblx0XHQgKiBEYXRhVGFibGVzIHdpbGwgdXNlIGl0J3Mgc21hcnQgZmlsdGVyaW5nIG1ldGhvZHMgKHRvIHdvcmQgbWF0Y2ggYXRcblx0XHQgKiBhbnkgcG9pbnQgaW4gdGhlIGRhdGEpLCB3aGVuIGZhbHNlIHRoaXMgd2lsbCBub3QgYmUgZG9uZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaFwiOiB7XCJzZWFyY2hcIjogXCJJbml0aWFsIHNlYXJjaFwifVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwib1NlYXJjaFwiOiAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCApLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3IgYGFhRGF0YWAgZm9yXG5cdFx0ICogY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YSBmcm9tIGFuIEFqYXhcblx0XHQgKiBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlciBhbGxvd3MgdGhhdFxuXHRcdCAqIHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkIG9iamVjdCBub3RhdGlvbiB0b1xuXHRcdCAqIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IGRhdGFcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhEYXRhUHJvcFxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic0FqYXhEYXRhUHJvcFwiOiBcImRhdGFcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIFlvdSBjYW4gaW5zdHJ1Y3QgRGF0YVRhYmxlcyB0byBsb2FkIGRhdGEgZnJvbSBhbiBleHRlcm5hbFxuXHRcdCAqIHNvdXJjZSB1c2luZyB0aGlzIHBhcmFtZXRlciAodXNlIGFEYXRhIGlmIHlvdSB3YW50IHRvIHBhc3MgZGF0YSBpbiB5b3Vcblx0XHQgKiBhbHJlYWR5IGhhdmUpLiBTaW1wbHkgcHJvdmlkZSBhIHVybCBhIEpTT04gb2JqZWN0IGNhbiBiZSBvYnRhaW5lZCBmcm9tLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFNvdXJjZVxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic0FqYXhTb3VyY2VcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaW5pdGlhbGlzYXRpb24gdmFyaWFibGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGV4YWN0bHkgd2hlcmUgaW4gdGhlXG5cdFx0ICogRE9NIHlvdSB3YW50IERhdGFUYWJsZXMgdG8gaW5qZWN0IHRoZSB2YXJpb3VzIGNvbnRyb2xzIGl0IGFkZHMgdG8gdGhlIHBhZ2Vcblx0XHQgKiAoZm9yIGV4YW1wbGUgeW91IG1pZ2h0IHdhbnQgdGhlIHBhZ2luYXRpb24gY29udHJvbHMgYXQgdGhlIHRvcCBvZiB0aGVcblx0XHQgKiB0YWJsZSkuIERJViBlbGVtZW50cyAod2l0aCBvciB3aXRob3V0IGEgY3VzdG9tIGNsYXNzKSBjYW4gYWxzbyBiZSBhZGRlZCB0b1xuXHRcdCAqIGFpZCBzdHlsaW5nLiBUaGUgZm9sbG93IHN5bnRheCBpcyB1c2VkOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhbGxvd2VkOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgYWxsb3dlZDpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+J0gnIC0galF1ZXJ5VUkgdGhlbWUgXCJoZWFkZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10bCB1aS1jb3JuZXItdHIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidGJyAtIGpRdWVyeVVJIHRoZW1lIFwiZm9vdGVyXCIgY2xhc3NlcyAoJ2ZnLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYmwgdWktY29ybmVyLWJyIHVpLWhlbHBlci1jbGVhcmZpeCcpPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBzeW50YXggaXMgZXhwZWN0ZWQ6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7JyBhbmQgJyZndDsnIC0gZGl2IGVsZW1lbnRzPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wiY2xhc3NcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYSBjbGFzczwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDtcIiNpZFwiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhbiBJRDwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgICAgPGxpPkV4YW1wbGVzOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wid3JhcHBlclwiZmxpcHQmZ3Q7JzwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDtsZiZsdDt0Jmd0O2lwJmd0Oyc8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbGZydGlwIDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgZmFsc2UpPC9pPiA8Yj5vcjwvYj5cblx0XHQgKiAgICA8XCJIXCJsZnI+dDxcIkZcImlwPiA8aT4od2hlbiBgalF1ZXJ5VUlgIGlzIHRydWUpPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kb21cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZG9tXCI6ICcmbHQ7XCJ0b3BcImkmZ3Q7cnQmbHQ7XCJib3R0b21cImZscCZndDsmbHQ7XCJjbGVhclwiJmd0Oydcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzRG9tXCI6IFwibGZydGlwXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWFyY2ggZGVsYXkgb3B0aW9uLiBUaGlzIHdpbGwgdGhyb3R0bGUgZnVsbCB0YWJsZSBzZWFyY2hlcyB0aGF0IHVzZSB0aGVcblx0XHQgKiBEYXRhVGFibGVzIHByb3ZpZGVkIHNlYXJjaCBpbnB1dCBlbGVtZW50IChpdCBkb2VzIG5vdCBlZmZlY3QgY2FsbHMgdG9cblx0XHQgKiBgZHQtYXBpIHNlYXJjaCgpYCwgcHJvdmlkaW5nIGEgZGVsYXkgYmVmb3JlIHRoZSBzZWFyY2ggaXMgbWFkZS5cblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaERlbGF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaERlbGF5XCI6IDIwMFxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgZmVhdHVyZXMgc2l4IGRpZmZlcmVudCBidWlsdC1pbiBvcHRpb25zIGZvciB0aGUgYnV0dG9ucyB0b1xuXHRcdCAqIGRpc3BsYXkgZm9yIHBhZ2luYXRpb24gY29udHJvbDpcblx0XHQgKlxuXHRcdCAqICogYG51bWJlcnNgIC0gUGFnZSBudW1iZXIgYnV0dG9ucyBvbmx5XG5cdFx0ICogKiBgc2ltcGxlYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zIG9ubHlcblx0XHQgKiAqICdzaW1wbGVfbnVtYmVyc2AgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcblx0XHQgKiAqIGBmdWxsX251bWJlcnNgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAqIGBmaXJzdF9sYXN0X251bWJlcnNgIC0gJ0ZpcnN0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG5cdFx0ICogIFxuXHRcdCAqIEZ1cnRoZXIgbWV0aG9kcyBjYW4gYmUgYWRkZWQgdXNpbmcge0BsaW5rIERhdGFUYWJsZS5leHQub1BhZ2luYXRpb259LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgc2ltcGxlX251bWJlcnNcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nVHlwZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdpbmdUeXBlXCI6IFwiZnVsbF9udW1iZXJzXCJcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInNpbXBsZV9udW1iZXJzXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdoZW4gYSB0YWJsZSBpcyB0b28gd2lkZSB0byBmaXQgaW50byBhXG5cdFx0ICogY2VydGFpbiBsYXlvdXQsIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCB5b3Vcblx0XHQgKiBjYW4gZW5hYmxlIHgtc2Nyb2xsaW5nIHRvIHNob3cgdGhlIHRhYmxlIGluIGEgdmlld3BvcnQsIHdoaWNoIGNhbiBiZVxuXHRcdCAqIHNjcm9sbGVkLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBgdHJ1ZWAgd2hpY2ggd2lsbCBhbGxvdyB0aGUgdGFibGUgdG9cblx0XHQgKiBzY3JvbGwgaG9yaXpvbnRhbGx5IHdoZW4gbmVlZGVkLCBvciBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaFxuXHRcdCAqIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLiBTZXR0aW5nIGFzIHNpbXBseSBgdHJ1ZWBcblx0XHQgKiBpcyByZWNvbW1lbmRlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2Nyb2xsWFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBmb3JjZSBhIERhdGFUYWJsZSB0byB1c2UgbW9yZSB3aWR0aCB0aGFuIGl0XG5cdFx0ICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxuXHRcdCAqIHRhYmxlIHdoaWNoIHJlcXVpcmVzIHRvIGJlIHdlbGwgc3BhY2VkLCB0aGlzIHBhcmFtZXRlciBpcyB1c2VmdWwgZm9yXG5cdFx0ICogXCJvdmVyLXNpemluZ1wiIHRoZSB0YWJsZSwgYW5kIHRodXMgZm9yY2luZyBzY3JvbGxpbmcuIFRoaXMgcHJvcGVydHkgY2FuIGJ5XG5cdFx0ICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxuXHRcdCAqIG1lYXN1cmVtZW50KS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhJbm5lclxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IFwiMTAwJVwiLFxuXHRcdCAqICAgICAgICBcInNjcm9sbFhJbm5lclwiOiBcIjExMCVcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTY3JvbGxYSW5uZXJcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyB3aWxsIGNvbnN0cmFpbiB0aGUgRGF0YVRhYmxlXG5cdFx0ICogdG8gdGhlIGdpdmVuIGhlaWdodCwgYW5kIGVuYWJsZSBzY3JvbGxpbmcgZm9yIGFueSBkYXRhIHdoaWNoIG92ZXJmbG93cyB0aGVcblx0XHQgKiBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHBhZ2luZyB0byBkaXNwbGF5XG5cdFx0ICogYSBsb3Qgb2YgZGF0YSBpbiBhIHNtYWxsIGFyZWEgKGFsdGhvdWdoIHBhZ2luZyBhbmQgc2Nyb2xsaW5nIGNhbiBib3RoIGJlXG5cdFx0ICogZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYW55IENTUyB1bml0LCBvciBhIG51bWJlclxuXHRcdCAqIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxZXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1Njcm9sbFlcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIFNldCB0aGUgSFRUUCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG1ha2UgdGhlIEFqYXggY2FsbCBmb3Igc2VydmVyLXNpZGVcblx0XHQgKiBwcm9jZXNzaW5nIG9yIEFqYXggc291cmNlZCBkYXRhLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgR0VUXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJNZXRob2Rcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcInNTZXJ2ZXJNZXRob2RcIjogXCJHRVRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgbWFrZXMgdXNlIG9mIHJlbmRlcmVycyB3aGVuIGRpc3BsYXlpbmcgSFRNTCBlbGVtZW50cyBmb3Jcblx0XHQgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXG5cdFx0ICogZ2VuZXJhdGUgc3VpdGFibGUgbWFyay11cCBmb3IgYSBzaXRlLiBGb3IgZXhhbXBsZSB0aGUgQm9vdHN0cmFwXG5cdFx0ICogaW50ZWdyYXRpb24gcGx1Zy1pbiBmb3IgRGF0YVRhYmxlcyB1c2VzIGEgcGFnaW5nIGJ1dHRvbiByZW5kZXJlciB0b1xuXHRcdCAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cblx0XHQgKlxuXHRcdCAqIEZvciBmdXJ0aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlcnMgYXZhaWxhYmxlIHNlZVxuXHRcdCAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcblx0XHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJlbmRlcmVyXG5cdFx0ICpcblx0XHQgKi9cblx0XHRcInJlbmRlcmVyXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGRhdGEgcHJvcGVydHkgbmFtZSB0aGF0IERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0byBnZXQgYSByb3cncyBpZFxuXHRcdCAqIHRvIHNldCBhcyB0aGUgYGlkYCBwcm9wZXJ0eSBpbiB0aGUgbm9kZS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IERUX1Jvd0lkXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0lkXG5cdFx0ICovXG5cdFx0XCJyb3dJZFwiOiBcIkRUX1Jvd0lkXCJcblx0fTtcblx0XG5cdF9mbkh1bmdhcmlhbk1hcCggRGF0YVRhYmxlLmRlZmF1bHRzICk7XG5cdFxuXHRcblx0XG5cdC8qXG5cdCAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cblx0ICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIENvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb24gdGltZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIHdoaWNoIGNvbHVtbihzKSBhbiBvcmRlciB3aWxsIG9jY3VyIG9uIGZvciB0aGlzIGNvbHVtbi4gVGhpc1xuXHRcdCAqIGFsbG93cyBhIGNvbHVtbidzIG9yZGVyaW5nIHRvIHRha2UgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGFjY291bnQgd2hlblxuXHRcdCAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XG5cdFx0ICogbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zIG1ha2Ugc2Vuc2UgdG8gZG8gYSBtdWx0aS1jb2x1bW4gc29ydCBvdmVyIHRoZVxuXHRcdCAqIHR3byBjb2x1bW5zLlxuXHRcdCAqICBAdHlwZSBhcnJheXxpbnRcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5UYWtlcyB0aGUgdmFsdWUgb2YgdGhlIGNvbHVtbiBpbmRleCBhdXRvbWF0aWNhbGx5PC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0sIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiwgXCJ0YXJnZXRzXCI6IFsgMiBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IDIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcdFwiaURhdGFTb3J0XCI6IC0xLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXG5cdFx0ICogYmVoYXZpb3VyIG9mIHRoZSBzb3J0IGhhbmRsZXIgKGkuZS4gb25seSBhbGxvdyBhc2NlbmRpbmcgb3JkZXJpbmcgZXRjKVxuXHRcdCAqIHVzaW5nIHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbICdhc2MnLCAnZGVzYycgXVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJTZXF1ZW5jZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAyIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDMgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhc1NvcnRpbmdcIjogWyAnYXNjJywgJ2Rlc2MnIF0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb24gdGhlIGRhdGEgaW4gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uc2VhcmNoYWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNlYXJjaGFibGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyYWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF0gfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udmlzaWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidmlzaWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidmlzaWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlZpc2libGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IHRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuXHRcdCAqICBAcGFyYW0geyp9IGNlbGxEYXRhIFRoZSBEYXRhIGZvciB0aGUgY2VsbFxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gcm93RGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gaW5kZXggZm9yIGFvQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY3JlYXRlZENlbGxcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWzNdLFxuXHRcdCAqICAgICAgICAgIFwiY3JlYXRlZENlbGxcIjogZnVuY3Rpb24gKHRkLCBjZWxsRGF0YSwgcm93RGF0YSwgcm93LCBjb2wpIHtcblx0XHQgKiAgICAgICAgICAgIGlmICggY2VsbERhdGEgPT0gXCIxLjdcIiApIHtcblx0XHQgKiAgICAgICAgICAgICAgJCh0ZCkuY3NzKCdjb2xvcicsICdibHVlJylcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVwbGFjZWQgYnkgYGRhdGFgIGluIERhdGFUYWJsZXMgdG8gZW5zdXJlIG5hbWluZ1xuXHRcdCAqIGNvbnNpc3RlbmN5LiBgZGF0YVByb3BgIGNhbiBzdGlsbCBiZSB1c2VkLCBhcyB0aGVyZSBpcyBiYWNrd2FyZHNcblx0XHQgKiBjb21wYXRpYmlsaXR5IGluIERhdGFUYWJsZXMgZm9yIHRoaXMgb3B0aW9uLCBidXQgaXQgaXMgc3Ryb25nbHlcblx0XHQgKiByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgYGRhdGFgIGluIHByZWZlcmVuY2UgdG8gYGRhdGFQcm9wYC5cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhUHJvcFxuXHRcdCAqL1xuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXG5cdFx0ICogaW5jbHVkaW5nIGRlZXBseSBuZXN0ZWQgb2JqZWN0cyAvIHByb3BlcnRpZXMuIGBkYXRhYCBjYW4gYmUgZ2l2ZW4gaW4gYVxuXHRcdCAqIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB3aGljaCBlZmZlY3QgaXRzIGJlaGF2aW91cjpcblx0XHQgKlxuXHRcdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHRcdCAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cblx0XHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHRcdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHRcdCAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuXHRcdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHRcdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHRcdCAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG5cdFx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHRcdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0XHQgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcblx0XHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdFx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHRcdCAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG5cdFx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0XHQgKiAgICAgIHJldHVybmVkLlxuXHRcdCAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcblx0XHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdFx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdFx0ICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG5cdFx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XG5cdFx0ICogICAgICBmdW5jdGlvbiBub3RhdGlvbiBpcyByZWNvbW1lbmRlZCBmb3IgdXNlIGluIGByZW5kZXJgIHJhdGhlciB0aGFuXG5cdFx0ICogICAgICBgZGF0YWAgYXMgaXQgaXMgbXVjaCBzaW1wbGVyIHRvIHVzZSBhcyBhIHJlbmRlcmVyLlxuXHRcdCAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xuXHRcdCAqICAgZGF0YSBkaXJlY3RseSBmcm9tIGl0LiBUaGlzIGFjdGlvbiBoYXMgZWZmZWN0cyBvbiB0d28gb3RoZXJcblx0XHQgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxuXHRcdCAqICAgICAgYGRlZmF1bHRDb250ZW50YCBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB2YWx1ZSBkZWZpbmVkIGJ5XG5cdFx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbGwuXG5cdFx0ICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXG5cdFx0ICogICAgICBvcHRpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgd2hvbGUgZGF0YSBzb3VyY2UgZm9yIHRoZVxuXHRcdCAqICAgICAgcm93IGlzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdFx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdFx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgICogUGFyYW1ldGVyczpcblx0XHQgKiAgICAgICogYHthcnJheXxvYmplY3R9YCBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3dcblx0XHQgKiAgICAgICogYHtzdHJpbmd9YCBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdzZXQnIHdoZW5cblx0XHQgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxuXHRcdCAqICAgICAgICB3aGVuIGdhdGhlcmluZyBkYXRhLiBOb3RlIHRoYXQgd2hlbiBgdW5kZWZpbmVkYCBpcyBnaXZlbiBmb3IgdGhlXG5cdFx0ICogICAgICAgIHR5cGUgRGF0YVRhYmxlcyBleHBlY3RzIHRvIGdldCB0aGUgcmF3IGRhdGEgZm9yIHRoZSBvYmplY3QgYmFjazxcblx0XHQgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cblx0XHQgKiAgICAqIFJldHVybjpcblx0XHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiAnc2V0JyBpc1xuXHRcdCAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcblx0XHQgKiAgICAgICAgZm9yIHRoZSBkYXRhIHJlcXVlc3RlZC5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcblx0XHQgKiBmb3JtYXR0aW5nIG9mIGRhdGEgZm9yIG91dHB1dCwgeW91IHdpbGwgbGlrZWx5IHdhbnQgdG8gdXNlIGByZW5kZXJgIHdoaWNoXG5cdFx0ICogaXMgc2ltcGx5IGEgZ2V0dGVyIGFuZCB0aHVzIHNpbXBsZXIgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHByaW9yIHRvIERhdGFUYWJsZXMgMS45LjIgYGRhdGFgIHdhcyBjYWxsZWQgYG1EYXRhUHJvcGAuIFRoZVxuXHRcdCAqIG5hbWUgY2hhbmdlIHJlZmxlY3RzIHRoZSBmbGV4aWJpbGl0eSBvZiB0aGlzIHByb3BlcnR5IGFuZCBpcyBjb25zaXN0ZW50XG5cdFx0ICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcblx0XHQgKiBiZSB1c2VkIGJ5IERhdGFUYWJsZXMsIGFzIGl0IGF1dG9tYXRpY2FsbHkgbWFwcyB0aGUgb2xkIG5hbWUgdG8gdGhlIG5ld1xuXHRcdCAqIGlmIHJlcXVpcmVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPlVzZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgY29sdW1uIGluZGV4PC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGF0YVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVhZCB0YWJsZSBkYXRhIGZyb20gb2JqZWN0c1xuXHRcdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0XHQgKiAgICAvLyAgIHtcblx0XHQgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwidmVyc2lvblwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJncmFkZVwiOiB7dmFsdWV9XG5cdFx0ICogICAgLy8gICB9XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9vYmplY3RzLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlYWQgaW5mb3JtYXRpb24gZnJvbSBkZWVwbHkgbmVzdGVkIG9iamVjdHNcblx0XHQgKiAgICAvLyBKU09OIHN0cnVjdHVyZSBmb3IgZWFjaCByb3c6XG5cdFx0ICogICAgLy8gICB7XG5cdFx0ICogICAgLy8gICAgICBcImVuZ2luZVwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJicm93c2VyXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHtcblx0XHQgKiAgICAvLyAgICAgICAgIFwiaW5uZXJcIjoge3ZhbHVlfVxuXHRcdCAqICAgIC8vICAgICAgfSxcblx0XHQgKiAgICAvLyAgICAgIFwiZGV0YWlsc1wiOiBbXG5cdFx0ICogICAgLy8gICAgICAgICB7dmFsdWV9LCB7dmFsdWV9XG5cdFx0ICogICAgLy8gICAgICBdXG5cdFx0ICogICAgLy8gICB9XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uaW5uZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZGV0YWlscy4wXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImRldGFpbHMuMVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBkYXRhYCBhcyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGlmZmVyZW50IGluZm9ybWF0aW9uIGZvclxuXHRcdCAqICAgIC8vIHNvcnRpbmcsIGZpbHRlcmluZyBhbmQgZGlzcGxheS4gSW4gdGhpcyBjYXNlLCBjdXJyZW5jeSAocHJpY2UpXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBzb3VyY2UsIHR5cGUsIHZhbCApIHtcblx0XHQgKiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2V0Jykge1xuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2UgPSB2YWw7XG5cdFx0ICogICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wdXRlZCBkaXNwbGF5IGFuZCBmaWx0ZXIgdmFsdWVzIGZvciBlZmZpY2llbmN5XG5cdFx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9kaXNwbGF5ID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpO1xuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZmlsdGVyICA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKStcIiBcIit2YWw7XG5cdFx0ICogICAgICAgICAgICAgIHJldHVybjtcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdkaXNwbGF5Jykge1xuXHRcdCAqICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnByaWNlX2Rpc3BsYXk7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZmlsdGVyJykge1xuXHRcdCAqICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnByaWNlX2ZpbHRlcjtcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICAgIC8vICdzb3J0JywgJ3R5cGUnIGFuZCB1bmRlZmluZWQgYWxsIGp1c3QgdXNlIHRoZSBpbnRlZ2VyXG5cdFx0ICogICAgICAgICAgICByZXR1cm4gc291cmNlLnByaWNlO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgZGVmYXVsdCBjb250ZW50XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCxcblx0XHQgKiAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiQ2xpY2sgdG8gZWRpdFwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGFycmF5IG5vdGF0aW9uIC0gb3V0cHV0dGluZyBhIGxpc3QgZnJvbSBhbiBhcnJheVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IFwibmFtZVssIF1cIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKi9cblx0XHRcIm1EYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGlzIHRoZSByZW5kZXJpbmcgcGFydG5lciB0byBgZGF0YWAgYW5kIGl0IGlzIHN1Z2dlc3RlZCB0aGF0XG5cdFx0ICogd2hlbiB5b3Ugd2FudCB0byBtYW5pcHVsYXRlIGRhdGEgZm9yIGRpc3BsYXkgKGluY2x1ZGluZyBmaWx0ZXJpbmcsXG5cdFx0ICogc29ydGluZyBldGMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBmb3IgdGhlIHRhYmxlLCB1c2UgdGhpc1xuXHRcdCAqIHByb3BlcnR5LiBgcmVuZGVyYCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSB0aGUgdGhlIHJlYWQgb25seSBjb21wYW5pb24gdG9cblx0XHQgKiBgZGF0YWAgd2hpY2ggaXMgcmVhZCAvIHdyaXRlICh0aGVuIGFzIHN1Y2ggbW9yZSBjb21wbGV4KS4gTGlrZSBgZGF0YWBcblx0XHQgKiB0aGlzIG9wdGlvbiBjYW4gYmUgZ2l2ZW4gaW4gYSBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgdG8gZWZmZWN0IGl0c1xuXHRcdCAqIGJlaGF2aW91cjpcblx0XHQgKlxuXHRcdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHRcdCAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cblx0XHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHRcdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHRcdCAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuXHRcdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHRcdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHRcdCAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG5cdFx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHRcdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0XHQgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcblx0XHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdFx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHRcdCAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG5cdFx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0XHQgKiAgICAgIHJldHVybmVkLlxuXHRcdCAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcblx0XHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdFx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdFx0ICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG5cdFx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC5cblx0XHQgKiAqIGBvYmplY3RgIC0gdXNlIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IGRhdGEgdHlwZXMgcmVxdWVzdGVkIGJ5XG5cdFx0ICogICBEYXRhVGFibGVzICgnZmlsdGVyJywgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnKS4gVGhlIHByb3BlcnR5IG5hbWVzXG5cdFx0ICogICBvZiB0aGUgb2JqZWN0IGlzIHRoZSBkYXRhIHR5cGUgdGhlIHByb3BlcnR5IHJlZmVycyB0byBhbmQgdGhlIHZhbHVlIGNhblxuXHRcdCAqICAgZGVmaW5lZCB1c2luZyBhbiBpbnRlZ2VyLCBzdHJpbmcgb3IgZnVuY3Rpb24gdXNpbmcgdGhlIHNhbWUgcnVsZXMgYXNcblx0XHQgKiAgIGByZW5kZXJgIG5vcm1hbGx5IGRvZXMuIE5vdGUgdGhhdCBhbiBgX2Agb3B0aW9uIF9tdXN0XyBiZSBzcGVjaWZpZWQuXG5cdFx0ICogICBUaGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB5b3UgaGF2ZW4ndCBzcGVjaWZpZWQgYSB2YWx1ZSBmb3Jcblx0XHQgKiAgIHRoZSBkYXRhIHR5cGUgcmVxdWVzdGVkIGJ5IERhdGFUYWJsZXMuXG5cdFx0ICogKiBgZnVuY3Rpb25gIC0gdGhlIGZ1bmN0aW9uIGdpdmVuIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgRGF0YVRhYmxlc1xuXHRcdCAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxuXHRcdCAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcblx0XHQgKiAgICAqIFBhcmFtZXRlcnM6XG5cdFx0ICogICAgICAqIHthcnJheXxvYmplY3R9IFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAoYmFzZWQgb24gYGRhdGFgKVxuXHRcdCAqICAgICAgKiB7c3RyaW5nfSBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdmaWx0ZXInLFxuXHRcdCAqICAgICAgICAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcuXG5cdFx0ICogICAgICAqIHthcnJheXxvYmplY3R9IFRoZSBmdWxsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChub3QgYmFzZWQgb25cblx0XHQgKiAgICAgICAgYGRhdGFgKVxuXHRcdCAqICAgICogUmV0dXJuOlxuXHRcdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHdoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGVcblx0XHQgKiAgICAgICAgZGF0YSByZXF1ZXN0ZWQuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGludHxmdW5jdGlvbnxvYmplY3R8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIFVzZSB0aGUgZGF0YSBzb3VyY2UgdmFsdWUuXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5yZW5kZXJcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIENyZWF0ZSBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvZGVlcC50eHRcIixcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImRhdGFcIjogXCJwbGF0Zm9ybVwiLFxuXHRcdCAqICAgICAgICAgICAgXCJyZW5kZXJcIjogXCJbLCBdLm5hbWVcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiB0byBvYnRhaW4gZGF0YVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxuXHRcdCAqICAgICAgICAgIFwicmVuZGVyXCI6IFwiYnJvd3Nlck5hbWUoKVwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEFzIGFuIG9iamVjdCwgZXh0cmFjdGluZyBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCB0eXBlc1xuXHRcdCAqICAgIC8vIFRoaXMgd291bGQgYmUgdXNlZCB3aXRoIGEgZGF0YSBzb3VyY2Ugc3VjaCBhczpcblx0XHQgKiAgICAvLyAgIHsgXCJwaG9uZVwiOiA1NTUyMzY4LCBcInBob25lX2ZpbHRlclwiOiBcIjU1NTIzNjggNTU1LTIzNjhcIiwgXCJwaG9uZV9kaXNwbGF5XCI6IFwiNTU1LTIzNjhcIiB9XG5cdFx0ICogICAgLy8gSGVyZSB0aGUgYHBob25lYCBpbnRlZ2VyIGlzIHVzZWQgZm9yIHNvcnRpbmcgYW5kIHR5cGUgZGV0ZWN0aW9uLCB3aGlsZSBgcGhvbmVfZmlsdGVyYFxuXHRcdCAqICAgIC8vICh3aGljaCBoYXMgYm90aCBmb3JtcykgaXMgdXNlZCBmb3IgZmlsdGVyaW5nIGZvciBpZiBhIHVzZXIgaW5wdXRzIGVpdGhlciBmb3JtYXQsIHdoaWxlXG5cdFx0ICogICAgLy8gdGhlIGZvcm1hdHRlZCBwaG9uZSBudW1iZXIgaXMgdGhlIG9uZSB0aGF0IGlzIHNob3duIGluIHRoZSB0YWJsZS5cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLCAvLyBVc2UgdGhlIGZ1bGwgZGF0YSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgcmVuZGVyZXIncyBzb3VyY2Vcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiB7XG5cdFx0ICogICAgICAgICAgICBcIl9cIjogXCJwaG9uZVwiLFxuXHRcdCAqICAgICAgICAgICAgXCJmaWx0ZXJcIjogXCJwaG9uZV9maWx0ZXJcIixcblx0XHQgKiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcInBob25lX2Rpc3BsYXlcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNlIGFzIGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbGluayBmcm9tIHRoZSBkYXRhIHNvdXJjZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IFwiZG93bmxvYWRfbGlua1wiLFxuXHRcdCAqICAgICAgICAgIFwicmVuZGVyXCI6IGZ1bmN0aW9uICggZGF0YSwgdHlwZSwgZnVsbCApIHtcblx0XHQgKiAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cIicrZGF0YSsnXCI+RG93bmxvYWQ8L2E+Jztcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcIm1SZW5kZXJcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENoYW5nZSB0aGUgY2VsbCB0eXBlIGNyZWF0ZWQgZm9yIHRoZSBjb2x1bW4gLSBlaXRoZXIgVEQgY2VsbHMgb3IgVEggY2VsbHMuIFRoaXNcblx0XHQgKiBjYW4gYmUgdXNlZnVsIGFzIFRIIGNlbGxzIGhhdmUgc2VtYW50aWMgbWVhbmluZyBpbiB0aGUgdGFibGUgYm9keSwgYWxsb3dpbmcgdGhlbVxuXHRcdCAqIHRvIGFjdCBhcyBhIGhlYWRlciBmb3IgYSByb3cgKHlvdSBtYXkgd2lzaCB0byBhZGQgc2NvcGU9J3JvdycgdG8gdGhlIFRIIGVsZW1lbnRzKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHRkXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jZWxsVHlwZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gTWFrZSB0aGUgZmlyc3QgY29sdW1uIHVzZSBUSCBjZWxsc1xuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJjZWxsVHlwZVwiOiBcInRoXCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0NlbGxUeXBlXCI6IFwidGRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIHRvIGdpdmUgdG8gZWFjaCBjZWxsIGluIHRoaXMgY29sdW1uLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2xhc3Ncblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImNsYXNzXCI6IFwibXlfY2xhc3NcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImNsYXNzXCI6IFwibXlfY2xhc3NcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNDbGFzc1wiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdFx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHRcdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHRcdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdFx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHRcdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0XHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdFx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0XHQgKiBHZW5lcmFsbHkgeW91IHNob3VsZG4ndCBuZWVkIHRoaXMhXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8aT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNvbnRlbnRQYWRkaW5nXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiY29udGVudFBhZGRpbmdcIjogXCJtbW1cIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNDb250ZW50UGFkZGluZ1wiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXG5cdFx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIGBkYXRhYFxuXHRcdCAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kZWZhdWx0Q29udGVudFxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImRhdGFcIjogbnVsbCxcblx0XHQgKiAgICAgICAgICAgIFwiZGVmYXVsdENvbnRlbnRcIjogXCJFZGl0XCIsXG5cdFx0ICogICAgICAgICAgICBcInRhcmdldHNcIjogWyAtMSBdXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImRhdGFcIjogbnVsbCxcblx0XHQgKiAgICAgICAgICAgIFwiZGVmYXVsdENvbnRlbnRcIjogXCJFZGl0XCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzRGVmYXVsdENvbnRlbnRcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpbiBEYXRhVGFibGVzJyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLiBJdCBjYW5cblx0XHQgKiBiZSBleGNlcHRpb25hbGx5IHVzZWZ1bCB0byBrbm93IHdoYXQgY29sdW1ucyBhcmUgYmVpbmcgZGlzcGxheWVkIG9uIHRoZVxuXHRcdCAqIGNsaWVudCBzaWRlLCBhbmQgdG8gbWFwIHRoZXNlIHRvIGRhdGFiYXNlIGZpZWxkcy4gV2hlbiBkZWZpbmVkLCB0aGUgbmFtZXNcblx0XHQgKiBhbHNvIGFsbG93IERhdGFUYWJsZXMgdG8gcmVvcmRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaWYgaXQgY29tZXNcblx0XHQgKiBiYWNrIGluIGFuIHVuZXhwZWN0ZWQgb3JkZXIgKGkuZS4gaWYgeW91IHN3aXRjaCB5b3VyIGNvbHVtbnMgYXJvdW5kIG9uIHRoZVxuXHRcdCAqIGNsaWVudC1zaWRlLCB5b3VyIHNlcnZlci1zaWRlIGNvZGUgZG9lcyBub3QgYWxzbyBuZWVkIHVwZGF0aW5nKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm5hbWVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJlbmdpbmVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIsIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGxhdGZvcm1cIiwgXCJ0YXJnZXRzXCI6IFsgMiBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJ2ZXJzaW9uXCIsIFwidGFyZ2V0c1wiOiBbIDMgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic05hbWVcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgYSBkYXRhIHNvdXJjZSB0eXBlIGZvciB0aGUgb3JkZXJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVhZFxuXHRcdCAqIHJlYWwtdGltZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0YWJsZSAodXBkYXRpbmcgdGhlIGludGVybmFsbHkgY2FjaGVkXG5cdFx0ICogdmVyc2lvbikgcHJpb3IgdG8gb3JkZXJpbmcuIFRoaXMgYWxsb3dzIG9yZGVyaW5nIHRvIG9jY3VyIG9uIHVzZXJcblx0XHQgKiBlZGl0YWJsZSBlbGVtZW50cyBzdWNoIGFzIGZvcm0gaW5wdXRzLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgc3RkXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFUeXBlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0YXJnZXRzXCI6IFsgMiwgMyBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcInR5cGVcIjogXCJudW1lcmljXCIsIFwidGFyZ2V0c1wiOiBbIDMgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXNlbGVjdFwiLCBcInRhcmdldHNcIjogWyA0IF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiLCBcInRhcmdldHNcIjogWyA1IF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInR5cGVcIjogXCJudW1lcmljXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1zZWxlY3RcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLWNoZWNrYm94XCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1NvcnREYXRhVHlwZVwiOiBcInN0ZFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRpdGxlIG9mIHRoaXMgY29sdW1uLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5EZXJpdmVkIGZyb20gdGhlICdUSCcgdmFsdWUgZm9yIHRoaXMgY29sdW1uIGluIHRoZVxuXHRcdCAqICAgIG9yaWdpbmFsIEhUTUwgdGFibGUuPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udGl0bGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiTXkgY29sdW1uIHRpdGxlXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1RpdGxlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgaG93IHRoZSBkYXRhIGZvciB0aGlzIGNvbHVtbiB3aWxsIGJlXG5cdFx0ICogb3JkZXJlZC4gRm91ciB0eXBlcyAoc3RyaW5nLCBudW1lcmljLCBkYXRlIGFuZCBodG1sICh3aGljaCB3aWxsIHN0cmlwXG5cdFx0ICogSFRNTCB0YWdzIGJlZm9yZSBvcmRlcmluZykpIGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlLiBOb3RlIHRoYXQgb25seSBkYXRlXG5cdFx0ICogZm9ybWF0cyB1bmRlcnN0b29kIGJ5IEphdmFzY3JpcHQncyBEYXRlKCkgb2JqZWN0IHdpbGwgYmUgYWNjZXB0ZWQgYXMgdHlwZVxuXHRcdCAqIGRhdGUuIEZvciBleGFtcGxlOiBcIk1hciAyNiwgMjAwOCA1OjAzIFBNXCIuIE1heSB0YWtlIHRoZSB2YWx1ZXM6ICdzdHJpbmcnLFxuXHRcdCAqICdudW1lcmljJywgJ2RhdGUnIG9yICdodG1sJyAoYnkgZGVmYXVsdCkuIEZ1cnRoZXIgdHlwZXMgY2FuIGJlIGFkZGluZ1xuXHRcdCAqIHRocm91Z2ggcGx1Zy1pbnMuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPkF1dG8tZGV0ZWN0ZWQgZnJvbSByYXcgZGF0YTwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnR5cGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInR5cGVcIjogXCJodG1sXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1R5cGVcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlZmluaW5nIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLCB0aGlzIHBhcmFtZXRlciBtYXkgdGFrZSBhbnkgQ1NTIHZhbHVlXG5cdFx0ICogKDNlbSwgMjBweCBldGMpLiBEYXRhVGFibGVzIGFwcGxpZXMgJ3NtYXJ0JyB3aWR0aHMgdG8gY29sdW1ucyB3aGljaCBoYXZlIG5vdFxuXHRcdCAqIGJlZW4gZ2l2ZW4gYSBzcGVjaWZpYyB3aWR0aCB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlIGVuc3VyaW5nIHRoYXQgdGhlIHRhYmxlXG5cdFx0ICogcmVtYWlucyByZWFkYWJsZS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+QXV0b21hdGljPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ud2lkdGhcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIndpZHRoXCI6IFwiMjAlXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1dpZHRoXCI6IG51bGxcblx0fTtcblx0XG5cdF9mbkh1bmdhcmlhbk1hcCggRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgLSB0aGlzIGhvbGRzIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkIGZvciBhXG5cdCAqIGdpdmVuIHRhYmxlLCBpbmNsdWRpbmcgY29uZmlndXJhdGlvbiwgZGF0YSBhbmQgY3VycmVudCBhcHBsaWNhdGlvbiBvZiB0aGVcblx0ICogdGFibGUgb3B0aW9ucy4gRGF0YVRhYmxlcyBkb2VzIG5vdCBoYXZlIGEgc2luZ2xlIGluc3RhbmNlIGZvciBlYWNoIERhdGFUYWJsZVxuXHQgKiB3aXRoIHRoZSBzZXR0aW5ncyBhdHRhY2hlZCB0byB0aGF0IGluc3RhbmNlLCBidXQgcmF0aGVyIGluc3RhbmNlcyBvZiB0aGVcblx0ICogRGF0YVRhYmxlIFwiY2xhc3NcIiBhcmUgY3JlYXRlZCBvbi10aGUtZmx5IGFzIG5lZWRlZCAodHlwaWNhbGx5IGJ5IGFcblx0ICogJCgpLmRhdGFUYWJsZSgpIGNhbGwpIGFuZCB0aGUgc2V0dGluZ3Mgb2JqZWN0IGlzIHRoZW4gYXBwbGllZCB0byB0aGF0XG5cdCAqIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfSBidXQgdGhpc1xuXHQgKiBvbmUgaXMgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIERhdGFUYWJsZXMncyBjYWNoZSBvZiBjb2x1bW5zLiBJdCBzaG91bGRcblx0ICogTk9UIGJlIG1hbmlwdWxhdGVkIG91dHNpZGUgb2YgRGF0YVRhYmxlcy4gQW55IGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIGRvbmVcblx0ICogdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICogIEB0b2RvIFJlYWxseSBzaG91bGQgYXR0YWNoIHRoZSBzZXR0aW5ncyBvYmplY3QgdG8gaW5kaXZpZHVhbCBpbnN0YW5jZXMgc28gd2Vcblx0ICogICAgZG9uJ3QgbmVlZCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvbiBlYWNoICQoKS5kYXRhVGFibGUoKSBjYWxsIChpZiB0aGVcblx0ICogICAgdGFibGUgYWxyZWFkeSBleGlzdHMpLiBJdCB3b3VsZCBhbHNvIHNhdmUgcGFzc2luZyBvU2V0dGluZ3MgYXJvdW5kIGFuZFxuXHQgKiAgICBpbnRvIGV2ZXJ5IHNpbmdsZSBmdW5jdGlvbi4gSG93ZXZlciwgdGhpcyBpcyBhIHZlcnkgc2lnbmlmaWNhbnRcblx0ICogICAgYXJjaGl0ZWN0dXJlIGNoYW5nZSBmb3IgRGF0YVRhYmxlcyBhbmQgd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJyZWFrXG5cdCAqICAgIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucy4gVGhpcyBpcyBzb21ldGhpbmcgdGhhdFxuXHQgKiAgICB3aWxsIGJlIGRvbmUgaW4gMi4wLlxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MgPSB7XG5cdFx0LyoqXG5cdFx0ICogUHJpbWFyeSBmZWF0dXJlcyBvZiBEYXRhVGFibGVzIGFuZCB0aGVpciBlbmFibGVtZW50IHN0YXRlLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvRmVhdHVyZXNcIjoge1xuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRmxhZyB0byBzYXkgaWYgRGF0YVRhYmxlcyBzaG91bGQgYXV0b21hdGljYWxseSB0cnkgdG8gY2FsY3VsYXRlIHRoZVxuXHRcdFx0ICogb3B0aW11bSB0YWJsZSBhbmQgY29sdW1ucyB3aWR0aHMgKHRydWUpIG9yIG5vdCAoZmFsc2UpLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJBdXRvV2lkdGhcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERlbGF5IHRoZSBjcmVhdGlvbiBvZiBUUiBhbmQgVEQgZWxlbWVudHMgdW50aWwgdGhleSBhcmUgYWN0dWFsbHlcblx0XHRcdCAqIG5lZWRlZCBieSBhIGRyaXZlbiBwYWdlIGRyYXcuIFRoaXMgY2FuIGdpdmUgYSBzaWduaWZpY2FudCBzcGVlZFxuXHRcdFx0ICogaW5jcmVhc2UgZm9yIEFqYXggc291cmNlIGFuZCBKYXZhc2NyaXB0IHNvdXJjZSBkYXRhLCBidXQgbWFrZXMgbm9cblx0XHRcdCAqIGRpZmZlcmVuY2UgYXQgYWxsIGZvciBET00gYW5kIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJEZWZlclJlbmRlclwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRW5hYmxlIGZpbHRlcmluZyBvbiB0aGUgdGFibGUgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZFxuXHRcdFx0ICogdGhlbiB0aGVyZSBpcyBubyBmaWx0ZXJpbmcgYXQgYWxsIG9uIHRoZSB0YWJsZSwgaW5jbHVkaW5nIGZuRmlsdGVyLlxuXHRcdFx0ICogVG8ganVzdCByZW1vdmUgdGhlIGZpbHRlcmluZyBpbnB1dCB1c2Ugc0RvbSBhbmQgcmVtb3ZlIHRoZSAnZicgb3B0aW9uLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJGaWx0ZXJcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnQgKHRoZSAnU2hvd2luZyB4IG9mIHkgcmVjb3JkcycgZGl2KSBlbmFibGVcblx0XHRcdCAqIGZsYWcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkluZm9cIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFByZXNlbnQgYSB1c2VyIGNvbnRyb2wgYWxsb3dpbmcgdGhlIGVuZCB1c2VyIHRvIGNoYW5nZSB0aGUgcGFnZSBzaXplXG5cdFx0XHQgKiB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiTGVuZ3RoQ2hhbmdlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYWdpbmF0aW9uIGVuYWJsZWQgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZCB0aGVuIGxlbmd0aFxuXHRcdFx0ICogY2hhbmdpbmcgbXVzdCBhbHNvIGJlIGRpc2FibGVkLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJQYWdpbmF0ZVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUHJvY2Vzc2luZyBpbmRpY2F0b3IgZW5hYmxlIGZsYWcgd2hlbmV2ZXIgRGF0YVRhYmxlcyBpcyBlbmFjdGluZyBhXG5cdFx0XHQgKiB1c2VyIHJlcXVlc3QgLSB0eXBpY2FsbHkgYW4gQWpheCByZXF1ZXN0IGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJQcm9jZXNzaW5nXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGVuYWJsZWQgZmxhZyAtIHdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGxcblx0XHRcdCAqIGdldCBhbGwgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgZm9yIGV2ZXJ5IGRyYXcgLSB0aGVyZSBpcyBubyBmaWx0ZXJpbmcsXG5cdFx0XHQgKiBzb3J0aW5nIG9yIHBhZ2luZyBkb25lIG9uIHRoZSBjbGllbnQtc2lkZS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU2VydmVyU2lkZVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU29ydGluZyBlbmFibGVtZW50IGZsYWcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNvcnRcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIE11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNvcnRNdWx0aVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwbHkgYSBjbGFzcyB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgYmVpbmcgc29ydGVkIHRvIHByb3ZpZGUgYVxuXHRcdFx0ICogdmlzdWFsIGhpZ2hsaWdodCBvciBub3QuIFRoaXMgY2FuIHNsb3cgdGhpbmdzIGRvd24gd2hlbiBlbmFibGVkIHNpbmNlXG5cdFx0XHQgKiB0aGVyZSBpcyBhIGxvdCBvZiBET00gaW50ZXJhY3Rpb24uXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNvcnRDbGFzc2VzXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdGF0ZSBzYXZpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTdGF0ZVNhdmVcIjogbnVsbFxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTY3JvbGxpbmcgc2V0dGluZ3MgZm9yIGEgdGFibGUuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKi9cblx0XHRcIm9TY3JvbGxcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIHRoZSB0YWJsZSBpcyBzaG9ydGVyIGluIGhlaWdodCB0aGFuIHNTY3JvbGxZLCBjb2xsYXBzZSB0aGVcblx0XHRcdCAqIHRhYmxlIGNvbnRhaW5lciBkb3duIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRhYmxlICh3aGVuIHRydWUpLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJDb2xsYXBzZVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogV2lkdGggb2YgdGhlIHNjcm9sbGJhciBmb3IgdGhlIHdlYi1icm93c2VyJ3MgcGxhdGZvcm0uIENhbGN1bGF0ZWRcblx0XHRcdCAqIGR1cmluZyB0YWJsZSBpbml0aWFsaXNhdGlvbi5cblx0XHRcdCAqICBAdHlwZSBpbnRcblx0XHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0XHQgKi9cblx0XHRcdFwiaUJhcldpZHRoXCI6IDAsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBWaWV3cG9ydCB3aWR0aCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIEhvcml6b250YWwgc2Nyb2xsaW5nIGlzXG5cdFx0XHQgKiBkaXNhYmxlZCBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0XCJzWFwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogV2lkdGggdG8gZXhwYW5kIHRoZSB0YWJsZSB0byB3aGVuIHVzaW5nIHgtc2Nyb2xsaW5nLiBUeXBpY2FsbHkgeW91XG5cdFx0XHQgKiBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoaXMuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVwcmVjYXRlZFxuXHRcdFx0ICovXG5cdFx0XHRcInNYSW5uZXJcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFZpZXdwb3J0IGhlaWdodCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nLiBWZXJ0aWNhbCBzY3JvbGxpbmcgaXMgZGlzYWJsZWRcblx0XHRcdCAqIGlmIGFuIGVtcHR5IHN0cmluZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRcInNZXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBMYW5ndWFnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2Vcblx0XHQgKi9cblx0XHRcIm9MYW5ndWFnZVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEluZm9ybWF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uLiBTZWVcblx0XHRcdCAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuZm5JbmZvQ2FsbGJhY2t9XG5cdFx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0XHQgKi9cblx0XHRcdFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbFxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJyb3dzZXIgc3VwcG9ydCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKi9cblx0XHRcIm9Ccm93c2VyXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogSW5kaWNhdGUgaWYgdGhlIGJyb3dzZXIgaW5jb3JyZWN0bHkgY2FsY3VsYXRlcyB3aWR0aDoxMDAlIGluc2lkZSBhXG5cdFx0XHQgKiBzY3JvbGxpbmcgZWxlbWVudCAoSUU2LzcpXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNjcm9sbE92ZXJzaXplXCI6IGZhbHNlLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGV0ZXJtaW5lIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgb24gdGhlIHJpZ2h0IG9yIGxlZnQgb2YgdGhlXG5cdFx0XHQgKiBzY3JvbGxpbmcgY29udGFpbmVyIC0gbmVlZGVkIGZvciBydGwgbGFuZ3VhZ2UgbGF5b3V0LCBhbHRob3VnaCBub3Rcblx0XHRcdCAqIGFsbCBicm93c2VycyBtb3ZlIHRoZSBzY3JvbGxiYXIgKFNhZmFyaSkuXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNjcm9sbGJhckxlZnRcIjogZmFsc2UsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGbGFnIGZvciBpZiBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBpcyBmdWxseSBzdXBwb3J0ZWQgb3Igbm90XG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0XHQgKi9cblx0XHRcdFwiYkJvdW5kaW5nXCI6IGZhbHNlLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQnJvd3NlciBzY3JvbGxiYXIgd2lkdGhcblx0XHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdFx0ICovXG5cdFx0XHRcImJhcldpZHRoXCI6IDBcblx0XHR9LFxuXHRcblx0XG5cdFx0XCJhamF4XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSByZWZlcmVuY2luZyB0aGUgbm9kZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHRoZSBmZWF0dXJlcy4gVGhlXG5cdFx0ICogcGFyYW1ldGVycyBvZiB0aGlzIG9iamVjdCBtYXRjaCB3aGF0IGlzIGFsbG93ZWQgYnkgc0RvbSAtIGkuZS5cblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG5cdFx0ICogICAgIDxsaT4nZicgLSBGaWx0ZXJpbmcgaW5wdXQ8L2xpPlxuXHRcdCAqICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XG5cdFx0ICogICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG5cdFx0ICogICAgIDxsaT4ncCcgLSBQYWdpbmF0aW9uPC9saT5cblx0XHQgKiAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxuXHRcdCAqICAgPC91bD5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFhbkZlYXR1cmVzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBkYXRhIGluZm9ybWF0aW9uIC0gc2VlIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9Sb3d9IGZvciBkZXRhaWxlZFxuXHRcdCAqIGluZm9ybWF0aW9uLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9EYXRhXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBpbmRleGVzIHdoaWNoIGFyZSBpbiB0aGUgY3VycmVudCBkaXNwbGF5IChhZnRlciBmaWx0ZXJpbmcgZXRjKVxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWlEaXNwbGF5XCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBpbmRleGVzIGZvciBkaXNwbGF5IC0gbm8gZmlsdGVyaW5nXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhaURpc3BsYXlNYXN0ZXJcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIE1hcCBvZiByb3cgaWRzIHRvIGRhdGEgaW5kZXhlc1xuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRcImFJZHNcIjoge30sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggY29sdW1uIHRoYXQgaXMgaW4gdXNlXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0NvbHVtbnNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGhlYWRlclxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9IZWFkZXJcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGZvb3RlclxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Gb290ZXJcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIHRoZSBhcHBsaWVkIGdsb2JhbCBzZWFyY2ggaW5mb3JtYXRpb24gaW4gY2FzZSB3ZSB3YW50IHRvIGZvcmNlIGFcblx0XHQgKiByZXNlYXJjaCBvciBjb21wYXJlIHRoZSBvbGQgc2VhcmNoIHRvIGEgbmV3IG9uZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoXG5cdFx0ICovXG5cdFx0XCJvUHJldmlvdXNTZWFyY2hcIjoge30sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIHRoZSBhcHBsaWVkIHNlYXJjaCBmb3IgZWFjaCBjb2x1bW4gLSBzZWVcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNofSBmb3IgdGhlIGZvcm1hdCB0aGF0IGlzIHVzZWQgZm9yIHRoZVxuXHRcdCAqIGZpbHRlcmluZyBpbmZvcm1hdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1ByZVNlYXJjaENvbHNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvcnRpbmcgdGhhdCBpcyBhcHBsaWVkIHRvIHRoZSB0YWJsZS4gTm90ZSB0aGF0IHRoZSBpbm5lciBhcnJheXMgYXJlXG5cdFx0ICogdXNlZCBpbiB0aGUgZm9sbG93aW5nIG1hbm5lcjpcblx0XHQgKiA8dWw+XG5cdFx0ICogICA8bGk+SW5kZXggMCAtIGNvbHVtbiBudW1iZXI8L2xpPlxuXHRcdCAqICAgPGxpPkluZGV4IDEgLSBjdXJyZW50IHNvcnRpbmcgZGlyZWN0aW9uPC9saT5cblx0XHQgKiA8L3VsPlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQHRvZG8gVGhlc2UgaW5uZXIgYXJyYXlzIHNob3VsZCByZWFsbHkgYmUgb2JqZWN0c1xuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvcnRpbmcgdGhhdCBpcyBhbHdheXMgYXBwbGllZCB0byB0aGUgdGFibGUgKGkuZS4gcHJlZml4ZWQgaW4gZnJvbnQgb2Zcblx0XHQgKiBhYVNvcnRpbmcpLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzc2VzIHRvIHVzZSBmb3IgdGhlIHN0cmlwaW5nIG9mIGEgdGFibGUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHN0cmlwaW5nIGNsYXNzZXMgYXMgd2VsbFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYXNEZXN0cm95U3RyaXBlc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgcmVzdG9yaW5nIGEgdGFibGUgLSB3ZSBzaG91bGQgcmVzdG9yZSBpdHMgd2lkdGhcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcInNEZXN0cm95V2lkdGhcIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGFycmF5IGZvciBldmVyeSB0aW1lIGEgcm93IGlzIGluc2VydGVkIChpLmUuIG9uIGEgZHJhdykuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1Jvd0NhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBoZWFkZXIgb24gZWFjaCBkcmF3LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9IZWFkZXJDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBmb290ZXIgb24gZWFjaCBkcmF3LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Gb290ZXJDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBkcmF3IGNhbGxiYWNrIGZ1bmN0aW9uc1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9EcmF3Q2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igcm93IGNyZWF0ZWQgZnVuY3Rpb25cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUm93Q3JlYXRlZENhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIGp1c3QgYmVmb3JlIHRoZSB0YWJsZSBpcyByZWRyYXduLiBBIHJldHVybiBvZlxuXHRcdCAqIGZhbHNlIHdpbGwgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1ByZURyYXdDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSW5pdENvbXBsZXRlXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRvIGJlIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nLCBwcmlvciB0b1xuXHRcdCAqIHNhdmluZyBzdGF0ZS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVTYXZlUGFyYW1zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdGhhdCBoYXZlIGJlZW4gc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmdcblx0XHQgKiBwcmlvciB0byB1c2luZyB0aGUgc3RvcmVkIHZhbHVlcyB0byByZXN0b3JlIHRoZSBzdGF0ZS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVMb2FkUGFyYW1zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFja3MgZm9yIG9wZXJhdGluZyBvbiB0aGUgc2V0dGluZ3Mgb2JqZWN0IG9uY2UgdGhlIHNhdmVkIHN0YXRlIGhhcyBiZWVuXG5cdFx0ICogbG9hZGVkXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlTG9hZGVkXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWNoZSB0aGUgdGFibGUgSUQgZm9yIHF1aWNrIGFjY2Vzc1xuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqL1xuXHRcdFwic1RhYmxlSWRcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIFRBQkxFIG5vZGUgZm9yIHRoZSBtYWluIHRhYmxlXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRhYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRoZWFkIGVsZW1lbnRcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVEhlYWRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGZvb3QgZWxlbWVudCAtIGlmIGl0IGV4aXN0c1xuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5URm9vdFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Ym9keSBlbGVtZW50XG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRCb2R5XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIHRoZSB3cmFwcGVyIG5vZGUgKGNvbnRhaW5zIGFsbCBEYXRhVGFibGVzIGNvbnRyb2xsZWQgZWxlbWVudHMpXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRhYmxlV3JhcHBlclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSBpZiB3aGVuIHVzaW5nIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGhlIGxvYWRpbmcgb2YgZGF0YVxuXHRcdCAqIHNob3VsZCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgc2Vjb25kIGRyYXcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiRGVmZXJMb2FkaW5nXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSBpZiBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaGFzIGJlZW4gcmVhZCBpblxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiSW5pdGlhbGlzZWRcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZm9ybWF0aW9uIGFib3V0IG9wZW4gcm93cy4gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5IGhhcyB0aGUgcGFyYW1ldGVyc1xuXHRcdCAqICduVHInIGFuZCAnblBhcmVudCdcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvT3BlblJvd3NcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERpY3RhdGUgdGhlIHBvc2l0aW9uaW5nIG9mIERhdGFUYWJsZXMnIGNvbnRyb2wgZWxlbWVudHMgLSBzZWVcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLm1vZGVsLm9Jbml0LnNEb219LlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNEb21cIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2VhcmNoIGRlbGF5IChpbiBtUylcblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGljaCB0eXBlIG9mIHBhZ2luYXRpb24gc2hvdWxkIGJlIHVzZWQuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgdHdvX2J1dHRvblxuXHRcdCAqL1xuXHRcdFwic1BhZ2luYXRpb25UeXBlXCI6IFwidHdvX2J1dHRvblwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgc3RhdGUgZHVyYXRpb24gKGZvciBgc3RhdGVTYXZlYCkgaW4gc2Vjb25kcy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJpU3RhdGVEdXJhdGlvblwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIHNhdmluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG5cdFx0ICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG5cdFx0ICogICAgICAgYW5kIHRoZSBKU09OIHN0cmluZyB0byBzYXZlIHRoYXQgaGFzIGJlZW4gdGh1cyBmYXIgY3JlYXRlZC4gUmV0dXJuc1xuXHRcdCAqICAgICAgIGEgSlNPTiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgaW50byBhIGpzb24gb2JqZWN0XG5cdFx0ICogICAgICAgKGkuZS4gJ1wicGFyYW1cIjogWyAwLCAxLCAyXScpPC9saT5cblx0XHQgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxuXHRcdCAqICAgPC91bD5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVTYXZlXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIGxvYWRpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHRcdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHRcdCAqICAgICAgIGFuZCB0aGUgb2JqZWN0IHN0b3JlZC4gTWF5IHJldHVybiBmYWxzZSB0byBjYW5jZWwgc3RhdGUgbG9hZGluZzwvbGk+XG5cdFx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlTG9hZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RhdGUgdGhhdCB3YXMgc2F2ZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2Vcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9TYXZlZFN0YXRlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0YXRlIHRoYXQgd2FzIGxvYWRlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0xvYWRlZFN0YXRlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvdXJjZSB1cmwgZm9yIEFKQVggZGF0YSBmb3IgdGhlIHRhYmxlLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNBamF4U291cmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IGZyb20gYSBnaXZlbiBvYmplY3QgZnJvbSB3aGljaCB0byByZWFkIHRoZSB0YWJsZSBkYXRhIGZyb20uIFRoaXNcblx0XHQgKiBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nICh3aGVuIG5vdCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nKSwgaW4gd2hpY2ggY2FzZVxuXHRcdCAqIGl0IGlzICBhc3N1bWVkIGFuIGFuIGFycmF5IGlzIGdpdmVuIGRpcmVjdGx5LlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzQWpheERhdGFQcm9wXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IGpRdWVyeSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgZm9yIHNlcnZlci1zaWRlIGRhdGEgZ2F0aGVyaW5nLlxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHdvcmtpbmcgd2l0aCB0aGUgWEhSIGluZm9ybWF0aW9uIGluIG9uZSBvZiB0aGVcblx0XHQgKiBjYWxsYmFja3Ncblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImpxWEhSXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0XCJqc29uXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBwcmlvciB0byBzZW5kaW5nIGFuIEFqYXggcmVxdWVzdCBzbyBleHRyYVxuXHRcdCAqIHBhcmFtZXRlcnMgY2FuIGVhc2lseSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU2VydmVyUGFyYW1zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZW5kIHRoZSBYSFIgSFRUUCBtZXRob2QgLSBHRVQgb3IgUE9TVCAoY291bGQgYmUgUFVUIG9yIERFTEVURSBpZlxuXHRcdCAqIHJlcXVpcmVkKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGb3JtYXQgbnVtYmVycyBmb3IgZGlzcGxheS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHVzZXIgc2VsZWN0YWJsZSBsZW5ndGggbWVudS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3Jcblx0XHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJpRHJhd1wiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSBpZiBhIHJlZHJhdyBpcyBiZWluZyBkb25lIC0gdXNlZnVsIGZvciBBamF4XG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJEcmF3aW5nXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBEcmF3IGluZGV4IChpRHJhdykgb2YgdGhlIGxhc3QgZXJyb3Igd2hlbiBwYXJzaW5nIHRoZSByZXR1cm5lZCBkYXRhXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdFwiaURyYXdFcnJvclwiOiAtMSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFnaW5nIGRpc3BsYXkgbGVuZ3RoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAxMFxuXHRcdCAqL1xuXHRcdFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYWdpbmcgc3RhcnQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgcmVzdWx0IHNldFxuXHRcdCAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cblx0XHQgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG5cdFx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxuXHRcdCAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2lSZWNvcmRzRGlzcGxheVwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY2xhc3NlcyB0byB1c2UgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRcIm9DbGFzc2VzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHRcdCAqIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqICBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0XHQgKiBldmVudHMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJTb3J0ZWRcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIHRoYXQgaWYgbXVsdGlwbGUgcm93cyBhcmUgaW4gdGhlIGhlYWRlciBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuXG5cdFx0ICogb25lIHVuaXF1ZSBjZWxsIHBlciBjb2x1bW4sIGlmIHRoZSB0b3Agb25lICh0cnVlKSBvciBib3R0b20gb25lIChmYWxzZSlcblx0XHQgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU29ydENlbGxzVG9wXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luaXRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBjYWxsYmFjayBmdW5jdGlvbnMgLSBmb3IgcGx1Zy1pbnMgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG8gdGhlXG5cdFx0ICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XG5cdFx0XHRcdHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcblx0XHRcdFx0dGhpcy5haURpc3BsYXkubGVuZ3RoO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZGlzcGxheSBlbmQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuRGlzcGxheUVuZFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhclxuXHRcdFx0XHRsZW4gICAgICA9IHRoaXMuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRzdGFydCAgICA9IHRoaXMuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRcdHJlY29yZHMgID0gdGhpcy5haURpc3BsYXkubGVuZ3RoLFxuXHRcdFx0XHRmZWF0dXJlcyA9IHRoaXMub0ZlYXR1cmVzLFxuXHRcdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRcdHN0YXJ0ICsgcmVjb3JkcyA6XG5cdFx0XHRcdFx0TWF0aC5taW4oIHN0YXJ0K2xlbiwgdGhpcy5faVJlY29yZHNEaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuICEgcGFnaW5hdGUgfHwgY2FsYz5yZWNvcmRzIHx8IGxlbj09PS0xID9cblx0XHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0XHRjYWxjO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcblx0XHQgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cblx0XHQgKiBpbmNyZW1lbnRpbmcgaW50ZXJuYWwgY291bnRlciBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcblx0XHQgKiBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSBhbmQgaXRzIGNvbnRyb2xzLlxuXHRcdCAqL1xuXHRcdFwiaVRhYkluZGV4XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHRcdCAqL1xuXHRcdFwiblNjcm9sbEhlYWRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXG5cdFx0ICovXG5cdFx0XCJuU2Nyb2xsRm9vdFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMYXN0IGFwcGxpZWQgc29ydFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYUxhc3RTb3J0XCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJvUGx1Z2luc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdXNlZCB0byBnZXQgYSByb3cncyBpZCBmcm9tIHRoZSByb3cncyBkYXRhXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInJvd0lkRm5cIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSBhIHJvdydzIGlkXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJyb3dJZFwiOiBudWxsXG5cdH07XG5cblx0LyoqXG5cdCAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGUuZXh0YCB3aGVyZSBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkLiBJdCBpc1xuXHQgKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5leHRcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgZXh0ZW5zaW9uc1xuXHQgKiBcblx0ICogVGhpcyBuYW1lc3BhY2UgYWN0cyBhcyBhIGNvbGxlY3Rpb24gYXJlYSBmb3IgcGx1Zy1pbnMgdGhhdCBjYW4gYmUgdXNlZCB0b1xuXHQgKiBleHRlbmQgRGF0YVRhYmxlcyBjYXBhYmlsaXRpZXMuIEluZGVlZCBtYW55IG9mIHRoZSBidWlsZCBpbiBtZXRob2RzXG5cdCAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3Jcblx0ICogZXhhbXBsZSkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XG5cdCAqIHJlYXNvbnNcblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5leHQgPSBfZXh0ID0ge1xuXHRcdC8qKlxuXHRcdCAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcblx0XHQgKiBkZWZpbmVkIGhlcmUgc28gb3RoZXIgZXh0ZW5zaW9ucyBjYW4gZGVmaW5lIGJ1dHRvbnMgcmVnYXJkbGVzcyBvZiBsb2FkXG5cdFx0ICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGJ1dHRvbnM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRWxlbWVudCBjbGFzcyBuYW1lc1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGNsYXNzZXM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBidWlsZCB0eXBlIChleHBhbmRlZCBieSB0aGUgZG93bmxvYWQgYnVpbGRlcilcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRidWlsZGVyOiBcIi1zb3VyY2UtXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdFx0ICogXG5cdFx0ICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXG5cdFx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdFx0ICovXG5cdFx0ZXJyTW9kZTogXCJhbGVydFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggZGVzY3JpYmUgdGhlIGZlYXR1cmUgcGx1Zy1pbnMgdGhhdCBhcmVcblx0XHQgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG5cdFx0ICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cblx0XHQgKiBcblx0XHQgKiBFYWNoIGZlYXR1cmUgcGx1Zy1pbiBpcyBkZXNjcmliZWQgYnkgYW4gb2JqZWN0IHdoaWNoIG11c3QgaGF2ZSB0aGVcblx0XHQgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBcblx0XHQgKiAqIGBmbkluaXRgIC0gZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHBsdWctaW4sXG5cdFx0ICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXG5cdFx0ICogICBpbnN0aWxsYXRpb24gb3B0aW9uLiBUaGlzIGlzIGNhc2Ugc2Vuc2l0aXZlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICpcblx0XHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdFx0ICogXG5cdFx0ICogKiB7bm9kZXxudWxsfSBUaGUgZWxlbWVudCB3aGljaCBjb250YWlucyB5b3VyIGZlYXR1cmUuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcblx0XHQgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxuXHRcdCAqICAgYmUgdXNlZnVsIHdoZW4gZGV2ZWxvcGluZyBhIHBsdWctaW4gd2hpY2ggYWxsb3dzIHRhYmxlIGNvbnRyb2wgdmlhXG5cdFx0ICogICBrZXlib2FyZCBlbnRyeVxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQuZmVhdHVyZXMucHVzaCgge1xuXHRcdCAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdGZlYXR1cmU6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUm93IHNlYXJjaGluZy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdFx0ICogc2VhcmNoaW5nLCBhbmQgYSBsb3QgbW9yZSBjb21wcmVoZW5zaXZlIGFzIGl0IGFsbG93cyB5b3UgY29tcGxldGUgY29udHJvbFxuXHRcdCAqIG92ZXIgdGhlIHNlYXJjaGluZyBsb2dpYy4gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXMgYSBmdW5jdGlvblxuXHRcdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdFx0ICogYW5kIHlvdXIgbG9naWMgZGVjaWRlcyBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaGluZyBkYXRhIHNldFxuXHRcdCAqIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIFNlYXJjaGluZyBmdW5jdGlvbnMgaGF2ZSB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogMi4gYHthcnJheXxvYmplY3R9YCBEYXRhIGZvciB0aGUgcm93IHRvIGJlIHByb2Nlc3NlZCAoc2FtZSBhcyB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0XHQgKiAgICBmcm9tIGEgRE9NIGRhdGEgc291cmNlXG5cdFx0ICogMy4gYHtpbnR9YCBSb3cgaW5kZXggKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncy5hb0RhdGF9KSwgd2hpY2hcblx0XHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHRcdCAqXG5cdFx0ICogKiB7Ym9vbGVhbn0gSW5jbHVkZSB0aGUgcm93IGluIHRoZSBzZWFyY2hlZCByZXN1bHQgc2V0ICh0cnVlKSBvciBub3Rcblx0XHQgKiAgIChmYWxzZSlcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBhcyB3aXRoIHRoZSBtYWluIHNlYXJjaCBhYmlsaXR5IGluIERhdGFUYWJsZXMsIHRlY2huaWNhbGx5IHRoaXNcblx0XHQgKiBpcyBcImZpbHRlcmluZ1wiLCBzaW5jZSBpdCBpcyBzdWJ0cmFjdGl2ZS4gSG93ZXZlciwgZm9yIGNvbnNpc3RlbmN5IGluXG5cdFx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdFx0ICogICAgLy8gZm91cnRoIGNvbHVtbiAoaS5lLiB0aGUgZGF0YVszXSBpbmRleCkgYmFzZWQgb24gdHdvIGlucHV0IHZhbHVlc1xuXHRcdCAqICAgIC8vIGZyb20gdGhlIGVuZC11c2VyLCBtYXRjaGluZyB0aGUgZGF0YSBpbiBhIGNlcnRhaW4gcmFuZ2UuXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHRcdCAqICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgIHZhciBtaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluJykudmFsdWUgKiAxO1xuXHRcdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0XHQgKiAgICAgICAgdmFyIHZlcnNpb24gPSBkYXRhWzNdID09IFwiLVwiID8gMCA6IGRhdGFbM10qMTtcblx0XHQgKlxuXHRcdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0c2VhcmNoOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcblx0XHQgKlxuXHRcdCAqIFRoZSBgc2VsZWN0b3JgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGVcblx0XHQgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcblx0XHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHRcdCAqIHRoZWlyIHBsdXJhbCBjb3VudGVycGFydHMpLiBGb3IgZXhhbXBsZSB0aGUgU2VsZWN0IGV4dGVuc2lvbiB1c2VzIHRoaXNcblx0XHQgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIGJ1aWx0IGluIHNlbGVjdG9yXG5cdFx0ICogb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggcHJvcGVydHkgaXMgYW4gYXJyYXkgdG8gd2hpY2ggZnVuY3Rpb25zIGNhbiBiZSBwdXNoZWQuIFRoZSBmdW5jdGlvbnNcblx0XHQgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XG5cdFx0ICpcblx0XHQgKiAqIFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcblx0XHQgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxuXHRcdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdFx0ICpcblx0XHQgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cblx0XHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqL1xuXHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRjZWxsOiBbXSxcblx0XHRcdGNvbHVtbjogW10sXG5cdFx0XHRyb3c6IFtdXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGZ1bmN0aW9ucywgZXhwb3NlZCBmb3IgdXNlZCBpbiBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoZSBpbnRlcm5hbCBtZXRob2RzIGZvclxuXHRcdCAqIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbHVnLWluIChhbmQgZXZlbiB0aGVuLCB0cnkgdG8gYXZvaWQgaWYgcG9zc2libGUpLlxuXHRcdCAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0aW50ZXJuYWw6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTGVnYWN5IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gRW5hYmxlIGFuZCBkaXNhYmxlIGxlZ2FjeSBvcHRpb25zIHRoYXRcblx0XHQgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICovXG5cdFx0bGVnYWN5OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0XHQgKiByZXF1ZXN0c1xuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRhamF4OiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxuXHRcdCAqIFxuXHRcdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHRcdCAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnZUJ1dHRvbn0uIFRoZSByZW5kZXJlciBhZGRyZXNzZXMgaG93IHRoZVxuXHRcdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdFx0ICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXG5cdFx0ICogZGVzY3JpcHRpb25zICh3aGF0IGVhY2ggYnV0dG9uIHdpbGwgZG8pLlxuXHRcdCAqXG5cdFx0ICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxuXHRcdCAqIG9wdGlvbnMgZGVmaW5lZCBoZXJlKSBjYW4gYmUgdXNlZCB0aHJvdWdoIHRoZSBgcGFnaW5hdGlvblR5cGVgXG5cdFx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxuXHRcdCAqIDIuIGB7aW50fSBwYWdlc2AgVGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcblx0XHQgKiBhcnJheSBjYW4gYmUgb25lIG9mOlxuXHRcdCAqXG5cdFx0ICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdFx0ICogKiBgbGFzdGAgLSBKdW1wIHRvIGxhc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGB7aW50fWAgLSBTaG93IHBhZ2Ugb2YgdGhlIGluZGV4IGdpdmVuXG5cdFx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHRcdCAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdFx0ICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcblx0XHQgKiBhYmlsaXR5IGlzIHN0aWxsIHN1cHBvcnRlZCBieSBEYXRhVGFibGVzIDEuMTArIHRvIHByb3ZpZGUgYmFja3dhcmRzXG5cdFx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHRcdCAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZUV4dC5vUGFnaW5hdGlvbi5jdXJyZW50ID0gZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHRcdCAqICAgIH07XG5cdFx0ICovXG5cdFx0cGFnZXI6IHt9LFxuXHRcblx0XG5cdFx0cmVuZGVyZXI6IHtcblx0XHRcdHBhZ2VCdXR0b246IHt9LFxuXHRcdFx0aGVhZGVyOiB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBPcmRlcmluZyBwbHVnLWlucyAtIGN1c3RvbSBkYXRhIHNvdXJjZVxuXHRcdCAqIFxuXHRcdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdFx0ICogdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvcmRlcmluZyB0aGF0IERhdGFUYWJsZXMgdHlwaWNhbGx5IHVzZXMuIEl0XG5cdFx0ICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuXHRcdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcblx0XHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdFx0ICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cblx0XHQgKiBcblx0XHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdFx0ICogd2lzaCB0byBiZSBvcmRlcmluZyBmb3IgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhhdFxuXHRcdCAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cblx0XHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdFx0ICogZnVuY3Rpb24gaXMgcnVuIGhlcmUgZGVwZW5kcyBvbiB0aGUgYGR0LWluaXQgY29sdW1ucy5vcmRlckRhdGFUeXBlYFxuXHRcdCAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHRcdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5OlxuXHRcdCAqXG5cdFx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0b3JkZXI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBwbHVnLWlucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xuXHRcdCAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cblx0XHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0XHQgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdHR5cGU6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuXHRcdFx0ICogYSBjb2x1bW4ncyB0eXBlLCBtYWtpbmcgaW5pdGlhbGlzYXRpb24gb2YgRGF0YVRhYmxlcyBzdXBlciBlYXN5LCBldmVuXG5cdFx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxuXHRcdCAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0XHQgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXG5cdFx0ICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG5cdFx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuXHRcdFx0ICogICBwYXNzIGl0IG9uIHRvIHRoZSBvdGhlciB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuXHRcdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnB1c2goXG5cdFx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuXHRcdFx0ICogICAgICAgIGlmICggISBkYXRhLnN1YnN0cmluZygxKS5tYXRjaCgvWzAtOV0vKSApIHtcblx0XHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHRcdCAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gJ2N1cnJlbmN5Jztcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgICk7XG5cdFx0XHQgKi9cblx0XHRcdGRldGVjdDogW10sXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXG5cdFx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHRcdCAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdFx0ICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG5cdFx0XHQgKiBcblx0XHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdFx0ICogZm9yIGEgY29sdW1uIChvciBoYXZlIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIHlvdSBieSBEYXRhVGFibGVzXG5cdFx0XHQgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3Jcblx0XHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHRcdCAqIGJ5IGFsbG93aW5nIHlvdSB0byBwcmUtcHJvY2Vzc2luZyB0aGUgZGF0YSBhbmQgcmV0dXJuaW5nIHRoZSBkYXRhIGluXG5cdFx0XHQgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcblx0XHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHRcdCAqIGZvciB0aGF0IHRhcmdldCBjb2x1bW4uIFRoaXMgaXMgdGhlIGNvcm9sbGFyeSBvZiA8aT5hZm5Tb3J0RGF0YTwvaT5cblx0XHRcdCAqIGZvciBzZWFyY2hpbmcgZGF0YS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0XHQgKiAgQGRlZmF1bHQge31cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0ICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqL1xuXHRcdFx0c2VhcmNoOiB7fSxcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXG5cdFx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0XHQgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdFx0ICogdGhpcyBvYmplY3Q6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdFx0ICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXG5cdFx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHRcdCAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuXHRcdFx0ICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbmQgcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHsqfWAgRGF0YSB0byBiZSBzb3J0ZWQgdXBvblxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdFx0ICogZnVuY3Rpb25zLCB0YWtpbmcgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdFx0ICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0ICpcblx0XHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcblx0XHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdFx0ICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuXHRcdFx0ICogICBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBcblx0XHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuXHRcdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuXHRcdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2Rcblx0XHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRvcmRlcjoge31cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBpbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF91bmlxdWU6IDAsXG5cdFxuXHRcblx0XHQvL1xuXHRcdC8vIERlcHJlY2lhdGVkXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgb25seS5cblx0XHQvLyBUaGUgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlXG5cdFx0Ly8gdmVyc2lvblxuXHRcdC8vXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFZlcnNpb24gY2hlY2sgZnVuY3Rpb24uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBkZXByZWNpYXRlZCBTaW5jZSAxLjEwXG5cdFx0ICovXG5cdFx0Zm5WZXJzaW9uQ2hlY2s6IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IGZvciB3aGF0ICd0aGlzJyBpbmRleCBBUEkgZnVuY3Rpb25zIHNob3VsZCB1c2Vcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICovXG5cdFx0aUFwaUluZGV4OiAwLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogalF1ZXJ5IFVJIGNsYXNzIGNvbnRhaW5lclxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKi9cblx0XHRvSlVJQ2xhc3Nlczoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTb2Z0d2FyZSB2ZXJzaW9uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqL1xuXHRcdHNWZXJzaW9uOiBEYXRhVGFibGUudmVyc2lvblxuXHR9O1xuXHRcblx0XG5cdC8vXG5cdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBBbGlhcyB0byBwcmUgMS4xMCBIdW5nYXJpYW4gbm90YXRpb24gY291bnRlciBwYXJ0c1xuXHQvL1xuXHQkLmV4dGVuZCggX2V4dCwge1xuXHRcdGFmbkZpbHRlcmluZzogX2V4dC5zZWFyY2gsXG5cdFx0YVR5cGVzOiAgICAgICBfZXh0LnR5cGUuZGV0ZWN0LFxuXHRcdG9mblNlYXJjaDogICAgX2V4dC50eXBlLnNlYXJjaCxcblx0XHRvU29ydDogICAgICAgIF9leHQudHlwZS5vcmRlcixcblx0XHRhZm5Tb3J0RGF0YTogIF9leHQub3JkZXIsXG5cdFx0YW9GZWF0dXJlczogICBfZXh0LmZlYXR1cmUsXG5cdFx0b0FwaTogICAgICAgICBfZXh0LmludGVybmFsLFxuXHRcdG9TdGRDbGFzc2VzOiAgX2V4dC5jbGFzc2VzLFxuXHRcdG9QYWdpbmF0aW9uOiAgX2V4dC5wYWdlclxuXHR9ICk7XG5cdFxuXHRcblx0JC5leHRlbmQoIERhdGFUYWJsZS5leHQuY2xhc3Nlcywge1xuXHRcdFwic1RhYmxlXCI6IFwiZGF0YVRhYmxlXCIsXG5cdFx0XCJzTm9Gb290ZXJcIjogXCJuby1mb290ZXJcIixcblx0XG5cdFx0LyogUGFnaW5nIGJ1dHRvbnMgKi9cblx0XHRcInNQYWdlQnV0dG9uXCI6IFwicGFnaW5hdGVfYnV0dG9uXCIsXG5cdFx0XCJzUGFnZUJ1dHRvbkFjdGl2ZVwiOiBcImN1cnJlbnRcIixcblx0XHRcInNQYWdlQnV0dG9uRGlzYWJsZWRcIjogXCJkaXNhYmxlZFwiLFxuXHRcblx0XHQvKiBTdHJpcGluZyBjbGFzc2VzICovXG5cdFx0XCJzU3RyaXBlT2RkXCI6IFwib2RkXCIsXG5cdFx0XCJzU3RyaXBlRXZlblwiOiBcImV2ZW5cIixcblx0XG5cdFx0LyogRW1wdHkgcm93ICovXG5cdFx0XCJzUm93RW1wdHlcIjogXCJkYXRhVGFibGVzX2VtcHR5XCIsXG5cdFxuXHRcdC8qIEZlYXR1cmVzICovXG5cdFx0XCJzV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfd3JhcHBlclwiLFxuXHRcdFwic0ZpbHRlclwiOiBcImRhdGFUYWJsZXNfZmlsdGVyXCIsXG5cdFx0XCJzSW5mb1wiOiBcImRhdGFUYWJsZXNfaW5mb1wiLFxuXHRcdFwic1BhZ2luZ1wiOiBcImRhdGFUYWJsZXNfcGFnaW5hdGUgcGFnaW5nX1wiLCAvKiBOb3RlIHRoYXQgdGhlIHR5cGUgaXMgcG9zdGZpeGVkICovXG5cdFx0XCJzTGVuZ3RoXCI6IFwiZGF0YVRhYmxlc19sZW5ndGhcIixcblx0XHRcInNQcm9jZXNzaW5nXCI6IFwiZGF0YVRhYmxlc19wcm9jZXNzaW5nXCIsXG5cdFxuXHRcdC8qIFNvcnRpbmcgKi9cblx0XHRcInNTb3J0QXNjXCI6IFwic29ydGluZ19hc2NcIixcblx0XHRcInNTb3J0RGVzY1wiOiBcInNvcnRpbmdfZGVzY1wiLFxuXHRcdFwic1NvcnRhYmxlXCI6IFwic29ydGluZ1wiLCAvKiBTb3J0YWJsZSBpbiBib3RoIGRpcmVjdGlvbnMgKi9cblx0XHRcInNTb3J0YWJsZUFzY1wiOiBcInNvcnRpbmdfZGVzY19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRhYmxlRGVzY1wiOiBcInNvcnRpbmdfYXNjX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydGFibGVOb25lXCI6IFwic29ydGluZ19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRDb2x1bW5cIjogXCJzb3J0aW5nX1wiLCAvKiBOb3RlIHRoYXQgYW4gaW50IGlzIHBvc3RmaXhlZCBmb3IgdGhlIHNvcnRpbmcgb3JkZXIgKi9cblx0XG5cdFx0LyogRmlsdGVyaW5nICovXG5cdFx0XCJzRmlsdGVySW5wdXRcIjogXCJcIixcblx0XG5cdFx0LyogUGFnZSBsZW5ndGggKi9cblx0XHRcInNMZW5ndGhTZWxlY3RcIjogXCJcIixcblx0XG5cdFx0LyogU2Nyb2xsaW5nICovXG5cdFx0XCJzU2Nyb2xsV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsXCIsXG5cdFx0XCJzU2Nyb2xsSGVhZFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZFwiLFxuXHRcdFwic1Njcm9sbEhlYWRJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZElubmVyXCIsXG5cdFx0XCJzU2Nyb2xsQm9keVwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsQm9keVwiLFxuXHRcdFwic1Njcm9sbEZvb3RcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RcIixcblx0XHRcInNTY3JvbGxGb290SW5uZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RJbm5lclwiLFxuXHRcblx0XHQvKiBNaXNjICovXG5cdFx0XCJzSGVhZGVyVEhcIjogXCJcIixcblx0XHRcInNGb290ZXJUSFwiOiBcIlwiLFxuXHRcblx0XHQvLyBEZXByZWNhdGVkXG5cdFx0XCJzU29ydEpVSUFzY1wiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlEZXNjXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSVwiOiBcIlwiLFxuXHRcdFwic1NvcnRKVUlBc2NBbGxvd2VkXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSURlc2NBbGxvd2VkXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSVdyYXBwZXJcIjogXCJcIixcblx0XHRcInNTb3J0SWNvblwiOiBcIlwiLFxuXHRcdFwic0pVSUhlYWRlclwiOiBcIlwiLFxuXHRcdFwic0pVSUZvb3RlclwiOiBcIlwiXG5cdH0gKTtcblx0XG5cdFxuXHR2YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XG5cdFxuXHRmdW5jdGlvbiBfbnVtYmVycyAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdHZhclxuXHRcdFx0bnVtYmVycyA9IFtdLFxuXHRcdFx0YnV0dG9ucyA9IGV4dFBhZ2luYXRpb24ubnVtYmVyc19sZW5ndGgsXG5cdFx0XHRoYWxmID0gTWF0aC5mbG9vciggYnV0dG9ucyAvIDIgKSxcblx0XHRcdGkgPSAxO1xuXHRcblx0XHRpZiAoIHBhZ2VzIDw9IGJ1dHRvbnMgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBwYWdlcyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA8PSBoYWxmICkge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZSggMCwgYnV0dG9ucy0yICk7XG5cdFx0XHRudW1iZXJzLnB1c2goICdlbGxpcHNpcycgKTtcblx0XHRcdG51bWJlcnMucHVzaCggcGFnZXMtMSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmICkge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZSggcGFnZXMtKGJ1dHRvbnMtMiksIHBhZ2VzICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApOyAvLyBubyB1bnNoaWZ0IGluIGllNlxuXHRcdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsIDAgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlLWhhbGYrMiwgcGFnZStoYWxmLTEgKTtcblx0XHRcdG51bWJlcnMucHVzaCggJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsIDAgKTtcblx0XHR9XG5cdFxuXHRcdG51bWJlcnMuRFRfZWwgPSAnc3Bhbic7XG5cdFx0cmV0dXJuIG51bWJlcnM7XG5cdH1cblx0XG5cdFxuXHQkLmV4dGVuZCggZXh0UGFnaW5hdGlvbiwge1xuXHRcdHNpbXBsZTogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsICduZXh0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdGZ1bGw6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyAgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ25leHQnLCAnbGFzdCcgXTtcblx0XHR9LFxuXHRcblx0XHRudW1iZXJzOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgX251bWJlcnMocGFnZSwgcGFnZXMpIF07XG5cdFx0fSxcblx0XG5cdFx0c2ltcGxlX251bWJlcnM6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyAncHJldmlvdXMnLCBfbnVtYmVycyhwYWdlLCBwYWdlcyksICduZXh0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdGZ1bGxfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdmaXJzdCcsICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnLCAnbGFzdCcgXTtcblx0XHR9LFxuXHRcdFxuXHRcdGZpcnN0X2xhc3RfbnVtYmVyczogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XG5cdCBcdFx0cmV0dXJuIFsnZmlyc3QnLCBfbnVtYmVycyhwYWdlLCBwYWdlcyksICdsYXN0J107XG5cdCBcdH0sXG5cdFxuXHRcdC8vIEZvciB0ZXN0aW5nIGFuZCBwbHVnLWlucyB0byB1c2Vcblx0XHRfbnVtYmVyczogX251bWJlcnMsXG5cdFxuXHRcdC8vIE51bWJlciBvZiBudW1iZXIgYnV0dG9ucyAoaW5jbHVkaW5nIGVsbGlwc2lzKSB0byBzaG93LiBfTXVzdCBiZSBvZGQhX1xuXHRcdG51bWJlcnNfbGVuZ3RoOiA3XG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdHBhZ2VCdXR0b246IHtcblx0XHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHRcdHZhciBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9QYWdpbmF0ZTtcblx0XHRcdFx0dmFyIGFyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWEucGFnaW5hdGUgfHwge307XG5cdFx0XHRcdHZhciBidG5EaXNwbGF5LCBidG5DbGFzcywgY291bnRlcj0wO1xuXHRcblx0XHRcdFx0dmFyIGF0dGFjaCA9IGZ1bmN0aW9uKCBjb250YWluZXIsIGJ1dHRvbnMgKSB7XG5cdFx0XHRcdFx0dmFyIGksIGllbiwgbm9kZSwgYnV0dG9uLCB0YWJJbmRleDtcblx0XHRcdFx0XHR2YXIgZGlzYWJsZWRDbGFzcyA9IGNsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZDtcblx0XHRcdFx0XHR2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRcdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGUuZGF0YS5hY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0YnV0dG9uID0gYnV0dG9uc1tpXTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGJ1dHRvbiApICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5uZXIgPSAkKCAnPCcrKGJ1dHRvbi5EVF9lbCB8fCAnZGl2JykrJy8+JyApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XHRcdFx0XHRcdFx0YXR0YWNoKCBpbm5lciwgYnV0dG9uICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uO1xuXHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IHNldHRpbmdzLmlUYWJJbmRleDtcblx0XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGJ1dHRvbiApIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdlbGxpcHNpcyc6XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kKCc8c3BhbiBjbGFzcz1cImVsbGlwc2lzXCI+JiN4MjAyNjs8L3NwYW4+Jyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZmlyc3QnOlxuXHRcdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc0ZpcnN0O1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcGFnZSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFiSW5kZXggPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgKz0gJyAnICsgZGlzYWJsZWRDbGFzcztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdwcmV2aW91cyc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zUHJldmlvdXM7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc05leHQ7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlcyA9PT0gMCB8fCBwYWdlID09PSBwYWdlcy0xICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2xhc3QnOlxuXHRcdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc0xhc3Q7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlcyA9PT0gMCB8fCBwYWdlID09PSBwYWdlcy0xICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGJ1dHRvbiArIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gcGFnZSA9PT0gYnV0dG9uID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zUGFnZUJ1dHRvbkFjdGl2ZSA6ICcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdGlmICggYnRuRGlzcGxheSAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gJCgnPGE+Jywge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNQYWdlQnV0dG9uKycgJytidG5DbGFzcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2FyaWEtbGFiZWwnOiBhcmlhWyBidXR0b24gXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2RhdGEtZHQtaWR4JzogY291bnRlcixcblx0XHRcdFx0XHRcdFx0XHRcdFx0J3RhYmluZGV4JzogdGFiSW5kZXgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdpZCc6IGlkeCA9PT0gMCAmJiB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3Muc1RhYmxlSWQgKydfJysgYnV0dG9uIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdFx0XHRcdC5odG1sKCBidG5EaXNwbGF5IClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyggY29udGFpbmVyICk7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdF9mbkJpbmRBY3Rpb24oXG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLCB7YWN0aW9uOiBidXR0b259LCBjbGlja0hhbmRsZXJcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjb3VudGVyKys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFxuXHRcdFx0XHQvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcblx0XHRcdFx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4gVHJ5IC8gY2F0Y2ggdGhlIGVycm9yLiBOb3QgZ29vZCBmb3Jcblx0XHRcdFx0Ly8gYWNjZXNzaWJpbGl0eSwgYnV0IG5laXRoZXIgYXJlIGZyYW1lcy5cblx0XHRcdFx0dmFyIGFjdGl2ZUVsO1xuXHRcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBCZWNhdXNlIHRoaXMgYXBwcm9hY2ggaXMgZGVzdHJveWluZyBhbmQgcmVjcmVhdGluZyB0aGUgcGFnaW5nXG5cdFx0XHRcdFx0Ly8gZWxlbWVudHMsIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHNlbGVjdCBidXR0b24gd2hpY2ggaXMgYmFkIGZvclxuXHRcdFx0XHRcdC8vIGFjY2Vzc2liaWxpdHkuIFNvIHdlIHdhbnQgdG8gcmVzdG9yZSBmb2N1cyBvbmNlIHRoZSBkcmF3IGhhc1xuXHRcdFx0XHRcdC8vIGNvbXBsZXRlZFxuXHRcdFx0XHRcdGFjdGl2ZUVsID0gJChob3N0KS5maW5kKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmRhdGEoJ2R0LWlkeCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7fVxuXHRcblx0XHRcdFx0YXR0YWNoKCAkKGhvc3QpLmVtcHR5KCksIGJ1dHRvbnMgKTtcblx0XG5cdFx0XHRcdGlmICggYWN0aXZlRWwgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQkKGhvc3QpLmZpbmQoICdbZGF0YS1kdC1pZHg9JythY3RpdmVFbCsnXScgKS50cmlnZ2VyKCdmb2N1cycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8vIEJ1aWx0IGluIHR5cGUgZGV0ZWN0aW9uLiBTZWUgbW9kZWwuZXh0LmFUeXBlcyBmb3IgaW5mb3JtYXRpb24gYWJvdXRcblx0Ly8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoaXMgbWV0aG9kcy5cblx0JC5leHRlbmQoIERhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QsIFtcblx0XHQvLyBQbGFpbiBudW1iZXJzIC0gZmlyc3Qgc2luY2UgVjggZGV0ZWN0cyBzb21lIHBsYWluIG51bWJlcnMgYXMgZGF0ZXNcblx0XHQvLyBlLmcuIERhdGUucGFyc2UoJzU1JykgKGJ1dCBub3QgYWxsLCBlLmcuIERhdGUucGFyc2UoJzIyJykuLi4pLlxuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCApID8gJ251bScrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gRGF0ZXMgKG9ubHkgdGhvc2UgcmVjb2duaXNlZCBieSB0aGUgYnJvd3NlcidzIERhdGUucGFyc2UpXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0Ly8gVjggdHJpZXMgX3ZlcnlfIGhhcmQgdG8gbWFrZSBhIHN0cmluZyBwYXNzZWQgaW50byBgRGF0ZS5wYXJzZSgpYFxuXHRcdFx0Ly8gdmFsaWQsIHNvIHdlIG5lZWQgdG8gdXNlIGEgcmVnZXggdG8gcmVzdHJpY3QgZGF0ZSBmb3JtYXRzLiBVc2UgYVxuXHRcdFx0Ly8gcGx1Zy1pbiBmb3IgYW55dGhpbmcgb3RoZXIgdGhhbiBJU084NjAxIHN0eWxlIHN0cmluZ3Ncblx0XHRcdGlmICggZCAmJiAhKGQgaW5zdGFuY2VvZiBEYXRlKSAmJiAhIF9yZV9kYXRlLnRlc3QoZCkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZCk7XG5cdFx0XHRyZXR1cm4gKHBhcnNlZCAhPT0gbnVsbCAmJiAhaXNOYU4ocGFyc2VkKSkgfHwgX2VtcHR5KGQpID8gJ2RhdGUnIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBGb3JtYXR0ZWQgbnVtYmVyc1xuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCwgdHJ1ZSApID8gJ251bS1mbXQnK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEhUTUwgbnVtZXJpY1xuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCApID8gJ2h0bWwtbnVtJytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCwgdHJ1ZSApID8gJ2h0bWwtbnVtLWZtdCcrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gSFRNTCAodGhpcyBpcyBzdHJpY3QgY2hlY2tpbmcgLSB0aGVyZSBtdXN0IGJlIGh0bWwpXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5pbmRleE9mKCc8JykgIT09IC0xKSA/XG5cdFx0XHRcdCdodG1sJyA6IG51bGw7XG5cdFx0fVxuXHRdICk7XG5cdFxuXHRcblx0XG5cdC8vIEZpbHRlciBmb3JtYXR0aW5nIGZ1bmN0aW9ucy4gU2VlIG1vZGVsLmV4dC5vZm5TZWFyY2ggZm9yIGluZm9ybWF0aW9uIGFib3V0XG5cdC8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGVzZSBtZXRob2RzLlxuXHQvLyBcblx0Ly8gTm90ZSB0aGF0IGFkZGl0aW9uYWwgc2VhcmNoIG1ldGhvZHMgYXJlIGFkZGVkIGZvciB0aGUgaHRtbCBudW1iZXJzIGFuZFxuXHQvLyBodG1sIGZvcm1hdHRlZCBudW1iZXJzIGJ5IGBfYWRkTnVtZXJpY1NvcnQoKWAgd2hlbiB3ZSBrbm93IHdoYXQgdGhlIGRlY2ltYWxcblx0Ly8gcGxhY2UgaXNcblx0XG5cdFxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaCwge1xuXHRcdGh0bWw6IGZ1bmN0aW9uICggZGF0YSApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoZGF0YSkgP1xuXHRcdFx0XHRkYXRhIDpcblx0XHRcdFx0dHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRkYXRhXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggX3JlX25ld19saW5lcywgXCIgXCIgKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoIF9yZV9odG1sLCBcIlwiICkgOlxuXHRcdFx0XHRcdCcnO1xuXHRcdH0sXG5cdFxuXHRcdHN0cmluZzogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShkYXRhKSA/XG5cdFx0XHRcdGRhdGEgOlxuXHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGRhdGEucmVwbGFjZSggX3JlX25ld19saW5lcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0dmFyIF9fbnVtZXJpY1JlcGxhY2UgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQbGFjZSwgcmUxLCByZTIgKSB7XG5cdFx0aWYgKCBkICE9PSAwICYmICghZCB8fCBkID09PSAnLScpICkge1xuXHRcdFx0cmV0dXJuIC1JbmZpbml0eTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIGEgZGVjaW1hbCBwbGFjZSBvdGhlciB0aGFuIGAuYCBpcyB1c2VkLCBpdCBuZWVkcyB0byBiZSBnaXZlbiB0byB0aGVcblx0XHQvLyBmdW5jdGlvbiBzbyB3ZSBjYW4gZGV0ZWN0IGl0IGFuZCByZXBsYWNlIHdpdGggYSBgLmAgd2hpY2ggaXMgdGhlIG9ubHlcblx0XHQvLyBkZWNpbWFsIHBsYWNlIEphdmFzY3JpcHQgcmVjb2duaXNlcyAtIGl0IGlzIG5vdCBsb2NhbGUgYXdhcmUuXG5cdFx0aWYgKCBkZWNpbWFsUGxhY2UgKSB7XG5cdFx0XHRkID0gX251bVRvRGVjaW1hbCggZCwgZGVjaW1hbFBsYWNlICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGQucmVwbGFjZSApIHtcblx0XHRcdGlmICggcmUxICkge1xuXHRcdFx0XHRkID0gZC5yZXBsYWNlKCByZTEsICcnICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCByZTIgKSB7XG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMiwgJycgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBkICogMTtcblx0fTtcblx0XG5cdFxuXHQvLyBBZGQgdGhlIG51bWVyaWMgJ2RlZm9ybWF0dGluZycgZnVuY3Rpb25zIGZvciBzb3J0aW5nIGFuZCBzZWFyY2guIFRoaXMgaXMgZG9uZVxuXHQvLyBpbiBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYW4gZWFzeSBhYmlsaXR5IGZvciB0aGUgbGFuZ3VhZ2Ugb3B0aW9ucyB0byBhZGRcblx0Ly8gYWRkaXRpb25hbCBtZXRob2RzIGlmIGEgbm9uLXBlcmlvZCBkZWNpbWFsIHBsYWNlIGlzIHVzZWQuXG5cdGZ1bmN0aW9uIF9hZGROdW1lcmljU29ydCAoIGRlY2ltYWxQbGFjZSApIHtcblx0XHQkLmVhY2goXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFBsYWluIG51bWJlcnNcblx0XHRcdFx0XCJudW1cIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0XHRcdFx0fSxcblx0XG5cdFx0XHRcdC8vIEZvcm1hdHRlZCBudW1iZXJzXG5cdFx0XHRcdFwibnVtLWZtdFwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSwgX3JlX2Zvcm1hdHRlZF9udW1lcmljICk7XG5cdFx0XHRcdH0sXG5cdFxuXHRcdFx0XHQvLyBIVE1MIG51bWVyaWNcblx0XHRcdFx0XCJodG1sLW51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSwgX3JlX2h0bWwgKTtcblx0XHRcdFx0fSxcblx0XG5cdFx0XHRcdC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXG5cdFx0XHRcdFwiaHRtbC1udW0tZm10XCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCwgX3JlX2Zvcm1hdHRlZF9udW1lcmljICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmdW5jdGlvbiAoIGtleSwgZm4gKSB7XG5cdFx0XHRcdC8vIEFkZCB0aGUgb3JkZXJpbmcgbWV0aG9kXG5cdFx0XHRcdF9leHQudHlwZS5vcmRlclsga2V5K2RlY2ltYWxQbGFjZSsnLXByZScgXSA9IGZuO1xuXHRcblx0XHRcdFx0Ly8gRm9yIEhUTUwgdHlwZXMgYWRkIGEgc2VhcmNoIGZvcm1hdHRlciB0aGF0IHdpbGwgc3RyaXAgdGhlIEhUTUxcblx0XHRcdFx0aWYgKCBrZXkubWF0Y2goL15odG1sXFwtLykgKSB7XG5cdFx0XHRcdFx0X2V4dC50eXBlLnNlYXJjaFsga2V5K2RlY2ltYWxQbGFjZSBdID0gX2V4dC50eXBlLnNlYXJjaC5odG1sO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblx0fVxuXHRcblx0XG5cdC8vIERlZmF1bHQgc29ydCBtZXRob2RzXG5cdCQuZXh0ZW5kKCBfZXh0LnR5cGUub3JkZXIsIHtcblx0XHQvLyBEYXRlc1xuXHRcdFwiZGF0ZS1wcmVcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0dmFyIHRzID0gRGF0ZS5wYXJzZSggZCApO1xuXHRcdFx0cmV0dXJuIGlzTmFOKHRzKSA/IC1JbmZpbml0eSA6IHRzO1xuXHRcdH0sXG5cdFxuXHRcdC8vIGh0bWxcblx0XHRcImh0bWwtcHJlXCI6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoYSkgP1xuXHRcdFx0XHQnJyA6XG5cdFx0XHRcdGEucmVwbGFjZSA/XG5cdFx0XHRcdFx0YS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdGErJyc7XG5cdFx0fSxcblx0XG5cdFx0Ly8gc3RyaW5nXG5cdFx0XCJzdHJpbmctcHJlXCI6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdC8vIFRoaXMgaXMgYSBsaXR0bGUgY29tcGxleCwgYnV0IGZhc3RlciB0aGFuIGFsd2F5cyBjYWxsaW5nIHRvU3RyaW5nLFxuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdG9zdHJpbmctdi1jaGVja1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0dHlwZW9mIGEgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRhLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCEgYS50b1N0cmluZyA/XG5cdFx0XHRcdFx0XHQnJyA6XG5cdFx0XHRcdFx0XHRhLnRvU3RyaW5nKCk7XG5cdFx0fSxcblx0XG5cdFx0Ly8gc3RyaW5nLWFzYyBhbmQgLWRlc2MgYXJlIHJldGFpbmVkIG9ubHkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkXG5cdFx0Ly8gc29ydCBtZXRob2RzXG5cdFx0XCJzdHJpbmctYXNjXCI6IGZ1bmN0aW9uICggeCwgeSApIHtcblx0XHRcdHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xuXHRcdH0sXG5cdFxuXHRcdFwic3RyaW5nLWRlc2NcIjogZnVuY3Rpb24gKCB4LCB5ICkge1xuXHRcdFx0cmV0dXJuICgoeCA8IHkpID8gMSA6ICgoeCA+IHkpID8gLTEgOiAwKSk7XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHRcblx0Ly8gTnVtZXJpYyBzb3J0aW5nIHR5cGVzIC0gb3JkZXIgZG9lc24ndCBtYXR0ZXIgaGVyZVxuXHRfYWRkTnVtZXJpY1NvcnQoICcnICk7XG5cdFxuXHRcblx0JC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcblx0XHRoZWFkZXI6IHtcblx0XHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3NlcyApIHtcblx0XHRcdFx0Ly8gTm8gYWRkaXRpb25hbCBtYXJrLXVwIHJlcXVpcmVkXG5cdFx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnQgLSBub3RlIHRoYXQgdXNpbmcgdGhlXG5cdFx0XHRcdC8vIGBEVGAgbmFtZXNwYWNlIHdpbGwgYWxsb3cgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWQgYXV0b21hdGljYWxseVxuXHRcdFx0XHQvLyBvbiBkZXN0cm95LCB3aGlsZSB0aGUgYGR0YCBuYW1lc3BhY2VkIGV2ZW50IGlzIHRoZSBvbmUgd2UgYXJlXG5cdFx0XHRcdC8vIGxpc3RlbmluZyBmb3Jcblx0XHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoIGUsIGN0eCwgc29ydGluZywgY29sdW1ucyApIHtcblx0XHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7IC8vIG5lZWQgdG8gY2hlY2sgdGhpcyB0aGlzIGlzIHRoZSBob3N0XG5cdFx0XHRcdFx0XHRyZXR1cm47ICAgICAgICAgICAgICAgLy8gdGFibGUsIG5vdCBhIG5lc3RlZCBvbmVcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgKycgJytcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydERlc2Ncblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFxuXHRcdFx0anF1ZXJ5dWk6IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3NlcyApIHtcblx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRKVUlXcmFwcGVyIClcblx0XHRcdFx0XHQuYXBwZW5kKCBjZWxsLmNvbnRlbnRzKCkgKVxuXHRcdFx0XHRcdC5hcHBlbmQoICQoJzxzcGFuLz4nKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjbGFzc2VzLnNTb3J0SWNvbisnICcrY29sdW1uLnNTb3J0aW5nQ2xhc3NKVUkgKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIGNlbGwgKTtcblx0XG5cdFx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnRcblx0XHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoIGUsIGN0eCwgc29ydGluZywgY29sdW1ucyApIHtcblx0XHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR2YXIgY29sSWR4ID0gY29sdW1uLmlkeDtcblx0XG5cdFx0XHRcdFx0Y2VsbFxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjbGFzc2VzLnNTb3J0QXNjICtcIiBcIitjbGFzc2VzLnNTb3J0RGVzYyApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydERlc2MgOlxuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzXG5cdFx0XHRcdFx0XHQpO1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQuZmluZCggJ3NwYW4uJytjbGFzc2VzLnNTb3J0SWNvbiApXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2MgK1wiIFwiK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0SlVJRGVzYyArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUkgK1wiIFwiK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZCArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjIDpcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0Lypcblx0ICogUHVibGljIGhlbHBlciBmdW5jdGlvbnMuIFRoZXNlIGFyZW4ndCB1c2VkIGludGVybmFsbHkgYnkgRGF0YVRhYmxlcywgb3Jcblx0ICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxuXHQgKiBleHRlcm5hbGx5IGJ5IGRldmVsb3BlcnMgd29ya2luZyB3aXRoIERhdGFUYWJsZXMuIFRoZXkgYXJlIGhlbHBlciBmdW5jdGlvbnNcblx0ICogdG8gbWFrZSB3b3JraW5nIHdpdGggRGF0YVRhYmxlcyBhIGxpdHRsZSBiaXQgZWFzaWVyLlxuXHQgKi9cblx0XG5cdHZhciBfX2h0bWxFc2NhcGVFbnRpdGllcyA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuXHRcdFx0ZCA9IGQuam9pbignLCcpO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/XG5cdFx0XHRkXG5cdFx0XHRcdC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG5cdFx0XHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHRcdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdFx0XHQucmVwbGFjZSgvXCIvZywgJyZxdW90OycpIDpcblx0XHRcdGQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSGVscGVycyBmb3IgYGNvbHVtbnMucmVuZGVyYC5cblx0ICpcblx0ICogVGhlIG9wdGlvbnMgZGVmaW5lZCBoZXJlIGNhbiBiZSB1c2VkIHdpdGggdGhlIGBjb2x1bW5zLnJlbmRlcmAgaW5pdGlhbGlzYXRpb25cblx0ICogb3B0aW9uIHRvIHByb3ZpZGUgYSBkaXNwbGF5IHJlbmRlcmVyLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZDpcblx0ICpcblx0ICogKiBgbnVtYmVyYCAtIFdpbGwgZm9ybWF0IG51bWVyaWMgZGF0YSAoZGVmaW5lZCBieSBgY29sdW1ucy5kYXRhYCkgZm9yXG5cdCAqICAgZGlzcGxheSwgcmV0YWluaW5nIHRoZSBvcmlnaW5hbCB1bmZvcm1hdHRlZCBkYXRhIGZvciBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcuXG5cdCAqICAgSXQgdGFrZXMgNSBwYXJhbWV0ZXJzOlxuXHQgKiAgICogYHN0cmluZ2AgLSBUaG91c2FuZHMgZ3JvdXBpbmcgc2VwYXJhdG9yXG5cdCAqICAgKiBgc3RyaW5nYCAtIERlY2ltYWwgcG9pbnQgaW5kaWNhdG9yXG5cdCAqICAgKiBgaW50ZWdlcmAgLSBOdW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdG8gc2hvd1xuXHQgKiAgICogYHN0cmluZ2AgKG9wdGlvbmFsKSAtIFByZWZpeC5cblx0ICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQb3N0Zml4ICgvc3VmZml4KS5cblx0ICogKiBgdGV4dGAgLSBFc2NhcGUgSFRNTCB0byBoZWxwIHByZXZlbnQgWFNTIGF0dGFja3MuIEl0IGhhcyBubyBvcHRpb25hbFxuXHQgKiAgIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gQ29sdW1uIGRlZmluaXRpb24gdXNpbmcgdGhlIG51bWJlciByZW5kZXJlclxuXHQgKiAgIHtcblx0ICogICAgIGRhdGE6IFwic2FsYXJ5XCIsXG5cdCAqICAgICByZW5kZXI6ICQuZm4uZGF0YVRhYmxlLnJlbmRlci5udW1iZXIoICdcXCcnLCAnLicsIDAsICckJyApXG5cdCAqICAgfVxuXHQgKlxuXHQgKiBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUucmVuZGVyID0ge1xuXHRcdG51bWJlcjogZnVuY3Rpb24gKCB0aG91c2FuZHMsIGRlY2ltYWwsIHByZWNpc2lvbiwgcHJlZml4LCBwb3N0Zml4ICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGlzcGxheTogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGQgIT09ICdudW1iZXInICYmIHR5cGVvZiBkICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0dmFyIG5lZ2F0aXZlID0gZCA8IDAgPyAnLScgOiAnJztcblx0XHRcdFx0XHR2YXIgZmxvID0gcGFyc2VGbG9hdCggZCApO1xuXHRcblx0XHRcdFx0XHQvLyBJZiBOYU4gdGhlbiB0aGVyZSBpc24ndCBtdWNoIGZvcm1hdHRpbmcgdGhhdCB3ZSBjYW4gZG8gLSBqdXN0XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIGltbWVkaWF0ZWx5LCBlc2NhcGluZyBhbnkgSFRNTCAodGhpcyB3YXMgc3VwcG9zZWQgdG9cblx0XHRcdFx0XHQvLyBiZSBhIG51bWJlciBhZnRlciBhbGwpXG5cdFx0XHRcdFx0aWYgKCBpc05hTiggZmxvICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX19odG1sRXNjYXBlRW50aXRpZXMoIGQgKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGZsbyA9IGZsby50b0ZpeGVkKCBwcmVjaXNpb24gKTtcblx0XHRcdFx0XHRkID0gTWF0aC5hYnMoIGZsbyApO1xuXHRcblx0XHRcdFx0XHR2YXIgaW50UGFydCA9IHBhcnNlSW50KCBkLCAxMCApO1xuXHRcdFx0XHRcdHZhciBmbG9hdFBhcnQgPSBwcmVjaXNpb24gP1xuXHRcdFx0XHRcdFx0ZGVjaW1hbCsoZCAtIGludFBhcnQpLnRvRml4ZWQoIHByZWNpc2lvbiApLnN1YnN0cmluZyggMiApOlxuXHRcdFx0XHRcdFx0Jyc7XG5cdFxuXHRcdFx0XHRcdC8vIElmIHplcm8sIHRoZW4gY2FuJ3QgaGF2ZSBhIG5lZ2F0aXZlIHByZWZpeFxuXHRcdFx0XHRcdGlmIChpbnRQYXJ0ID09PSAwICYmIHBhcnNlRmxvYXQoZmxvYXRQYXJ0KSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0bmVnYXRpdmUgPSAnJztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHJldHVybiBuZWdhdGl2ZSArIChwcmVmaXh8fCcnKSArXG5cdFx0XHRcdFx0XHRpbnRQYXJ0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdFx0XHRcdFx0L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHRob3VzYW5kc1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0XHRmbG9hdFBhcnQgK1xuXHRcdFx0XHRcdFx0KHBvc3RmaXh8fCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcblx0XHR0ZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkaXNwbGF5OiBfX2h0bWxFc2NhcGVFbnRpdGllcyxcblx0XHRcdFx0ZmlsdGVyOiBfX2h0bWxFc2NhcGVFbnRpdGllc1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0Lypcblx0ICogVGhpcyBpcyByZWFsbHkgYSBnb29kIGJpdCBydWJiaXNoIHRoaXMgbWV0aG9kIG9mIGV4cG9zaW5nIHRoZSBpbnRlcm5hbCBtZXRob2RzXG5cdCAqIHB1YmxpY2x5Li4uIC0gVG8gYmUgZml4ZWQgaW4gMi4wIHVzaW5nIG1ldGhvZHMgb24gdGhlIHByb3RvdHlwZVxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGEgd3JhcHBlciBmdW5jdGlvbiBmb3IgZXhwb3J0aW5nIGFuIGludGVybmFsIGZ1bmN0aW9ucyB0byBhbiBleHRlcm5hbCBBUEkuXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gZm4gQVBJIGZ1bmN0aW9uIG5hbWVcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNpbnRlcm5hbFxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRXh0ZXJuQXBpRnVuYyAoZm4pXG5cdHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IFtfZm5TZXR0aW5nc0Zyb21Ob2RlKCB0aGlzW0RhdGFUYWJsZS5leHQuaUFwaUluZGV4XSApXS5jb25jYXQoXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbFtmbl0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHR9O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlZmVyZW5jZSB0byBpbnRlcm5hbCBmdW5jdGlvbnMgZm9yIHVzZSBieSBwbHVnLWluIGRldmVsb3BlcnMuIE5vdGUgdGhhdFxuXHQgKiB0aGVzZSBtZXRob2RzIGFyZSByZWZlcmVuY2VzIHRvIGludGVybmFsIGZ1bmN0aW9ucyBhbmQgYXJlIGNvbnNpZGVyZWQgdG8gYmVcblx0ICogcHJpdmF0ZS4gSWYgeW91IHVzZSB0aGVzZSBtZXRob2RzLCBiZSBhd2FyZSB0aGF0IHRoZXkgYXJlIGxpYWJsZSB0byBjaGFuZ2Vcblx0ICogYmV0d2VlbiB2ZXJzaW9ucy5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LmludGVybmFsLCB7XG5cdFx0X2ZuRXh0ZXJuQXBpRnVuYzogX2ZuRXh0ZXJuQXBpRnVuYyxcblx0XHRfZm5CdWlsZEFqYXg6IF9mbkJ1aWxkQWpheCxcblx0XHRfZm5BamF4VXBkYXRlOiBfZm5BamF4VXBkYXRlLFxuXHRcdF9mbkFqYXhQYXJhbWV0ZXJzOiBfZm5BamF4UGFyYW1ldGVycyxcblx0XHRfZm5BamF4VXBkYXRlRHJhdzogX2ZuQWpheFVwZGF0ZURyYXcsXG5cdFx0X2ZuQWpheERhdGFTcmM6IF9mbkFqYXhEYXRhU3JjLFxuXHRcdF9mbkFkZENvbHVtbjogX2ZuQWRkQ29sdW1uLFxuXHRcdF9mbkNvbHVtbk9wdGlvbnM6IF9mbkNvbHVtbk9wdGlvbnMsXG5cdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nOiBfZm5BZGp1c3RDb2x1bW5TaXppbmcsXG5cdFx0X2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXg6IF9mblZpc2libGVUb0NvbHVtbkluZGV4LFxuXHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxcblx0XHRfZm5WaXNibGVDb2x1bW5zOiBfZm5WaXNibGVDb2x1bW5zLFxuXHRcdF9mbkdldENvbHVtbnM6IF9mbkdldENvbHVtbnMsXG5cdFx0X2ZuQ29sdW1uVHlwZXM6IF9mbkNvbHVtblR5cGVzLFxuXHRcdF9mbkFwcGx5Q29sdW1uRGVmczogX2ZuQXBwbHlDb2x1bW5EZWZzLFxuXHRcdF9mbkh1bmdhcmlhbk1hcDogX2ZuSHVuZ2FyaWFuTWFwLFxuXHRcdF9mbkNhbWVsVG9IdW5nYXJpYW46IF9mbkNhbWVsVG9IdW5nYXJpYW4sXG5cdFx0X2ZuTGFuZ3VhZ2VDb21wYXQ6IF9mbkxhbmd1YWdlQ29tcGF0LFxuXHRcdF9mbkJyb3dzZXJEZXRlY3Q6IF9mbkJyb3dzZXJEZXRlY3QsXG5cdFx0X2ZuQWRkRGF0YTogX2ZuQWRkRGF0YSxcblx0XHRfZm5BZGRUcjogX2ZuQWRkVHIsXG5cdFx0X2ZuTm9kZVRvRGF0YUluZGV4OiBfZm5Ob2RlVG9EYXRhSW5kZXgsXG5cdFx0X2ZuTm9kZVRvQ29sdW1uSW5kZXg6IF9mbk5vZGVUb0NvbHVtbkluZGV4LFxuXHRcdF9mbkdldENlbGxEYXRhOiBfZm5HZXRDZWxsRGF0YSxcblx0XHRfZm5TZXRDZWxsRGF0YTogX2ZuU2V0Q2VsbERhdGEsXG5cdFx0X2ZuU3BsaXRPYmpOb3RhdGlvbjogX2ZuU3BsaXRPYmpOb3RhdGlvbixcblx0XHRfZm5HZXRPYmplY3REYXRhRm46IF9mbkdldE9iamVjdERhdGFGbixcblx0XHRfZm5TZXRPYmplY3REYXRhRm46IF9mblNldE9iamVjdERhdGFGbixcblx0XHRfZm5HZXREYXRhTWFzdGVyOiBfZm5HZXREYXRhTWFzdGVyLFxuXHRcdF9mbkNsZWFyVGFibGU6IF9mbkNsZWFyVGFibGUsXG5cdFx0X2ZuRGVsZXRlSW5kZXg6IF9mbkRlbGV0ZUluZGV4LFxuXHRcdF9mbkludmFsaWRhdGU6IF9mbkludmFsaWRhdGUsXG5cdFx0X2ZuR2V0Um93RWxlbWVudHM6IF9mbkdldFJvd0VsZW1lbnRzLFxuXHRcdF9mbkNyZWF0ZVRyOiBfZm5DcmVhdGVUcixcblx0XHRfZm5CdWlsZEhlYWQ6IF9mbkJ1aWxkSGVhZCxcblx0XHRfZm5EcmF3SGVhZDogX2ZuRHJhd0hlYWQsXG5cdFx0X2ZuRHJhdzogX2ZuRHJhdyxcblx0XHRfZm5SZURyYXc6IF9mblJlRHJhdyxcblx0XHRfZm5BZGRPcHRpb25zSHRtbDogX2ZuQWRkT3B0aW9uc0h0bWwsXG5cdFx0X2ZuRGV0ZWN0SGVhZGVyOiBfZm5EZXRlY3RIZWFkZXIsXG5cdFx0X2ZuR2V0VW5pcXVlVGhzOiBfZm5HZXRVbmlxdWVUaHMsXG5cdFx0X2ZuRmVhdHVyZUh0bWxGaWx0ZXI6IF9mbkZlYXR1cmVIdG1sRmlsdGVyLFxuXHRcdF9mbkZpbHRlckNvbXBsZXRlOiBfZm5GaWx0ZXJDb21wbGV0ZSxcblx0XHRfZm5GaWx0ZXJDdXN0b206IF9mbkZpbHRlckN1c3RvbSxcblx0XHRfZm5GaWx0ZXJDb2x1bW46IF9mbkZpbHRlckNvbHVtbixcblx0XHRfZm5GaWx0ZXI6IF9mbkZpbHRlcixcblx0XHRfZm5GaWx0ZXJDcmVhdGVTZWFyY2g6IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxcblx0XHRfZm5Fc2NhcGVSZWdleDogX2ZuRXNjYXBlUmVnZXgsXG5cdFx0X2ZuRmlsdGVyRGF0YTogX2ZuRmlsdGVyRGF0YSxcblx0XHRfZm5GZWF0dXJlSHRtbEluZm86IF9mbkZlYXR1cmVIdG1sSW5mbyxcblx0XHRfZm5VcGRhdGVJbmZvOiBfZm5VcGRhdGVJbmZvLFxuXHRcdF9mbkluZm9NYWNyb3M6IF9mbkluZm9NYWNyb3MsXG5cdFx0X2ZuSW5pdGlhbGlzZTogX2ZuSW5pdGlhbGlzZSxcblx0XHRfZm5Jbml0Q29tcGxldGU6IF9mbkluaXRDb21wbGV0ZSxcblx0XHRfZm5MZW5ndGhDaGFuZ2U6IF9mbkxlbmd0aENoYW5nZSxcblx0XHRfZm5GZWF0dXJlSHRtbExlbmd0aDogX2ZuRmVhdHVyZUh0bWxMZW5ndGgsXG5cdFx0X2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZTogX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxcblx0XHRfZm5QYWdlQ2hhbmdlOiBfZm5QYWdlQ2hhbmdlLFxuXHRcdF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZzogX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nLFxuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5OiBfZm5Qcm9jZXNzaW5nRGlzcGxheSxcblx0XHRfZm5GZWF0dXJlSHRtbFRhYmxlOiBfZm5GZWF0dXJlSHRtbFRhYmxlLFxuXHRcdF9mblNjcm9sbERyYXc6IF9mblNjcm9sbERyYXcsXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuOiBfZm5BcHBseVRvQ2hpbGRyZW4sXG5cdFx0X2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzOiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMsXG5cdFx0X2ZuVGhyb3R0bGU6IF9mblRocm90dGxlLFxuXHRcdF9mbkNvbnZlcnRUb1dpZHRoOiBfZm5Db252ZXJ0VG9XaWR0aCxcblx0XHRfZm5HZXRXaWRlc3ROb2RlOiBfZm5HZXRXaWRlc3ROb2RlLFxuXHRcdF9mbkdldE1heExlblN0cmluZzogX2ZuR2V0TWF4TGVuU3RyaW5nLFxuXHRcdF9mblN0cmluZ1RvQ3NzOiBfZm5TdHJpbmdUb0Nzcyxcblx0XHRfZm5Tb3J0RmxhdHRlbjogX2ZuU29ydEZsYXR0ZW4sXG5cdFx0X2ZuU29ydDogX2ZuU29ydCxcblx0XHRfZm5Tb3J0QXJpYTogX2ZuU29ydEFyaWEsXG5cdFx0X2ZuU29ydExpc3RlbmVyOiBfZm5Tb3J0TGlzdGVuZXIsXG5cdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyOiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsXG5cdFx0X2ZuU29ydGluZ0NsYXNzZXM6IF9mblNvcnRpbmdDbGFzc2VzLFxuXHRcdF9mblNvcnREYXRhOiBfZm5Tb3J0RGF0YSxcblx0XHRfZm5TYXZlU3RhdGU6IF9mblNhdmVTdGF0ZSxcblx0XHRfZm5Mb2FkU3RhdGU6IF9mbkxvYWRTdGF0ZSxcblx0XHRfZm5JbXBsZW1lbnRTdGF0ZTogX2ZuSW1wbGVtZW50U3RhdGUsXG5cdFx0X2ZuU2V0dGluZ3NGcm9tTm9kZTogX2ZuU2V0dGluZ3NGcm9tTm9kZSxcblx0XHRfZm5Mb2c6IF9mbkxvZyxcblx0XHRfZm5NYXA6IF9mbk1hcCxcblx0XHRfZm5CaW5kQWN0aW9uOiBfZm5CaW5kQWN0aW9uLFxuXHRcdF9mbkNhbGxiYWNrUmVnOiBfZm5DYWxsYmFja1JlZyxcblx0XHRfZm5DYWxsYmFja0ZpcmU6IF9mbkNhbGxiYWNrRmlyZSxcblx0XHRfZm5MZW5ndGhPdmVyZmxvdzogX2ZuTGVuZ3RoT3ZlcmZsb3csXG5cdFx0X2ZuUmVuZGVyZXI6IF9mblJlbmRlcmVyLFxuXHRcdF9mbkRhdGFTb3VyY2U6IF9mbkRhdGFTb3VyY2UsXG5cdFx0X2ZuUm93QXR0cmlidXRlczogX2ZuUm93QXR0cmlidXRlcyxcblx0XHRfZm5FeHRlbmQ6IF9mbkV4dGVuZCxcblx0XHRfZm5DYWxjdWxhdGVFbmQ6IGZ1bmN0aW9uICgpIHt9IC8vIFVzZWQgYnkgYSBsb3Qgb2YgcGx1Zy1pbnMsIGJ1dCByZWR1bmRhbnRcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIDEuMTAsIHNvIHRoaXMgZGVhZC1lbmQgZnVuY3Rpb24gaXNcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGVkIHRvIHByZXZlbnQgZXJyb3JzXG5cdH0gKTtcblx0XG5cblx0Ly8galF1ZXJ5IGFjY2Vzc1xuXHQkLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcblxuXHQvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG5cdERhdGFUYWJsZS4kID0gJDtcblxuXHQvLyBMZWdhY3kgYWxpYXNlc1xuXHQkLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHQkLmZuLmRhdGFUYWJsZUV4dCA9IERhdGFUYWJsZS5leHQ7XG5cblx0Ly8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcblx0Ly8galF1ZXJ5IG9iamVjdFxuXHQkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uICggb3B0cyApIHtcblx0XHRyZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUoIG9wdHMgKS5hcGkoKTtcblx0fTtcblxuXHQvLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcblx0Ly8gYXZhaWxhYmxlIG9uICQuZm4uRGF0YVRhYmxlXG5cdCQuZWFjaCggRGF0YVRhYmxlLCBmdW5jdGlvbiAoIHByb3AsIHZhbCApIHtcblx0XHQkLmZuLkRhdGFUYWJsZVsgcHJvcCBdID0gdmFsO1xuXHR9ICk7XG5cblx0cmV0dXJuIERhdGFUYWJsZTtcbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==