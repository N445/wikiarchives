(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_filepond_dist_filepond_js"],{

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

/*!
 * FilePond 4.30.3
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */

/* eslint-disable */

(function(global, factory) {
     true
        ? factory(exports)
        : 0;
})(this, function(exports) {
    'use strict';

    var isNode = function isNode(value) {
        return value instanceof HTMLElement;
    };

    var createStore = function createStore(initialState) {
        var queries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        // internal state
        var state = Object.assign({}, initialState);

        // contains all actions for next frame, is clear when actions are requested
        var actionQueue = [];
        var dispatchQueue = [];

        // returns a duplicate of the current state
        var getState = function getState() {
            return Object.assign({}, state);
        };

        // returns a duplicate of the actions array and clears the actions array
        var processActionQueue = function processActionQueue() {
            // create copy of actions queue
            var queue = [].concat(actionQueue);

            // clear actions queue (we don't want no double actions)
            actionQueue.length = 0;

            return queue;
        };

        // processes actions that might block the main UI thread
        var processDispatchQueue = function processDispatchQueue() {
            // create copy of actions queue
            var queue = [].concat(dispatchQueue);

            // clear actions queue (we don't want no double actions)
            dispatchQueue.length = 0;

            // now dispatch these actions
            queue.forEach(function(_ref) {
                var type = _ref.type,
                    data = _ref.data;
                dispatch(type, data);
            });
        };

        // adds a new action, calls its handler and
        var dispatch = function dispatch(type, data, isBlocking) {
            // is blocking action (should never block if document is hidden)
            if (isBlocking && !document.hidden) {
                dispatchQueue.push({ type: type, data: data });
                return;
            }

            // if this action has a handler, handle the action
            if (actionHandlers[type]) {
                actionHandlers[type](data);
            }

            // now add action
            actionQueue.push({
                type: type,
                data: data,
            });
        };

        var query = function query(str) {
            var _queryHandles;
            for (
                var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
                _key < _len;
                _key++
            ) {
                args[_key - 1] = arguments[_key];
            }
            return queryHandles[str]
                ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)
                : null;
        };

        var api = {
            getState: getState,
            processActionQueue: processActionQueue,
            processDispatchQueue: processDispatchQueue,
            dispatch: dispatch,
            query: query,
        };

        var queryHandles = {};
        queries.forEach(function(query) {
            queryHandles = Object.assign({}, query(state), {}, queryHandles);
        });

        var actionHandlers = {};
        actions.forEach(function(action) {
            actionHandlers = Object.assign({}, action(dispatch, query, state), {}, actionHandlers);
        });

        return api;
    };

    var defineProperty = function defineProperty(obj, property, definition) {
        if (typeof definition === 'function') {
            obj[property] = definition;
            return;
        }
        Object.defineProperty(obj, property, Object.assign({}, definition));
    };

    var forin = function forin(obj, cb) {
        for (var key in obj) {
            if (!obj.hasOwnProperty(key)) {
                continue;
            }

            cb(key, obj[key]);
        }
    };

    var createObject = function createObject(definition) {
        var obj = {};
        forin(definition, function(property) {
            defineProperty(obj, property, definition[property]);
        });
        return obj;
    };

    var attr = function attr(node, name) {
        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (value === null) {
            return node.getAttribute(name) || node.hasAttribute(name);
        }
        node.setAttribute(name, value);
    };

    var ns = 'http://www.w3.org/2000/svg';
    var svgElements = ['svg', 'path']; // only svg elements used

    var isSVGElement = function isSVGElement(tag) {
        return svgElements.includes(tag);
    };

    var createElement = function createElement(tag, className) {
        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (typeof className === 'object') {
            attributes = className;
            className = null;
        }
        var element = isSVGElement(tag)
            ? document.createElementNS(ns, tag)
            : document.createElement(tag);
        if (className) {
            if (isSVGElement(tag)) {
                attr(element, 'class', className);
            } else {
                element.className = className;
            }
        }
        forin(attributes, function(name, value) {
            attr(element, name, value);
        });
        return element;
    };

    var appendChild = function appendChild(parent) {
        return function(child, index) {
            if (typeof index !== 'undefined' && parent.children[index]) {
                parent.insertBefore(child, parent.children[index]);
            } else {
                parent.appendChild(child);
            }
        };
    };

    var appendChildView = function appendChildView(parent, childViews) {
        return function(view, index) {
            if (typeof index !== 'undefined') {
                childViews.splice(index, 0, view);
            } else {
                childViews.push(view);
            }

            return view;
        };
    };

    var removeChildView = function removeChildView(parent, childViews) {
        return function(view) {
            // remove from child views
            childViews.splice(childViews.indexOf(view), 1);

            // remove the element
            if (view.element.parentNode) {
                parent.removeChild(view.element);
            }

            return view;
        };
    };

    var IS_BROWSER = (function() {
        return typeof window !== 'undefined' && typeof window.document !== 'undefined';
    })();
    var isBrowser = function isBrowser() {
        return IS_BROWSER;
    };

    var testElement = isBrowser() ? createElement('svg') : {};
    var getChildCount =
        'children' in testElement
            ? function(el) {
                  return el.children.length;
              }
            : function(el) {
                  return el.childNodes.length;
              };

    var getViewRect = function getViewRect(elementRect, childViews, offset, scale) {
        var left = offset[0] || elementRect.left;
        var top = offset[1] || elementRect.top;
        var right = left + elementRect.width;
        var bottom = top + elementRect.height * (scale[1] || 1);

        var rect = {
            // the rectangle of the element itself
            element: Object.assign({}, elementRect),

            // the rectangle of the element expanded to contain its children, does not include any margins
            inner: {
                left: elementRect.left,
                top: elementRect.top,
                right: elementRect.right,
                bottom: elementRect.bottom,
            },

            // the rectangle of the element expanded to contain its children including own margin and child margins
            // margins will be added after we've recalculated the size
            outer: {
                left: left,
                top: top,
                right: right,
                bottom: bottom,
            },
        };

        // expand rect to fit all child rectangles
        childViews
            .filter(function(childView) {
                return !childView.isRectIgnored();
            })
            .map(function(childView) {
                return childView.rect;
            })
            .forEach(function(childViewRect) {
                expandRect(rect.inner, Object.assign({}, childViewRect.inner));
                expandRect(rect.outer, Object.assign({}, childViewRect.outer));
            });

        // calculate inner width and height
        calculateRectSize(rect.inner);

        // append additional margin (top and left margins are included in top and left automatically)
        rect.outer.bottom += rect.element.marginBottom;
        rect.outer.right += rect.element.marginRight;

        // calculate outer width and height
        calculateRectSize(rect.outer);

        return rect;
    };

    var expandRect = function expandRect(parent, child) {
        // adjust for parent offset
        child.top += parent.top;
        child.right += parent.left;
        child.bottom += parent.top;
        child.left += parent.left;

        if (child.bottom > parent.bottom) {
            parent.bottom = child.bottom;
        }

        if (child.right > parent.right) {
            parent.right = child.right;
        }
    };

    var calculateRectSize = function calculateRectSize(rect) {
        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
    };

    var isNumber = function isNumber(value) {
        return typeof value === 'number';
    };

    /**
     * Determines if position is at destination
     * @param position
     * @param destination
     * @param velocity
     * @param errorMargin
     * @returns {boolean}
     */
    var thereYet = function thereYet(position, destination, velocity) {
        var errorMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;
        return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;
    };

    /**
     * Spring animation
     */
    var spring =
        // default options
        function spring() // method definition
        {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref$stiffness = _ref.stiffness,
                stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,
                _ref$damping = _ref.damping,
                damping = _ref$damping === void 0 ? 0.75 : _ref$damping,
                _ref$mass = _ref.mass,
                mass = _ref$mass === void 0 ? 10 : _ref$mass;
            var target = null;
            var position = null;
            var velocity = 0;
            var resting = false;

            // updates spring state
            var interpolate = function interpolate(ts, skipToEndState) {
                // in rest, don't animate
                if (resting) return;

                // need at least a target or position to do springy things
                if (!(isNumber(target) && isNumber(position))) {
                    resting = true;
                    velocity = 0;
                    return;
                }

                // calculate spring force
                var f = -(position - target) * stiffness;

                // update velocity by adding force based on mass
                velocity += f / mass;

                // update position by adding velocity
                position += velocity;

                // slow down based on amount of damping
                velocity *= damping;

                // we've arrived if we're near target and our velocity is near zero
                if (thereYet(position, target, velocity) || skipToEndState) {
                    position = target;
                    velocity = 0;
                    resting = true;

                    // we done
                    api.onupdate(position);
                    api.oncomplete(position);
                } else {
                    // progress update
                    api.onupdate(position);
                }
            };

            /**
             * Set new target value
             * @param value
             */
            var setTarget = function setTarget(value) {
                // if currently has no position, set target and position to this value
                if (isNumber(value) && !isNumber(position)) {
                    position = value;
                }

                // next target value will not be animated to
                if (target === null) {
                    target = value;
                    position = value;
                }

                // let start moving to target
                target = value;

                // already at target
                if (position === target || typeof target === 'undefined') {
                    // now resting as target is current position, stop moving
                    resting = true;
                    velocity = 0;

                    // done!
                    api.onupdate(position);
                    api.oncomplete(position);

                    return;
                }

                resting = false;
            };

            // need 'api' to call onupdate callback
            var api = createObject({
                interpolate: interpolate,
                target: {
                    set: setTarget,
                    get: function get() {
                        return target;
                    },
                },

                resting: {
                    get: function get() {
                        return resting;
                    },
                },

                onupdate: function onupdate(value) {},
                oncomplete: function oncomplete(value) {},
            });

            return api;
        };

    var easeLinear = function easeLinear(t) {
        return t;
    };
    var easeInOutQuad = function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    };

    var tween =
        // default values
        function tween() // method definition
        {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref$duration = _ref.duration,
                duration = _ref$duration === void 0 ? 500 : _ref$duration,
                _ref$easing = _ref.easing,
                easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,
                _ref$delay = _ref.delay,
                delay = _ref$delay === void 0 ? 0 : _ref$delay;
            var start = null;
            var t;
            var p;
            var resting = true;
            var reverse = false;
            var target = null;

            var interpolate = function interpolate(ts, skipToEndState) {
                if (resting || target === null) return;

                if (start === null) {
                    start = ts;
                }

                if (ts - start < delay) return;

                t = ts - start - delay;

                if (t >= duration || skipToEndState) {
                    t = 1;
                    p = reverse ? 0 : 1;
                    api.onupdate(p * target);
                    api.oncomplete(p * target);
                    resting = true;
                } else {
                    p = t / duration;
                    api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);
                }
            };

            // need 'api' to call onupdate callback
            var api = createObject({
                interpolate: interpolate,
                target: {
                    get: function get() {
                        return reverse ? 0 : target;
                    },
                    set: function set(value) {
                        // is initial value
                        if (target === null) {
                            target = value;
                            api.onupdate(value);
                            api.oncomplete(value);
                            return;
                        }

                        // want to tween to a smaller value and have a current value
                        if (value < target) {
                            target = 1;
                            reverse = true;
                        } else {
                            // not tweening to a smaller value
                            reverse = false;
                            target = value;
                        }

                        // let's go!
                        resting = false;
                        start = null;
                    },
                },

                resting: {
                    get: function get() {
                        return resting;
                    },
                },

                onupdate: function onupdate(value) {},
                oncomplete: function oncomplete(value) {},
            });

            return api;
        };

    var animator = {
        spring: spring,
        tween: tween,
    };

    /*
                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };
                       { translation: { type: 'spring', ... }, ... }
                       { translation: { x: { type: 'spring', ... } } }
                      */
    var createAnimator = function createAnimator(definition, category, property) {
        // default is single definition
        // we check if transform is set, if so, we check if property is set
        var def =
            definition[category] && typeof definition[category][property] === 'object'
                ? definition[category][property]
                : definition[category] || definition;

        var type = typeof def === 'string' ? def : def.type;
        var props = typeof def === 'object' ? Object.assign({}, def) : {};

        return animator[type] ? animator[type](props) : null;
    };

    var addGetSet = function addGetSet(keys, obj, props) {
        var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        obj = Array.isArray(obj) ? obj : [obj];
        obj.forEach(function(o) {
            keys.forEach(function(key) {
                var name = key;
                var getter = function getter() {
                    return props[key];
                };
                var setter = function setter(value) {
                    return (props[key] = value);
                };

                if (typeof key === 'object') {
                    name = key.key;
                    getter = key.getter || getter;
                    setter = key.setter || setter;
                }

                if (o[name] && !overwrite) {
                    return;
                }

                o[name] = {
                    get: getter,
                    set: setter,
                };
            });
        });
    };

    // add to state,
    // add getters and setters to internal and external api (if not set)
    // setup animators

    var animations = function animations(_ref) {
        var mixinConfig = _ref.mixinConfig,
            viewProps = _ref.viewProps,
            viewInternalAPI = _ref.viewInternalAPI,
            viewExternalAPI = _ref.viewExternalAPI;
        // initial properties
        var initialProps = Object.assign({}, viewProps);

        // list of all active animations
        var animations = [];

        // setup animators
        forin(mixinConfig, function(property, animation) {
            var animator = createAnimator(animation);
            if (!animator) {
                return;
            }

            // when the animator updates, update the view state value
            animator.onupdate = function(value) {
                viewProps[property] = value;
            };

            // set animator target
            animator.target = initialProps[property];

            // when value is set, set the animator target value
            var prop = {
                key: property,
                setter: function setter(value) {
                    // if already at target, we done!
                    if (animator.target === value) {
                        return;
                    }

                    animator.target = value;
                },
                getter: function getter() {
                    return viewProps[property];
                },
            };

            // add getters and setters
            addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);

            // add it to the list for easy updating from the _write method
            animations.push(animator);
        });

        // expose internal write api
        return {
            write: function write(ts) {
                var skipToEndState = document.hidden;
                var resting = true;
                animations.forEach(function(animation) {
                    if (!animation.resting) resting = false;
                    animation.interpolate(ts, skipToEndState);
                });
                return resting;
            },
            destroy: function destroy() {},
        };
    };

    var addEvent = function addEvent(element) {
        return function(type, fn) {
            element.addEventListener(type, fn);
        };
    };

    var removeEvent = function removeEvent(element) {
        return function(type, fn) {
            element.removeEventListener(type, fn);
        };
    };

    // mixin
    var listeners = function listeners(_ref) {
        var mixinConfig = _ref.mixinConfig,
            viewProps = _ref.viewProps,
            viewInternalAPI = _ref.viewInternalAPI,
            viewExternalAPI = _ref.viewExternalAPI,
            viewState = _ref.viewState,
            view = _ref.view;
        var events = [];

        var add = addEvent(view.element);
        var remove = removeEvent(view.element);

        viewExternalAPI.on = function(type, fn) {
            events.push({
                type: type,
                fn: fn,
            });

            add(type, fn);
        };

        viewExternalAPI.off = function(type, fn) {
            events.splice(
                events.findIndex(function(event) {
                    return event.type === type && event.fn === fn;
                }),
                1
            );

            remove(type, fn);
        };

        return {
            write: function write() {
                // not busy
                return true;
            },
            destroy: function destroy() {
                events.forEach(function(event) {
                    remove(event.type, event.fn);
                });
            },
        };
    };

    // add to external api and link to props

    var apis = function apis(_ref) {
        var mixinConfig = _ref.mixinConfig,
            viewProps = _ref.viewProps,
            viewExternalAPI = _ref.viewExternalAPI;
        addGetSet(mixinConfig, viewExternalAPI, viewProps);
    };

    var isDefined = function isDefined(value) {
        return value != null;
    };

    // add to state,
    // add getters and setters to internal and external api (if not set)
    // set initial state based on props in viewProps
    // apply as transforms each frame

    var defaults = {
        opacity: 1,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        rotateX: 0,
        rotateY: 0,
        rotateZ: 0,
        originX: 0,
        originY: 0,
    };

    var styles = function styles(_ref) {
        var mixinConfig = _ref.mixinConfig,
            viewProps = _ref.viewProps,
            viewInternalAPI = _ref.viewInternalAPI,
            viewExternalAPI = _ref.viewExternalAPI,
            view = _ref.view;
        // initial props
        var initialProps = Object.assign({}, viewProps);

        // current props
        var currentProps = {};

        // we will add those properties to the external API and link them to the viewState
        addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);

        // override rect on internal and external rect getter so it takes in account transforms
        var getOffset = function getOffset() {
            return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];
        };

        var getScale = function getScale() {
            return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];
        };
        var getRect = function getRect() {
            return view.rect
                ? getViewRect(view.rect, view.childViews, getOffset(), getScale())
                : null;
        };
        viewInternalAPI.rect = { get: getRect };
        viewExternalAPI.rect = { get: getRect };

        // apply view props
        mixinConfig.forEach(function(key) {
            viewProps[key] =
                typeof initialProps[key] === 'undefined' ? defaults[key] : initialProps[key];
        });

        // expose api
        return {
            write: function write() {
                // see if props have changed
                if (!propsHaveChanged(currentProps, viewProps)) {
                    return;
                }

                // moves element to correct position on screen
                applyStyles(view.element, viewProps);

                // store new transforms
                Object.assign(currentProps, Object.assign({}, viewProps));

                // no longer busy
                return true;
            },
            destroy: function destroy() {},
        };
    };

    var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {
        // different amount of keys
        if (Object.keys(currentProps).length !== Object.keys(newProps).length) {
            return true;
        }

        // lets analyze the individual props
        for (var prop in newProps) {
            if (newProps[prop] !== currentProps[prop]) {
                return true;
            }
        }

        return false;
    };

    var applyStyles = function applyStyles(element, _ref2) {
        var opacity = _ref2.opacity,
            perspective = _ref2.perspective,
            translateX = _ref2.translateX,
            translateY = _ref2.translateY,
            scaleX = _ref2.scaleX,
            scaleY = _ref2.scaleY,
            rotateX = _ref2.rotateX,
            rotateY = _ref2.rotateY,
            rotateZ = _ref2.rotateZ,
            originX = _ref2.originX,
            originY = _ref2.originY,
            width = _ref2.width,
            height = _ref2.height;

        var transforms = '';
        var styles = '';

        // handle transform origin
        if (isDefined(originX) || isDefined(originY)) {
            styles += 'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';
        }

        // transform order is relevant
        // 0. perspective
        if (isDefined(perspective)) {
            transforms += 'perspective(' + perspective + 'px) ';
        }

        // 1. translate
        if (isDefined(translateX) || isDefined(translateY)) {
            transforms +=
                'translate3d(' + (translateX || 0) + 'px, ' + (translateY || 0) + 'px, 0) ';
        }

        // 2. scale
        if (isDefined(scaleX) || isDefined(scaleY)) {
            transforms +=
                'scale3d(' +
                (isDefined(scaleX) ? scaleX : 1) +
                ', ' +
                (isDefined(scaleY) ? scaleY : 1) +
                ', 1) ';
        }

        // 3. rotate
        if (isDefined(rotateZ)) {
            transforms += 'rotateZ(' + rotateZ + 'rad) ';
        }

        if (isDefined(rotateX)) {
            transforms += 'rotateX(' + rotateX + 'rad) ';
        }

        if (isDefined(rotateY)) {
            transforms += 'rotateY(' + rotateY + 'rad) ';
        }

        // add transforms
        if (transforms.length) {
            styles += 'transform:' + transforms + ';';
        }

        // add opacity
        if (isDefined(opacity)) {
            styles += 'opacity:' + opacity + ';';

            // if we reach zero, we make the element inaccessible
            if (opacity === 0) {
                styles += 'visibility:hidden;';
            }

            // if we're below 100% opacity this element can't be clicked
            if (opacity < 1) {
                styles += 'pointer-events:none;';
            }
        }

        // add height
        if (isDefined(height)) {
            styles += 'height:' + height + 'px;';
        }

        // add width
        if (isDefined(width)) {
            styles += 'width:' + width + 'px;';
        }

        // apply styles
        var elementCurrentStyle = element.elementCurrentStyle || '';

        // if new styles does not match current styles, lets update!
        if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {
            element.style.cssText = styles;
            // store current styles so we can compare them to new styles later on
            // _not_ getting the style value is faster
            element.elementCurrentStyle = styles;
        }
    };

    var Mixins = {
        styles: styles,
        listeners: listeners,
        animations: animations,
        apis: apis,
    };

    var updateRect = function updateRect() {
        var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (!element.layoutCalculated) {
            rect.paddingTop = parseInt(style.paddingTop, 10) || 0;
            rect.marginTop = parseInt(style.marginTop, 10) || 0;
            rect.marginRight = parseInt(style.marginRight, 10) || 0;
            rect.marginBottom = parseInt(style.marginBottom, 10) || 0;
            rect.marginLeft = parseInt(style.marginLeft, 10) || 0;
            element.layoutCalculated = true;
        }

        rect.left = element.offsetLeft || 0;
        rect.top = element.offsetTop || 0;
        rect.width = element.offsetWidth || 0;
        rect.height = element.offsetHeight || 0;

        rect.right = rect.left + rect.width;
        rect.bottom = rect.top + rect.height;

        rect.scrollTop = element.scrollTop;

        rect.hidden = element.offsetParent === null;

        return rect;
    };

    var createView =
        // default view definition
        function createView() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref$tag = _ref.tag,
                tag = _ref$tag === void 0 ? 'div' : _ref$tag,
                _ref$name = _ref.name,
                name = _ref$name === void 0 ? null : _ref$name,
                _ref$attributes = _ref.attributes,
                attributes = _ref$attributes === void 0 ? {} : _ref$attributes,
                _ref$read = _ref.read,
                read = _ref$read === void 0 ? function() {} : _ref$read,
                _ref$write = _ref.write,
                write = _ref$write === void 0 ? function() {} : _ref$write,
                _ref$create = _ref.create,
                create = _ref$create === void 0 ? function() {} : _ref$create,
                _ref$destroy = _ref.destroy,
                destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,
                _ref$filterFrameActio = _ref.filterFrameActionsForChild,
                filterFrameActionsForChild =
                    _ref$filterFrameActio === void 0
                        ? function(child, actions) {
                              return actions;
                          }
                        : _ref$filterFrameActio,
                _ref$didCreateView = _ref.didCreateView,
                didCreateView = _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,
                _ref$didWriteView = _ref.didWriteView,
                didWriteView = _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,
                _ref$ignoreRect = _ref.ignoreRect,
                ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,
                _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,
                ignoreRectUpdate = _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,
                _ref$mixins = _ref.mixins,
                mixins = _ref$mixins === void 0 ? [] : _ref$mixins;
            return function(
                // each view requires reference to store
                store
            ) {
                var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                // root element should not be changed
                var element = createElement(tag, 'filepond--' + name, attributes);

                // style reference should also not be changed
                var style = window.getComputedStyle(element, null);

                // element rectangle
                var rect = updateRect();
                var frameRect = null;

                // rest state
                var isResting = false;

                // pretty self explanatory
                var childViews = [];

                // loaded mixins
                var activeMixins = [];

                // references to created children
                var ref = {};

                // state used for each instance
                var state = {};

                // list of writers that will be called to update this view
                var writers = [
                    write, // default writer
                ];

                var readers = [
                    read, // default reader
                ];

                var destroyers = [
                    destroy, // default destroy
                ];

                // core view methods
                var getElement = function getElement() {
                    return element;
                };
                var getChildViews = function getChildViews() {
                    return childViews.concat();
                };
                var getReference = function getReference() {
                    return ref;
                };
                var createChildView = function createChildView(store) {
                    return function(view, props) {
                        return view(store, props);
                    };
                };
                var getRect = function getRect() {
                    if (frameRect) {
                        return frameRect;
                    }
                    frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);
                    return frameRect;
                };
                var getStyle = function getStyle() {
                    return style;
                };

                /**
                 * Read data from DOM
                 * @private
                 */
                var _read = function _read() {
                    frameRect = null;

                    // read child views
                    childViews.forEach(function(child) {
                        return child._read();
                    });

                    var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);
                    if (shouldUpdate) {
                        updateRect(rect, element, style);
                    }

                    // readers
                    var api = { root: internalAPI, props: props, rect: rect };
                    readers.forEach(function(reader) {
                        return reader(api);
                    });
                };

                /**
                 * Write data to DOM
                 * @private
                 */
                var _write = function _write(ts, frameActions, shouldOptimize) {
                    // if no actions, we assume that the view is resting
                    var resting = frameActions.length === 0;

                    // writers
                    writers.forEach(function(writer) {
                        var writerResting = writer({
                            props: props,
                            root: internalAPI,
                            actions: frameActions,
                            timestamp: ts,
                            shouldOptimize: shouldOptimize,
                        });

                        if (writerResting === false) {
                            resting = false;
                        }
                    });

                    // run mixins
                    activeMixins.forEach(function(mixin) {
                        // if one of the mixins is still busy after write operation, we are not resting
                        var mixinResting = mixin.write(ts);
                        if (mixinResting === false) {
                            resting = false;
                        }
                    });

                    // updates child views that are currently attached to the DOM
                    childViews
                        .filter(function(child) {
                            return !!child.element.parentNode;
                        })
                        .forEach(function(child) {
                            // if a child view is not resting, we are not resting
                            var childResting = child._write(
                                ts,
                                filterFrameActionsForChild(child, frameActions),
                                shouldOptimize
                            );

                            if (!childResting) {
                                resting = false;
                            }
                        });

                    // append new elements to DOM and update those
                    childViews
                        //.filter(child => !child.element.parentNode)
                        .forEach(function(child, index) {
                            // skip
                            if (child.element.parentNode) {
                                return;
                            }

                            // append to DOM
                            internalAPI.appendChild(child.element, index);

                            // call read (need to know the size of these elements)
                            child._read();

                            // re-call write
                            child._write(
                                ts,
                                filterFrameActionsForChild(child, frameActions),
                                shouldOptimize
                            );

                            // we just added somthing to the dom, no rest
                            resting = false;
                        });

                    // update resting state
                    isResting = resting;

                    didWriteView({
                        props: props,
                        root: internalAPI,
                        actions: frameActions,
                        timestamp: ts,
                    });

                    // let parent know if we are resting
                    return resting;
                };

                var _destroy = function _destroy() {
                    activeMixins.forEach(function(mixin) {
                        return mixin.destroy();
                    });
                    destroyers.forEach(function(destroyer) {
                        destroyer({ root: internalAPI, props: props });
                    });
                    childViews.forEach(function(child) {
                        return child._destroy();
                    });
                };

                // sharedAPI
                var sharedAPIDefinition = {
                    element: {
                        get: getElement,
                    },

                    style: {
                        get: getStyle,
                    },

                    childViews: {
                        get: getChildViews,
                    },
                };

                // private API definition
                var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {
                    rect: {
                        get: getRect,
                    },

                    // access to custom children references
                    ref: {
                        get: getReference,
                    },

                    // dom modifiers
                    is: function is(needle) {
                        return name === needle;
                    },
                    appendChild: appendChild(element),
                    createChildView: createChildView(store),
                    linkView: function linkView(view) {
                        childViews.push(view);
                        return view;
                    },
                    unlinkView: function unlinkView(view) {
                        childViews.splice(childViews.indexOf(view), 1);
                    },
                    appendChildView: appendChildView(element, childViews),
                    removeChildView: removeChildView(element, childViews),
                    registerWriter: function registerWriter(writer) {
                        return writers.push(writer);
                    },
                    registerReader: function registerReader(reader) {
                        return readers.push(reader);
                    },
                    registerDestroyer: function registerDestroyer(destroyer) {
                        return destroyers.push(destroyer);
                    },
                    invalidateLayout: function invalidateLayout() {
                        return (element.layoutCalculated = false);
                    },

                    // access to data store
                    dispatch: store.dispatch,
                    query: store.query,
                });

                // public view API methods
                var externalAPIDefinition = {
                    element: {
                        get: getElement,
                    },

                    childViews: {
                        get: getChildViews,
                    },

                    rect: {
                        get: getRect,
                    },

                    resting: {
                        get: function get() {
                            return isResting;
                        },
                    },

                    isRectIgnored: function isRectIgnored() {
                        return ignoreRect;
                    },
                    _read: _read,
                    _write: _write,
                    _destroy: _destroy,
                };

                // mixin API methods
                var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {
                    rect: {
                        get: function get() {
                            return rect;
                        },
                    },
                });

                // add mixin functionality
                Object.keys(mixins)
                    .sort(function(a, b) {
                        // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)
                        if (a === 'styles') {
                            return 1;
                        } else if (b === 'styles') {
                            return -1;
                        }
                        return 0;
                    })
                    .forEach(function(key) {
                        var mixinAPI = Mixins[key]({
                            mixinConfig: mixins[key],
                            viewProps: props,
                            viewState: state,
                            viewInternalAPI: internalAPIDefinition,
                            viewExternalAPI: externalAPIDefinition,
                            view: createObject(mixinAPIDefinition),
                        });

                        if (mixinAPI) {
                            activeMixins.push(mixinAPI);
                        }
                    });

                // construct private api
                var internalAPI = createObject(internalAPIDefinition);

                // create the view
                create({
                    root: internalAPI,
                    props: props,
                });

                // append created child views to root node
                var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order
                childViews.forEach(function(child, index) {
                    internalAPI.appendChild(child.element, childCount + index);
                });

                // call did create
                didCreateView(internalAPI);

                // expose public api
                return createObject(externalAPIDefinition);
            };
        };

    var createPainter = function createPainter(read, write) {
        var fps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;

        var name = '__framePainter';

        // set global painter
        if (window[name]) {
            window[name].readers.push(read);
            window[name].writers.push(write);
            return;
        }

        window[name] = {
            readers: [read],
            writers: [write],
        };

        var painter = window[name];

        var interval = 1000 / fps;
        var last = null;
        var id = null;
        var requestTick = null;
        var cancelTick = null;

        var setTimerType = function setTimerType() {
            if (document.hidden) {
                requestTick = function requestTick() {
                    return window.setTimeout(function() {
                        return tick(performance.now());
                    }, interval);
                };
                cancelTick = function cancelTick() {
                    return window.clearTimeout(id);
                };
            } else {
                requestTick = function requestTick() {
                    return window.requestAnimationFrame(tick);
                };
                cancelTick = function cancelTick() {
                    return window.cancelAnimationFrame(id);
                };
            }
        };

        document.addEventListener('visibilitychange', function() {
            if (cancelTick) cancelTick();
            setTimerType();
            tick(performance.now());
        });

        var tick = function tick(ts) {
            // queue next tick
            id = requestTick(tick);

            // limit fps
            if (!last) {
                last = ts;
            }

            var delta = ts - last;

            if (delta <= interval) {
                // skip frame
                return;
            }

            // align next frame
            last = ts - (delta % interval);

            // update view
            painter.readers.forEach(function(read) {
                return read();
            });
            painter.writers.forEach(function(write) {
                return write(ts);
            });
        };

        setTimerType();
        tick(performance.now());

        return {
            pause: function pause() {
                cancelTick(id);
            },
        };
    };

    var createRoute = function createRoute(routes, fn) {
        return function(_ref) {
            var root = _ref.root,
                props = _ref.props,
                _ref$actions = _ref.actions,
                actions = _ref$actions === void 0 ? [] : _ref$actions,
                timestamp = _ref.timestamp,
                shouldOptimize = _ref.shouldOptimize;
            actions
                .filter(function(action) {
                    return routes[action.type];
                })
                .forEach(function(action) {
                    return routes[action.type]({
                        root: root,
                        props: props,
                        action: action.data,
                        timestamp: timestamp,
                        shouldOptimize: shouldOptimize,
                    });
                });

            if (fn) {
                fn({
                    root: root,
                    props: props,
                    actions: actions,
                    timestamp: timestamp,
                    shouldOptimize: shouldOptimize,
                });
            }
        };
    };

    var insertBefore = function insertBefore(newNode, referenceNode) {
        return referenceNode.parentNode.insertBefore(newNode, referenceNode);
    };

    var insertAfter = function insertAfter(newNode, referenceNode) {
        return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    };

    var isArray = function isArray(value) {
        return Array.isArray(value);
    };

    var isEmpty = function isEmpty(value) {
        return value == null;
    };

    var trim = function trim(str) {
        return str.trim();
    };

    var toString = function toString(value) {
        return '' + value;
    };

    var toArray = function toArray(value) {
        var splitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
        if (isEmpty(value)) {
            return [];
        }
        if (isArray(value)) {
            return value;
        }
        return toString(value)
            .split(splitter)
            .map(trim)
            .filter(function(str) {
                return str.length;
            });
    };

    var isBoolean = function isBoolean(value) {
        return typeof value === 'boolean';
    };

    var toBoolean = function toBoolean(value) {
        return isBoolean(value) ? value : value === 'true';
    };

    var isString = function isString(value) {
        return typeof value === 'string';
    };

    var toNumber = function toNumber(value) {
        return isNumber(value)
            ? value
            : isString(value)
            ? toString(value).replace(/[a-z]+/gi, '')
            : 0;
    };

    var toInt = function toInt(value) {
        return parseInt(toNumber(value), 10);
    };

    var toFloat = function toFloat(value) {
        return parseFloat(toNumber(value));
    };

    var isInt = function isInt(value) {
        return isNumber(value) && isFinite(value) && Math.floor(value) === value;
    };

    var toBytes = function toBytes(value) {
        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        // is in bytes
        if (isInt(value)) {
            return value;
        }

        // is natural file size
        var naturalFileSize = toString(value).trim();

        // if is value in megabytes
        if (/MB$/i.test(naturalFileSize)) {
            naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();
            return toInt(naturalFileSize) * base * base;
        }

        // if is value in kilobytes
        if (/KB/i.test(naturalFileSize)) {
            naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();
            return toInt(naturalFileSize) * base;
        }

        return toInt(naturalFileSize);
    };

    var isFunction = function isFunction(value) {
        return typeof value === 'function';
    };

    var toFunctionReference = function toFunctionReference(string) {
        var ref = self;
        var levels = string.split('.');
        var level = null;
        while ((level = levels.shift())) {
            ref = ref[level];
            if (!ref) {
                return null;
            }
        }
        return ref;
    };

    var methods = {
        process: 'POST',
        patch: 'PATCH',
        revert: 'DELETE',
        fetch: 'GET',
        restore: 'GET',
        load: 'GET',
    };

    var createServerAPI = function createServerAPI(outline) {
        var api = {};

        api.url = isString(outline) ? outline : outline.url || '';
        api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;
        api.headers = outline.headers ? outline.headers : {};

        forin(methods, function(key) {
            api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);
        });

        // remove process if no url or process on outline
        api.process = outline.process || isString(outline) || outline.url ? api.process : null;

        // special treatment for remove
        api.remove = outline.remove || null;

        // remove generic headers from api object
        delete api.headers;

        return api;
    };

    var createAction = function createAction(name, outline, method, timeout, headers) {
        // is explicitely set to null so disable
        if (outline === null) {
            return null;
        }

        // if is custom function, done! Dev handles everything.
        if (typeof outline === 'function') {
            return outline;
        }

        // build action object
        var action = {
            url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',
            method: method,
            headers: headers,
            withCredentials: false,
            timeout: timeout,
            onload: null,
            ondata: null,
            onerror: null,
        };

        // is a single url
        if (isString(outline)) {
            action.url = outline;
            return action;
        }

        // overwrite
        Object.assign(action, outline);

        // see if should reformat headers;
        if (isString(action.headers)) {
            var parts = action.headers.split(/:(.+)/);
            action.headers = {
                header: parts[0],
                value: parts[1],
            };
        }

        // if is bool withCredentials
        action.withCredentials = toBoolean(action.withCredentials);

        return action;
    };

    var toServerAPI = function toServerAPI(value) {
        return createServerAPI(value);
    };

    var isNull = function isNull(value) {
        return value === null;
    };

    var isObject = function isObject(value) {
        return typeof value === 'object' && value !== null;
    };

    var isAPI = function isAPI(value) {
        return (
            isObject(value) &&
            isString(value.url) &&
            isObject(value.process) &&
            isObject(value.revert) &&
            isObject(value.restore) &&
            isObject(value.fetch)
        );
    };

    var getType = function getType(value) {
        if (isArray(value)) {
            return 'array';
        }

        if (isNull(value)) {
            return 'null';
        }

        if (isInt(value)) {
            return 'int';
        }

        if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {
            return 'bytes';
        }

        if (isAPI(value)) {
            return 'api';
        }

        return typeof value;
    };

    var replaceSingleQuotes = function replaceSingleQuotes(str) {
        return str
            .replace(/{\s*'/g, '{"')
            .replace(/'\s*}/g, '"}')
            .replace(/'\s*:/g, '":')
            .replace(/:\s*'/g, ':"')
            .replace(/,\s*'/g, ',"')
            .replace(/'\s*,/g, '",');
    };

    var conversionTable = {
        array: toArray,
        boolean: toBoolean,
        int: function int(value) {
            return getType(value) === 'bytes' ? toBytes(value) : toInt(value);
        },
        number: toFloat,
        float: toFloat,
        bytes: toBytes,
        string: function string(value) {
            return isFunction(value) ? value : toString(value);
        },
        function: function _function(value) {
            return toFunctionReference(value);
        },
        serverapi: toServerAPI,
        object: function object(value) {
            try {
                return JSON.parse(replaceSingleQuotes(value));
            } catch (e) {
                return null;
            }
        },
    };

    var convertTo = function convertTo(value, type) {
        return conversionTable[type](value);
    };

    var getValueByType = function getValueByType(newValue, defaultValue, valueType) {
        // can always assign default value
        if (newValue === defaultValue) {
            return newValue;
        }

        // get the type of the new value
        var newValueType = getType(newValue);

        // is valid type?
        if (newValueType !== valueType) {
            // is string input, let's attempt to convert
            var convertedValue = convertTo(newValue, valueType);

            // what is the type now
            newValueType = getType(convertedValue);

            // no valid conversions found
            if (convertedValue === null) {
                throw 'Trying to assign value with incorrect type to "' +
                    option +
                    '", allowed type: "' +
                    valueType +
                    '"';
            } else {
                newValue = convertedValue;
            }
        }

        // assign new value
        return newValue;
    };

    var createOption = function createOption(defaultValue, valueType) {
        var currentValue = defaultValue;
        return {
            enumerable: true,
            get: function get() {
                return currentValue;
            },
            set: function set(newValue) {
                currentValue = getValueByType(newValue, defaultValue, valueType);
            },
        };
    };

    var createOptions = function createOptions(options) {
        var obj = {};
        forin(options, function(prop) {
            var optionDefinition = options[prop];
            obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);
        });
        return createObject(obj);
    };

    var createInitialState = function createInitialState(options) {
        return {
            // model
            items: [],

            // timeout used for calling update items
            listUpdateTimeout: null,

            // timeout used for stacking metadata updates
            itemUpdateTimeout: null,

            // queue of items waiting to be processed
            processingQueue: [],

            // options
            options: createOptions(options),
        };
    };

    var fromCamels = function fromCamels(string) {
        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';
        return string
            .split(/(?=[A-Z])/)
            .map(function(part) {
                return part.toLowerCase();
            })
            .join(separator);
    };

    var createOptionAPI = function createOptionAPI(store, options) {
        var obj = {};
        forin(options, function(key) {
            obj[key] = {
                get: function get() {
                    return store.getState().options[key];
                },
                set: function set(value) {
                    store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {
                        value: value,
                    });
                },
            };
        });
        return obj;
    };

    var createOptionActions = function createOptionActions(options) {
        return function(dispatch, query, state) {
            var obj = {};
            forin(options, function(key) {
                var name = fromCamels(key, '_').toUpperCase();

                obj['SET_' + name] = function(action) {
                    try {
                        state.options[key] = action.value;
                    } catch (e) {} // nope, failed

                    // we successfully set the value of this option
                    dispatch('DID_SET_' + name, { value: state.options[key] });
                };
            });
            return obj;
        };
    };

    var createOptionQueries = function createOptionQueries(options) {
        return function(state) {
            var obj = {};
            forin(options, function(key) {
                obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {
                    return state.options[key];
                };
            });
            return obj;
        };
    };

    var InteractionMethod = {
        API: 1,
        DROP: 2,
        BROWSE: 3,
        PASTE: 4,
        NONE: 5,
    };

    var getUniqueId = function getUniqueId() {
        return Math.random()
            .toString(36)
            .substr(2, 9);
    };

    function _typeof(obj) {
        if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
            _typeof = function(obj) {
                return typeof obj;
            };
        } else {
            _typeof = function(obj) {
                return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
            };
        }

        return _typeof(obj);
    }

    var REACT_ELEMENT_TYPE;

    function _jsx(type, props, key, children) {
        if (!REACT_ELEMENT_TYPE) {
            REACT_ELEMENT_TYPE =
                (typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element')) ||
                0xeac7;
        }

        var defaultProps = type && type.defaultProps;
        var childrenLength = arguments.length - 3;

        if (!props && childrenLength !== 0) {
            props = {
                children: void 0,
            };
        }

        if (props && defaultProps) {
            for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                }
            }
        } else if (!props) {
            props = defaultProps || {};
        }

        if (childrenLength === 1) {
            props.children = children;
        } else if (childrenLength > 1) {
            var childArray = new Array(childrenLength);

            for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 3];
            }

            props.children = childArray;
        }

        return {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key === undefined ? null : '' + key,
            ref: null,
            props: props,
            _owner: null,
        };
    }

    function _asyncIterator(iterable) {
        var method;

        if (typeof Symbol !== 'undefined') {
            if (Symbol.asyncIterator) {
                method = iterable[Symbol.asyncIterator];
                if (method != null) return method.call(iterable);
            }

            if (Symbol.iterator) {
                method = iterable[Symbol.iterator];
                if (method != null) return method.call(iterable);
            }
        }

        throw new TypeError('Object is not async iterable');
    }

    function _AwaitValue(value) {
        this.wrapped = value;
    }

    function _AsyncGenerator(gen) {
        var front, back;

        function send(key, arg) {
            return new Promise(function(resolve, reject) {
                var request = {
                    key: key,
                    arg: arg,
                    resolve: resolve,
                    reject: reject,
                    next: null,
                };

                if (back) {
                    back = back.next = request;
                } else {
                    front = back = request;
                    resume(key, arg);
                }
            });
        }

        function resume(key, arg) {
            try {
                var result = gen[key](arg);
                var value = result.value;
                var wrappedAwait = value instanceof _AwaitValue;
                Promise.resolve(wrappedAwait ? value.wrapped : value).then(
                    function(arg) {
                        if (wrappedAwait) {
                            resume('next', arg);
                            return;
                        }

                        settle(result.done ? 'return' : 'normal', arg);
                    },
                    function(err) {
                        resume('throw', err);
                    }
                );
            } catch (err) {
                settle('throw', err);
            }
        }

        function settle(type, value) {
            switch (type) {
                case 'return':
                    front.resolve({
                        value: value,
                        done: true,
                    });
                    break;

                case 'throw':
                    front.reject(value);
                    break;

                default:
                    front.resolve({
                        value: value,
                        done: false,
                    });
                    break;
            }

            front = front.next;

            if (front) {
                resume(front.key, front.arg);
            } else {
                back = null;
            }
        }

        this._invoke = send;

        if (typeof gen.return !== 'function') {
            this.return = undefined;
        }
    }

    if (typeof Symbol === 'function' && Symbol.asyncIterator) {
        _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
            return this;
        };
    }

    _AsyncGenerator.prototype.next = function(arg) {
        return this._invoke('next', arg);
    };

    _AsyncGenerator.prototype.throw = function(arg) {
        return this._invoke('throw', arg);
    };

    _AsyncGenerator.prototype.return = function(arg) {
        return this._invoke('return', arg);
    };

    function _wrapAsyncGenerator(fn) {
        return function() {
            return new _AsyncGenerator(fn.apply(this, arguments));
        };
    }

    function _awaitAsyncGenerator(value) {
        return new _AwaitValue(value);
    }

    function _asyncGeneratorDelegate(inner, awaitWrap) {
        var iter = {},
            waiting = false;

        function pump(key, value) {
            waiting = true;
            value = new Promise(function(resolve) {
                resolve(inner[key](value));
            });
            return {
                done: false,
                value: awaitWrap(value),
            };
        }

        if (typeof Symbol === 'function' && Symbol.iterator) {
            iter[Symbol.iterator] = function() {
                return this;
            };
        }

        iter.next = function(value) {
            if (waiting) {
                waiting = false;
                return value;
            }

            return pump('next', value);
        };

        if (typeof inner.throw === 'function') {
            iter.throw = function(value) {
                if (waiting) {
                    waiting = false;
                    throw value;
                }

                return pump('throw', value);
            };
        }

        if (typeof inner.return === 'function') {
            iter.return = function(value) {
                return pump('return', value);
            };
        }

        return iter;
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
            var info = gen[key](arg);
            var value = info.value;
        } catch (error) {
            reject(error);
            return;
        }

        if (info.done) {
            resolve(value);
        } else {
            Promise.resolve(value).then(_next, _throw);
        }
    }

    function _asyncToGenerator(fn) {
        return function() {
            var self = this,
                args = arguments;
            return new Promise(function(resolve, reject) {
                var gen = fn.apply(self, args);

                function _next(value) {
                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
                }

                function _throw(err) {
                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
                }

                _next(undefined);
            });
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
    }

    function _defineEnumerableProperties(obj, descs) {
        for (var key in descs) {
            var desc = descs[key];
            desc.configurable = desc.enumerable = true;
            if ('value' in desc) desc.writable = true;
            Object.defineProperty(obj, key, desc);
        }

        if (Object.getOwnPropertySymbols) {
            var objectSymbols = Object.getOwnPropertySymbols(descs);

            for (var i = 0; i < objectSymbols.length; i++) {
                var sym = objectSymbols[i];
                var desc = descs[sym];
                desc.configurable = desc.enumerable = true;
                if ('value' in desc) desc.writable = true;
                Object.defineProperty(obj, sym, desc);
            }
        }

        return obj;
    }

    function _defaults(obj, defaults) {
        var keys = Object.getOwnPropertyNames(defaults);

        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = Object.getOwnPropertyDescriptor(defaults, key);

            if (value && value.configurable && obj[key] === undefined) {
                Object.defineProperty(obj, key, value);
            }
        }

        return obj;
    }

    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
            });
        } else {
            obj[key] = value;
        }

        return obj;
    }

    function _extends() {
        _extends =
            Object.assign ||
            function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

        return _extends.apply(this, arguments);
    }

    function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            var ownKeys = Object.keys(source);

            if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(
                    Object.getOwnPropertySymbols(source).filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                    })
                );
            }

            ownKeys.forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        }

        return target;
    }

    function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
            keys.push.apply(keys, symbols);
        }

        return keys;
    }

    function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};

            if (i % 2) {
                ownKeys(source, true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                });
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
                ownKeys(source).forEach(function(key) {
                    Object.defineProperty(
                        target,
                        key,
                        Object.getOwnPropertyDescriptor(source, key)
                    );
                });
            }
        }

        return target;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function');
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: true,
                configurable: true,
            },
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
              };
        return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf =
            Object.setPrototypeOf ||
            function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
            };

        return _setPrototypeOf(o, p);
    }

    function isNativeReflectConstruct() {
        if (typeof Reflect === 'undefined' || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === 'function') return true;

        try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
            return true;
        } catch (e) {
            return false;
        }
    }

    function _construct(Parent, args, Class) {
        if (isNativeReflectConstruct()) {
            _construct = Reflect.construct;
        } else {
            _construct = function _construct(Parent, args, Class) {
                var a = [null];
                a.push.apply(a, args);
                var Constructor = Function.bind.apply(Parent, a);
                var instance = new Constructor();
                if (Class) _setPrototypeOf(instance, Class.prototype);
                return instance;
            };
        }

        return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf('[native code]') !== -1;
    }

    function _wrapNativeSuper(Class) {
        var _cache = typeof Map === 'function' ? new Map() : undefined;

        _wrapNativeSuper = function _wrapNativeSuper(Class) {
            if (Class === null || !_isNativeFunction(Class)) return Class;

            if (typeof Class !== 'function') {
                throw new TypeError('Super expression must either be null or a function');
            }

            if (typeof _cache !== 'undefined') {
                if (_cache.has(Class)) return _cache.get(Class);

                _cache.set(Class, Wrapper);
            }

            function Wrapper() {
                return _construct(Class, arguments, _getPrototypeOf(this).constructor);
            }

            Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                    value: Wrapper,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                },
            });
            return _setPrototypeOf(Wrapper, Class);
        };

        return _wrapNativeSuper(Class);
    }

    function _instanceof(left, right) {
        if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {
            return !!right[Symbol.hasInstance](left);
        } else {
            return left instanceof right;
        }
    }

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule
            ? obj
            : {
                  default: obj,
              };
    }

    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};

            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        var desc =
                            Object.defineProperty && Object.getOwnPropertyDescriptor
                                ? Object.getOwnPropertyDescriptor(obj, key)
                                : {};

                        if (desc.get || desc.set) {
                            Object.defineProperty(newObj, key, desc);
                        } else {
                            newObj[key] = obj[key];
                        }
                    }
                }
            }

            newObj.default = obj;
            return newObj;
        }
    }

    function _newArrowCheck(innerThis, boundThis) {
        if (innerThis !== boundThis) {
            throw new TypeError('Cannot instantiate an arrow function');
        }
    }

    function _objectDestructuringEmpty(obj) {
        if (obj == null) throw new TypeError('Cannot destructure undefined');
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null) return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;

        for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
        }

        return target;
    }

    function _objectWithoutProperties(source, excluded) {
        if (source == null) return {};

        var target = _objectWithoutPropertiesLoose(source, excluded);

        var key, i;

        if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

            for (i = 0; i < sourceSymbolKeys.length; i++) {
                key = sourceSymbolKeys[i];
                if (excluded.indexOf(key) >= 0) continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                target[key] = source[key];
            }
        }

        return target;
    }

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (typeof call === 'object' || typeof call === 'function')) {
            return call;
        }

        return _assertThisInitialized(self);
    }

    function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break;
        }

        return object;
    }

    function _get(target, property, receiver) {
        if (typeof Reflect !== 'undefined' && Reflect.get) {
            _get = Reflect.get;
        } else {
            _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);

                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);

                if (desc.get) {
                    return desc.get.call(receiver);
                }

                return desc.value;
            };
        }

        return _get(target, property, receiver || target);
    }

    function set(target, property, value, receiver) {
        if (typeof Reflect !== 'undefined' && Reflect.set) {
            set = Reflect.set;
        } else {
            set = function set(target, property, value, receiver) {
                var base = _superPropBase(target, property);

                var desc;

                if (base) {
                    desc = Object.getOwnPropertyDescriptor(base, property);

                    if (desc.set) {
                        desc.set.call(receiver, value);
                        return true;
                    } else if (!desc.writable) {
                        return false;
                    }
                }

                desc = Object.getOwnPropertyDescriptor(receiver, property);

                if (desc) {
                    if (!desc.writable) {
                        return false;
                    }

                    desc.value = value;
                    Object.defineProperty(receiver, property, desc);
                } else {
                    _defineProperty(receiver, property, value);
                }

                return true;
            };
        }

        return set(target, property, value, receiver);
    }

    function _set(target, property, value, receiver, isStrict) {
        var s = set(target, property, value, receiver || target);

        if (!s && isStrict) {
            throw new Error('failed to set property');
        }

        return value;
    }

    function _taggedTemplateLiteral(strings, raw) {
        if (!raw) {
            raw = strings.slice(0);
        }

        return Object.freeze(
            Object.defineProperties(strings, {
                raw: {
                    value: Object.freeze(raw),
                },
            })
        );
    }

    function _taggedTemplateLiteralLoose(strings, raw) {
        if (!raw) {
            raw = strings.slice(0);
        }

        strings.raw = raw;
        return strings;
    }

    function _temporalRef(val, name) {
        if (val === _temporalUndefined) {
            throw new ReferenceError(name + ' is not defined - temporal dead zone');
        } else {
            return val;
        }
    }

    function _readOnlyError(name) {
        throw new Error('"' + name + '" is read-only');
    }

    function _classNameTDZError(name) {
        throw new Error('Class "' + name + '" cannot be referenced in computed property keys.');
    }

    var _temporalUndefined = {};

    function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _slicedToArrayLoose(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _nonIterableRest();
    }

    function _toArray(arr) {
        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

            return arr2;
        }
    }

    function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
        if (
            Symbol.iterator in Object(iter) ||
            Object.prototype.toString.call(iter) === '[object Arguments]'
        )
            return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally {
            try {
                if (!_n && _i['return'] != null) _i['return']();
            } finally {
                if (_d) throw _e;
            }
        }

        return _arr;
    }

    function _iterableToArrayLimitLoose(arr, i) {
        var _arr = [];

        for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {
            _arr.push(_step.value);

            if (i && _arr.length === i) break;
        }

        return _arr;
    }

    function _nonIterableSpread() {
        throw new TypeError('Invalid attempt to spread non-iterable instance');
    }

    function _nonIterableRest() {
        throw new TypeError('Invalid attempt to destructure non-iterable instance');
    }

    function _skipFirstGeneratorNext(fn) {
        return function() {
            var it = fn.apply(this, arguments);
            it.next();
            return it;
        };
    }

    function _toPrimitive(input, hint) {
        if (typeof input !== 'object' || input === null) return input;
        var prim = input[Symbol.toPrimitive];

        if (prim !== undefined) {
            var res = prim.call(input, hint || 'default');
            if (typeof res !== 'object') return res;
            throw new TypeError('@@toPrimitive must return a primitive value.');
        }

        return (hint === 'string' ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, 'string');

        return typeof key === 'symbol' ? key : String(key);
    }

    function _initializerWarningHelper(descriptor, context) {
        throw new Error(
            'Decorating class property failed. Please ensure that ' +
                'proposal-class-properties is enabled and set to use loose mode. ' +
                'To use proposal-class-properties in spec mode with decorators, wait for ' +
                'the next major version of decorators in stage 2.'
        );
    }

    function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }

    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function(key) {
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
            desc.writable = true;
        }

        desc = decorators
            .slice()
            .reverse()
            .reduce(function(desc, decorator) {
                return decorator(target, property, desc) || desc;
            }, desc);

        if (context && desc.initializer !== void 0) {
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }

    var id = 0;

    function _classPrivateFieldLooseKey(name) {
        return '__private_' + id++ + '_' + name;
    }

    function _classPrivateFieldLooseBase(receiver, privateKey) {
        if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
            throw new TypeError('attempted to use private field on non-instance');
        }

        return receiver;
    }

    function _classPrivateFieldGet(receiver, privateMap) {
        var descriptor = privateMap.get(receiver);

        if (!descriptor) {
            throw new TypeError('attempted to get private field on non-instance');
        }

        if (descriptor.get) {
            return descriptor.get.call(receiver);
        }

        return descriptor.value;
    }

    function _classPrivateFieldSet(receiver, privateMap, value) {
        var descriptor = privateMap.get(receiver);

        if (!descriptor) {
            throw new TypeError('attempted to set private field on non-instance');
        }

        if (descriptor.set) {
            descriptor.set.call(receiver, value);
        } else {
            if (!descriptor.writable) {
                throw new TypeError('attempted to set read only private field');
            }

            descriptor.value = value;
        }

        return value;
    }

    function _classPrivateFieldDestructureSet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError('attempted to set private field on non-instance');
        }

        var descriptor = privateMap.get(receiver);

        if (descriptor.set) {
            if (!('__destrObj' in descriptor)) {
                descriptor.__destrObj = {
                    set value(v) {
                        descriptor.set.call(receiver, v);
                    },
                };
            }

            return descriptor.__destrObj;
        } else {
            if (!descriptor.writable) {
                throw new TypeError('attempted to set read only private field');
            }

            return descriptor;
        }
    }

    function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
        if (receiver !== classConstructor) {
            throw new TypeError('Private static access of wrong provenance');
        }

        return descriptor.value;
    }

    function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
        if (receiver !== classConstructor) {
            throw new TypeError('Private static access of wrong provenance');
        }

        if (!descriptor.writable) {
            throw new TypeError('attempted to set read only private field');
        }

        descriptor.value = value;
        return value;
    }

    function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
        if (receiver !== classConstructor) {
            throw new TypeError('Private static access of wrong provenance');
        }

        return method;
    }

    function _classStaticPrivateMethodSet() {
        throw new TypeError('attempted to set read only static private field');
    }

    function _decorate(decorators, factory, superClass, mixins) {
        var api = _getDecoratorsApi();

        if (mixins) {
            for (var i = 0; i < mixins.length; i++) {
                api = mixins[i](api);
            }
        }

        var r = factory(function initialize(O) {
            api.initializeInstanceElements(O, decorated.elements);
        }, superClass);
        var decorated = api.decorateClass(
            _coalesceClassElements(r.d.map(_createElementDescriptor)),
            decorators
        );
        api.initializeClassElements(r.F, decorated.elements);
        return api.runClassFinishers(r.F, decorated.finishers);
    }

    function _getDecoratorsApi() {
        _getDecoratorsApi = function() {
            return api;
        };

        var api = {
            elementsDefinitionOrder: [['method'], ['field']],
            initializeInstanceElements: function(O, elements) {
                ['method', 'field'].forEach(function(kind) {
                    elements.forEach(function(element) {
                        if (element.kind === kind && element.placement === 'own') {
                            this.defineClassElement(O, element);
                        }
                    }, this);
                }, this);
            },
            initializeClassElements: function(F, elements) {
                var proto = F.prototype;
                ['method', 'field'].forEach(function(kind) {
                    elements.forEach(function(element) {
                        var placement = element.placement;

                        if (
                            element.kind === kind &&
                            (placement === 'static' || placement === 'prototype')
                        ) {
                            var receiver = placement === 'static' ? F : proto;
                            this.defineClassElement(receiver, element);
                        }
                    }, this);
                }, this);
            },
            defineClassElement: function(receiver, element) {
                var descriptor = element.descriptor;

                if (element.kind === 'field') {
                    var initializer = element.initializer;
                    descriptor = {
                        enumerable: descriptor.enumerable,
                        writable: descriptor.writable,
                        configurable: descriptor.configurable,
                        value: initializer === void 0 ? void 0 : initializer.call(receiver),
                    };
                }

                Object.defineProperty(receiver, element.key, descriptor);
            },
            decorateClass: function(elements, decorators) {
                var newElements = [];
                var finishers = [];
                var placements = {
                    static: [],
                    prototype: [],
                    own: [],
                };
                elements.forEach(function(element) {
                    this.addElementPlacement(element, placements);
                }, this);
                elements.forEach(function(element) {
                    if (!_hasDecorators(element)) return newElements.push(element);
                    var elementFinishersExtras = this.decorateElement(element, placements);
                    newElements.push(elementFinishersExtras.element);
                    newElements.push.apply(newElements, elementFinishersExtras.extras);
                    finishers.push.apply(finishers, elementFinishersExtras.finishers);
                }, this);

                if (!decorators) {
                    return {
                        elements: newElements,
                        finishers: finishers,
                    };
                }

                var result = this.decorateConstructor(newElements, decorators);
                finishers.push.apply(finishers, result.finishers);
                result.finishers = finishers;
                return result;
            },
            addElementPlacement: function(element, placements, silent) {
                var keys = placements[element.placement];

                if (!silent && keys.indexOf(element.key) !== -1) {
                    throw new TypeError('Duplicated element (' + element.key + ')');
                }

                keys.push(element.key);
            },
            decorateElement: function(element, placements) {
                var extras = [];
                var finishers = [];

                for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
                    var keys = placements[element.placement];
                    keys.splice(keys.indexOf(element.key), 1);
                    var elementObject = this.fromElementDescriptor(element);
                    var elementFinisherExtras = this.toElementFinisherExtras(
                        (0, decorators[i])(elementObject) || elementObject
                    );
                    element = elementFinisherExtras.element;
                    this.addElementPlacement(element, placements);

                    if (elementFinisherExtras.finisher) {
                        finishers.push(elementFinisherExtras.finisher);
                    }

                    var newExtras = elementFinisherExtras.extras;

                    if (newExtras) {
                        for (var j = 0; j < newExtras.length; j++) {
                            this.addElementPlacement(newExtras[j], placements);
                        }

                        extras.push.apply(extras, newExtras);
                    }
                }

                return {
                    element: element,
                    finishers: finishers,
                    extras: extras,
                };
            },
            decorateConstructor: function(elements, decorators) {
                var finishers = [];

                for (var i = decorators.length - 1; i >= 0; i--) {
                    var obj = this.fromClassDescriptor(elements);
                    var elementsAndFinisher = this.toClassDescriptor(
                        (0, decorators[i])(obj) || obj
                    );

                    if (elementsAndFinisher.finisher !== undefined) {
                        finishers.push(elementsAndFinisher.finisher);
                    }

                    if (elementsAndFinisher.elements !== undefined) {
                        elements = elementsAndFinisher.elements;

                        for (var j = 0; j < elements.length - 1; j++) {
                            for (var k = j + 1; k < elements.length; k++) {
                                if (
                                    elements[j].key === elements[k].key &&
                                    elements[j].placement === elements[k].placement
                                ) {
                                    throw new TypeError(
                                        'Duplicated element (' + elements[j].key + ')'
                                    );
                                }
                            }
                        }
                    }
                }

                return {
                    elements: elements,
                    finishers: finishers,
                };
            },
            fromElementDescriptor: function(element) {
                var obj = {
                    kind: element.kind,
                    key: element.key,
                    placement: element.placement,
                    descriptor: element.descriptor,
                };
                var desc = {
                    value: 'Descriptor',
                    configurable: true,
                };
                Object.defineProperty(obj, Symbol.toStringTag, desc);
                if (element.kind === 'field') obj.initializer = element.initializer;
                return obj;
            },
            toElementDescriptors: function(elementObjects) {
                if (elementObjects === undefined) return;
                return _toArray(elementObjects).map(function(elementObject) {
                    var element = this.toElementDescriptor(elementObject);
                    this.disallowProperty(elementObject, 'finisher', 'An element descriptor');
                    this.disallowProperty(elementObject, 'extras', 'An element descriptor');
                    return element;
                }, this);
            },
            toElementDescriptor: function(elementObject) {
                var kind = String(elementObject.kind);

                if (kind !== 'method' && kind !== 'field') {
                    throw new TypeError(
                        'An element descriptor\'s .kind property must be either "method" or' +
                            ' "field", but a decorator created an element descriptor with' +
                            ' .kind "' +
                            kind +
                            '"'
                    );
                }

                var key = _toPropertyKey(elementObject.key);

                var placement = String(elementObject.placement);

                if (placement !== 'static' && placement !== 'prototype' && placement !== 'own') {
                    throw new TypeError(
                        'An element descriptor\'s .placement property must be one of "static",' +
                            ' "prototype" or "own", but a decorator created an element descriptor' +
                            ' with .placement "' +
                            placement +
                            '"'
                    );
                }

                var descriptor = elementObject.descriptor;
                this.disallowProperty(elementObject, 'elements', 'An element descriptor');
                var element = {
                    kind: kind,
                    key: key,
                    placement: placement,
                    descriptor: Object.assign({}, descriptor),
                };

                if (kind !== 'field') {
                    this.disallowProperty(elementObject, 'initializer', 'A method descriptor');
                } else {
                    this.disallowProperty(
                        descriptor,
                        'get',
                        'The property descriptor of a field descriptor'
                    );
                    this.disallowProperty(
                        descriptor,
                        'set',
                        'The property descriptor of a field descriptor'
                    );
                    this.disallowProperty(
                        descriptor,
                        'value',
                        'The property descriptor of a field descriptor'
                    );
                    element.initializer = elementObject.initializer;
                }

                return element;
            },
            toElementFinisherExtras: function(elementObject) {
                var element = this.toElementDescriptor(elementObject);

                var finisher = _optionalCallableProperty(elementObject, 'finisher');

                var extras = this.toElementDescriptors(elementObject.extras);
                return {
                    element: element,
                    finisher: finisher,
                    extras: extras,
                };
            },
            fromClassDescriptor: function(elements) {
                var obj = {
                    kind: 'class',
                    elements: elements.map(this.fromElementDescriptor, this),
                };
                var desc = {
                    value: 'Descriptor',
                    configurable: true,
                };
                Object.defineProperty(obj, Symbol.toStringTag, desc);
                return obj;
            },
            toClassDescriptor: function(obj) {
                var kind = String(obj.kind);

                if (kind !== 'class') {
                    throw new TypeError(
                        'A class descriptor\'s .kind property must be "class", but a decorator' +
                            ' created a class descriptor with .kind "' +
                            kind +
                            '"'
                    );
                }

                this.disallowProperty(obj, 'key', 'A class descriptor');
                this.disallowProperty(obj, 'placement', 'A class descriptor');
                this.disallowProperty(obj, 'descriptor', 'A class descriptor');
                this.disallowProperty(obj, 'initializer', 'A class descriptor');
                this.disallowProperty(obj, 'extras', 'A class descriptor');

                var finisher = _optionalCallableProperty(obj, 'finisher');

                var elements = this.toElementDescriptors(obj.elements);
                return {
                    elements: elements,
                    finisher: finisher,
                };
            },
            runClassFinishers: function(constructor, finishers) {
                for (var i = 0; i < finishers.length; i++) {
                    var newConstructor = (0, finishers[i])(constructor);

                    if (newConstructor !== undefined) {
                        if (typeof newConstructor !== 'function') {
                            throw new TypeError('Finishers must return a constructor.');
                        }

                        constructor = newConstructor;
                    }
                }

                return constructor;
            },
            disallowProperty: function(obj, name, objectType) {
                if (obj[name] !== undefined) {
                    throw new TypeError(objectType + " can't have a ." + name + ' property.');
                }
            },
        };
        return api;
    }

    function _createElementDescriptor(def) {
        var key = _toPropertyKey(def.key);

        var descriptor;

        if (def.kind === 'method') {
            descriptor = {
                value: def.value,
                writable: true,
                configurable: true,
                enumerable: false,
            };
        } else if (def.kind === 'get') {
            descriptor = {
                get: def.value,
                configurable: true,
                enumerable: false,
            };
        } else if (def.kind === 'set') {
            descriptor = {
                set: def.value,
                configurable: true,
                enumerable: false,
            };
        } else if (def.kind === 'field') {
            descriptor = {
                configurable: true,
                writable: true,
                enumerable: true,
            };
        }

        var element = {
            kind: def.kind === 'field' ? 'field' : 'method',
            key: key,
            placement: def.static ? 'static' : def.kind === 'field' ? 'own' : 'prototype',
            descriptor: descriptor,
        };
        if (def.decorators) element.decorators = def.decorators;
        if (def.kind === 'field') element.initializer = def.value;
        return element;
    }

    function _coalesceGetterSetter(element, other) {
        if (element.descriptor.get !== undefined) {
            other.descriptor.get = element.descriptor.get;
        } else {
            other.descriptor.set = element.descriptor.set;
        }
    }

    function _coalesceClassElements(elements) {
        var newElements = [];

        var isSameElement = function(other) {
            return (
                other.kind === 'method' &&
                other.key === element.key &&
                other.placement === element.placement
            );
        };

        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var other;

            if (element.kind === 'method' && (other = newElements.find(isSameElement))) {
                if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
                    if (_hasDecorators(element) || _hasDecorators(other)) {
                        throw new ReferenceError(
                            'Duplicated methods (' + element.key + ") can't be decorated."
                        );
                    }

                    other.descriptor = element.descriptor;
                } else {
                    if (_hasDecorators(element)) {
                        if (_hasDecorators(other)) {
                            throw new ReferenceError(
                                "Decorators can't be placed on different accessors with for " +
                                    'the same property (' +
                                    element.key +
                                    ').'
                            );
                        }

                        other.decorators = element.decorators;
                    }

                    _coalesceGetterSetter(element, other);
                }
            } else {
                newElements.push(element);
            }
        }

        return newElements;
    }

    function _hasDecorators(element) {
        return element.decorators && element.decorators.length;
    }

    function _isDataDescriptor(desc) {
        return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
    }

    function _optionalCallableProperty(obj, name) {
        var value = obj[name];

        if (value !== undefined && typeof value !== 'function') {
            throw new TypeError("Expected '" + name + "' to be a function");
        }

        return value;
    }

    function _classPrivateMethodGet(receiver, privateSet, fn) {
        if (!privateSet.has(receiver)) {
            throw new TypeError('attempted to get private field on non-instance');
        }

        return fn;
    }

    function _classPrivateMethodSet() {
        throw new TypeError('attempted to reassign private method');
    }

    function _wrapRegExp(re, groups) {
        _wrapRegExp = function(re, groups) {
            return new BabelRegExp(re, groups);
        };

        var _RegExp = _wrapNativeSuper(RegExp);

        var _super = RegExp.prototype;

        var _groups = new WeakMap();

        function BabelRegExp(re, groups) {
            var _this = _RegExp.call(this, re);

            _groups.set(_this, groups);

            return _this;
        }

        _inherits(BabelRegExp, _RegExp);

        BabelRegExp.prototype.exec = function(str) {
            var result = _super.exec.call(this, str);

            if (result) result.groups = buildGroups(result, this);
            return result;
        };

        BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {
            if (typeof substitution === 'string') {
                var groups = _groups.get(this);

                return _super[Symbol.replace].call(
                    this,
                    str,
                    substitution.replace(/\$<([^>]+)>/g, function(_, name) {
                        return '$' + groups[name];
                    })
                );
            } else if (typeof substitution === 'function') {
                var _this = this;

                return _super[Symbol.replace].call(this, str, function() {
                    var args = [];
                    args.push.apply(args, arguments);

                    if (typeof args[args.length - 1] !== 'object') {
                        args.push(buildGroups(args, _this));
                    }

                    return substitution.apply(this, args);
                });
            } else {
                return _super[Symbol.replace].call(this, str, substitution);
            }
        };

        function buildGroups(result, re) {
            var g = _groups.get(re);

            return Object.keys(g).reduce(function(groups, name) {
                groups[name] = result[g[name]];
                return groups;
            }, Object.create(null));
        }

        return _wrapRegExp.apply(this, arguments);
    }

    var arrayRemove = function arrayRemove(arr, index) {
        return arr.splice(index, 1);
    };

    var run = function run(cb, sync) {
        if (sync) {
            cb();
        } else if (document.hidden) {
            Promise.resolve(1).then(cb);
        } else {
            setTimeout(cb, 0);
        }
    };

    var on = function on() {
        var listeners = [];
        var off = function off(event, cb) {
            arrayRemove(
                listeners,
                listeners.findIndex(function(listener) {
                    return listener.event === event && (listener.cb === cb || !cb);
                })
            );
        };
        var _fire = function fire(event, args, sync) {
            listeners
                .filter(function(listener) {
                    return listener.event === event;
                })
                .map(function(listener) {
                    return listener.cb;
                })
                .forEach(function(cb) {
                    return run(function() {
                        return cb.apply(void 0, _toConsumableArray(args));
                    }, sync);
                });
        };
        return {
            fireSync: function fireSync(event) {
                for (
                    var _len = arguments.length,
                        args = new Array(_len > 1 ? _len - 1 : 0),
                        _key = 1;
                    _key < _len;
                    _key++
                ) {
                    args[_key - 1] = arguments[_key];
                }
                _fire(event, args, true);
            },
            fire: function fire(event) {
                for (
                    var _len2 = arguments.length,
                        args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                        _key2 = 1;
                    _key2 < _len2;
                    _key2++
                ) {
                    args[_key2 - 1] = arguments[_key2];
                }
                _fire(event, args, false);
            },
            on: function on(event, cb) {
                listeners.push({ event: event, cb: cb });
            },
            onOnce: function onOnce(event, _cb) {
                listeners.push({
                    event: event,
                    cb: function cb() {
                        off(event, _cb);
                        _cb.apply(void 0, arguments);
                    },
                });
            },
            off: off,
        };
    };

    var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(
        src,
        target,
        excluded
    ) {
        Object.getOwnPropertyNames(src)
            .filter(function(property) {
                return !excluded.includes(property);
            })
            .forEach(function(key) {
                return Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(src, key)
                );
            });
    };

    var PRIVATE = [
        'fire',
        'process',
        'revert',
        'load',
        'on',
        'off',
        'onOnce',
        'retryLoad',
        'extend',
        'archive',
        'archived',
        'release',
        'released',
        'requestProcessing',
        'freeze',
    ];

    var createItemAPI = function createItemAPI(item) {
        var api = {};
        copyObjectPropertiesToObject(item, api, PRIVATE);
        return api;
    };

    var removeReleasedItems = function removeReleasedItems(items) {
        items.forEach(function(item, index) {
            if (item.released) {
                arrayRemove(items, index);
            }
        });
    };

    var ItemStatus = {
        INIT: 1,
        IDLE: 2,
        PROCESSING_QUEUED: 9,
        PROCESSING: 3,
        PROCESSING_COMPLETE: 5,
        PROCESSING_ERROR: 6,
        PROCESSING_REVERT_ERROR: 10,
        LOADING: 7,
        LOAD_ERROR: 8,
    };

    var FileOrigin = {
        INPUT: 1,
        LIMBO: 2,
        LOCAL: 3,
    };

    var getNonNumeric = function getNonNumeric(str) {
        return /[^0-9]+/.exec(str);
    };

    var getDecimalSeparator = function getDecimalSeparator() {
        return getNonNumeric((1.1).toLocaleString())[0];
    };

    var getThousandsSeparator = function getThousandsSeparator() {
        // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)
        // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot
        var decimalSeparator = getDecimalSeparator();
        var thousandsStringWithSeparator = (1000.0).toLocaleString();
        var thousandsStringWithoutSeparator = (1000.0).toString();
        if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {
            return getNonNumeric(thousandsStringWithSeparator)[0];
        }
        return decimalSeparator === '.' ? ',' : '.';
    };

    var Type = {
        BOOLEAN: 'boolean',
        INT: 'int',
        NUMBER: 'number',
        STRING: 'string',
        ARRAY: 'array',
        OBJECT: 'object',
        FUNCTION: 'function',
        ACTION: 'action',
        SERVER_API: 'serverapi',
        REGEX: 'regex',
    };

    // all registered filters
    var filters = [];

    // loops over matching filters and passes options to each filter, returning the mapped results
    var applyFilterChain = function applyFilterChain(key, value, utils) {
        return new Promise(function(resolve, reject) {
            // find matching filters for this key
            var matchingFilters = filters
                .filter(function(f) {
                    return f.key === key;
                })
                .map(function(f) {
                    return f.cb;
                });

            // resolve now
            if (matchingFilters.length === 0) {
                resolve(value);
                return;
            }

            // first filter to kick things of
            var initialFilter = matchingFilters.shift();

            // chain filters
            matchingFilters
                .reduce(
                    // loop over promises passing value to next promise
                    function(current, next) {
                        return current.then(function(value) {
                            return next(value, utils);
                        });
                    },

                    // call initial filter, will return a promise
                    initialFilter(value, utils)

                    // all executed
                )
                .then(function(value) {
                    return resolve(value);
                })
                .catch(function(error) {
                    return reject(error);
                });
        });
    };

    var applyFilters = function applyFilters(key, value, utils) {
        return filters
            .filter(function(f) {
                return f.key === key;
            })
            .map(function(f) {
                return f.cb(value, utils);
            });
    };

    // adds a new filter to the list
    var addFilter = function addFilter(key, cb) {
        return filters.push({ key: key, cb: cb });
    };

    var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {
        return Object.assign(defaultOptions, additionalOptions);
    };

    var getOptions = function getOptions() {
        return Object.assign({}, defaultOptions);
    };

    var setOptions = function setOptions(opts) {
        forin(opts, function(key, value) {
            // key does not exist, so this option cannot be set
            if (!defaultOptions[key]) {
                return;
            }
            defaultOptions[key][0] = getValueByType(
                value,
                defaultOptions[key][0],
                defaultOptions[key][1]
            );
        });
    };

    // default options on app
    var defaultOptions = {
        // the id to add to the root element
        id: [null, Type.STRING],

        // input field name to use
        name: ['filepond', Type.STRING],

        // disable the field
        disabled: [false, Type.BOOLEAN],

        // classname to put on wrapper
        className: [null, Type.STRING],

        // is the field required
        required: [false, Type.BOOLEAN],

        // Allow media capture when value is set
        captureMethod: [null, Type.STRING],
        // - "camera", "microphone" or "camcorder",
        // - Does not work with multiple on apple devices
        // - If set, acceptedFileTypes must be made to match with media wildcard "image/*", "audio/*" or "video/*"

        // sync `acceptedFileTypes` property with `accept` attribute
        allowSyncAcceptAttribute: [true, Type.BOOLEAN],

        // Feature toggles
        allowDrop: [true, Type.BOOLEAN], // Allow dropping of files
        allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system
        allowPaste: [true, Type.BOOLEAN], // Allow pasting files
        allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)
        allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)
        allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload
        allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file
        allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button
        allowReorder: [false, Type.BOOLEAN], // Allow reordering of files
        allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)

        // Try store file if `server` not set
        storeAsFile: [false, Type.BOOLEAN],

        // Revert mode
        forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal

        // Input requirements
        maxFiles: [null, Type.INT], // Max number of files
        checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages

        // Where to put file
        itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list
        itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list
        itemInsertInterval: [75, Type.INT],

        // Drag 'n Drop related
        dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)
        dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)
        dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop
        ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],

        // Upload related
        instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop
        maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel
        allowMinimumUploadDuration: [true, Type.BOOLEAN], // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened

        // Chunks
        chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads
        chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size
        chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)
        chunkRetryDelays: [[500, 1000, 3000], Type.ARRAY], // Amount of times to retry upload of a chunk when it fails

        // The server api end points to use for uploading (see docs)
        server: [null, Type.SERVER_API],

        // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000
        fileSizeBase: [1000, Type.INT],

        // Labels and status messages
        labelFileSizeBytes: ['bytes', Type.STRING],
        labelFileSizeKilobytes: ['KB', Type.STRING],
        labelFileSizeMegabytes: ['MB', Type.STRING],
        labelFileSizeGigabytes: ['GB', Type.STRING],

        labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator
        labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator

        labelIdle: [
            'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
            Type.STRING,
        ],

        labelInvalidField: ['Field contains invalid files', Type.STRING],
        labelFileWaitingForSize: ['Waiting for size', Type.STRING],
        labelFileSizeNotAvailable: ['Size not available', Type.STRING],
        labelFileCountSingular: ['file in list', Type.STRING],
        labelFileCountPlural: ['files in list', Type.STRING],
        labelFileLoading: ['Loading', Type.STRING],
        labelFileAdded: ['Added', Type.STRING], // assistive only
        labelFileLoadError: ['Error during load', Type.STRING],
        labelFileRemoved: ['Removed', Type.STRING], // assistive only
        labelFileRemoveError: ['Error during remove', Type.STRING],
        labelFileProcessing: ['Uploading', Type.STRING],
        labelFileProcessingComplete: ['Upload complete', Type.STRING],
        labelFileProcessingAborted: ['Upload cancelled', Type.STRING],
        labelFileProcessingError: ['Error during upload', Type.STRING],
        labelFileProcessingRevertError: ['Error during revert', Type.STRING],

        labelTapToCancel: ['tap to cancel', Type.STRING],
        labelTapToRetry: ['tap to retry', Type.STRING],
        labelTapToUndo: ['tap to undo', Type.STRING],

        labelButtonRemoveItem: ['Remove', Type.STRING],
        labelButtonAbortItemLoad: ['Abort', Type.STRING],
        labelButtonRetryItemLoad: ['Retry', Type.STRING],
        labelButtonAbortItemProcessing: ['Cancel', Type.STRING],
        labelButtonUndoItemProcessing: ['Undo', Type.STRING],
        labelButtonRetryItemProcessing: ['Retry', Type.STRING],
        labelButtonProcessItem: ['Upload', Type.STRING],

        // make sure width and height plus viewpox are even numbers so icons are nicely centered
        iconRemove: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING,
        ],

        iconProcess: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
            Type.STRING,
        ],

        iconRetry: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING,
        ],

        iconUndo: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING,
        ],

        iconDone: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING,
        ],

        // event handlers
        oninit: [null, Type.FUNCTION],
        onwarning: [null, Type.FUNCTION],
        onerror: [null, Type.FUNCTION],
        onactivatefile: [null, Type.FUNCTION],
        oninitfile: [null, Type.FUNCTION],
        onaddfilestart: [null, Type.FUNCTION],
        onaddfileprogress: [null, Type.FUNCTION],
        onaddfile: [null, Type.FUNCTION],
        onprocessfilestart: [null, Type.FUNCTION],
        onprocessfileprogress: [null, Type.FUNCTION],
        onprocessfileabort: [null, Type.FUNCTION],
        onprocessfilerevert: [null, Type.FUNCTION],
        onprocessfile: [null, Type.FUNCTION],
        onprocessfiles: [null, Type.FUNCTION],
        onremovefile: [null, Type.FUNCTION],
        onpreparefile: [null, Type.FUNCTION],
        onupdatefiles: [null, Type.FUNCTION],
        onreorderfiles: [null, Type.FUNCTION],

        // hooks
        beforeDropFile: [null, Type.FUNCTION],
        beforeAddFile: [null, Type.FUNCTION],
        beforeRemoveFile: [null, Type.FUNCTION],
        beforePrepareFile: [null, Type.FUNCTION],

        // styles
        stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'
        stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1
        styleItemPanelAspectRatio: [null, Type.STRING],
        styleButtonRemoveItemPosition: ['left', Type.STRING],
        styleButtonProcessItemPosition: ['right', Type.STRING],
        styleLoadIndicatorPosition: ['right', Type.STRING],
        styleProgressIndicatorPosition: ['right', Type.STRING],
        styleButtonRemoveItemAlign: [false, Type.BOOLEAN],

        // custom initial files array
        files: [[], Type.ARRAY],

        // show support by displaying credits
        credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY],
    };

    var getItemByQuery = function getItemByQuery(items, query) {
        // just return first index
        if (isEmpty(query)) {
            return items[0] || null;
        }

        // query is index
        if (isInt(query)) {
            return items[query] || null;
        }

        // if query is item, get the id
        if (typeof query === 'object') {
            query = query.id;
        }

        // assume query is a string and return item by id
        return (
            items.find(function(item) {
                return item.id === query;
            }) || null
        );
    };

    var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(aspectRatio) {
        if (isEmpty(aspectRatio)) {
            return aspectRatio;
        }
        if (/:/.test(aspectRatio)) {
            var parts = aspectRatio.split(':');
            return parts[1] / parts[0];
        }
        return parseFloat(aspectRatio);
    };

    var getActiveItems = function getActiveItems(items) {
        return items.filter(function(item) {
            return !item.archived;
        });
    };

    var Status = {
        EMPTY: 0,
        IDLE: 1, // waiting
        ERROR: 2, // a file is in error state
        BUSY: 3, // busy processing or loading
        READY: 4, // all files uploaded
    };

    var res = null;
    var canUpdateFileInput = function canUpdateFileInput() {
        if (res === null) {
            try {
                var dataTransfer = new DataTransfer();
                dataTransfer.items.add(new File(['hello world'], 'This_Works.txt'));
                var el = document.createElement('input');
                el.setAttribute('type', 'file');
                el.files = dataTransfer.files;
                res = el.files.length === 1;
            } catch (err) {
                res = false;
            }
        }
        return res;
    };

    var ITEM_ERROR = [
        ItemStatus.LOAD_ERROR,
        ItemStatus.PROCESSING_ERROR,
        ItemStatus.PROCESSING_REVERT_ERROR,
    ];

    var ITEM_BUSY = [
        ItemStatus.LOADING,
        ItemStatus.PROCESSING,
        ItemStatus.PROCESSING_QUEUED,
        ItemStatus.INIT,
    ];

    var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];

    var isItemInErrorState = function isItemInErrorState(item) {
        return ITEM_ERROR.includes(item.status);
    };
    var isItemInBusyState = function isItemInBusyState(item) {
        return ITEM_BUSY.includes(item.status);
    };
    var isItemInReadyState = function isItemInReadyState(item) {
        return ITEM_READY.includes(item.status);
    };

    var isAsync = function isAsync(state) {
        return (
            isObject(state.options.server) &&
            (isObject(state.options.server.process) || isFunction(state.options.server.process))
        );
    };

    var queries = function queries(state) {
        return {
            GET_STATUS: function GET_STATUS() {
                var items = getActiveItems(state.items);
                var EMPTY = Status.EMPTY,
                    ERROR = Status.ERROR,
                    BUSY = Status.BUSY,
                    IDLE = Status.IDLE,
                    READY = Status.READY;

                if (items.length === 0) return EMPTY;

                if (items.some(isItemInErrorState)) return ERROR;

                if (items.some(isItemInBusyState)) return BUSY;

                if (items.some(isItemInReadyState)) return READY;

                return IDLE;
            },

            GET_ITEM: function GET_ITEM(query) {
                return getItemByQuery(state.items, query);
            },

            GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {
                return getItemByQuery(getActiveItems(state.items), query);
            },

            GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {
                return getActiveItems(state.items);
            },

            GET_ITEMS: function GET_ITEMS() {
                return state.items;
            },

            GET_ITEM_NAME: function GET_ITEM_NAME(query) {
                var item = getItemByQuery(state.items, query);
                return item ? item.filename : null;
            },

            GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {
                var item = getItemByQuery(state.items, query);
                return item ? item.fileSize : null;
            },

            GET_STYLES: function GET_STYLES() {
                return Object.keys(state.options)
                    .filter(function(key) {
                        return /^style/.test(key);
                    })
                    .map(function(option) {
                        return {
                            name: option,
                            value: state.options[option],
                        };
                    });
            },

            GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {
                var isShapeCircle = /circle/.test(state.options.stylePanelLayout);
                var aspectRatio = isShapeCircle
                    ? 1
                    : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);
                return aspectRatio;
            },

            GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {
                return state.options.styleItemPanelAspectRatio;
            },

            GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {
                return getActiveItems(state.items).filter(function(item) {
                    return item.status === status;
                });
            },

            GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {
                return getActiveItems(state.items).length;
            },

            SHOULD_UPDATE_FILE_INPUT: function SHOULD_UPDATE_FILE_INPUT() {
                return state.options.storeAsFile && canUpdateFileInput() && !isAsync(state);
            },

            IS_ASYNC: function IS_ASYNC() {
                return isAsync(state);
            },

            GET_FILE_SIZE_LABELS: function GET_FILE_SIZE_LABELS(query) {
                return {
                    labelBytes: query('GET_LABEL_FILE_SIZE_BYTES') || undefined,
                    labelKilobytes: query('GET_LABEL_FILE_SIZE_KILOBYTES') || undefined,
                    labelMegabytes: query('GET_LABEL_FILE_SIZE_MEGABYTES') || undefined,
                    labelGigabytes: query('GET_LABEL_FILE_SIZE_GIGABYTES') || undefined,
                };
            },
        };
    };

    var hasRoomForItem = function hasRoomForItem(state) {
        var count = getActiveItems(state.items).length;

        // if cannot have multiple items, to add one item it should currently not contain items
        if (!state.options.allowMultiple) {
            return count === 0;
        }

        // if allows multiple items, we check if a max item count has been set, if not, there's no limit
        var maxFileCount = state.options.maxFiles;
        if (maxFileCount === null) {
            return true;
        }

        // we check if the current count is smaller than the max count, if so, another file can still be added
        if (count < maxFileCount) {
            return true;
        }

        // no more room for another file
        return false;
    };

    var limit = function limit(value, min, max) {
        return Math.max(Math.min(max, value), min);
    };

    var arrayInsert = function arrayInsert(arr, index, item) {
        return arr.splice(index, 0, item);
    };

    var insertItem = function insertItem(items, item, index) {
        if (isEmpty(item)) {
            return null;
        }

        // if index is undefined, append
        if (typeof index === 'undefined') {
            items.push(item);
            return item;
        }

        // limit the index to the size of the items array
        index = limit(index, 0, items.length);

        // add item to array
        arrayInsert(items, index, item);

        // expose
        return item;
    };

    var isBase64DataURI = function isBase64DataURI(str) {
        return /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(
            str
        );
    };

    var getFilenameFromURL = function getFilenameFromURL(url) {
        return url
            .split('/')
            .pop()
            .split('?')
            .shift();
    };

    var getExtensionFromFilename = function getExtensionFromFilename(name) {
        return name.split('.').pop();
    };

    var guesstimateExtension = function guesstimateExtension(type) {
        // if no extension supplied, exit here
        if (typeof type !== 'string') {
            return '';
        }

        // get subtype
        var subtype = type.split('/').pop();

        // is svg subtype
        if (/svg/.test(subtype)) {
            return 'svg';
        }

        if (/zip|compressed/.test(subtype)) {
            return 'zip';
        }

        if (/plain/.test(subtype)) {
            return 'txt';
        }

        if (/msword/.test(subtype)) {
            return 'doc';
        }

        // if is valid subtype
        if (/[a-z]+/.test(subtype)) {
            // always use jpg extension
            if (subtype === 'jpeg') {
                return 'jpg';
            }

            // return subtype
            return subtype;
        }

        return '';
    };

    var leftPad = function leftPad(value) {
        var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        return (padding + value).slice(-padding.length);
    };

    var getDateString = function getDateString() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return (
            date.getFullYear() +
            '-' +
            leftPad(date.getMonth() + 1, '00') +
            '-' +
            leftPad(date.getDate(), '00') +
            '_' +
            leftPad(date.getHours(), '00') +
            '-' +
            leftPad(date.getMinutes(), '00') +
            '-' +
            leftPad(date.getSeconds(), '00')
        );
    };

    var getFileFromBlob = function getFileFromBlob(blob, filename) {
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var extension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var file =
            typeof type === 'string'
                ? blob.slice(0, blob.size, type)
                : blob.slice(0, blob.size, blob.type);
        file.lastModifiedDate = new Date();

        // copy relative path
        if (blob._relativePath) file._relativePath = blob._relativePath;

        // if blob has name property, use as filename if no filename supplied
        if (!isString(filename)) {
            filename = getDateString();
        }

        // if filename supplied but no extension and filename has extension
        if (filename && extension === null && getExtensionFromFilename(filename)) {
            file.name = filename;
        } else {
            extension = extension || guesstimateExtension(file.type);
            file.name = filename + (extension ? '.' + extension : '');
        }

        return file;
    };

    var getBlobBuilder = function getBlobBuilder() {
        return (window.BlobBuilder =
            window.BlobBuilder ||
            window.WebKitBlobBuilder ||
            window.MozBlobBuilder ||
            window.MSBlobBuilder);
    };

    var createBlob = function createBlob(arrayBuffer, mimeType) {
        var BB = getBlobBuilder();

        if (BB) {
            var bb = new BB();
            bb.append(arrayBuffer);
            return bb.getBlob(mimeType);
        }

        return new Blob([arrayBuffer], {
            type: mimeType,
        });
    };

    var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(
        byteString,
        mimeType
    ) {
        var ab = new ArrayBuffer(byteString.length);
        var ia = new Uint8Array(ab);

        for (var i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }

        return createBlob(ab, mimeType);
    };

    var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(dataURI) {
        return (/^data:(.+);/.exec(dataURI) || [])[1] || null;
    };

    var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(dataURI) {
        // get data part of string (remove data:image/jpeg...,)
        var data = dataURI.split(',')[1];

        // remove any whitespace as that causes InvalidCharacterError in IE
        return data.replace(/\s/g, '');
    };

    var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(dataURI) {
        return atob(getBase64DataFromBase64DataURI(dataURI));
    };

    var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {
        var mimeType = getMimeTypeFromBase64DataURI(dataURI);
        var byteString = getByteStringFromBase64DataURI(dataURI);

        return getBlobFromByteStringWithMimeType(byteString, mimeType);
    };

    var getFileFromBase64DataURI = function getFileFromBase64DataURI(dataURI, filename, extension) {
        return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);
    };

    var getFileNameFromHeader = function getFileNameFromHeader(header) {
        // test if is content disposition header, if not exit
        if (!/^content-disposition:/i.test(header)) return null;

        // get filename parts
        var matches = header
            .split(/filename=|filename\*=.+''/)
            .splice(1)
            .map(function(name) {
                return name.trim().replace(/^["']|[;"']{0,2}$/g, '');
            })
            .filter(function(name) {
                return name.length;
            });

        return matches.length ? decodeURI(matches[matches.length - 1]) : null;
    };

    var getFileSizeFromHeader = function getFileSizeFromHeader(header) {
        if (/content-length:/i.test(header)) {
            var size = header.match(/[0-9]+/)[0];
            return size ? parseInt(size, 10) : null;
        }
        return null;
    };

    var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {
        if (/x-content-transfer-id:/i.test(header)) {
            var id = (header.split(':')[1] || '').trim();
            return id || null;
        }
        return null;
    };

    var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {
        var info = {
            source: null,
            name: null,
            size: null,
        };

        var rows = headers.split('\n');
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for (
                var _iterator = rows[Symbol.iterator](), _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
            ) {
                var header = _step.value;

                var name = getFileNameFromHeader(header);
                if (name) {
                    info.name = name;
                    continue;
                }

                var size = getFileSizeFromHeader(header);
                if (size) {
                    info.size = size;
                    continue;
                }

                var source = getTranfserIdFromHeader(header);
                if (source) {
                    info.source = source;
                    continue;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return info;
    };

    var createFileLoader = function createFileLoader(fetchFn) {
        var state = {
            source: null,
            complete: false,
            progress: 0,
            size: null,
            timestamp: null,
            duration: 0,
            request: null,
        };

        var getProgress = function getProgress() {
            return state.progress;
        };
        var abort = function abort() {
            if (state.request && state.request.abort) {
                state.request.abort();
            }
        };

        // load source
        var load = function load() {
            // get quick reference
            var source = state.source;

            api.fire('init', source);

            // Load Files
            if (source instanceof File) {
                api.fire('load', source);
            } else if (source instanceof Blob) {
                // Load blobs, set default name to current date
                api.fire('load', getFileFromBlob(source, source.name));
            } else if (isBase64DataURI(source)) {
                // Load base 64, set default name to current date
                api.fire('load', getFileFromBase64DataURI(source));
            } else {
                // Deal as if is external URL, let's load it!
                loadURL(source);
            }
        };

        // loads a url
        var loadURL = function loadURL(url) {
            // is remote url and no fetch method supplied
            if (!fetchFn) {
                api.fire('error', {
                    type: 'error',
                    body: "Can't load URL",
                    code: 400,
                });

                return;
            }

            // set request start
            state.timestamp = Date.now();

            // load file
            state.request = fetchFn(
                url,
                function(response) {
                    // update duration
                    state.duration = Date.now() - state.timestamp;

                    // done!
                    state.complete = true;

                    // turn blob response into a file
                    if (response instanceof Blob) {
                        response = getFileFromBlob(
                            response,
                            response.name || getFilenameFromURL(url)
                        );
                    }

                    api.fire(
                        'load',
                        // if has received blob, we go with blob, if no response, we return null
                        response instanceof Blob ? response : response ? response.body : null
                    );
                },
                function(error) {
                    api.fire(
                        'error',
                        typeof error === 'string'
                            ? {
                                  type: 'error',
                                  code: 0,
                                  body: error,
                              }
                            : error
                    );
                },
                function(computable, current, total) {
                    // collected some meta data already
                    if (total) {
                        state.size = total;
                    }

                    // update duration
                    state.duration = Date.now() - state.timestamp;

                    // if we can't compute progress, we're not going to fire progress events
                    if (!computable) {
                        state.progress = null;
                        return;
                    }

                    // update progress percentage
                    state.progress = current / total;

                    // expose
                    api.fire('progress', state.progress);
                },
                function() {
                    api.fire('abort');
                },
                function(response) {
                    var fileinfo = getFileInfoFromHeaders(
                        typeof response === 'string' ? response : response.headers
                    );
                    api.fire('meta', {
                        size: state.size || fileinfo.size,
                        filename: fileinfo.name,
                        source: fileinfo.source,
                    });
                }
            );
        };

        var api = Object.assign({}, on(), {
            setSource: function setSource(source) {
                return (state.source = source);
            },
            getProgress: getProgress, // file load progress
            abort: abort, // abort file load
            load: load, // start load
        });

        return api;
    };

    var isGet = function isGet(method) {
        return /GET|HEAD/.test(method);
    };

    var sendRequest = function sendRequest(data, url, options) {
        var api = {
            onheaders: function onheaders() {},
            onprogress: function onprogress() {},
            onload: function onload() {},
            ontimeout: function ontimeout() {},
            onerror: function onerror() {},
            onabort: function onabort() {},
            abort: function abort() {
                aborted = true;
                xhr.abort();
            },
        };

        // timeout identifier, only used when timeout is defined
        var aborted = false;
        var headersReceived = false;

        // set default options
        options = Object.assign(
            {
                method: 'POST',
                headers: {},
                withCredentials: false,
            },
            options
        );

        // encode url
        url = encodeURI(url);

        // if method is GET, add any received data to url

        if (isGet(options.method) && data) {
            url =
                '' +
                url +
                encodeURIComponent(typeof data === 'string' ? data : JSON.stringify(data));
        }

        // create request
        var xhr = new XMLHttpRequest();

        // progress of load
        var process = isGet(options.method) ? xhr : xhr.upload;
        process.onprogress = function(e) {
            // no progress event when aborted ( onprogress is called once after abort() )
            if (aborted) {
                return;
            }

            api.onprogress(e.lengthComputable, e.loaded, e.total);
        };

        // tries to get header info to the app as fast as possible
        xhr.onreadystatechange = function() {
            // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)
            if (xhr.readyState < 2) {
                return;
            }

            // no server response
            if (xhr.readyState === 4 && xhr.status === 0) {
                return;
            }

            if (headersReceived) {
                return;
            }

            headersReceived = true;

            // we've probably received some useful data in response headers
            api.onheaders(xhr);
        };

        // load successful
        xhr.onload = function() {
            // is classified as valid response
            if (xhr.status >= 200 && xhr.status < 300) {
                api.onload(xhr);
            } else {
                api.onerror(xhr);
            }
        };

        // error during load
        xhr.onerror = function() {
            return api.onerror(xhr);
        };

        // request aborted
        xhr.onabort = function() {
            aborted = true;
            api.onabort();
        };

        // request timeout
        xhr.ontimeout = function() {
            return api.ontimeout(xhr);
        };

        // open up open up!
        xhr.open(options.method, url, true);

        // set timeout if defined (do it after open so IE11 plays ball)
        if (isInt(options.timeout)) {
            xhr.timeout = options.timeout;
        }

        // add headers
        Object.keys(options.headers).forEach(function(key) {
            var value = unescape(encodeURIComponent(options.headers[key]));
            xhr.setRequestHeader(key, value);
        });

        // set type of response
        if (options.responseType) {
            xhr.responseType = options.responseType;
        }

        // set credentials
        if (options.withCredentials) {
            xhr.withCredentials = true;
        }

        // let's send our data
        xhr.send(data);

        return api;
    };

    var createResponse = function createResponse(type, code, body, headers) {
        return {
            type: type,
            code: code,
            body: body,
            headers: headers,
        };
    };

    var createTimeoutResponse = function createTimeoutResponse(cb) {
        return function(xhr) {
            cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));
        };
    };

    var hasQS = function hasQS(str) {
        return /\?/.test(str);
    };
    var buildURL = function buildURL() {
        var url = '';
        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
            parts[_key] = arguments[_key];
        }
        parts.forEach(function(part) {
            url += hasQS(url) && hasQS(part) ? part.replace(/\?/, '&') : part;
        });
        return url;
    };

    var createFetchFunction = function createFetchFunction() {
        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var action = arguments.length > 1 ? arguments[1] : undefined;
        // custom handler (should also handle file, load, error, progress and abort)
        if (typeof action === 'function') {
            return action;
        }

        // no action supplied
        if (!action || !isString(action.url)) {
            return null;
        }

        // set onload hanlder
        var onload =
            action.onload ||
            function(res) {
                return res;
            };
        var onerror =
            action.onerror ||
            function(res) {
                return null;
            };

        // internal handler
        return function(url, load, error, progress, abort, headers) {
            // do local or remote request based on if the url is external
            var request = sendRequest(
                url,
                buildURL(apiUrl, action.url),
                Object.assign({}, action, {
                    responseType: 'blob',
                })
            );

            request.onload = function(xhr) {
                // get headers
                var headers = xhr.getAllResponseHeaders();

                // get filename
                var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);

                // create response
                load(
                    createResponse(
                        'load',
                        xhr.status,
                        action.method === 'HEAD'
                            ? null
                            : getFileFromBlob(onload(xhr.response), filename),
                        headers
                    )
                );
            };

            request.onerror = function(xhr) {
                error(
                    createResponse(
                        'error',
                        xhr.status,
                        onerror(xhr.response) || xhr.statusText,
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.onheaders = function(xhr) {
                headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));
            };

            request.ontimeout = createTimeoutResponse(error);
            request.onprogress = progress;
            request.onabort = abort;

            // should return request
            return request;
        };
    };

    var ChunkStatus = {
        QUEUED: 0,
        COMPLETE: 1,
        PROCESSING: 2,
        ERROR: 3,
        WAITING: 4,
    };

    /*
                                                       function signature:
                                                         (file, metadata, load, error, progress, abort, transfer, options) => {
                                                           return {
                                                           abort:() => {}
                                                         }
                                                       }
                                                       */

    // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options
    var processFileChunked = function processFileChunked(
        apiUrl,
        action,
        name,
        file,
        metadata,
        load,
        error,
        progress,
        abort,
        transfer,
        options
    ) {
        // all chunks
        var chunks = [];
        var chunkTransferId = options.chunkTransferId,
            chunkServer = options.chunkServer,
            chunkSize = options.chunkSize,
            chunkRetryDelays = options.chunkRetryDelays;

        // default state
        var state = {
            serverId: chunkTransferId,
            aborted: false,
        };

        // set onload handlers
        var ondata =
            action.ondata ||
            function(fd) {
                return fd;
            };
        var onload =
            action.onload ||
            function(xhr, method) {
                return method === 'HEAD' ? xhr.getResponseHeader('Upload-Offset') : xhr.response;
            };
        var onerror =
            action.onerror ||
            function(res) {
                return null;
            };

        // create server hook
        var requestTransferId = function requestTransferId(cb) {
            var formData = new FormData();

            // add metadata under same name
            if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));

            var headers =
                typeof action.headers === 'function'
                    ? action.headers(file, metadata)
                    : Object.assign({}, action.headers, {
                          'Upload-Length': file.size,
                      });

            var requestParams = Object.assign({}, action, {
                headers: headers,
            });

            // send request object
            var request = sendRequest(
                ondata(formData),
                buildURL(apiUrl, action.url),
                requestParams
            );

            request.onload = function(xhr) {
                return cb(onload(xhr, requestParams.method));
            };

            request.onerror = function(xhr) {
                return error(
                    createResponse(
                        'error',
                        xhr.status,
                        onerror(xhr.response) || xhr.statusText,
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.ontimeout = createTimeoutResponse(error);
        };

        var requestTransferOffset = function requestTransferOffset(cb) {
            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);

            var headers =
                typeof action.headers === 'function'
                    ? action.headers(state.serverId)
                    : Object.assign({}, action.headers);

            var requestParams = {
                headers: headers,
                method: 'HEAD',
            };

            var request = sendRequest(null, requestUrl, requestParams);

            request.onload = function(xhr) {
                return cb(onload(xhr, requestParams.method));
            };

            request.onerror = function(xhr) {
                return error(
                    createResponse(
                        'error',
                        xhr.status,
                        onerror(xhr.response) || xhr.statusText,
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.ontimeout = createTimeoutResponse(error);
        };

        // create chunks
        var lastChunkIndex = Math.floor(file.size / chunkSize);
        for (var i = 0; i <= lastChunkIndex; i++) {
            var offset = i * chunkSize;
            var data = file.slice(offset, offset + chunkSize, 'application/offset+octet-stream');
            chunks[i] = {
                index: i,
                size: data.size,
                offset: offset,
                data: data,
                file: file,
                progress: 0,
                retries: _toConsumableArray(chunkRetryDelays),
                status: ChunkStatus.QUEUED,
                error: null,
                request: null,
                timeout: null,
            };
        }

        var completeProcessingChunks = function completeProcessingChunks() {
            return load(state.serverId);
        };

        var canProcessChunk = function canProcessChunk(chunk) {
            return chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;
        };

        var processChunk = function processChunk(chunk) {
            // processing is paused, wait here
            if (state.aborted) return;

            // get next chunk to process
            chunk = chunk || chunks.find(canProcessChunk);

            // no more chunks to process
            if (!chunk) {
                // all done?
                if (
                    chunks.every(function(chunk) {
                        return chunk.status === ChunkStatus.COMPLETE;
                    })
                ) {
                    completeProcessingChunks();
                }

                // no chunk to handle
                return;
            }

            // now processing this chunk
            chunk.status = ChunkStatus.PROCESSING;
            chunk.progress = null;

            // allow parsing of formdata
            var ondata =
                chunkServer.ondata ||
                function(fd) {
                    return fd;
                };
            var onerror =
                chunkServer.onerror ||
                function(res) {
                    return null;
                };

            // send request object
            var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);

            var headers =
                typeof chunkServer.headers === 'function'
                    ? chunkServer.headers(chunk)
                    : Object.assign({}, chunkServer.headers, {
                          'Content-Type': 'application/offset+octet-stream',
                          'Upload-Offset': chunk.offset,
                          'Upload-Length': file.size,
                          'Upload-Name': file.name,
                      });

            var request = (chunk.request = sendRequest(
                ondata(chunk.data),
                requestUrl,
                Object.assign({}, chunkServer, {
                    headers: headers,
                })
            ));

            request.onload = function() {
                // done!
                chunk.status = ChunkStatus.COMPLETE;

                // remove request reference
                chunk.request = null;

                // start processing more chunks
                processChunks();
            };

            request.onprogress = function(lengthComputable, loaded, total) {
                chunk.progress = lengthComputable ? loaded : null;
                updateTotalProgress();
            };

            request.onerror = function(xhr) {
                chunk.status = ChunkStatus.ERROR;
                chunk.request = null;
                chunk.error = onerror(xhr.response) || xhr.statusText;
                if (!retryProcessChunk(chunk)) {
                    error(
                        createResponse(
                            'error',
                            xhr.status,
                            onerror(xhr.response) || xhr.statusText,
                            xhr.getAllResponseHeaders()
                        )
                    );
                }
            };

            request.ontimeout = function(xhr) {
                chunk.status = ChunkStatus.ERROR;
                chunk.request = null;
                if (!retryProcessChunk(chunk)) {
                    createTimeoutResponse(error)(xhr);
                }
            };

            request.onabort = function() {
                chunk.status = ChunkStatus.QUEUED;
                chunk.request = null;
                abort();
            };
        };

        var retryProcessChunk = function retryProcessChunk(chunk) {
            // no more retries left
            if (chunk.retries.length === 0) return false;

            // new retry
            chunk.status = ChunkStatus.WAITING;
            clearTimeout(chunk.timeout);
            chunk.timeout = setTimeout(function() {
                processChunk(chunk);
            }, chunk.retries.shift());

            // we're going to retry
            return true;
        };

        var updateTotalProgress = function updateTotalProgress() {
            // calculate total progress fraction
            var totalBytesTransfered = chunks.reduce(function(p, chunk) {
                if (p === null || chunk.progress === null) return null;
                return p + chunk.progress;
            }, 0);

            // can't compute progress
            if (totalBytesTransfered === null) return progress(false, 0, 0);

            // calculate progress values
            var totalSize = chunks.reduce(function(total, chunk) {
                return total + chunk.size;
            }, 0);

            // can update progress indicator
            progress(true, totalBytesTransfered, totalSize);
        };

        // process new chunks
        var processChunks = function processChunks() {
            var totalProcessing = chunks.filter(function(chunk) {
                return chunk.status === ChunkStatus.PROCESSING;
            }).length;
            if (totalProcessing >= 1) return;
            processChunk();
        };

        var abortChunks = function abortChunks() {
            chunks.forEach(function(chunk) {
                clearTimeout(chunk.timeout);
                if (chunk.request) {
                    chunk.request.abort();
                }
            });
        };

        // let's go!
        if (!state.serverId) {
            requestTransferId(function(serverId) {
                // stop here if aborted, might have happened in between request and callback
                if (state.aborted) return;

                // pass back to item so we can use it if something goes wrong
                transfer(serverId);

                // store internally
                state.serverId = serverId;
                processChunks();
            });
        } else {
            requestTransferOffset(function(offset) {
                // stop here if aborted, might have happened in between request and callback
                if (state.aborted) return;

                // mark chunks with lower offset as complete
                chunks
                    .filter(function(chunk) {
                        return chunk.offset < offset;
                    })
                    .forEach(function(chunk) {
                        chunk.status = ChunkStatus.COMPLETE;
                        chunk.progress = chunk.size;
                    });

                // continue processing
                processChunks();
            });
        }

        return {
            abort: function abort() {
                state.aborted = true;
                abortChunks();
            },
        };
    };

    /*
                                                               function signature:
                                                                 (file, metadata, load, error, progress, abort) => {
                                                                   return {
                                                                   abort:() => {}
                                                                 }
                                                               }
                                                               */
    var createFileProcessorFunction = function createFileProcessorFunction(
        apiUrl,
        action,
        name,
        options
    ) {
        return function(file, metadata, load, error, progress, abort, transfer) {
            // no file received
            if (!file) return;

            // if was passed a file, and we can chunk it, exit here
            var canChunkUpload = options.chunkUploads;
            var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;
            var willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);
            if (file instanceof Blob && willChunkUpload)
                return processFileChunked(
                    apiUrl,
                    action,
                    name,
                    file,
                    metadata,
                    load,
                    error,
                    progress,
                    abort,
                    transfer,
                    options
                );

            // set handlers
            var ondata =
                action.ondata ||
                function(fd) {
                    return fd;
                };
            var onload =
                action.onload ||
                function(res) {
                    return res;
                };
            var onerror =
                action.onerror ||
                function(res) {
                    return null;
                };

            var headers =
                typeof action.headers === 'function'
                    ? action.headers(file, metadata) || {}
                    : Object.assign(
                          {},

                          action.headers
                      );

            var requestParams = Object.assign({}, action, {
                headers: headers,
            });

            // create formdata object
            var formData = new FormData();

            // add metadata under same name
            if (isObject(metadata)) {
                formData.append(name, JSON.stringify(metadata));
            }

            // Turn into an array of objects so no matter what the input, we can handle it the same way
            (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(function(item) {
                formData.append(
                    name,
                    item.file,
                    item.name === null ? item.file.name : '' + item.name + item.file.name
                );
            });

            // send request object
            var request = sendRequest(
                ondata(formData),
                buildURL(apiUrl, action.url),
                requestParams
            );
            request.onload = function(xhr) {
                load(
                    createResponse(
                        'load',
                        xhr.status,
                        onload(xhr.response),
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.onerror = function(xhr) {
                error(
                    createResponse(
                        'error',
                        xhr.status,
                        onerror(xhr.response) || xhr.statusText,
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.ontimeout = createTimeoutResponse(error);
            request.onprogress = progress;
            request.onabort = abort;

            // should return request
            return request;
        };
    };

    var createProcessorFunction = function createProcessorFunction() {
        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var action = arguments.length > 1 ? arguments[1] : undefined;
        var name = arguments.length > 2 ? arguments[2] : undefined;
        var options = arguments.length > 3 ? arguments[3] : undefined;

        // custom handler (should also handle file, load, error, progress and abort)
        if (typeof action === 'function')
            return function() {
                for (
                    var _len = arguments.length, params = new Array(_len), _key = 0;
                    _key < _len;
                    _key++
                ) {
                    params[_key] = arguments[_key];
                }
                return action.apply(void 0, [name].concat(params, [options]));
            };

        // no action supplied
        if (!action || !isString(action.url)) return null;

        // internal handler
        return createFileProcessorFunction(apiUrl, action, name, options);
    };

    /*
                                                      function signature:
                                                      (uniqueFileId, load, error) => { }
                                                      */
    var createRevertFunction = function createRevertFunction() {
        var apiUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var action = arguments.length > 1 ? arguments[1] : undefined;
        // is custom implementation
        if (typeof action === 'function') {
            return action;
        }

        // no action supplied, return stub function, interface will work, but file won't be removed
        if (!action || !isString(action.url)) {
            return function(uniqueFileId, load) {
                return load();
            };
        }

        // set onload hanlder
        var onload =
            action.onload ||
            function(res) {
                return res;
            };
        var onerror =
            action.onerror ||
            function(res) {
                return null;
            };

        // internal implementation
        return function(uniqueFileId, load, error) {
            var request = sendRequest(
                uniqueFileId,
                apiUrl + action.url,
                action // contains method, headers and withCredentials properties
            );
            request.onload = function(xhr) {
                load(
                    createResponse(
                        'load',
                        xhr.status,
                        onload(xhr.response),
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.onerror = function(xhr) {
                error(
                    createResponse(
                        'error',
                        xhr.status,
                        onerror(xhr.response) || xhr.statusText,
                        xhr.getAllResponseHeaders()
                    )
                );
            };

            request.ontimeout = createTimeoutResponse(error);

            return request;
        };
    };

    var getRandomNumber = function getRandomNumber() {
        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return min + Math.random() * (max - min);
    };

    var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(cb) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var tickMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;
        var tickMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
        var timeout = null;
        var start = Date.now();

        var tick = function tick() {
            var runtime = Date.now() - start;
            var delay = getRandomNumber(tickMin, tickMax);

            if (runtime + delay > duration) {
                delay = runtime + delay - duration;
            }

            var progress = runtime / duration;
            if (progress >= 1 || document.hidden) {
                cb(1);
                return;
            }

            cb(progress);

            timeout = setTimeout(tick, delay);
        };

        if (duration > 0) tick();

        return {
            clear: function clear() {
                clearTimeout(timeout);
            },
        };
    };

    var createFileProcessor = function createFileProcessor(processFn, options) {
        var state = {
            complete: false,
            perceivedProgress: 0,
            perceivedPerformanceUpdater: null,
            progress: null,
            timestamp: null,
            perceivedDuration: 0,
            duration: 0,
            request: null,
            response: null,
        };
        var allowMinimumUploadDuration = options.allowMinimumUploadDuration;

        var process = function process(file, metadata) {
            var progressFn = function progressFn() {
                // we've not yet started the real download, stop here
                // the request might not go through, for instance, there might be some server trouble
                // if state.progress is null, the server does not allow computing progress and we show the spinner instead
                if (state.duration === 0 || state.progress === null) return;

                // as we're now processing, fire the progress event
                api.fire('progress', api.getProgress());
            };

            var completeFn = function completeFn() {
                state.complete = true;
                api.fire('load-perceived', state.response.body);
            };

            // let's start processing
            api.fire('start');

            // set request start
            state.timestamp = Date.now();

            // create perceived performance progress indicator
            state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(
                function(progress) {
                    state.perceivedProgress = progress;
                    state.perceivedDuration = Date.now() - state.timestamp;

                    progressFn();

                    // if fake progress is done, and a response has been received,
                    // and we've not yet called the complete method
                    if (state.response && state.perceivedProgress === 1 && !state.complete) {
                        // we done!
                        completeFn();
                    }
                },
                // random delay as in a list of files you start noticing
                // files uploading at the exact same speed
                allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0
            );

            // remember request so we can abort it later
            state.request = processFn(
                // the file to process
                file,

                // the metadata to send along
                metadata,

                // callbacks (load, error, progress, abort, transfer)
                // load expects the body to be a server id if
                // you want to make use of revert
                function(response) {
                    // we put the response in state so we can access
                    // it outside of this method
                    state.response = isObject(response)
                        ? response
                        : {
                              type: 'load',
                              code: 200,
                              body: '' + response,
                              headers: {},
                          };

                    // update duration
                    state.duration = Date.now() - state.timestamp;

                    // force progress to 1 as we're now done
                    state.progress = 1;

                    // actual load is done let's share results
                    api.fire('load', state.response.body);

                    // we are really done
                    // if perceived progress is 1 ( wait for perceived progress to complete )
                    // or if server does not support progress ( null )
                    if (
                        !allowMinimumUploadDuration ||
                        (allowMinimumUploadDuration && state.perceivedProgress === 1)
                    ) {
                        completeFn();
                    }
                },

                // error is expected to be an object with type, code, body
                function(error) {
                    // cancel updater
                    state.perceivedPerformanceUpdater.clear();

                    // update others about this error
                    api.fire(
                        'error',
                        isObject(error)
                            ? error
                            : {
                                  type: 'error',
                                  code: 0,
                                  body: '' + error,
                              }
                    );
                },

                // actual processing progress
                function(computable, current, total) {
                    // update actual duration
                    state.duration = Date.now() - state.timestamp;

                    // update actual progress
                    state.progress = computable ? current / total : null;

                    progressFn();
                },

                // abort does not expect a value
                function() {
                    // stop updater
                    state.perceivedPerformanceUpdater.clear();

                    // fire the abort event so we can switch visuals
                    api.fire('abort', state.response ? state.response.body : null);
                },

                // register the id for this transfer
                function(transferId) {
                    api.fire('transfer', transferId);
                }
            );
        };

        var abort = function abort() {
            // no request running, can't abort
            if (!state.request) return;

            // stop updater
            state.perceivedPerformanceUpdater.clear();

            // abort actual request
            if (state.request.abort) state.request.abort();

            // if has response object, we've completed the request
            state.complete = true;
        };

        var reset = function reset() {
            abort();
            state.complete = false;
            state.perceivedProgress = 0;
            state.progress = 0;
            state.timestamp = null;
            state.perceivedDuration = 0;
            state.duration = 0;
            state.request = null;
            state.response = null;
        };

        var getProgress = allowMinimumUploadDuration
            ? function() {
                  return state.progress ? Math.min(state.progress, state.perceivedProgress) : null;
              }
            : function() {
                  return state.progress || null;
              };

        var getDuration = allowMinimumUploadDuration
            ? function() {
                  return Math.min(state.duration, state.perceivedDuration);
              }
            : function() {
                  return state.duration;
              };

        var api = Object.assign({}, on(), {
            process: process, // start processing file
            abort: abort, // abort active process request
            getProgress: getProgress,
            getDuration: getDuration,
            reset: reset,
        });

        return api;
    };

    var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {
        return name.substr(0, name.lastIndexOf('.')) || name;
    };

    var createFileStub = function createFileStub(source) {
        var data = [source.name, source.size, source.type];

        // is blob or base64, then we need to set the name
        if (source instanceof Blob || isBase64DataURI(source)) {
            data[0] = source.name || getDateString();
        } else if (isBase64DataURI(source)) {
            // if is base64 data uri we need to determine the average size and type
            data[1] = source.length;
            data[2] = getMimeTypeFromBase64DataURI(source);
        } else if (isString(source)) {
            // url
            data[0] = getFilenameFromURL(source);
            data[1] = 0;
            data[2] = 'application/octet-stream';
        }

        return {
            name: data[0],
            size: data[1],
            type: data[2],
        };
    };

    var isFile = function isFile(value) {
        return !!(value instanceof File || (value instanceof Blob && value.name));
    };

    var deepCloneObject = function deepCloneObject(src) {
        if (!isObject(src)) return src;
        var target = isArray(src) ? [] : {};
        for (var key in src) {
            if (!src.hasOwnProperty(key)) continue;
            var v = src[key];
            target[key] = v && isObject(v) ? deepCloneObject(v) : v;
        }
        return target;
    };

    var createItem = function createItem() {
        var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var serverFileReference =
            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // unique id for this item, is used to identify the item across views
        var id = getUniqueId();

        /**
         * Internal item state
         */
        var state = {
            // is archived
            archived: false,

            // if is frozen, no longer fires events
            frozen: false,

            // removed from view
            released: false,

            // original source
            source: null,

            // file model reference
            file: file,

            // id of file on server
            serverFileReference: serverFileReference,

            // id of file transfer on server
            transferId: null,

            // is aborted
            processingAborted: false,

            // current item status
            status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,

            // active processes
            activeLoader: null,
            activeProcessor: null,
        };

        // callback used when abort processing is called to link back to the resolve method
        var abortProcessingRequestComplete = null;

        /**
         * Externally added item metadata
         */
        var metadata = {};

        // item data
        var setStatus = function setStatus(status) {
            return (state.status = status);
        };

        // fire event unless the item has been archived
        var fire = function fire(event) {
            if (state.released || state.frozen) return;
            for (
                var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
                _key < _len;
                _key++
            ) {
                params[_key - 1] = arguments[_key];
            }
            api.fire.apply(api, [event].concat(params));
        };

        // file data
        var getFileExtension = function getFileExtension() {
            return getExtensionFromFilename(state.file.name);
        };
        var getFileType = function getFileType() {
            return state.file.type;
        };
        var getFileSize = function getFileSize() {
            return state.file.size;
        };
        var getFile = function getFile() {
            return state.file;
        };

        //
        // logic to load a file
        //
        var load = function load(source, loader, onload) {
            // remember the original item source
            state.source = source;

            // source is known
            api.fireSync('init');

            // file stub is already there
            if (state.file) {
                api.fireSync('load-skip');
                return;
            }

            // set a stub file object while loading the actual data
            state.file = createFileStub(source);

            // starts loading
            loader.on('init', function() {
                fire('load-init');
            });

            // we'eve received a size indication, let's update the stub
            loader.on('meta', function(meta) {
                // set size of file stub
                state.file.size = meta.size;

                // set name of file stub
                state.file.filename = meta.filename;

                // if has received source, we done
                if (meta.source) {
                    origin = FileOrigin.LIMBO;
                    state.serverFileReference = meta.source;
                    state.status = ItemStatus.PROCESSING_COMPLETE;
                }

                // size has been updated
                fire('load-meta');
            });

            // the file is now loading we need to update the progress indicators
            loader.on('progress', function(progress) {
                setStatus(ItemStatus.LOADING);

                fire('load-progress', progress);
            });

            // an error was thrown while loading the file, we need to switch to error state
            loader.on('error', function(error) {
                setStatus(ItemStatus.LOAD_ERROR);

                fire('load-request-error', error);
            });

            // user or another process aborted the file load (cannot retry)
            loader.on('abort', function() {
                setStatus(ItemStatus.INIT);
                fire('load-abort');
            });

            // done loading
            loader.on('load', function(file) {
                // as we've now loaded the file the loader is no longer required
                state.activeLoader = null;

                // called when file has loaded succesfully
                var success = function success(result) {
                    // set (possibly) transformed file
                    state.file = isFile(result) ? result : state.file;

                    // file received
                    if (origin === FileOrigin.LIMBO && state.serverFileReference) {
                        setStatus(ItemStatus.PROCESSING_COMPLETE);
                    } else {
                        setStatus(ItemStatus.IDLE);
                    }

                    fire('load');
                };

                var error = function error(result) {
                    // set original file
                    state.file = file;
                    fire('load-meta');

                    setStatus(ItemStatus.LOAD_ERROR);
                    fire('load-file-error', result);
                };

                // if we already have a server file reference, we don't need to call the onload method
                if (state.serverFileReference) {
                    success(file);
                    return;
                }

                // no server id, let's give this file the full treatment
                onload(file, success, error);
            });

            // set loader source data
            loader.setSource(source);

            // set as active loader
            state.activeLoader = loader;

            // load the source data
            loader.load();
        };

        var retryLoad = function retryLoad() {
            if (!state.activeLoader) {
                return;
            }
            state.activeLoader.load();
        };

        var abortLoad = function abortLoad() {
            if (state.activeLoader) {
                state.activeLoader.abort();
                return;
            }
            setStatus(ItemStatus.INIT);
            fire('load-abort');
        };

        //
        // logic to process a file
        //
        var process = function process(processor, onprocess) {
            // processing was aborted
            if (state.processingAborted) {
                state.processingAborted = false;
                return;
            }

            // now processing
            setStatus(ItemStatus.PROCESSING);

            // reset abort callback
            abortProcessingRequestComplete = null;

            // if no file loaded we'll wait for the load event
            if (!(state.file instanceof Blob)) {
                api.on('load', function() {
                    process(processor, onprocess);
                });
                return;
            }

            // setup processor
            processor.on('load', function(serverFileReference) {
                // need this id to be able to revert the upload
                state.transferId = null;
                state.serverFileReference = serverFileReference;
            });

            // register transfer id
            processor.on('transfer', function(transferId) {
                // need this id to be able to revert the upload
                state.transferId = transferId;
            });

            processor.on('load-perceived', function(serverFileReference) {
                // no longer required
                state.activeProcessor = null;

                // need this id to be able to rever the upload
                state.transferId = null;
                state.serverFileReference = serverFileReference;

                setStatus(ItemStatus.PROCESSING_COMPLETE);
                fire('process-complete', serverFileReference);
            });

            processor.on('start', function() {
                fire('process-start');
            });

            processor.on('error', function(error) {
                state.activeProcessor = null;
                setStatus(ItemStatus.PROCESSING_ERROR);
                fire('process-error', error);
            });

            processor.on('abort', function(serverFileReference) {
                state.activeProcessor = null;

                // if file was uploaded but processing was cancelled during perceived processor time store file reference
                state.serverFileReference = serverFileReference;

                setStatus(ItemStatus.IDLE);
                fire('process-abort');

                // has timeout so doesn't interfere with remove action
                if (abortProcessingRequestComplete) {
                    abortProcessingRequestComplete();
                }
            });

            processor.on('progress', function(progress) {
                fire('process-progress', progress);
            });

            // when successfully transformed
            var success = function success(file) {
                // if was archived in the mean time, don't process
                if (state.archived) return;

                // process file!
                processor.process(file, Object.assign({}, metadata));
            };

            // something went wrong during transform phase
            var error = console.error;

            // start processing the file
            onprocess(state.file, success, error);

            // set as active processor
            state.activeProcessor = processor;
        };

        var requestProcessing = function requestProcessing() {
            state.processingAborted = false;
            setStatus(ItemStatus.PROCESSING_QUEUED);
        };

        var abortProcessing = function abortProcessing() {
            return new Promise(function(resolve) {
                if (!state.activeProcessor) {
                    state.processingAborted = true;

                    setStatus(ItemStatus.IDLE);
                    fire('process-abort');

                    resolve();
                    return;
                }

                abortProcessingRequestComplete = function abortProcessingRequestComplete() {
                    resolve();
                };

                state.activeProcessor.abort();
            });
        };

        //
        // logic to revert a processed file
        //
        var revert = function revert(revertFileUpload, forceRevert) {
            return new Promise(function(resolve, reject) {
                // a completed upload will have a serverFileReference, a failed chunked upload where
                // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set
                var serverTransferId =
                    state.serverFileReference !== null
                        ? state.serverFileReference
                        : state.transferId;

                // cannot revert without a server id for this process
                if (serverTransferId === null) {
                    resolve();
                    return;
                }

                // revert the upload (fire and forget)
                revertFileUpload(
                    serverTransferId,
                    function() {
                        // reset file server id and transfer id as now it's not available on the server
                        state.serverFileReference = null;
                        state.transferId = null;
                        resolve();
                    },
                    function(error) {
                        // don't set error state when reverting is optional, it will always resolve
                        if (!forceRevert) {
                            resolve();
                            return;
                        }

                        // oh no errors
                        setStatus(ItemStatus.PROCESSING_REVERT_ERROR);
                        fire('process-revert-error');
                        reject(error);
                    }
                );

                // fire event
                setStatus(ItemStatus.IDLE);
                fire('process-revert');
            });
        };

        // exposed methods
        var _setMetadata = function setMetadata(key, value, silent) {
            var keys = key.split('.');
            var root = keys[0];
            var last = keys.pop();
            var data = metadata;
            keys.forEach(function(key) {
                return (data = data[key]);
            });

            // compare old value against new value, if they're the same, we're not updating
            if (JSON.stringify(data[last]) === JSON.stringify(value)) return;

            // update value
            data[last] = value;

            // fire update
            fire('metadata-update', {
                key: root,
                value: metadata[root],
                silent: silent,
            });
        };

        var getMetadata = function getMetadata(key) {
            return deepCloneObject(key ? metadata[key] : metadata);
        };

        var api = Object.assign(
            {
                id: {
                    get: function get() {
                        return id;
                    },
                },
                origin: {
                    get: function get() {
                        return origin;
                    },
                    set: function set(value) {
                        return (origin = value);
                    },
                },
                serverId: {
                    get: function get() {
                        return state.serverFileReference;
                    },
                },
                transferId: {
                    get: function get() {
                        return state.transferId;
                    },
                },
                status: {
                    get: function get() {
                        return state.status;
                    },
                },
                filename: {
                    get: function get() {
                        return state.file.name;
                    },
                },
                filenameWithoutExtension: {
                    get: function get() {
                        return getFilenameWithoutExtension(state.file.name);
                    },
                },
                fileExtension: { get: getFileExtension },
                fileType: { get: getFileType },
                fileSize: { get: getFileSize },
                file: { get: getFile },
                relativePath: {
                    get: function get() {
                        return state.file._relativePath;
                    },
                },

                source: {
                    get: function get() {
                        return state.source;
                    },
                },

                getMetadata: getMetadata,
                setMetadata: function setMetadata(key, value, silent) {
                    if (isObject(key)) {
                        var data = key;
                        Object.keys(data).forEach(function(key) {
                            _setMetadata(key, data[key], value);
                        });
                        return key;
                    }
                    _setMetadata(key, value, silent);
                    return value;
                },

                extend: function extend(name, handler) {
                    return (itemAPI[name] = handler);
                },

                abortLoad: abortLoad,
                retryLoad: retryLoad,
                requestProcessing: requestProcessing,
                abortProcessing: abortProcessing,

                load: load,
                process: process,
                revert: revert,
            },

            on(),
            {
                freeze: function freeze() {
                    return (state.frozen = true);
                },

                release: function release() {
                    return (state.released = true);
                },
                released: {
                    get: function get() {
                        return state.released;
                    },
                },

                archive: function archive() {
                    return (state.archived = true);
                },
                archived: {
                    get: function get() {
                        return state.archived;
                    },
                },
            }
        );

        // create it here instead of returning it instantly so we can extend it later
        var itemAPI = createObject(api);

        return itemAPI;
    };

    var getItemIndexByQuery = function getItemIndexByQuery(items, query) {
        // just return first index
        if (isEmpty(query)) {
            return 0;
        }

        // invalid queries
        if (!isString(query)) {
            return -1;
        }

        // return item by id (or -1 if not found)
        return items.findIndex(function(item) {
            return item.id === query;
        });
    };

    var getItemById = function getItemById(items, itemId) {
        var index = getItemIndexByQuery(items, itemId);
        if (index < 0) {
            return;
        }
        return items[index] || null;
    };

    var fetchBlob = function fetchBlob(url, load, error, progress, abort, headers) {
        var request = sendRequest(null, url, {
            method: 'GET',
            responseType: 'blob',
        });

        request.onload = function(xhr) {
            // get headers
            var headers = xhr.getAllResponseHeaders();

            // get filename
            var filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);

            // create response
            load(
                createResponse('load', xhr.status, getFileFromBlob(xhr.response, filename), headers)
            );
        };

        request.onerror = function(xhr) {
            error(createResponse('error', xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));
        };

        request.onheaders = function(xhr) {
            headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));
        };

        request.ontimeout = createTimeoutResponse(error);
        request.onprogress = progress;
        request.onabort = abort;

        // should return request
        return request;
    };

    var getDomainFromURL = function getDomainFromURL(url) {
        if (url.indexOf('//') === 0) {
            url = location.protocol + url;
        }
        return url
            .toLowerCase()
            .replace('blob:', '')
            .replace(/([a-z])?:\/\//, '$1')
            .split('/')[0];
    };

    var isExternalURL = function isExternalURL(url) {
        return (
            (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&
            getDomainFromURL(location.href) !== getDomainFromURL(url)
        );
    };

    var dynamicLabel = function dynamicLabel(label) {
        return function() {
            return isFunction(label) ? label.apply(void 0, arguments) : label;
        };
    };

    var isMockItem = function isMockItem(item) {
        return !isFile(item.file);
    };

    var listUpdated = function listUpdated(dispatch, state) {
        clearTimeout(state.listUpdateTimeout);
        state.listUpdateTimeout = setTimeout(function() {
            dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });
        }, 0);
    };

    var optionalPromise = function optionalPromise(fn) {
        for (
            var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
            _key < _len;
            _key++
        ) {
            params[_key - 1] = arguments[_key];
        }
        return new Promise(function(resolve) {
            if (!fn) {
                return resolve(true);
            }

            var result = fn.apply(void 0, params);

            if (result == null) {
                return resolve(true);
            }

            if (typeof result === 'boolean') {
                return resolve(result);
            }

            if (typeof result.then === 'function') {
                result.then(resolve);
            }
        });
    };

    var sortItems = function sortItems(state, compare) {
        state.items.sort(function(a, b) {
            return compare(createItemAPI(a), createItemAPI(b));
        });
    };

    // returns item based on state
    var getItemByQueryFromState = function getItemByQueryFromState(state, itemHandler) {
        return function() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var query = _ref.query,
                _ref$success = _ref.success,
                success = _ref$success === void 0 ? function() {} : _ref$success,
                _ref$failure = _ref.failure,
                failure = _ref$failure === void 0 ? function() {} : _ref$failure,
                options = _objectWithoutProperties(_ref, ['query', 'success', 'failure']);
            var item = getItemByQuery(state.items, query);
            if (!item) {
                failure({
                    error: createResponse('error', 0, 'Item not found'),
                    file: null,
                });

                return;
            }
            itemHandler(item, success, failure, options || {});
        };
    };

    var actions = function actions(dispatch, query, state) {
        return {
            /**
             * Aborts all ongoing processes
             */
            ABORT_ALL: function ABORT_ALL() {
                getActiveItems(state.items).forEach(function(item) {
                    item.freeze();
                    item.abortLoad();
                    item.abortProcessing();
                });
            },

            /**
             * Sets initial files
             */
            DID_SET_FILES: function DID_SET_FILES(_ref2) {
                var _ref2$value = _ref2.value,
                    value = _ref2$value === void 0 ? [] : _ref2$value;
                // map values to file objects
                var files = value.map(function(file) {
                    return {
                        source: file.source ? file.source : file,
                        options: file.options,
                    };
                });

                // loop over files, if file is in list, leave it be, if not, remove
                // test if items should be moved
                var activeItems = getActiveItems(state.items);

                activeItems.forEach(function(item) {
                    // if item not is in new value, remove
                    if (
                        !files.find(function(file) {
                            return file.source === item.source || file.source === item.file;
                        })
                    ) {
                        dispatch('REMOVE_ITEM', { query: item, remove: false });
                    }
                });

                // add new files
                activeItems = getActiveItems(state.items);
                files.forEach(function(file, index) {
                    // if file is already in list
                    if (
                        activeItems.find(function(item) {
                            return item.source === file.source || item.file === file.source;
                        })
                    )
                        return;

                    // not in list, add
                    dispatch(
                        'ADD_ITEM',
                        Object.assign({}, file, {
                            interactionMethod: InteractionMethod.NONE,
                            index: index,
                        })
                    );
                });
            },

            DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {
                var id = _ref3.id,
                    action = _ref3.action,
                    change = _ref3.change;
                // don't do anything
                if (change.silent) return;

                // if is called multiple times in close succession we combined all calls together to save resources
                clearTimeout(state.itemUpdateTimeout);
                state.itemUpdateTimeout = setTimeout(function() {
                    var item = getItemById(state.items, id);

                    // only revert and attempt to upload when we're uploading to a server
                    if (!query('IS_ASYNC')) {
                        // should we update the output data
                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {
                            item: item,
                            query: query,
                            action: action,
                            change: change,
                        }).then(function(shouldPrepareOutput) {
                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook
                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');
                            if (beforePrepareFile)
                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);

                            if (!shouldPrepareOutput) return;

                            dispatch(
                                'REQUEST_PREPARE_OUTPUT',
                                {
                                    query: id,
                                    item: item,
                                    success: function success(file) {
                                        dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });
                                    },
                                },

                                true
                            );
                        });

                        return;
                    }

                    // if is local item we need to enable upload button so change can be propagated to server
                    if (item.origin === FileOrigin.LOCAL) {
                        dispatch('DID_LOAD_ITEM', {
                            id: item.id,
                            error: null,
                            serverFileReference: item.source,
                        });
                    }

                    // for async scenarios
                    var upload = function upload() {
                        // we push this forward a bit so the interface is updated correctly
                        setTimeout(function() {
                            dispatch('REQUEST_ITEM_PROCESSING', { query: id });
                        }, 32);
                    };

                    var revert = function revert(doUpload) {
                        item.revert(
                            createRevertFunction(
                                state.options.server.url,
                                state.options.server.revert
                            ),
                            query('GET_FORCE_REVERT')
                        )
                            .then(doUpload ? upload : function() {})
                            .catch(function() {});
                    };

                    var abort = function abort(doUpload) {
                        item.abortProcessing().then(doUpload ? upload : function() {});
                    };

                    // if we should re-upload the file immediately
                    if (item.status === ItemStatus.PROCESSING_COMPLETE) {
                        return revert(state.options.instantUpload);
                    }

                    // if currently uploading, cancel upload
                    if (item.status === ItemStatus.PROCESSING) {
                        return abort(state.options.instantUpload);
                    }

                    if (state.options.instantUpload) {
                        upload();
                    }
                }, 0);
            },

            MOVE_ITEM: function MOVE_ITEM(_ref4) {
                var query = _ref4.query,
                    index = _ref4.index;
                var item = getItemByQuery(state.items, query);
                if (!item) return;
                var currentIndex = state.items.indexOf(item);
                index = limit(index, 0, state.items.length - 1);
                if (currentIndex === index) return;
                state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);
            },

            SORT: function SORT(_ref5) {
                var compare = _ref5.compare;
                sortItems(state, compare);
                dispatch('DID_SORT_ITEMS', {
                    items: query('GET_ACTIVE_ITEMS'),
                });
            },

            ADD_ITEMS: function ADD_ITEMS(_ref6) {
                var items = _ref6.items,
                    index = _ref6.index,
                    interactionMethod = _ref6.interactionMethod,
                    _ref6$success = _ref6.success,
                    success = _ref6$success === void 0 ? function() {} : _ref6$success,
                    _ref6$failure = _ref6.failure,
                    failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;
                var currentIndex = index;

                if (index === -1 || typeof index === 'undefined') {
                    var insertLocation = query('GET_ITEM_INSERT_LOCATION');
                    var totalItems = query('GET_TOTAL_ITEMS');
                    currentIndex = insertLocation === 'before' ? 0 : totalItems;
                }

                var ignoredFiles = query('GET_IGNORED_FILES');
                var isValidFile = function isValidFile(source) {
                    return isFile(source)
                        ? !ignoredFiles.includes(source.name.toLowerCase())
                        : !isEmpty(source);
                };
                var validItems = items.filter(isValidFile);

                var promises = validItems.map(function(source) {
                    return new Promise(function(resolve, reject) {
                        dispatch('ADD_ITEM', {
                            interactionMethod: interactionMethod,
                            source: source.source || source,
                            success: resolve,
                            failure: reject,
                            index: currentIndex++,
                            options: source.options || {},
                        });
                    });
                });

                Promise.all(promises)
                    .then(success)
                    .catch(failure);
            },

            /**
             * @param source
             * @param index
             * @param interactionMethod
             */
            ADD_ITEM: function ADD_ITEM(_ref7) {
                var source = _ref7.source,
                    _ref7$index = _ref7.index,
                    index = _ref7$index === void 0 ? -1 : _ref7$index,
                    interactionMethod = _ref7.interactionMethod,
                    _ref7$success = _ref7.success,
                    success = _ref7$success === void 0 ? function() {} : _ref7$success,
                    _ref7$failure = _ref7.failure,
                    failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,
                    _ref7$options = _ref7.options,
                    options = _ref7$options === void 0 ? {} : _ref7$options;
                // if no source supplied
                if (isEmpty(source)) {
                    failure({
                        error: createResponse('error', 0, 'No source'),
                        file: null,
                    });

                    return;
                }

                // filter out invalid file items, used to filter dropped directory contents
                if (
                    isFile(source) &&
                    state.options.ignoredFiles.includes(source.name.toLowerCase())
                ) {
                    // fail silently
                    return;
                }

                // test if there's still room in the list of files
                if (!hasRoomForItem(state)) {
                    // if multiple allowed, we can't replace
                    // or if only a single item is allowed but we're not allowed to replace it we exit
                    if (
                        state.options.allowMultiple ||
                        (!state.options.allowMultiple && !state.options.allowReplace)
                    ) {
                        var error = createResponse('warning', 0, 'Max files');

                        dispatch('DID_THROW_MAX_FILES', {
                            source: source,
                            error: error,
                        });

                        failure({ error: error, file: null });

                        return;
                    }

                    // let's replace the item
                    // id of first item we're about to remove
                    var _item = getActiveItems(state.items)[0];

                    // if has been processed remove it from the server as well
                    if (
                        _item.status === ItemStatus.PROCESSING_COMPLETE ||
                        _item.status === ItemStatus.PROCESSING_REVERT_ERROR
                    ) {
                        var forceRevert = query('GET_FORCE_REVERT');
                        _item
                            .revert(
                                createRevertFunction(
                                    state.options.server.url,
                                    state.options.server.revert
                                ),
                                forceRevert
                            )
                            .then(function() {
                                if (!forceRevert) return;

                                // try to add now
                                dispatch('ADD_ITEM', {
                                    source: source,
                                    index: index,
                                    interactionMethod: interactionMethod,
                                    success: success,
                                    failure: failure,
                                    options: options,
                                });
                            })
                            .catch(function() {}); // no need to handle this catch state for now

                        if (forceRevert) return;
                    }

                    // remove first item as it will be replaced by this item
                    dispatch('REMOVE_ITEM', { query: _item.id });
                }

                // where did the file originate
                var origin =
                    options.type === 'local'
                        ? FileOrigin.LOCAL
                        : options.type === 'limbo'
                        ? FileOrigin.LIMBO
                        : FileOrigin.INPUT;

                // create a new blank item
                var item = createItem(
                    // where did this file come from
                    origin,

                    // an input file never has a server file reference
                    origin === FileOrigin.INPUT ? null : source,

                    // file mock data, if defined
                    options.file
                );

                // set initial meta data
                Object.keys(options.metadata || {}).forEach(function(key) {
                    item.setMetadata(key, options.metadata[key]);
                });

                // created the item, let plugins add methods
                applyFilters('DID_CREATE_ITEM', item, { query: query, dispatch: dispatch });

                // where to insert new items
                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');

                // adjust index if is not allowed to pick location
                if (!state.options.itemInsertLocationFreedom) {
                    index = itemInsertLocation === 'before' ? -1 : state.items.length;
                }

                // add item to list
                insertItem(state.items, item, index);

                // sort items in list
                if (isFunction(itemInsertLocation) && source) {
                    sortItems(state, itemInsertLocation);
                }

                // get a quick reference to the item id
                var id = item.id;

                // observe item events
                item.on('init', function() {
                    dispatch('DID_INIT_ITEM', { id: id });
                });

                item.on('load-init', function() {
                    dispatch('DID_START_ITEM_LOAD', { id: id });
                });

                item.on('load-meta', function() {
                    dispatch('DID_UPDATE_ITEM_META', { id: id });
                });

                item.on('load-progress', function(progress) {
                    dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', { id: id, progress: progress });
                });

                item.on('load-request-error', function(error) {
                    var mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);

                    // is client error, no way to recover
                    if (error.code >= 400 && error.code < 500) {
                        dispatch('DID_THROW_ITEM_INVALID', {
                            id: id,
                            error: error,
                            status: {
                                main: mainStatus,
                                sub: error.code + ' (' + error.body + ')',
                            },
                        });

                        // reject the file so can be dealt with through API
                        failure({ error: error, file: createItemAPI(item) });
                        return;
                    }

                    // is possible server error, so might be possible to retry
                    dispatch('DID_THROW_ITEM_LOAD_ERROR', {
                        id: id,
                        error: error,
                        status: {
                            main: mainStatus,
                            sub: state.options.labelTapToRetry,
                        },
                    });
                });

                item.on('load-file-error', function(error) {
                    dispatch('DID_THROW_ITEM_INVALID', {
                        id: id,
                        error: error.status,
                        status: error.status,
                    });

                    failure({ error: error.status, file: createItemAPI(item) });
                });

                item.on('load-abort', function() {
                    dispatch('REMOVE_ITEM', { query: id });
                });

                item.on('load-skip', function() {
                    dispatch('COMPLETE_LOAD_ITEM', {
                        query: id,
                        item: item,
                        data: {
                            source: source,
                            success: success,
                        },
                    });
                });

                item.on('load', function() {
                    var handleAdd = function handleAdd(shouldAdd) {
                        // no should not add this file
                        if (!shouldAdd) {
                            dispatch('REMOVE_ITEM', {
                                query: id,
                            });

                            return;
                        }

                        // now interested in metadata updates
                        item.on('metadata-update', function(change) {
                            dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });
                        });

                        // let plugins decide if the output data should be prepared at this point
                        // means we'll do this and wait for idle state
                        applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {
                            item: item,
                            query: query,
                        }).then(function(shouldPrepareOutput) {
                            // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook
                            var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');
                            if (beforePrepareFile)
                                shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);

                            var loadComplete = function loadComplete() {
                                dispatch('COMPLETE_LOAD_ITEM', {
                                    query: id,
                                    item: item,
                                    data: {
                                        source: source,
                                        success: success,
                                    },
                                });

                                listUpdated(dispatch, state);
                            };

                            // exit
                            if (shouldPrepareOutput) {
                                // wait for idle state and then run PREPARE_OUTPUT
                                dispatch(
                                    'REQUEST_PREPARE_OUTPUT',
                                    {
                                        query: id,
                                        item: item,
                                        success: function success(file) {
                                            dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });
                                            loadComplete();
                                        },
                                    },

                                    true
                                );

                                return;
                            }

                            loadComplete();
                        });
                    };

                    // item loaded, allow plugins to
                    // - read data (quickly)
                    // - add metadata
                    applyFilterChain('DID_LOAD_ITEM', item, { query: query, dispatch: dispatch })
                        .then(function() {
                            optionalPromise(query('GET_BEFORE_ADD_FILE'), createItemAPI(item)).then(
                                handleAdd
                            );
                        })
                        .catch(function(e) {
                            if (!e || !e.error || !e.status) return handleAdd(false);
                            dispatch('DID_THROW_ITEM_INVALID', {
                                id: id,
                                error: e.error,
                                status: e.status,
                            });
                        });
                });

                item.on('process-start', function() {
                    dispatch('DID_START_ITEM_PROCESSING', { id: id });
                });

                item.on('process-progress', function(progress) {
                    dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', { id: id, progress: progress });
                });

                item.on('process-error', function(error) {
                    dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {
                        id: id,
                        error: error,
                        status: {
                            main: dynamicLabel(state.options.labelFileProcessingError)(error),
                            sub: state.options.labelTapToRetry,
                        },
                    });
                });

                item.on('process-revert-error', function(error) {
                    dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {
                        id: id,
                        error: error,
                        status: {
                            main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),
                            sub: state.options.labelTapToRetry,
                        },
                    });
                });

                item.on('process-complete', function(serverFileReference) {
                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {
                        id: id,
                        error: null,
                        serverFileReference: serverFileReference,
                    });

                    dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });
                });

                item.on('process-abort', function() {
                    dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });
                });

                item.on('process-revert', function() {
                    dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });
                    dispatch('DID_DEFINE_VALUE', { id: id, value: null });
                });

                // let view know the item has been inserted
                dispatch('DID_ADD_ITEM', {
                    id: id,
                    index: index,
                    interactionMethod: interactionMethod,
                });

                listUpdated(dispatch, state);

                // start loading the source
                var _ref8 = state.options.server || {},
                    url = _ref8.url,
                    load = _ref8.load,
                    restore = _ref8.restore,
                    fetch = _ref8.fetch;

                item.load(
                    source,

                    // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)
                    createFileLoader(
                        origin === FileOrigin.INPUT
                            ? // input, if is remote, see if should use custom fetch, else use default fetchBlob
                              isString(source) && isExternalURL(source)
                                ? fetch
                                    ? createFetchFunction(url, fetch)
                                    : fetchBlob // remote url
                                : fetchBlob // try to fetch url
                            : // limbo or local
                            origin === FileOrigin.LIMBO
                            ? createFetchFunction(url, restore) // limbo
                            : createFetchFunction(url, load) // local
                    ),

                    // called when the file is loaded so it can be piped through the filters
                    function(file, success, error) {
                        // let's process the file
                        applyFilterChain('LOAD_FILE', file, { query: query })
                            .then(success)
                            .catch(error);
                    }
                );
            },

            REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {
                var item = _ref9.item,
                    success = _ref9.success,
                    _ref9$failure = _ref9.failure,
                    failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;
                // error response if item archived
                var err = {
                    error: createResponse('error', 0, 'Item not found'),
                    file: null,
                };

                // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared
                if (item.archived) return failure(err);

                // allow plugins to alter the file data
                applyFilterChain('PREPARE_OUTPUT', item.file, { query: query, item: item }).then(
                    function(result) {
                        applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {
                            query: query,
                            item: item,
                        }).then(function(result) {
                            // don't handle archived items, an item could have been archived (load aborted) while being prepared
                            if (item.archived) return failure(err);

                            // we done!
                            success(result);
                        });
                    }
                );
            },

            COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {
                var item = _ref10.item,
                    data = _ref10.data;
                var success = data.success,
                    source = data.source;

                // sort items in list
                var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');
                if (isFunction(itemInsertLocation) && source) {
                    sortItems(state, itemInsertLocation);
                }

                // let interface know the item has loaded
                dispatch('DID_LOAD_ITEM', {
                    id: item.id,
                    error: null,
                    serverFileReference: item.origin === FileOrigin.INPUT ? null : source,
                });

                // item has been successfully loaded and added to the
                // list of items so can now be safely returned for use
                success(createItemAPI(item));

                // if this is a local server file we need to show a different state
                if (item.origin === FileOrigin.LOCAL) {
                    dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });
                    return;
                }

                // if is a temp server file we prevent async upload call here (as the file is already on the server)
                if (item.origin === FileOrigin.LIMBO) {
                    dispatch('DID_COMPLETE_ITEM_PROCESSING', {
                        id: item.id,
                        error: null,
                        serverFileReference: source,
                    });

                    dispatch('DID_DEFINE_VALUE', {
                        id: item.id,
                        value: item.serverId || source,
                    });

                    return;
                }

                // id we are allowed to upload the file immediately, lets do it
                if (query('IS_ASYNC') && state.options.instantUpload) {
                    dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });
                }
            },

            RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {
                // try loading the source one more time
                item.retryLoad();
            }),

            REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(item, _success, failure) {
                dispatch(
                    'REQUEST_PREPARE_OUTPUT',
                    {
                        query: item.id,
                        item: item,
                        success: function success(file) {
                            dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });
                            _success({
                                file: item,
                                output: file,
                            });
                        },
                        failure: failure,
                    },

                    true
                );
            }),

            REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(
                item,
                success,
                failure
            ) {
                // cannot be queued (or is already queued)
                var itemCanBeQueuedForProcessing =
                    // waiting for something
                    item.status === ItemStatus.IDLE ||
                    // processing went wrong earlier
                    item.status === ItemStatus.PROCESSING_ERROR;

                // not ready to be processed
                if (!itemCanBeQueuedForProcessing) {
                    var processNow = function processNow() {
                        return dispatch('REQUEST_ITEM_PROCESSING', {
                            query: item,
                            success: success,
                            failure: failure,
                        });
                    };

                    var process = function process() {
                        return document.hidden ? processNow() : setTimeout(processNow, 32);
                    };

                    // if already done processing or tried to revert but didn't work, try again
                    if (
                        item.status === ItemStatus.PROCESSING_COMPLETE ||
                        item.status === ItemStatus.PROCESSING_REVERT_ERROR
                    ) {
                        item.revert(
                            createRevertFunction(
                                state.options.server.url,
                                state.options.server.revert
                            ),
                            query('GET_FORCE_REVERT')
                        )
                            .then(process)
                            .catch(function() {}); // don't continue with processing if something went wrong
                    } else if (item.status === ItemStatus.PROCESSING) {
                        item.abortProcessing().then(process);
                    }

                    return;
                }

                // already queued for processing
                if (item.status === ItemStatus.PROCESSING_QUEUED) return;

                item.requestProcessing();

                dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });

                dispatch('PROCESS_ITEM', { query: item, success: success, failure: failure }, true);
            }),

            PROCESS_ITEM: getItemByQueryFromState(state, function(item, success, failure) {
                var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');
                var totalCurrentUploads = query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING)
                    .length;

                // queue and wait till queue is freed up
                if (totalCurrentUploads === maxParallelUploads) {
                    // queue for later processing
                    state.processingQueue.push({
                        id: item.id,
                        success: success,
                        failure: failure,
                    });

                    // stop it!
                    return;
                }

                // if was not queued or is already processing exit here
                if (item.status === ItemStatus.PROCESSING) return;

                var processNext = function processNext() {
                    // process queueud items
                    var queueEntry = state.processingQueue.shift();

                    // no items left
                    if (!queueEntry) return;

                    // get item reference
                    var id = queueEntry.id,
                        success = queueEntry.success,
                        failure = queueEntry.failure;
                    var itemReference = getItemByQuery(state.items, id);

                    // if item was archived while in queue, jump to next
                    if (!itemReference || itemReference.archived) {
                        processNext();
                        return;
                    }

                    // process queued item
                    dispatch(
                        'PROCESS_ITEM',
                        { query: id, success: success, failure: failure },
                        true
                    );
                };

                // we done function
                item.onOnce('process-complete', function() {
                    success(createItemAPI(item));
                    processNext();

                    // if origin is local, and we're instant uploading, trigger remove of original
                    // as revert will remove file from list
                    var server = state.options.server;
                    var instantUpload = state.options.instantUpload;
                    if (
                        instantUpload &&
                        item.origin === FileOrigin.LOCAL &&
                        isFunction(server.remove)
                    ) {
                        var noop = function noop() {};
                        item.origin = FileOrigin.LIMBO;
                        state.options.server.remove(item.source, noop, noop);
                    }

                    // All items processed? No errors?
                    var allItemsProcessed =
                        query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE).length ===
                        state.items.length;
                    if (allItemsProcessed) {
                        dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');
                    }
                });

                // we error function
                item.onOnce('process-error', function(error) {
                    failure({ error: error, file: createItemAPI(item) });
                    processNext();
                });

                // start file processing
                var options = state.options;
                item.process(
                    createFileProcessor(
                        createProcessorFunction(
                            options.server.url,
                            options.server.process,
                            options.name,
                            {
                                chunkTransferId: item.transferId,
                                chunkServer: options.server.patch,
                                chunkUploads: options.chunkUploads,
                                chunkForce: options.chunkForce,
                                chunkSize: options.chunkSize,
                                chunkRetryDelays: options.chunkRetryDelays,
                            }
                        ),

                        {
                            allowMinimumUploadDuration: query('GET_ALLOW_MINIMUM_UPLOAD_DURATION'),
                        }
                    ),

                    // called when the file is about to be processed so it can be piped through the transform filters
                    function(file, success, error) {
                        // allow plugins to alter the file data
                        applyFilterChain('PREPARE_OUTPUT', file, { query: query, item: item })
                            .then(function(file) {
                                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });

                                success(file);
                            })
                            .catch(error);
                    }
                );
            }),

            RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
                dispatch('REQUEST_ITEM_PROCESSING', { query: item });
            }),

            REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {
                optionalPromise(query('GET_BEFORE_REMOVE_FILE'), createItemAPI(item)).then(function(
                    shouldRemove
                ) {
                    if (!shouldRemove) {
                        return;
                    }
                    dispatch('REMOVE_ITEM', { query: item });
                });
            }),

            RELEASE_ITEM: getItemByQueryFromState(state, function(item) {
                item.release();
            }),

            REMOVE_ITEM: getItemByQueryFromState(state, function(item, success, failure, options) {
                var removeFromView = function removeFromView() {
                    // get id reference
                    var id = item.id;

                    // archive the item, this does not remove it from the list
                    getItemById(state.items, id).archive();

                    // tell the view the item has been removed
                    dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });

                    // now the list has been modified
                    listUpdated(dispatch, state);

                    // correctly removed
                    success(createItemAPI(item));
                };

                // if this is a local file and the `server.remove` function has been configured,
                // send source there so dev can remove file from server
                var server = state.options.server;
                if (
                    item.origin === FileOrigin.LOCAL &&
                    server &&
                    isFunction(server.remove) &&
                    options.remove !== false
                ) {
                    dispatch('DID_START_ITEM_REMOVE', { id: item.id });

                    server.remove(
                        item.source,
                        function() {
                            return removeFromView();
                        },
                        function(status) {
                            dispatch('DID_THROW_ITEM_REMOVE_ERROR', {
                                id: item.id,
                                error: createResponse('error', 0, status, null),
                                status: {
                                    main: dynamicLabel(state.options.labelFileRemoveError)(status),
                                    sub: state.options.labelTapToRetry,
                                },
                            });
                        }
                    );
                } else {
                    // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)
                    if (
                        (options.revert &&
                            item.origin !== FileOrigin.LOCAL &&
                            item.serverId !== null) ||
                        // if chunked uploads are enabled and we're uploading in chunks for this specific file
                        // or if the file isn't big enough for chunked uploads but chunkForce is set then call
                        // revert before removing from the view...
                        (state.options.chunkUploads && item.file.size > state.options.chunkSize) ||
                        (state.options.chunkUploads && state.options.chunkForce)
                    ) {
                        item.revert(
                            createRevertFunction(
                                state.options.server.url,
                                state.options.server.revert
                            ),
                            query('GET_FORCE_REVERT')
                        );
                    }

                    // can now safely remove from view
                    removeFromView();
                }
            }),

            ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {
                item.abortLoad();
            }),

            ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
                // test if is already processed
                if (item.serverId) {
                    dispatch('REVERT_ITEM_PROCESSING', { id: item.id });
                    return;
                }

                // abort
                item.abortProcessing().then(function() {
                    var shouldRemove = state.options.instantUpload;
                    if (shouldRemove) {
                        dispatch('REMOVE_ITEM', { query: item.id });
                    }
                });
            }),

            REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
                // not instant uploading, revert immediately
                if (!state.options.instantUpload) {
                    dispatch('REVERT_ITEM_PROCESSING', { query: item });
                    return;
                }

                // if we're instant uploading the file will also be removed if we revert,
                // so if a before remove file hook is defined we need to run it now
                var handleRevert = function handleRevert(shouldRevert) {
                    if (!shouldRevert) return;
                    dispatch('REVERT_ITEM_PROCESSING', { query: item });
                };

                var fn = query('GET_BEFORE_REMOVE_FILE');
                if (!fn) {
                    return handleRevert(true);
                }

                var requestRemoveResult = fn(createItemAPI(item));
                if (requestRemoveResult == null) {
                    // undefined or null
                    return handleRevert(true);
                }

                if (typeof requestRemoveResult === 'boolean') {
                    return handleRevert(requestRemoveResult);
                }

                if (typeof requestRemoveResult.then === 'function') {
                    requestRemoveResult.then(handleRevert);
                }
            }),

            REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
                item.revert(
                    createRevertFunction(state.options.server.url, state.options.server.revert),
                    query('GET_FORCE_REVERT')
                )
                    .then(function() {
                        var shouldRemove = state.options.instantUpload || isMockItem(item);
                        if (shouldRemove) {
                            dispatch('REMOVE_ITEM', { query: item.id });
                        }
                    })
                    .catch(function() {});
            }),

            SET_OPTIONS: function SET_OPTIONS(_ref11) {
                var options = _ref11.options;
                // get all keys passed
                var optionKeys = Object.keys(options);

                // get prioritized keyed to include (remove once not in options object)
                var prioritizedOptionKeys = PrioritizedOptions.filter(function(key) {
                    return optionKeys.includes(key);
                });

                // order the keys, prioritized first, then rest
                var orderedOptionKeys = [].concat(
                    _toConsumableArray(prioritizedOptionKeys),
                    _toConsumableArray(
                        Object.keys(options).filter(function(key) {
                            return !prioritizedOptionKeys.includes(key);
                        })
                    )
                );

                // dispatch set event for each option
                orderedOptionKeys.forEach(function(key) {
                    dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {
                        value: options[key],
                    });
                });
            },
        };
    };

    var PrioritizedOptions = ['server'];

    var formatFilename = function formatFilename(name) {
        return name;
    };

    var createElement$1 = function createElement(tagName) {
        return document.createElement(tagName);
    };

    var text = function text(node, value) {
        var textNode = node.childNodes[0];
        if (!textNode) {
            textNode = document.createTextNode(value);
            node.appendChild(textNode);
        } else if (value !== textNode.nodeValue) {
            textNode.nodeValue = value;
        }
    };

    var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;
        return {
            x: centerX + radius * Math.cos(angleInRadians),
            y: centerY + radius * Math.sin(angleInRadians),
        };
    };

    var describeArc = function describeArc(x, y, radius, startAngle, endAngle, arcSweep) {
        var start = polarToCartesian(x, y, radius, endAngle);
        var end = polarToCartesian(x, y, radius, startAngle);
        return ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');
    };

    var percentageArc = function percentageArc(x, y, radius, from, to) {
        var arcSweep = 1;
        if (to > from && to - from <= 0.5) {
            arcSweep = 0;
        }
        if (from > to && from - to >= 0.5) {
            arcSweep = 0;
        }
        return describeArc(
            x,
            y,
            radius,
            Math.min(0.9999, from) * 360,
            Math.min(0.9999, to) * 360,
            arcSweep
        );
    };

    var create = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        // start at 0
        props.spin = false;
        props.progress = 0;
        props.opacity = 0;

        // svg
        var svg = createElement('svg');
        root.ref.path = createElement('path', {
            'stroke-width': 2,
            'stroke-linecap': 'round',
        });

        svg.appendChild(root.ref.path);

        root.ref.svg = svg;

        root.appendChild(svg);
    };

    var write = function write(_ref2) {
        var root = _ref2.root,
            props = _ref2.props;
        if (props.opacity === 0) {
            return;
        }

        if (props.align) {
            root.element.dataset.align = props.align;
        }

        // get width of stroke
        var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);

        // calculate size of ring
        var size = root.rect.element.width * 0.5;

        // ring state
        var ringFrom = 0;
        var ringTo = 0;

        // now in busy mode
        if (props.spin) {
            ringFrom = 0;
            ringTo = 0.5;
        } else {
            ringFrom = 0;
            ringTo = props.progress;
        }

        // get arc path
        var coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);

        // update progress bar
        attr(root.ref.path, 'd', coordinates);

        // hide while contains 0 value
        attr(root.ref.path, 'stroke-opacity', props.spin || props.progress > 0 ? 1 : 0);
    };

    var progressIndicator = createView({
        tag: 'div',
        name: 'progress-indicator',
        ignoreRectUpdate: true,
        ignoreRect: true,
        create: create,
        write: write,
        mixins: {
            apis: ['progress', 'spin', 'align'],
            styles: ['opacity'],
            animations: {
                opacity: { type: 'tween', duration: 500 },
                progress: {
                    type: 'spring',
                    stiffness: 0.95,
                    damping: 0.65,
                    mass: 10,
                },
            },
        },
    });

    var create$1 = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        root.element.innerHTML = (props.icon || '') + ('<span>' + props.label + '</span>');

        props.isDisabled = false;
    };

    var write$1 = function write(_ref2) {
        var root = _ref2.root,
            props = _ref2.props;
        var isDisabled = props.isDisabled;
        var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;

        if (shouldDisable && !isDisabled) {
            props.isDisabled = true;
            attr(root.element, 'disabled', 'disabled');
        } else if (!shouldDisable && isDisabled) {
            props.isDisabled = false;
            root.element.removeAttribute('disabled');
        }
    };

    var fileActionButton = createView({
        tag: 'button',
        attributes: {
            type: 'button',
        },

        ignoreRect: true,
        ignoreRectUpdate: true,
        name: 'file-action-button',
        mixins: {
            apis: ['label'],
            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],
            animations: {
                scaleX: 'spring',
                scaleY: 'spring',
                translateX: 'spring',
                translateY: 'spring',
                opacity: { type: 'tween', duration: 250 },
            },

            listeners: true,
        },

        create: create$1,
        write: write$1,
    });

    var toNaturalFileSize = function toNaturalFileSize(bytes) {
        var decimalSeparator =
            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';
        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var _options$labelBytes = options.labelBytes,
            labelBytes = _options$labelBytes === void 0 ? 'bytes' : _options$labelBytes,
            _options$labelKilobyt = options.labelKilobytes,
            labelKilobytes = _options$labelKilobyt === void 0 ? 'KB' : _options$labelKilobyt,
            _options$labelMegabyt = options.labelMegabytes,
            labelMegabytes = _options$labelMegabyt === void 0 ? 'MB' : _options$labelMegabyt,
            _options$labelGigabyt = options.labelGigabytes,
            labelGigabytes = _options$labelGigabyt === void 0 ? 'GB' : _options$labelGigabyt;

        // no negative byte sizes
        bytes = Math.round(Math.abs(bytes));

        var KB = base;
        var MB = base * base;
        var GB = base * base * base;

        // just bytes
        if (bytes < KB) {
            return bytes + ' ' + labelBytes;
        }

        // kilobytes
        if (bytes < MB) {
            return Math.floor(bytes / KB) + ' ' + labelKilobytes;
        }

        // megabytes
        if (bytes < GB) {
            return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' ' + labelMegabytes;
        }

        // gigabytes
        return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' ' + labelGigabytes;
    };

    var removeDecimalsWhenZero = function removeDecimalsWhenZero(value, decimalCount, separator) {
        return value
            .toFixed(decimalCount)
            .split('.')
            .filter(function(part) {
                return part !== '0';
            })
            .join(separator);
    };

    var create$2 = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        // filename
        var fileName = createElement$1('span');
        fileName.className = 'filepond--file-info-main';
        // hide for screenreaders
        // the file is contained in a fieldset with legend that contains the filename
        // no need to read it twice
        attr(fileName, 'aria-hidden', 'true');
        root.appendChild(fileName);
        root.ref.fileName = fileName;

        // filesize
        var fileSize = createElement$1('span');
        fileSize.className = 'filepond--file-info-sub';
        root.appendChild(fileSize);
        root.ref.fileSize = fileSize;

        // set initial values
        text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));
        text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));
    };

    var updateFile = function updateFile(_ref2) {
        var root = _ref2.root,
            props = _ref2.props;
        text(
            root.ref.fileSize,
            toNaturalFileSize(
                root.query('GET_ITEM_SIZE', props.id),
                '.',
                root.query('GET_FILE_SIZE_BASE'),
                root.query('GET_FILE_SIZE_LABELS', root.query)
            )
        );

        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));
    };

    var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {
        var root = _ref3.root,
            props = _ref3.props;
        // if size is available don't fallback to unknown size message
        if (isInt(root.query('GET_ITEM_SIZE', props.id))) {
            updateFile({ root: root, props: props });
            return;
        }

        text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));
    };

    var fileInfo = createView({
        name: 'file-info',
        ignoreRect: true,
        ignoreRectUpdate: true,
        write: createRoute({
            DID_LOAD_ITEM: updateFile,
            DID_UPDATE_ITEM_META: updateFile,
            DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,
            DID_THROW_ITEM_INVALID: updateFileSizeOnError,
        }),

        didCreateView: function didCreateView(root) {
            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
        },
        create: create$2,
        mixins: {
            styles: ['translateX', 'translateY'],
            animations: {
                translateX: 'spring',
                translateY: 'spring',
            },
        },
    });

    var toPercentage = function toPercentage(value) {
        return Math.round(value * 100);
    };

    var create$3 = function create(_ref) {
        var root = _ref.root;

        // main status
        var main = createElement$1('span');
        main.className = 'filepond--file-status-main';
        root.appendChild(main);
        root.ref.main = main;

        // sub status
        var sub = createElement$1('span');
        sub.className = 'filepond--file-status-sub';
        root.appendChild(sub);
        root.ref.sub = sub;

        didSetItemLoadProgress({ root: root, action: { progress: null } });
    };

    var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {
        var root = _ref2.root,
            action = _ref2.action;
        var title =
            action.progress === null
                ? root.query('GET_LABEL_FILE_LOADING')
                : root.query('GET_LABEL_FILE_LOADING') + ' ' + toPercentage(action.progress) + '%';

        text(root.ref.main, title);
        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));
    };

    var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {
        var root = _ref3.root,
            action = _ref3.action;
        var title =
            action.progress === null
                ? root.query('GET_LABEL_FILE_PROCESSING')
                : root.query('GET_LABEL_FILE_PROCESSING') +
                  ' ' +
                  toPercentage(action.progress) +
                  '%';

        text(root.ref.main, title);
        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));
    };

    var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {
        var root = _ref4.root;
        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));
        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));
    };

    var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {
        var root = _ref5.root;
        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));
        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));
    };

    var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {
        var root = _ref6.root;
        text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));
        text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));
    };

    var clear = function clear(_ref7) {
        var root = _ref7.root;
        text(root.ref.main, '');
        text(root.ref.sub, '');
    };

    var error = function error(_ref8) {
        var root = _ref8.root,
            action = _ref8.action;
        text(root.ref.main, action.status.main);
        text(root.ref.sub, action.status.sub);
    };

    var fileStatus = createView({
        name: 'file-status',
        ignoreRect: true,
        ignoreRectUpdate: true,
        write: createRoute({
            DID_LOAD_ITEM: clear,
            DID_REVERT_ITEM_PROCESSING: clear,
            DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,
            DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,
            DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,
            DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,
            DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,
            DID_THROW_ITEM_LOAD_ERROR: error,
            DID_THROW_ITEM_INVALID: error,
            DID_THROW_ITEM_PROCESSING_ERROR: error,
            DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,
            DID_THROW_ITEM_REMOVE_ERROR: error,
        }),

        didCreateView: function didCreateView(root) {
            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
        },
        create: create$3,
        mixins: {
            styles: ['translateX', 'translateY', 'opacity'],
            animations: {
                opacity: { type: 'tween', duration: 250 },
                translateX: 'spring',
                translateY: 'spring',
            },
        },
    });

    /**
     * Button definitions for the file view
     */

    var Buttons = {
        AbortItemLoad: {
            label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',
            action: 'ABORT_ITEM_LOAD',
            className: 'filepond--action-abort-item-load',
            align: 'LOAD_INDICATOR_POSITION', // right
        },
        RetryItemLoad: {
            label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',
            action: 'RETRY_ITEM_LOAD',
            icon: 'GET_ICON_RETRY',
            className: 'filepond--action-retry-item-load',
            align: 'BUTTON_PROCESS_ITEM_POSITION', // right
        },
        RemoveItem: {
            label: 'GET_LABEL_BUTTON_REMOVE_ITEM',
            action: 'REQUEST_REMOVE_ITEM',
            icon: 'GET_ICON_REMOVE',
            className: 'filepond--action-remove-item',
            align: 'BUTTON_REMOVE_ITEM_POSITION', // left
        },
        ProcessItem: {
            label: 'GET_LABEL_BUTTON_PROCESS_ITEM',
            action: 'REQUEST_ITEM_PROCESSING',
            icon: 'GET_ICON_PROCESS',
            className: 'filepond--action-process-item',
            align: 'BUTTON_PROCESS_ITEM_POSITION', // right
        },
        AbortItemProcessing: {
            label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',
            action: 'ABORT_ITEM_PROCESSING',
            className: 'filepond--action-abort-item-processing',
            align: 'BUTTON_PROCESS_ITEM_POSITION', // right
        },
        RetryItemProcessing: {
            label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',
            action: 'RETRY_ITEM_PROCESSING',
            icon: 'GET_ICON_RETRY',
            className: 'filepond--action-retry-item-processing',
            align: 'BUTTON_PROCESS_ITEM_POSITION', // right
        },
        RevertItemProcessing: {
            label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',
            action: 'REQUEST_REVERT_ITEM_PROCESSING',
            icon: 'GET_ICON_UNDO',
            className: 'filepond--action-revert-item-processing',
            align: 'BUTTON_PROCESS_ITEM_POSITION', // right
        },
    };

    // make a list of buttons, we can then remove buttons from this list if they're disabled
    var ButtonKeys = [];
    forin(Buttons, function(key) {
        ButtonKeys.push(key);
    });

    var calculateFileInfoOffset = function calculateFileInfoOffset(root) {
        if (getRemoveIndicatorAligment(root) === 'right') return 0;
        var buttonRect = root.ref.buttonRemoveItem.rect.element;
        return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;
    };

    var calculateButtonWidth = function calculateButtonWidth(root) {
        var buttonRect = root.ref.buttonAbortItemLoad.rect.element;
        return buttonRect.width;
    };

    // Force on full pixels so text stays crips
    var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(root) {
        return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);
    };
    var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(root) {
        return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);
    };

    var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {
        return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');
    };
    var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(root) {
        return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');
    };
    var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {
        return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');
    };

    var DefaultStyle = {
        buttonAbortItemLoad: { opacity: 0 },
        buttonRetryItemLoad: { opacity: 0 },
        buttonRemoveItem: { opacity: 0 },
        buttonProcessItem: { opacity: 0 },
        buttonAbortItemProcessing: { opacity: 0 },
        buttonRetryItemProcessing: { opacity: 0 },
        buttonRevertItemProcessing: { opacity: 0 },
        loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },
        processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },
        processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },
        info: { translateX: 0, translateY: 0, opacity: 0 },
        status: { translateX: 0, translateY: 0, opacity: 0 },
    };

    var IdleStyle = {
        buttonRemoveItem: { opacity: 1 },
        buttonProcessItem: { opacity: 1 },
        info: { translateX: calculateFileInfoOffset },
        status: { translateX: calculateFileInfoOffset },
    };

    var ProcessingStyle = {
        buttonAbortItemProcessing: { opacity: 1 },
        processProgressIndicator: { opacity: 1 },
        status: { opacity: 1 },
    };

    var StyleMap = {
        DID_THROW_ITEM_INVALID: {
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { translateX: calculateFileInfoOffset, opacity: 1 },
        },

        DID_START_ITEM_LOAD: {
            buttonAbortItemLoad: { opacity: 1 },
            loadProgressIndicator: { opacity: 1 },
            status: { opacity: 1 },
        },

        DID_THROW_ITEM_LOAD_ERROR: {
            buttonRetryItemLoad: { opacity: 1 },
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 1 },
        },

        DID_START_ITEM_REMOVE: {
            processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 0 },
        },

        DID_THROW_ITEM_REMOVE_ERROR: {
            processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 1, translateX: calculateFileInfoOffset },
        },

        DID_LOAD_ITEM: IdleStyle,
        DID_LOAD_LOCAL_ITEM: {
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { translateX: calculateFileInfoOffset },
        },

        DID_START_ITEM_PROCESSING: ProcessingStyle,
        DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,
        DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,
        DID_COMPLETE_ITEM_PROCESSING: {
            buttonRevertItemProcessing: { opacity: 1 },
            info: { opacity: 1 },
            status: { opacity: 1 },
        },

        DID_THROW_ITEM_PROCESSING_ERROR: {
            buttonRemoveItem: { opacity: 1 },
            buttonRetryItemProcessing: { opacity: 1 },
            status: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
        },

        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
            buttonRevertItemProcessing: { opacity: 1 },
            status: { opacity: 1 },
            info: { opacity: 1 },
        },

        DID_ABORT_ITEM_PROCESSING: {
            buttonRemoveItem: { opacity: 1 },
            buttonProcessItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 1 },
        },

        DID_REVERT_ITEM_PROCESSING: IdleStyle,
    };

    // complete indicator view
    var processingCompleteIndicatorView = createView({
        create: function create(_ref) {
            var root = _ref.root;
            root.element.innerHTML = root.query('GET_ICON_DONE');
        },
        name: 'processing-complete-indicator',
        ignoreRect: true,
        mixins: {
            styles: ['scaleX', 'scaleY', 'opacity'],
            animations: {
                scaleX: 'spring',
                scaleY: 'spring',
                opacity: { type: 'tween', duration: 250 },
            },
        },
    });

    /**
     * Creates the file view
     */
    var create$4 = function create(_ref2) {
        var root = _ref2.root,
            props = _ref2.props;
        // copy Buttons object
        var LocalButtons = Object.keys(Buttons).reduce(function(prev, curr) {
            prev[curr] = Object.assign({}, Buttons[curr]);
            return prev;
        }, {});
        var id = props.id;

        // allow reverting upload
        var allowRevert = root.query('GET_ALLOW_REVERT');

        // allow remove file
        var allowRemove = root.query('GET_ALLOW_REMOVE');

        // allow processing upload
        var allowProcess = root.query('GET_ALLOW_PROCESS');

        // is instant uploading, need this to determine the icon of the undo button
        var instantUpload = root.query('GET_INSTANT_UPLOAD');

        // is async set up
        var isAsync = root.query('IS_ASYNC');

        // should align remove item buttons
        var alignRemoveItemButton = root.query('GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN');

        // enabled buttons array
        var buttonFilter;
        if (isAsync) {
            if (allowProcess && !allowRevert) {
                // only remove revert button
                buttonFilter = function buttonFilter(key) {
                    return !/RevertItemProcessing/.test(key);
                };
            } else if (!allowProcess && allowRevert) {
                // only remove process button
                buttonFilter = function buttonFilter(key) {
                    return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);
                };
            } else if (!allowProcess && !allowRevert) {
                // remove all process buttons
                buttonFilter = function buttonFilter(key) {
                    return !/Process/.test(key);
                };
            }
        } else {
            // no process controls available
            buttonFilter = function buttonFilter(key) {
                return !/Process/.test(key);
            };
        }

        var enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();

        // update icon and label for revert button when instant uploading
        if (instantUpload && allowRevert) {
            LocalButtons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';
            LocalButtons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';
        }

        // remove last button (revert) if not allowed
        if (isAsync && !allowRevert) {
            var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];
            map.info.translateX = calculateFileHorizontalCenterOffset;
            map.info.translateY = calculateFileVerticalCenterOffset;
            map.status.translateY = calculateFileVerticalCenterOffset;
            map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
        }

        // should align center
        if (isAsync && !allowProcess) {
            [
                'DID_START_ITEM_PROCESSING',
                'DID_REQUEST_ITEM_PROCESSING',
                'DID_UPDATE_ITEM_PROCESS_PROGRESS',
                'DID_THROW_ITEM_PROCESSING_ERROR',
            ].forEach(function(key) {
                StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;
            });
            StyleMap['DID_THROW_ITEM_PROCESSING_ERROR'].status.translateX = calculateButtonWidth;
        }

        // move remove button to right
        if (alignRemoveItemButton && allowRevert) {
            LocalButtons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';
            var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];
            _map.info.translateX = calculateFileInfoOffset;
            _map.status.translateY = calculateFileVerticalCenterOffset;
            _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
        }

        // show/hide RemoveItem button
        if (!allowRemove) {
            LocalButtons['RemoveItem'].disabled = true;
        }

        // create the button views
        forin(LocalButtons, function(key, definition) {
            // create button
            var buttonView = root.createChildView(fileActionButton, {
                label: root.query(definition.label),
                icon: root.query(definition.icon),
                opacity: 0,
            });

            // should be appended?
            if (enabledButtons.includes(key)) {
                root.appendChildView(buttonView);
            }

            // toggle
            if (definition.disabled) {
                buttonView.element.setAttribute('disabled', 'disabled');
                buttonView.element.setAttribute('hidden', 'hidden');
            }

            // add position attribute
            buttonView.element.dataset.align = root.query('GET_STYLE_' + definition.align);

            // add class
            buttonView.element.classList.add(definition.className);

            // handle interactions
            buttonView.on('click', function(e) {
                e.stopPropagation();
                if (definition.disabled) return;
                root.dispatch(definition.action, { query: id });
            });

            // set reference
            root.ref['button' + key] = buttonView;
        });

        // checkmark
        root.ref.processingCompleteIndicator = root.appendChildView(
            root.createChildView(processingCompleteIndicatorView)
        );

        root.ref.processingCompleteIndicator.element.dataset.align = root.query(
            'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'
        );

        // create file info view
        root.ref.info = root.appendChildView(root.createChildView(fileInfo, { id: id }));

        // create file status view
        root.ref.status = root.appendChildView(root.createChildView(fileStatus, { id: id }));

        // add progress indicators
        var loadIndicatorView = root.appendChildView(
            root.createChildView(progressIndicator, {
                opacity: 0,
                align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION'),
            })
        );

        loadIndicatorView.element.classList.add('filepond--load-indicator');
        root.ref.loadProgressIndicator = loadIndicatorView;

        var progressIndicatorView = root.appendChildView(
            root.createChildView(progressIndicator, {
                opacity: 0,
                align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION'),
            })
        );

        progressIndicatorView.element.classList.add('filepond--process-indicator');
        root.ref.processProgressIndicator = progressIndicatorView;

        // current active styles
        root.ref.activeStyles = [];
    };

    var write$2 = function write(_ref3) {
        var root = _ref3.root,
            actions = _ref3.actions,
            props = _ref3.props;
        // route actions
        route({ root: root, actions: actions, props: props });

        // select last state change action
        var action = actions
            .concat()
            .filter(function(action) {
                return /^DID_/.test(action.type);
            })
            .reverse()
            .find(function(action) {
                return StyleMap[action.type];
            });

        // a new action happened, let's get the matching styles
        if (action) {
            // define new active styles
            root.ref.activeStyles = [];

            var stylesToApply = StyleMap[action.type];
            forin(DefaultStyle, function(name, defaultStyles) {
                // get reference to control
                var control = root.ref[name];

                // loop over all styles for this control
                forin(defaultStyles, function(key, defaultValue) {
                    var value =
                        stylesToApply[name] && typeof stylesToApply[name][key] !== 'undefined'
                            ? stylesToApply[name][key]
                            : defaultValue;
                    root.ref.activeStyles.push({ control: control, key: key, value: value });
                });
            });
        }

        // apply active styles to element
        root.ref.activeStyles.forEach(function(_ref4) {
            var control = _ref4.control,
                key = _ref4.key,
                value = _ref4.value;
            control[key] = typeof value === 'function' ? value(root) : value;
        });
    };

    var route = createRoute({
        DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(
            _ref5
        ) {
            var root = _ref5.root,
                action = _ref5.action;
            root.ref.buttonAbortItemProcessing.label = action.value;
        },
        DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(_ref6) {
            var root = _ref6.root,
                action = _ref6.action;
            root.ref.buttonAbortItemLoad.label = action.value;
        },
        DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(
            _ref7
        ) {
            var root = _ref7.root,
                action = _ref7.action;
            root.ref.buttonAbortItemRemoval.label = action.value;
        },
        DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {
            var root = _ref8.root;
            root.ref.processProgressIndicator.spin = true;
            root.ref.processProgressIndicator.progress = 0;
        },
        DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {
            var root = _ref9.root;
            root.ref.loadProgressIndicator.spin = true;
            root.ref.loadProgressIndicator.progress = 0;
        },
        DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {
            var root = _ref10.root;
            root.ref.processProgressIndicator.spin = true;
            root.ref.processProgressIndicator.progress = 0;
        },
        DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(_ref11) {
            var root = _ref11.root,
                action = _ref11.action;
            root.ref.loadProgressIndicator.spin = false;
            root.ref.loadProgressIndicator.progress = action.progress;
        },
        DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(_ref12) {
            var root = _ref12.root,
                action = _ref12.action;
            root.ref.processProgressIndicator.spin = false;
            root.ref.processProgressIndicator.progress = action.progress;
        },
    });

    var file = createView({
        create: create$4,
        write: write$2,
        didCreateView: function didCreateView(root) {
            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
        },
        name: 'file',
    });

    /**
     * Creates the file view
     */
    var create$5 = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;

        // filename
        root.ref.fileName = createElement$1('legend');
        root.appendChild(root.ref.fileName);

        // file appended
        root.ref.file = root.appendChildView(root.createChildView(file, { id: props.id }));

        // data has moved to data.js
        root.ref.data = false;
    };

    /**
     * Data storage
     */
    var didLoadItem = function didLoadItem(_ref2) {
        var root = _ref2.root,
            props = _ref2.props;
        // updates the legend of the fieldset so screenreaders can better group buttons
        text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));
    };

    var fileWrapper = createView({
        create: create$5,
        ignoreRect: true,
        write: createRoute({
            DID_LOAD_ITEM: didLoadItem,
        }),

        didCreateView: function didCreateView(root) {
            applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
        },
        tag: 'fieldset',
        name: 'file-wrapper',
    });

    var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };

    var create$6 = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        [
            {
                name: 'top',
            },

            {
                name: 'center',
                props: {
                    translateY: null,
                    scaleY: null,
                },

                mixins: {
                    animations: {
                        scaleY: PANEL_SPRING_PROPS,
                    },

                    styles: ['translateY', 'scaleY'],
                },
            },

            {
                name: 'bottom',
                props: {
                    translateY: null,
                },

                mixins: {
                    animations: {
                        translateY: PANEL_SPRING_PROPS,
                    },

                    styles: ['translateY'],
                },
            },
        ].forEach(function(section) {
            createSection(root, section, props.name);
        });

        root.element.classList.add('filepond--' + props.name);

        root.ref.scalable = null;
    };

    var createSection = function createSection(root, section, className) {
        var viewConstructor = createView({
            name: 'panel-' + section.name + ' filepond--' + className,
            mixins: section.mixins,
            ignoreRectUpdate: true,
        });

        var view = root.createChildView(viewConstructor, section.props);

        root.ref[section.name] = root.appendChildView(view);
    };

    var write$3 = function write(_ref2) {
        var root = _ref2.root,
            props = _ref2.props;

        // update scalable state
        if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {
            root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;
            root.element.dataset.scalable = root.ref.scalable;
        }

        // no height, can't set
        if (!props.height) return;

        // get child rects
        var topRect = root.ref.top.rect.element;
        var bottomRect = root.ref.bottom.rect.element;

        // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)
        var height = Math.max(topRect.height + bottomRect.height, props.height);

        // offset center part
        root.ref.center.translateY = topRect.height;

        // scale center part
        // use math ceil to prevent transparent lines because of rounding errors
        root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;

        // offset bottom part
        root.ref.bottom.translateY = height - bottomRect.height;
    };

    var panel = createView({
        name: 'panel',
        read: function read(_ref3) {
            var root = _ref3.root,
                props = _ref3.props;
            return (props.heightCurrent = root.ref.bottom.translateY);
        },
        write: write$3,
        create: create$6,
        ignoreRect: true,
        mixins: {
            apis: ['height', 'heightCurrent', 'scalable'],
        },
    });

    var createDragHelper = function createDragHelper(items) {
        var itemIds = items.map(function(item) {
            return item.id;
        });
        var prevIndex = undefined;
        return {
            setIndex: function setIndex(index) {
                prevIndex = index;
            },
            getIndex: function getIndex() {
                return prevIndex;
            },
            getItemIndex: function getItemIndex(item) {
                return itemIds.indexOf(item.id);
            },
        };
    };

    var ITEM_TRANSLATE_SPRING = {
        type: 'spring',
        stiffness: 0.75,
        damping: 0.45,
        mass: 10,
    };

    var ITEM_SCALE_SPRING = 'spring';

    var StateMap = {
        DID_START_ITEM_LOAD: 'busy',
        DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',
        DID_THROW_ITEM_INVALID: 'load-invalid',
        DID_THROW_ITEM_LOAD_ERROR: 'load-error',
        DID_LOAD_ITEM: 'idle',
        DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',
        DID_START_ITEM_REMOVE: 'busy',
        DID_START_ITEM_PROCESSING: 'busy processing',
        DID_REQUEST_ITEM_PROCESSING: 'busy processing',
        DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',
        DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',
        DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',
        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',
        DID_ABORT_ITEM_PROCESSING: 'cancelled',
        DID_REVERT_ITEM_PROCESSING: 'idle',
    };

    /**
     * Creates the file view
     */
    var create$7 = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;

        // select
        root.ref.handleClick = function(e) {
            return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });
        };

        // set id
        root.element.id = 'filepond--item-' + props.id;
        root.element.addEventListener('click', root.ref.handleClick);

        // file view
        root.ref.container = root.appendChildView(
            root.createChildView(fileWrapper, { id: props.id })
        );

        // file panel
        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'item-panel' }));

        // default start height
        root.ref.panel.height = null;

        // by default not marked for removal
        props.markedForRemoval = false;

        // if not allowed to reorder file items, exit here
        if (!root.query('GET_ALLOW_REORDER')) return;

        // set to idle so shows grab cursor
        root.element.dataset.dragState = 'idle';

        var grab = function grab(e) {
            if (!e.isPrimary) return;

            var removedActivateListener = false;

            var origin = {
                x: e.pageX,
                y: e.pageY,
            };

            props.dragOrigin = {
                x: root.translateX,
                y: root.translateY,
            };

            props.dragCenter = {
                x: e.offsetX,
                y: e.offsetY,
            };

            var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));

            root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });

            var drag = function drag(e) {
                if (!e.isPrimary) return;

                e.stopPropagation();
                e.preventDefault();

                props.dragOffset = {
                    x: e.pageX - origin.x,
                    y: e.pageY - origin.y,
                };

                // if dragged stop listening to clicks, will re-add when done dragging
                var dist =
                    props.dragOffset.x * props.dragOffset.x +
                    props.dragOffset.y * props.dragOffset.y;
                if (dist > 16 && !removedActivateListener) {
                    removedActivateListener = true;
                    root.element.removeEventListener('click', root.ref.handleClick);
                }

                root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });
            };

            var drop = function drop(e) {
                if (!e.isPrimary) return;

                document.removeEventListener('pointermove', drag);
                document.removeEventListener('pointerup', drop);

                props.dragOffset = {
                    x: e.pageX - origin.x,
                    y: e.pageY - origin.y,
                };

                root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });

                // start listening to clicks again
                if (removedActivateListener) {
                    setTimeout(function() {
                        return root.element.addEventListener('click', root.ref.handleClick);
                    }, 0);
                }
            };

            document.addEventListener('pointermove', drag);
            document.addEventListener('pointerup', drop);
        };

        root.element.addEventListener('pointerdown', grab);
    };

    var route$1 = createRoute({
        DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {
            var root = _ref2.root,
                action = _ref2.action;
            root.height = action.height;
        },
    });

    var write$4 = createRoute(
        {
            DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {
                var root = _ref3.root,
                    props = _ref3.props;
                props.dragOrigin = {
                    x: root.translateX,
                    y: root.translateY,
                };
            },
            DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {
                var root = _ref4.root;
                root.element.dataset.dragState = 'drag';
            },
            DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {
                var root = _ref5.root,
                    props = _ref5.props;
                props.dragOffset = null;
                props.dragOrigin = null;
                root.element.dataset.dragState = 'drop';
            },
        },
        function(_ref6) {
            var root = _ref6.root,
                actions = _ref6.actions,
                props = _ref6.props,
                shouldOptimize = _ref6.shouldOptimize;

            if (root.element.dataset.dragState === 'drop') {
                if (root.scaleX <= 1) {
                    root.element.dataset.dragState = 'idle';
                }
            }

            // select last state change action
            var action = actions
                .concat()
                .filter(function(action) {
                    return /^DID_/.test(action.type);
                })
                .reverse()
                .find(function(action) {
                    return StateMap[action.type];
                });

            // no need to set same state twice
            if (action && action.type !== props.currentState) {
                // set current state
                props.currentState = action.type;

                // set state
                root.element.dataset.filepondItemState = StateMap[props.currentState] || '';
            }

            // route actions
            var aspectRatio =
                root.query('GET_ITEM_PANEL_ASPECT_RATIO') || root.query('GET_PANEL_ASPECT_RATIO');
            if (!aspectRatio) {
                route$1({ root: root, actions: actions, props: props });
                if (!root.height && root.ref.container.rect.element.height > 0) {
                    root.height = root.ref.container.rect.element.height;
                }
            } else if (!shouldOptimize) {
                root.height = root.rect.element.width * aspectRatio;
            }

            // sync panel height with item height
            if (shouldOptimize) {
                root.ref.panel.height = null;
            }

            root.ref.panel.height = root.height;
        }
    );

    var item = createView({
        create: create$7,
        write: write$4,
        destroy: function destroy(_ref7) {
            var root = _ref7.root,
                props = _ref7.props;
            root.element.removeEventListener('click', root.ref.handleClick);
            root.dispatch('RELEASE_ITEM', { query: props.id });
        },
        tag: 'li',
        name: 'item',
        mixins: {
            apis: [
                'id',
                'interactionMethod',
                'markedForRemoval',
                'spawnDate',
                'dragCenter',
                'dragOrigin',
                'dragOffset',
            ],
            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity', 'height'],

            animations: {
                scaleX: ITEM_SCALE_SPRING,
                scaleY: ITEM_SCALE_SPRING,
                translateX: ITEM_TRANSLATE_SPRING,
                translateY: ITEM_TRANSLATE_SPRING,
                opacity: { type: 'tween', duration: 150 },
            },
        },
    });

    var getItemsPerRow = function(horizontalSpace, itemWidth) {
        // add one pixel leeway, when using percentages for item width total items can be 1.99 per row

        return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));
    };

    var getItemIndexByPosition = function getItemIndexByPosition(view, children, positionInView) {
        if (!positionInView) return;

        var horizontalSpace = view.rect.element.width;
        // const children = view.childViews;
        var l = children.length;
        var last = null;

        // -1, don't move items to accomodate (either add to top or bottom)
        if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;

        // let's get the item width
        var item = children[0];
        var itemRect = item.rect.element;
        var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;
        var itemWidth = itemRect.width + itemHorizontalMargin;
        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);

        // stack
        if (itemsPerRow === 1) {
            for (var index = 0; index < l; index++) {
                var child = children[index];
                var childMid = child.rect.outer.top + child.rect.element.height * 0.5;
                if (positionInView.top < childMid) {
                    return index;
                }
            }
            return l;
        }

        // grid
        var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;
        var itemHeight = itemRect.height + itemVerticalMargin;
        for (var _index = 0; _index < l; _index++) {
            var indexX = _index % itemsPerRow;
            var indexY = Math.floor(_index / itemsPerRow);

            var offsetX = indexX * itemWidth;
            var offsetY = indexY * itemHeight;

            var itemTop = offsetY - itemRect.marginTop;
            var itemRight = offsetX + itemWidth;
            var itemBottom = offsetY + itemHeight + itemRect.marginBottom;

            if (positionInView.top < itemBottom && positionInView.top > itemTop) {
                if (positionInView.left < itemRight) {
                    return _index;
                } else if (_index !== l - 1) {
                    last = _index;
                } else {
                    last = null;
                }
            }
        }

        if (last !== null) {
            return last;
        }

        return l;
    };

    var dropAreaDimensions = {
        height: 0,
        width: 0,
        get getHeight() {
            return this.height;
        },
        set setHeight(val) {
            if (this.height === 0 || val === 0) this.height = val;
        },
        get getWidth() {
            return this.width;
        },
        set setWidth(val) {
            if (this.width === 0 || val === 0) this.width = val;
        },
        setDimensions: function setDimensions(height, width) {
            if (this.height === 0 || height === 0) this.height = height;
            if (this.width === 0 || width === 0) this.width = width;
        },
    };

    var create$8 = function create(_ref) {
        var root = _ref.root;
        // need to set role to list as otherwise it won't be read as a list by VoiceOver
        attr(root.element, 'role', 'list');

        root.ref.lastItemSpanwDate = Date.now();
    };

    /**
     * Inserts a new item
     * @param root
     * @param action
     */
    var addItemView = function addItemView(_ref2) {
        var root = _ref2.root,
            action = _ref2.action;
        var id = action.id,
            index = action.index,
            interactionMethod = action.interactionMethod;

        root.ref.addIndex = index;

        var now = Date.now();
        var spawnDate = now;
        var opacity = 1;

        if (interactionMethod !== InteractionMethod.NONE) {
            opacity = 0;
            var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');
            var dist = now - root.ref.lastItemSpanwDate;
            spawnDate = dist < cooldown ? now + (cooldown - dist) : now;
        }

        root.ref.lastItemSpanwDate = spawnDate;

        root.appendChildView(
            root.createChildView(
                // view type
                item,

                // props
                {
                    spawnDate: spawnDate,
                    id: id,
                    opacity: opacity,
                    interactionMethod: interactionMethod,
                }
            ),

            index
        );
    };

    var moveItem = function moveItem(item, x, y) {
        var vx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var vy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
        // set to null to remove animation while dragging
        if (item.dragOffset) {
            item.translateX = null;
            item.translateY = null;
            item.translateX = item.dragOrigin.x + item.dragOffset.x;
            item.translateY = item.dragOrigin.y + item.dragOffset.y;
            item.scaleX = 1.025;
            item.scaleY = 1.025;
        } else {
            item.translateX = x;
            item.translateY = y;

            if (Date.now() > item.spawnDate) {
                // reveal element
                if (item.opacity === 0) {
                    introItemView(item, x, y, vx, vy);
                }

                // make sure is default scale every frame
                item.scaleX = 1;
                item.scaleY = 1;
                item.opacity = 1;
            }
        }
    };

    var introItemView = function introItemView(item, x, y, vx, vy) {
        if (item.interactionMethod === InteractionMethod.NONE) {
            item.translateX = null;
            item.translateX = x;
            item.translateY = null;
            item.translateY = y;
        } else if (item.interactionMethod === InteractionMethod.DROP) {
            item.translateX = null;
            item.translateX = x - vx * 20;

            item.translateY = null;
            item.translateY = y - vy * 10;

            item.scaleX = 0.8;
            item.scaleY = 0.8;
        } else if (item.interactionMethod === InteractionMethod.BROWSE) {
            item.translateY = null;
            item.translateY = y - 30;
        } else if (item.interactionMethod === InteractionMethod.API) {
            item.translateX = null;
            item.translateX = x - 30;
            item.translateY = null;
        }
    };

    /**
     * Removes an existing item
     * @param root
     * @param action
     */
    var removeItemView = function removeItemView(_ref3) {
        var root = _ref3.root,
            action = _ref3.action;
        var id = action.id;

        // get the view matching the given id
        var view = root.childViews.find(function(child) {
            return child.id === id;
        });

        // if no view found, exit
        if (!view) {
            return;
        }

        // animate view out of view
        view.scaleX = 0.9;
        view.scaleY = 0.9;
        view.opacity = 0;

        // mark for removal
        view.markedForRemoval = true;
    };

    var getItemHeight = function getItemHeight(child) {
        return (
            child.rect.element.height +
            child.rect.element.marginBottom * 0.5 +
            child.rect.element.marginTop * 0.5
        );
    };
    var getItemWidth = function getItemWidth(child) {
        return (
            child.rect.element.width +
            child.rect.element.marginLeft * 0.5 +
            child.rect.element.marginRight * 0.5
        );
    };

    var dragItem = function dragItem(_ref4) {
        var root = _ref4.root,
            action = _ref4.action;
        var id = action.id,
            dragState = action.dragState;

        // reference to item
        var item = root.query('GET_ITEM', { id: id });

        // get the view matching the given id
        var view = root.childViews.find(function(child) {
            return child.id === id;
        });

        var numItems = root.childViews.length;
        var oldIndex = dragState.getItemIndex(item);

        // if no view found, exit
        if (!view) return;

        var dragPosition = {
            x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,
            y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y,
        };

        // get drag area dimensions
        var dragHeight = getItemHeight(view);
        var dragWidth = getItemWidth(view);

        // get rows and columns (There will always be at least one row and one column if a file is present)
        var cols = Math.floor(root.rect.outer.width / dragWidth);
        if (cols > numItems) cols = numItems;

        // rows are used to find when we have left the preview area bounding box
        var rows = Math.floor(numItems / cols + 1);

        dropAreaDimensions.setHeight = dragHeight * rows;
        dropAreaDimensions.setWidth = dragWidth * cols;

        // get new index of dragged item
        var location = {
            y: Math.floor(dragPosition.y / dragHeight),
            x: Math.floor(dragPosition.x / dragWidth),
            getGridIndex: function getGridIndex() {
                if (
                    dragPosition.y > dropAreaDimensions.getHeight ||
                    dragPosition.y < 0 ||
                    dragPosition.x > dropAreaDimensions.getWidth ||
                    dragPosition.x < 0
                )
                    return oldIndex;
                return this.y * cols + this.x;
            },
            getColIndex: function getColIndex() {
                var items = root.query('GET_ACTIVE_ITEMS');
                var visibleChildren = root.childViews.filter(function(child) {
                    return child.rect.element.height;
                });
                var children = items.map(function(item) {
                    return visibleChildren.find(function(childView) {
                        return childView.id === item.id;
                    });
                });

                var currentIndex = children.findIndex(function(child) {
                    return child === view;
                });
                var dragHeight = getItemHeight(view);
                var l = children.length;
                var idx = l;
                var childHeight = 0;
                var childBottom = 0;
                var childTop = 0;
                for (var i = 0; i < l; i++) {
                    childHeight = getItemHeight(children[i]);
                    childTop = childBottom;
                    childBottom = childTop + childHeight;
                    if (dragPosition.y < childBottom) {
                        if (currentIndex > i) {
                            if (dragPosition.y < childTop + dragHeight) {
                                idx = i;
                                break;
                            }
                            continue;
                        }
                        idx = i;
                        break;
                    }
                }
                return idx;
            },
        };

        // get new index
        var index = cols > 1 ? location.getGridIndex() : location.getColIndex();
        root.dispatch('MOVE_ITEM', { query: view, index: index });

        // if the index of the item changed, dispatch reorder action
        var currentIndex = dragState.getIndex();

        if (currentIndex === undefined || currentIndex !== index) {
            dragState.setIndex(index);

            if (currentIndex === undefined) return;

            root.dispatch('DID_REORDER_ITEMS', {
                items: root.query('GET_ACTIVE_ITEMS'),
                origin: oldIndex,
                target: index,
            });
        }
    };

    /**
     * Setup action routes
     */
    var route$2 = createRoute({
        DID_ADD_ITEM: addItemView,
        DID_REMOVE_ITEM: removeItemView,
        DID_DRAG_ITEM: dragItem,
    });

    /**
     * Write to view
     * @param root
     * @param actions
     * @param props
     */
    var write$5 = function write(_ref5) {
        var root = _ref5.root,
            props = _ref5.props,
            actions = _ref5.actions,
            shouldOptimize = _ref5.shouldOptimize;
        // route actions
        route$2({ root: root, props: props, actions: actions });
        var dragCoordinates = props.dragCoordinates;

        // available space on horizontal axis
        var horizontalSpace = root.rect.element.width;

        // only draw children that have dimensions
        var visibleChildren = root.childViews.filter(function(child) {
            return child.rect.element.height;
        });

        // sort based on current active items
        var children = root
            .query('GET_ACTIVE_ITEMS')
            .map(function(item) {
                return visibleChildren.find(function(child) {
                    return child.id === item.id;
                });
            })
            .filter(function(item) {
                return item;
            });

        // get index
        var dragIndex = dragCoordinates
            ? getItemIndexByPosition(root, children, dragCoordinates)
            : null;

        // add index is used to reserve the dropped/added item index till the actual item is rendered
        var addIndex = root.ref.addIndex || null;

        // add index no longer needed till possibly next draw
        root.ref.addIndex = null;

        var dragIndexOffset = 0;
        var removeIndexOffset = 0;
        var addIndexOffset = 0;

        if (children.length === 0) return;

        var childRect = children[0].rect.element;
        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
        var itemWidth = childRect.width + itemHorizontalMargin;
        var itemHeight = childRect.height + itemVerticalMargin;
        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);

        // stack
        if (itemsPerRow === 1) {
            var offsetY = 0;
            var dragOffset = 0;

            children.forEach(function(child, index) {
                if (dragIndex) {
                    var dist = index - dragIndex;
                    if (dist === -2) {
                        dragOffset = -itemVerticalMargin * 0.25;
                    } else if (dist === -1) {
                        dragOffset = -itemVerticalMargin * 0.75;
                    } else if (dist === 0) {
                        dragOffset = itemVerticalMargin * 0.75;
                    } else if (dist === 1) {
                        dragOffset = itemVerticalMargin * 0.25;
                    } else {
                        dragOffset = 0;
                    }
                }

                if (shouldOptimize) {
                    child.translateX = null;
                    child.translateY = null;
                }

                if (!child.markedForRemoval) {
                    moveItem(child, 0, offsetY + dragOffset);
                }

                var itemHeight = child.rect.element.height + itemVerticalMargin;

                var visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);

                offsetY += visualHeight;
            });
        }
        // grid
        else {
            var prevX = 0;
            var prevY = 0;

            children.forEach(function(child, index) {
                if (index === dragIndex) {
                    dragIndexOffset = 1;
                }

                if (index === addIndex) {
                    addIndexOffset += 1;
                }

                if (child.markedForRemoval && child.opacity < 0.5) {
                    removeIndexOffset -= 1;
                }

                var visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;

                var indexX = visualIndex % itemsPerRow;
                var indexY = Math.floor(visualIndex / itemsPerRow);

                var offsetX = indexX * itemWidth;
                var offsetY = indexY * itemHeight;

                var vectorX = Math.sign(offsetX - prevX);
                var vectorY = Math.sign(offsetY - prevY);

                prevX = offsetX;
                prevY = offsetY;

                if (child.markedForRemoval) return;

                if (shouldOptimize) {
                    child.translateX = null;
                    child.translateY = null;
                }

                moveItem(child, offsetX, offsetY, vectorX, vectorY);
            });
        }
    };

    /**
     * Filters actions that are meant specifically for a certain child of the list
     * @param child
     * @param actions
     */
    var filterSetItemActions = function filterSetItemActions(child, actions) {
        return actions.filter(function(action) {
            // if action has an id, filter out actions that don't have this child id
            if (action.data && action.data.id) {
                return child.id === action.data.id;
            }

            // allow all other actions
            return true;
        });
    };

    var list = createView({
        create: create$8,
        write: write$5,
        tag: 'ul',
        name: 'list',
        didWriteView: function didWriteView(_ref6) {
            var root = _ref6.root;
            root.childViews
                .filter(function(view) {
                    return view.markedForRemoval && view.opacity === 0 && view.resting;
                })
                .forEach(function(view) {
                    view._destroy();
                    root.removeChildView(view);
                });
        },
        filterFrameActionsForChild: filterSetItemActions,
        mixins: {
            apis: ['dragCoordinates'],
        },
    });

    var create$9 = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        root.ref.list = root.appendChildView(root.createChildView(list));
        props.dragCoordinates = null;
        props.overflowing = false;
    };

    var storeDragCoordinates = function storeDragCoordinates(_ref2) {
        var root = _ref2.root,
            props = _ref2.props,
            action = _ref2.action;
        if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;
        props.dragCoordinates = {
            left: action.position.scopeLeft - root.ref.list.rect.element.left,
            top:
                action.position.scopeTop -
                (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop),
        };
    };

    var clearDragCoordinates = function clearDragCoordinates(_ref3) {
        var props = _ref3.props;
        props.dragCoordinates = null;
    };

    var route$3 = createRoute({
        DID_DRAG: storeDragCoordinates,
        DID_END_DRAG: clearDragCoordinates,
    });

    var write$6 = function write(_ref4) {
        var root = _ref4.root,
            props = _ref4.props,
            actions = _ref4.actions;

        // route actions
        route$3({ root: root, props: props, actions: actions });

        // current drag position
        root.ref.list.dragCoordinates = props.dragCoordinates;

        // if currently overflowing but no longer received overflow
        if (props.overflowing && !props.overflow) {
            props.overflowing = false;

            // reset overflow state
            root.element.dataset.state = '';
            root.height = null;
        }

        // if is not overflowing currently but does receive overflow value
        if (props.overflow) {
            var newHeight = Math.round(props.overflow);
            if (newHeight !== root.height) {
                props.overflowing = true;
                root.element.dataset.state = 'overflow';
                root.height = newHeight;
            }
        }
    };

    var listScroller = createView({
        create: create$9,
        write: write$6,
        name: 'list-scroller',
        mixins: {
            apis: ['overflow', 'dragCoordinates'],
            styles: ['height', 'translateY'],
            animations: {
                translateY: 'spring',
            },
        },
    });

    var attrToggle = function attrToggle(element, name, state) {
        var enabledValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
        if (state) {
            attr(element, name, enabledValue);
        } else {
            element.removeAttribute(name);
        }
    };

    var resetFileInput = function resetFileInput(input) {
        // no value, no need to reset
        if (!input || input.value === '') {
            return;
        }

        try {
            // for modern browsers
            input.value = '';
        } catch (err) {}

        // for IE10
        if (input.value) {
            // quickly append input to temp form and reset form
            var form = createElement$1('form');
            var parentNode = input.parentNode;
            var ref = input.nextSibling;
            form.appendChild(input);
            form.reset();

            // re-inject input where it originally was
            if (ref) {
                parentNode.insertBefore(input, ref);
            } else {
                parentNode.appendChild(input);
            }
        }
    };

    var create$a = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;

        // set id so can be referenced from outside labels
        root.element.id = 'filepond--browser-' + props.id;

        // set name of element (is removed when a value is set)
        attr(root.element, 'name', root.query('GET_NAME'));

        // we have to link this element to the status element
        attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);

        // set label, we use labelled by as otherwise the screenreader does not read the "browse" text in the label (as it has tabindex: 0)
        attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);

        // set configurable props
        setAcceptedFileTypes({
            root: root,
            action: { value: root.query('GET_ACCEPTED_FILE_TYPES') },
        });
        toggleAllowMultiple({ root: root, action: { value: root.query('GET_ALLOW_MULTIPLE') } });
        toggleDirectoryFilter({
            root: root,
            action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') },
        });
        toggleDisabled({ root: root });
        toggleRequired({ root: root, action: { value: root.query('GET_REQUIRED') } });
        setCaptureMethod({ root: root, action: { value: root.query('GET_CAPTURE_METHOD') } });

        // handle changes to the input field
        root.ref.handleChange = function(e) {
            if (!root.element.value) {
                return;
            }

            // extract files and move value of webkitRelativePath path to _relativePath
            var files = Array.from(root.element.files).map(function(file) {
                file._relativePath = file.webkitRelativePath;
                return file;
            });

            // we add a little delay so the OS file select window can move out of the way before we add our file
            setTimeout(function() {
                // load files
                props.onload(files);

                // reset input, it's just for exposing a method to drop files, should not retain any state
                resetFileInput(root.element);
            }, 250);
        };

        root.element.addEventListener('change', root.ref.handleChange);
    };

    var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {
        var root = _ref2.root,
            action = _ref2.action;
        if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;
        attrToggle(
            root.element,
            'accept',
            !!action.value,
            action.value ? action.value.join(',') : ''
        );
    };

    var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {
        var root = _ref3.root,
            action = _ref3.action;
        attrToggle(root.element, 'multiple', action.value);
    };

    var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {
        var root = _ref4.root,
            action = _ref4.action;
        attrToggle(root.element, 'webkitdirectory', action.value);
    };

    var toggleDisabled = function toggleDisabled(_ref5) {
        var root = _ref5.root;
        var isDisabled = root.query('GET_DISABLED');
        var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');
        var disableField = isDisabled || !doesAllowBrowse;
        attrToggle(root.element, 'disabled', disableField);
    };

    var toggleRequired = function toggleRequired(_ref6) {
        var root = _ref6.root,
            action = _ref6.action;
        // want to remove required, always possible
        if (!action.value) {
            attrToggle(root.element, 'required', false);
        }
        // if want to make required, only possible when zero items
        else if (root.query('GET_TOTAL_ITEMS') === 0) {
            attrToggle(root.element, 'required', true);
        }
    };

    var setCaptureMethod = function setCaptureMethod(_ref7) {
        var root = _ref7.root,
            action = _ref7.action;
        attrToggle(
            root.element,
            'capture',
            !!action.value,
            action.value === true ? '' : action.value
        );
    };

    var updateRequiredStatus = function updateRequiredStatus(_ref8) {
        var root = _ref8.root;
        var element = root.element;
        // always remove the required attribute when more than zero items
        if (root.query('GET_TOTAL_ITEMS') > 0) {
            attrToggle(element, 'required', false);
            attrToggle(element, 'name', false);
        } else {
            // add name attribute
            attrToggle(element, 'name', true, root.query('GET_NAME'));

            // remove any validation messages
            var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');
            if (shouldCheckValidity) {
                element.setCustomValidity('');
            }

            // we only add required if the field has been deemed required
            if (root.query('GET_REQUIRED')) {
                attrToggle(element, 'required', true);
            }
        }
    };

    var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {
        var root = _ref9.root;
        var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');
        if (!shouldCheckValidity) return;
        root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));
    };

    var browser = createView({
        tag: 'input',
        name: 'browser',
        ignoreRect: true,
        ignoreRectUpdate: true,
        attributes: {
            type: 'file',
        },

        create: create$a,
        destroy: function destroy(_ref10) {
            var root = _ref10.root;
            root.element.removeEventListener('change', root.ref.handleChange);
        },
        write: createRoute({
            DID_LOAD_ITEM: updateRequiredStatus,
            DID_REMOVE_ITEM: updateRequiredStatus,
            DID_THROW_ITEM_INVALID: updateFieldValidityStatus,

            DID_SET_DISABLED: toggleDisabled,
            DID_SET_ALLOW_BROWSE: toggleDisabled,
            DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,
            DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,
            DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,
            DID_SET_CAPTURE_METHOD: setCaptureMethod,
            DID_SET_REQUIRED: toggleRequired,
        }),
    });

    var Key = {
        ENTER: 13,
        SPACE: 32,
    };

    var create$b = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;

        // create the label and link it to the file browser
        var label = createElement$1('label');
        attr(label, 'for', 'filepond--browser-' + props.id);

        // use for labeling file input (aria-labelledby on file input)
        attr(label, 'id', 'filepond--drop-label-' + props.id);

        // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.
        attr(label, 'aria-hidden', 'true');

        // handle keys
        root.ref.handleKeyDown = function(e) {
            var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;
            if (!isActivationKey) return;
            // stops from triggering the element a second time
            e.preventDefault();

            // click link (will then in turn activate file input)
            root.ref.label.click();
        };

        root.ref.handleClick = function(e) {
            var isLabelClick = e.target === label || label.contains(e.target);

            // don't want to click twice
            if (isLabelClick) return;

            // click link (will then in turn activate file input)
            root.ref.label.click();
        };

        // attach events
        label.addEventListener('keydown', root.ref.handleKeyDown);
        root.element.addEventListener('click', root.ref.handleClick);

        // update
        updateLabelValue(label, props.caption);

        // add!
        root.appendChild(label);
        root.ref.label = label;
    };

    var updateLabelValue = function updateLabelValue(label, value) {
        label.innerHTML = value;
        var clickable = label.querySelector('.filepond--label-action');
        if (clickable) {
            attr(clickable, 'tabindex', '0');
        }
        return value;
    };

    var dropLabel = createView({
        name: 'drop-label',
        ignoreRect: true,
        create: create$b,
        destroy: function destroy(_ref2) {
            var root = _ref2.root;
            root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);
            root.element.removeEventListener('click', root.ref.handleClick);
        },
        write: createRoute({
            DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {
                var root = _ref3.root,
                    action = _ref3.action;
                updateLabelValue(root.ref.label, action.value);
            },
        }),

        mixins: {
            styles: ['opacity', 'translateX', 'translateY'],
            animations: {
                opacity: { type: 'tween', duration: 150 },
                translateX: 'spring',
                translateY: 'spring',
            },
        },
    });

    var blob = createView({
        name: 'drip-blob',
        ignoreRect: true,
        mixins: {
            styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],
            animations: {
                scaleX: 'spring',
                scaleY: 'spring',
                translateX: 'spring',
                translateY: 'spring',
                opacity: { type: 'tween', duration: 250 },
            },
        },
    });

    var addBlob = function addBlob(_ref) {
        var root = _ref.root;
        var centerX = root.rect.element.width * 0.5;
        var centerY = root.rect.element.height * 0.5;

        root.ref.blob = root.appendChildView(
            root.createChildView(blob, {
                opacity: 0,
                scaleX: 2.5,
                scaleY: 2.5,
                translateX: centerX,
                translateY: centerY,
            })
        );
    };

    var moveBlob = function moveBlob(_ref2) {
        var root = _ref2.root,
            action = _ref2.action;
        if (!root.ref.blob) {
            addBlob({ root: root });
            return;
        }

        root.ref.blob.translateX = action.position.scopeLeft;
        root.ref.blob.translateY = action.position.scopeTop;
        root.ref.blob.scaleX = 1;
        root.ref.blob.scaleY = 1;
        root.ref.blob.opacity = 1;
    };

    var hideBlob = function hideBlob(_ref3) {
        var root = _ref3.root;
        if (!root.ref.blob) {
            return;
        }
        root.ref.blob.opacity = 0;
    };

    var explodeBlob = function explodeBlob(_ref4) {
        var root = _ref4.root;
        if (!root.ref.blob) {
            return;
        }
        root.ref.blob.scaleX = 2.5;
        root.ref.blob.scaleY = 2.5;
        root.ref.blob.opacity = 0;
    };

    var write$7 = function write(_ref5) {
        var root = _ref5.root,
            props = _ref5.props,
            actions = _ref5.actions;
        route$4({ root: root, props: props, actions: actions });
        var blob = root.ref.blob;

        if (actions.length === 0 && blob && blob.opacity === 0) {
            root.removeChildView(blob);
            root.ref.blob = null;
        }
    };

    var route$4 = createRoute({
        DID_DRAG: moveBlob,
        DID_DROP: explodeBlob,
        DID_END_DRAG: hideBlob,
    });

    var drip = createView({
        ignoreRect: true,
        ignoreRectUpdate: true,
        name: 'drip',
        write: write$7,
    });

    var setInputFiles = function setInputFiles(element, files) {
        try {
            // Create a DataTransfer instance and add a newly created file
            var dataTransfer = new DataTransfer();
            files.forEach(function(file) {
                if (file instanceof File) {
                    dataTransfer.items.add(file);
                } else {
                    dataTransfer.items.add(
                        new File([file], file.name, {
                            type: file.type,
                        })
                    );
                }
            });

            // Assign the DataTransfer files list to the file input
            element.files = dataTransfer.files;
        } catch (err) {
            return false;
        }
        return true;
    };

    var create$c = function create(_ref) {
        var root = _ref.root;
        return (root.ref.fields = {});
    };

    var getField = function getField(root, id) {
        return root.ref.fields[id];
    };

    var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {
        root.query('GET_ACTIVE_ITEMS').forEach(function(item) {
            if (!root.ref.fields[item.id]) return;
            root.element.appendChild(root.ref.fields[item.id]);
        });
    };

    var didReorderItems = function didReorderItems(_ref2) {
        var root = _ref2.root;
        return syncFieldPositionsWithItems(root);
    };

    var didAddItem = function didAddItem(_ref3) {
        var root = _ref3.root,
            action = _ref3.action;
        var fileItem = root.query('GET_ITEM', action.id);
        var isLocalFile = fileItem.origin === FileOrigin.LOCAL;
        var shouldUseFileInput = !isLocalFile && root.query('SHOULD_UPDATE_FILE_INPUT');
        var dataContainer = createElement$1('input');
        dataContainer.type = shouldUseFileInput ? 'file' : 'hidden';
        dataContainer.name = root.query('GET_NAME');
        dataContainer.disabled = root.query('GET_DISABLED');
        root.ref.fields[action.id] = dataContainer;
        syncFieldPositionsWithItems(root);
    };

    var didLoadItem$1 = function didLoadItem(_ref4) {
        var root = _ref4.root,
            action = _ref4.action;
        var field = getField(root, action.id);
        if (!field) return;

        // store server ref in hidden input
        if (action.serverFileReference !== null) field.value = action.serverFileReference;

        // store file item in file input
        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;

        var fileItem = root.query('GET_ITEM', action.id);
        setInputFiles(field, [fileItem.file]);
    };

    var didPrepareOutput = function didPrepareOutput(_ref5) {
        var root = _ref5.root,
            action = _ref5.action;
        // this timeout pushes the handler after 'load'
        if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;
        setTimeout(function() {
            var field = getField(root, action.id);
            if (!field) return;
            setInputFiles(field, [action.file]);
        }, 0);
    };

    var didSetDisabled = function didSetDisabled(_ref6) {
        var root = _ref6.root;
        root.element.disabled = root.query('GET_DISABLED');
    };

    var didRemoveItem = function didRemoveItem(_ref7) {
        var root = _ref7.root,
            action = _ref7.action;
        var field = getField(root, action.id);
        if (!field) return;
        if (field.parentNode) field.parentNode.removeChild(field);
        delete root.ref.fields[action.id];
    };

    // only runs for server files (so doesn't deal with file input)
    var didDefineValue = function didDefineValue(_ref8) {
        var root = _ref8.root,
            action = _ref8.action;
        var field = getField(root, action.id);
        if (!field) return;
        if (action.value === null) {
            // clear field value
            field.removeAttribute('value');
        } else {
            // set field value
            field.value = action.value;
        }
        syncFieldPositionsWithItems(root);
    };

    var write$8 = createRoute({
        DID_SET_DISABLED: didSetDisabled,
        DID_ADD_ITEM: didAddItem,
        DID_LOAD_ITEM: didLoadItem$1,
        DID_REMOVE_ITEM: didRemoveItem,
        DID_DEFINE_VALUE: didDefineValue,
        DID_PREPARE_OUTPUT: didPrepareOutput,
        DID_REORDER_ITEMS: didReorderItems,
        DID_SORT_ITEMS: didReorderItems,
    });

    var data = createView({
        tag: 'fieldset',
        name: 'data',
        create: create$c,
        write: write$8,
        ignoreRect: true,
    });

    var getRootNode = function getRootNode(element) {
        return 'getRootNode' in element ? element.getRootNode() : document;
    };

    var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];
    var text$1 = ['css', 'csv', 'html', 'txt'];
    var map = {
        zip: 'zip|compressed',
        epub: 'application/epub+zip',
    };

    var guesstimateMimeType = function guesstimateMimeType() {
        var extension = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        extension = extension.toLowerCase();
        if (images.includes(extension)) {
            return (
                'image/' +
                (extension === 'jpg' ? 'jpeg' : extension === 'svg' ? 'svg+xml' : extension)
            );
        }
        if (text$1.includes(extension)) {
            return 'text/' + extension;
        }

        return map[extension] || '';
    };

    var requestDataTransferItems = function requestDataTransferItems(dataTransfer) {
        return new Promise(function(resolve, reject) {
            // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)
            var links = getLinks(dataTransfer);
            if (links.length && !hasFiles(dataTransfer)) {
                return resolve(links);
            }
            // try to get files from the transfer
            getFiles(dataTransfer).then(resolve);
        });
    };

    /**
     * Test if datatransfer has files
     */
    var hasFiles = function hasFiles(dataTransfer) {
        if (dataTransfer.files) return dataTransfer.files.length > 0;
        return false;
    };

    /**
     * Extracts files from a DataTransfer object
     */
    var getFiles = function getFiles(dataTransfer) {
        return new Promise(function(resolve, reject) {
            // get the transfer items as promises
            var promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])
                // only keep file system items (files and directories)
                .filter(function(item) {
                    return isFileSystemItem(item);
                })

                // map each item to promise
                .map(function(item) {
                    return getFilesFromItem(item);
                });

            // if is empty, see if we can extract some info from the files property as a fallback
            if (!promisedFiles.length) {
                // TODO: test for directories (should not be allowed)
                // Use FileReader, problem is that the files property gets lost in the process
                resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);
                return;
            }

            // done!
            Promise.all(promisedFiles)
                .then(function(returnedFileGroups) {
                    // flatten groups
                    var files = [];
                    returnedFileGroups.forEach(function(group) {
                        files.push.apply(files, group);
                    });

                    // done (filter out empty files)!
                    resolve(
                        files
                            .filter(function(file) {
                                return file;
                            })
                            .map(function(file) {
                                if (!file._relativePath)
                                    file._relativePath = file.webkitRelativePath;
                                return file;
                            })
                    );
                })
                .catch(console.error);
        });
    };

    var isFileSystemItem = function isFileSystemItem(item) {
        if (isEntry(item)) {
            var entry = getAsEntry(item);
            if (entry) {
                return entry.isFile || entry.isDirectory;
            }
        }
        return item.kind === 'file';
    };

    var getFilesFromItem = function getFilesFromItem(item) {
        return new Promise(function(resolve, reject) {
            if (isDirectoryEntry(item)) {
                getFilesInDirectory(getAsEntry(item))
                    .then(resolve)
                    .catch(reject);
                return;
            }

            resolve([item.getAsFile()]);
        });
    };

    var getFilesInDirectory = function getFilesInDirectory(entry) {
        return new Promise(function(resolve, reject) {
            var files = [];

            // the total entries to read
            var dirCounter = 0;
            var fileCounter = 0;

            var resolveIfDone = function resolveIfDone() {
                if (fileCounter === 0 && dirCounter === 0) {
                    resolve(files);
                }
            };

            // the recursive function
            var readEntries = function readEntries(dirEntry) {
                dirCounter++;

                var directoryReader = dirEntry.createReader();

                // directories are returned in batches, we need to process all batches before we're done
                var readBatch = function readBatch() {
                    directoryReader.readEntries(function(entries) {
                        if (entries.length === 0) {
                            dirCounter--;
                            resolveIfDone();
                            return;
                        }

                        entries.forEach(function(entry) {
                            // recursively read more directories
                            if (entry.isDirectory) {
                                readEntries(entry);
                            } else {
                                // read as file
                                fileCounter++;

                                entry.file(function(file) {
                                    var correctedFile = correctMissingFileType(file);
                                    if (entry.fullPath)
                                        correctedFile._relativePath = entry.fullPath;
                                    files.push(correctedFile);
                                    fileCounter--;
                                    resolveIfDone();
                                });
                            }
                        });

                        // try to get next batch of files
                        readBatch();
                    }, reject);
                };

                // read first batch of files
                readBatch();
            };

            // go!
            readEntries(entry);
        });
    };

    var correctMissingFileType = function correctMissingFileType(file) {
        if (file.type.length) return file;
        var date = file.lastModifiedDate;
        var name = file.name;
        var type = guesstimateMimeType(getExtensionFromFilename(file.name));
        if (!type.length) return file;
        file = file.slice(0, file.size, type);
        file.name = name;
        file.lastModifiedDate = date;
        return file;
    };

    var isDirectoryEntry = function isDirectoryEntry(item) {
        return isEntry(item) && (getAsEntry(item) || {}).isDirectory;
    };

    var isEntry = function isEntry(item) {
        return 'webkitGetAsEntry' in item;
    };

    var getAsEntry = function getAsEntry(item) {
        return item.webkitGetAsEntry();
    };

    /**
     * Extracts links from a DataTransfer object
     */
    var getLinks = function getLinks(dataTransfer) {
        var links = [];
        try {
            // look in meta data property
            links = getLinksFromTransferMetaData(dataTransfer);
            if (links.length) {
                return links;
            }
            links = getLinksFromTransferURLData(dataTransfer);
        } catch (e) {
            // nope nope nope (probably IE trouble)
        }
        return links;
    };

    var getLinksFromTransferURLData = function getLinksFromTransferURLData(dataTransfer) {
        var data = dataTransfer.getData('url');
        if (typeof data === 'string' && data.length) {
            return [data];
        }
        return [];
    };

    var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(dataTransfer) {
        var data = dataTransfer.getData('text/html');
        if (typeof data === 'string' && data.length) {
            var matches = data.match(/src\s*=\s*"(.+?)"/);
            if (matches) {
                return [matches[1]];
            }
        }
        return [];
    };

    var dragNDropObservers = [];

    var eventPosition = function eventPosition(e) {
        return {
            pageLeft: e.pageX,
            pageTop: e.pageY,
            scopeLeft: e.offsetX || e.layerX,
            scopeTop: e.offsetY || e.layerY,
        };
    };

    var createDragNDropClient = function createDragNDropClient(
        element,
        scopeToObserve,
        filterElement
    ) {
        var observer = getDragNDropObserver(scopeToObserve);

        var client = {
            element: element,
            filterElement: filterElement,
            state: null,
            ondrop: function ondrop() {},
            onenter: function onenter() {},
            ondrag: function ondrag() {},
            onexit: function onexit() {},
            onload: function onload() {},
            allowdrop: function allowdrop() {},
        };

        client.destroy = observer.addListener(client);

        return client;
    };

    var getDragNDropObserver = function getDragNDropObserver(element) {
        // see if already exists, if so, return
        var observer = dragNDropObservers.find(function(item) {
            return item.element === element;
        });
        if (observer) {
            return observer;
        }

        // create new observer, does not yet exist for this element
        var newObserver = createDragNDropObserver(element);
        dragNDropObservers.push(newObserver);
        return newObserver;
    };

    var createDragNDropObserver = function createDragNDropObserver(element) {
        var clients = [];

        var routes = {
            dragenter: dragenter,
            dragover: dragover,
            dragleave: dragleave,
            drop: drop,
        };

        var handlers = {};

        forin(routes, function(event, createHandler) {
            handlers[event] = createHandler(element, clients);
            element.addEventListener(event, handlers[event], false);
        });

        var observer = {
            element: element,
            addListener: function addListener(client) {
                // add as client
                clients.push(client);

                // return removeListener function
                return function() {
                    // remove client
                    clients.splice(clients.indexOf(client), 1);

                    // if no more clients, clean up observer
                    if (clients.length === 0) {
                        dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);

                        forin(routes, function(event) {
                            element.removeEventListener(event, handlers[event], false);
                        });
                    }
                };
            },
        };

        return observer;
    };

    var elementFromPoint = function elementFromPoint(root, point) {
        if (!('elementFromPoint' in root)) {
            root = document;
        }
        return root.elementFromPoint(point.x, point.y);
    };

    var isEventTarget = function isEventTarget(e, target) {
        // get root
        var root = getRootNode(target);

        // get element at position
        // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document
        var elementAtPosition = elementFromPoint(root, {
            x: e.pageX - window.pageXOffset,
            y: e.pageY - window.pageYOffset,
        });

        // test if target is the element or if one of its children is
        return elementAtPosition === target || target.contains(elementAtPosition);
    };

    var initialTarget = null;

    var setDropEffect = function setDropEffect(dataTransfer, effect) {
        // is in try catch as IE11 will throw error if not
        try {
            dataTransfer.dropEffect = effect;
        } catch (e) {}
    };

    var dragenter = function dragenter(root, clients) {
        return function(e) {
            e.preventDefault();

            initialTarget = e.target;

            clients.forEach(function(client) {
                var element = client.element,
                    onenter = client.onenter;

                if (isEventTarget(e, element)) {
                    client.state = 'enter';

                    // fire enter event
                    onenter(eventPosition(e));
                }
            });
        };
    };

    var dragover = function dragover(root, clients) {
        return function(e) {
            e.preventDefault();

            var dataTransfer = e.dataTransfer;

            requestDataTransferItems(dataTransfer).then(function(items) {
                var overDropTarget = false;

                clients.some(function(client) {
                    var filterElement = client.filterElement,
                        element = client.element,
                        onenter = client.onenter,
                        onexit = client.onexit,
                        ondrag = client.ondrag,
                        allowdrop = client.allowdrop;

                    // by default we can drop
                    setDropEffect(dataTransfer, 'copy');

                    // allow transfer of these items
                    var allowsTransfer = allowdrop(items);

                    // only used when can be dropped on page
                    if (!allowsTransfer) {
                        setDropEffect(dataTransfer, 'none');
                        return;
                    }

                    // targetting this client
                    if (isEventTarget(e, element)) {
                        overDropTarget = true;

                        // had no previous state, means we are entering this client
                        if (client.state === null) {
                            client.state = 'enter';
                            onenter(eventPosition(e));
                            return;
                        }

                        // now over element (no matter if it allows the drop or not)
                        client.state = 'over';

                        // needs to allow transfer
                        if (filterElement && !allowsTransfer) {
                            setDropEffect(dataTransfer, 'none');
                            return;
                        }

                        // dragging
                        ondrag(eventPosition(e));
                    } else {
                        // should be over an element to drop
                        if (filterElement && !overDropTarget) {
                            setDropEffect(dataTransfer, 'none');
                        }

                        // might have just left this client?
                        if (client.state) {
                            client.state = null;
                            onexit(eventPosition(e));
                        }
                    }
                });
            });
        };
    };

    var drop = function drop(root, clients) {
        return function(e) {
            e.preventDefault();

            var dataTransfer = e.dataTransfer;

            requestDataTransferItems(dataTransfer).then(function(items) {
                clients.forEach(function(client) {
                    var filterElement = client.filterElement,
                        element = client.element,
                        ondrop = client.ondrop,
                        onexit = client.onexit,
                        allowdrop = client.allowdrop;

                    client.state = null;

                    // if we're filtering on element we need to be over the element to drop
                    if (filterElement && !isEventTarget(e, element)) return;

                    // no transfer for this client
                    if (!allowdrop(items)) return onexit(eventPosition(e));

                    // we can drop these items on this client
                    ondrop(eventPosition(e), items);
                });
            });
        };
    };

    var dragleave = function dragleave(root, clients) {
        return function(e) {
            if (initialTarget !== e.target) {
                return;
            }

            clients.forEach(function(client) {
                var onexit = client.onexit;

                client.state = null;

                onexit(eventPosition(e));
            });
        };
    };

    var createHopper = function createHopper(scope, validateItems, options) {
        // is now hopper scope
        scope.classList.add('filepond--hopper');

        // shortcuts
        var catchesDropsOnPage = options.catchesDropsOnPage,
            requiresDropOnElement = options.requiresDropOnElement,
            _options$filterItems = options.filterItems,
            filterItems =
                _options$filterItems === void 0
                    ? function(items) {
                          return items;
                      }
                    : _options$filterItems;

        // create a dnd client
        var client = createDragNDropClient(
            scope,
            catchesDropsOnPage ? document.documentElement : scope,
            requiresDropOnElement
        );

        // current client state
        var lastState = '';
        var currentState = '';

        // determines if a file may be dropped
        client.allowdrop = function(items) {
            // TODO: if we can, throw error to indicate the items cannot by dropped

            return validateItems(filterItems(items));
        };

        client.ondrop = function(position, items) {
            var filteredItems = filterItems(items);

            if (!validateItems(filteredItems)) {
                api.ondragend(position);
                return;
            }

            currentState = 'drag-drop';

            api.onload(filteredItems, position);
        };

        client.ondrag = function(position) {
            api.ondrag(position);
        };

        client.onenter = function(position) {
            currentState = 'drag-over';

            api.ondragstart(position);
        };

        client.onexit = function(position) {
            currentState = 'drag-exit';

            api.ondragend(position);
        };

        var api = {
            updateHopperState: function updateHopperState() {
                if (lastState !== currentState) {
                    scope.dataset.hopperState = currentState;
                    lastState = currentState;
                }
            },
            onload: function onload() {},
            ondragstart: function ondragstart() {},
            ondrag: function ondrag() {},
            ondragend: function ondragend() {},
            destroy: function destroy() {
                // destroy client
                client.destroy();
            },
        };

        return api;
    };

    var listening = false;
    var listeners$1 = [];

    var handlePaste = function handlePaste(e) {
        // if is pasting in input or textarea and the target is outside of a filepond scope, ignore
        var activeEl = document.activeElement;
        if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {
            // test textarea or input is contained in filepond root
            var inScope = false;
            var element = activeEl;
            while (element !== document.body) {
                if (element.classList.contains('filepond--root')) {
                    inScope = true;
                    break;
                }
                element = element.parentNode;
            }

            if (!inScope) return;
        }

        requestDataTransferItems(e.clipboardData).then(function(files) {
            // no files received
            if (!files.length) {
                return;
            }

            // notify listeners of received files
            listeners$1.forEach(function(listener) {
                return listener(files);
            });
        });
    };

    var listen = function listen(cb) {
        // can't add twice
        if (listeners$1.includes(cb)) {
            return;
        }

        // add initial listener
        listeners$1.push(cb);

        // setup paste listener for entire page
        if (listening) {
            return;
        }

        listening = true;
        document.addEventListener('paste', handlePaste);
    };

    var unlisten = function unlisten(listener) {
        arrayRemove(listeners$1, listeners$1.indexOf(listener));

        // clean up
        if (listeners$1.length === 0) {
            document.removeEventListener('paste', handlePaste);
            listening = false;
        }
    };

    var createPaster = function createPaster() {
        var cb = function cb(files) {
            api.onload(files);
        };

        var api = {
            destroy: function destroy() {
                unlisten(cb);
            },
            onload: function onload() {},
        };

        listen(cb);

        return api;
    };

    /**
     * Creates the file view
     */
    var create$d = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        root.element.id = 'filepond--assistant-' + props.id;
        attr(root.element, 'role', 'status');
        attr(root.element, 'aria-live', 'polite');
        attr(root.element, 'aria-relevant', 'additions');
    };

    var addFilesNotificationTimeout = null;
    var notificationClearTimeout = null;

    var filenames = [];

    var assist = function assist(root, message) {
        root.element.textContent = message;
    };

    var clear$1 = function clear(root) {
        root.element.textContent = '';
    };

    var listModified = function listModified(root, filename, label) {
        var total = root.query('GET_TOTAL_ITEMS');
        assist(
            root,
            label +
                ' ' +
                filename +
                ', ' +
                total +
                ' ' +
                (total === 1
                    ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')
                    : root.query('GET_LABEL_FILE_COUNT_PLURAL'))
        );

        // clear group after set amount of time so the status is not read twice
        clearTimeout(notificationClearTimeout);
        notificationClearTimeout = setTimeout(function() {
            clear$1(root);
        }, 1500);
    };

    var isUsingFilePond = function isUsingFilePond(root) {
        return root.element.parentNode.contains(document.activeElement);
    };

    var itemAdded = function itemAdded(_ref2) {
        var root = _ref2.root,
            action = _ref2.action;
        if (!isUsingFilePond(root)) {
            return;
        }

        root.element.textContent = '';
        var item = root.query('GET_ITEM', action.id);
        filenames.push(item.filename);

        clearTimeout(addFilesNotificationTimeout);
        addFilesNotificationTimeout = setTimeout(function() {
            listModified(root, filenames.join(', '), root.query('GET_LABEL_FILE_ADDED'));

            filenames.length = 0;
        }, 750);
    };

    var itemRemoved = function itemRemoved(_ref3) {
        var root = _ref3.root,
            action = _ref3.action;
        if (!isUsingFilePond(root)) {
            return;
        }

        var item = action.item;
        listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));
    };

    var itemProcessed = function itemProcessed(_ref4) {
        var root = _ref4.root,
            action = _ref4.action;
        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file

        var item = root.query('GET_ITEM', action.id);
        var filename = item.filename;
        var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');

        assist(root, filename + ' ' + label);
    };

    var itemProcessedUndo = function itemProcessedUndo(_ref5) {
        var root = _ref5.root,
            action = _ref5.action;
        var item = root.query('GET_ITEM', action.id);
        var filename = item.filename;
        var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');

        assist(root, filename + ' ' + label);
    };

    var itemError = function itemError(_ref6) {
        var root = _ref6.root,
            action = _ref6.action;
        var item = root.query('GET_ITEM', action.id);
        var filename = item.filename;

        // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file

        assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);
    };

    var assistant = createView({
        create: create$d,
        ignoreRect: true,
        ignoreRectUpdate: true,
        write: createRoute({
            DID_LOAD_ITEM: itemAdded,
            DID_REMOVE_ITEM: itemRemoved,
            DID_COMPLETE_ITEM_PROCESSING: itemProcessed,

            DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,
            DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,

            DID_THROW_ITEM_REMOVE_ERROR: itemError,
            DID_THROW_ITEM_LOAD_ERROR: itemError,
            DID_THROW_ITEM_INVALID: itemError,
            DID_THROW_ITEM_PROCESSING_ERROR: itemError,
        }),

        tag: 'span',
        name: 'assistant',
    });

    var toCamels = function toCamels(string) {
        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';
        return string.replace(new RegExp(separator + '.', 'g'), function(sub) {
            return sub.charAt(1).toUpperCase();
        });
    };

    var debounce = function debounce(func) {
        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
        var immidiateOnly =
            arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var last = Date.now();
        var timeout = null;

        return function() {
            for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
            ) {
                args[_key] = arguments[_key];
            }
            clearTimeout(timeout);

            var dist = Date.now() - last;

            var fn = function fn() {
                last = Date.now();
                func.apply(void 0, args);
            };

            if (dist < interval) {
                // we need to delay by the difference between interval and dist
                // for example: if distance is 10 ms and interval is 16 ms,
                // we need to wait an additional 6ms before calling the function)
                if (!immidiateOnly) {
                    timeout = setTimeout(fn, interval - dist);
                }
            } else {
                // go!
                fn();
            }
        };
    };

    var MAX_FILES_LIMIT = 1000000;

    var prevent = function prevent(e) {
        return e.preventDefault();
    };

    var create$e = function create(_ref) {
        var root = _ref.root,
            props = _ref.props;
        // Add id
        var id = root.query('GET_ID');
        if (id) {
            root.element.id = id;
        }

        // Add className
        var className = root.query('GET_CLASS_NAME');
        if (className) {
            className
                .split(' ')
                .filter(function(name) {
                    return name.length;
                })
                .forEach(function(name) {
                    root.element.classList.add(name);
                });
        }

        // Field label
        root.ref.label = root.appendChildView(
            root.createChildView(
                dropLabel,
                Object.assign({}, props, {
                    translateY: null,
                    caption: root.query('GET_LABEL_IDLE'),
                })
            )
        );

        // List of items
        root.ref.list = root.appendChildView(
            root.createChildView(listScroller, { translateY: null })
        );

        // Background panel
        root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'panel-root' }));

        // Assistant notifies assistive tech when content changes
        root.ref.assistant = root.appendChildView(
            root.createChildView(assistant, Object.assign({}, props))
        );

        // Data
        root.ref.data = root.appendChildView(root.createChildView(data, Object.assign({}, props)));

        // Measure (tests if fixed height was set)
        // DOCTYPE needs to be set for this to work
        root.ref.measure = createElement$1('div');
        root.ref.measure.style.height = '100%';
        root.element.appendChild(root.ref.measure);

        // information on the root height or fixed height status
        root.ref.bounds = null;

        // apply initial style properties
        root.query('GET_STYLES')
            .filter(function(style) {
                return !isEmpty(style.value);
            })
            .map(function(_ref2) {
                var name = _ref2.name,
                    value = _ref2.value;
                root.element.dataset[name] = value;
            });

        // determine if width changed
        root.ref.widthPrevious = null;
        root.ref.widthUpdated = debounce(function() {
            root.ref.updateHistory = [];
            root.dispatch('DID_RESIZE_ROOT');
        }, 250);

        // history of updates
        root.ref.previousAspectRatio = null;
        root.ref.updateHistory = [];

        // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)
        var canHover = window.matchMedia('(pointer: fine) and (hover: hover)').matches;
        var hasPointerEvents = 'PointerEvent' in window;
        if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {
            root.element.addEventListener('touchmove', prevent, { passive: false });
            root.element.addEventListener('gesturestart', prevent);
        }

        // add credits
        var credits = root.query('GET_CREDITS');
        var hasCredits = credits.length === 2;
        if (hasCredits) {
            var frag = document.createElement('a');
            frag.className = 'filepond--credits';
            frag.setAttribute('aria-hidden', 'true');
            frag.href = credits[0];
            frag.tabindex = -1;
            frag.target = '_blank';
            frag.rel = 'noopener noreferrer';
            frag.textContent = credits[1];
            root.element.appendChild(frag);
            root.ref.credits = frag;
        }
    };

    var write$9 = function write(_ref3) {
        var root = _ref3.root,
            props = _ref3.props,
            actions = _ref3.actions;
        // route actions
        route$5({ root: root, props: props, actions: actions });

        // apply style properties
        actions
            .filter(function(action) {
                return /^DID_SET_STYLE_/.test(action.type);
            })
            .filter(function(action) {
                return !isEmpty(action.data.value);
            })
            .map(function(_ref4) {
                var type = _ref4.type,
                    data = _ref4.data;
                var name = toCamels(type.substr(8).toLowerCase(), '_');
                root.element.dataset[name] = data.value;
                root.invalidateLayout();
            });

        if (root.rect.element.hidden) return;

        if (root.rect.element.width !== root.ref.widthPrevious) {
            root.ref.widthPrevious = root.rect.element.width;
            root.ref.widthUpdated();
        }

        // get box bounds, we do this only once
        var bounds = root.ref.bounds;
        if (!bounds) {
            bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);

            // destroy measure element
            root.element.removeChild(root.ref.measure);
            root.ref.measure = null;
        }

        // get quick references to various high level parts of the upload tool
        var _root$ref = root.ref,
            hopper = _root$ref.hopper,
            label = _root$ref.label,
            list = _root$ref.list,
            panel = _root$ref.panel;

        // sets correct state to hopper scope
        if (hopper) {
            hopper.updateHopperState();
        }

        // bool to indicate if we're full or not
        var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');
        var isMultiItem = root.query('GET_ALLOW_MULTIPLE');
        var totalItems = root.query('GET_TOTAL_ITEMS');
        var maxItems = isMultiItem ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT : 1;
        var atMaxCapacity = totalItems === maxItems;

        // action used to add item
        var addAction = actions.find(function(action) {
            return action.type === 'DID_ADD_ITEM';
        });

        // if reached max capacity and we've just reached it
        if (atMaxCapacity && addAction) {
            // get interaction type
            var interactionMethod = addAction.data.interactionMethod;

            // hide label
            label.opacity = 0;

            if (isMultiItem) {
                label.translateY = -40;
            } else {
                if (interactionMethod === InteractionMethod.API) {
                    label.translateX = 40;
                } else if (interactionMethod === InteractionMethod.BROWSE) {
                    label.translateY = 40;
                } else {
                    label.translateY = 30;
                }
            }
        } else if (!atMaxCapacity) {
            label.opacity = 1;
            label.translateX = 0;
            label.translateY = 0;
        }

        var listItemMargin = calculateListItemMargin(root);

        var listHeight = calculateListHeight(root);

        var labelHeight = label.rect.element.height;
        var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;

        var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;
        var listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;

        var visualHeight =
            currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;
        var boundsHeight =
            currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;

        // link list to label bottom position
        list.translateY =
            Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;

        if (aspectRatio) {
            // fixed aspect ratio

            // calculate height based on width
            var width = root.rect.element.width;
            var height = width * aspectRatio;

            // clear history if aspect ratio has changed
            if (aspectRatio !== root.ref.previousAspectRatio) {
                root.ref.previousAspectRatio = aspectRatio;
                root.ref.updateHistory = [];
            }

            // remember this width
            var history = root.ref.updateHistory;
            history.push(width);

            var MAX_BOUNCES = 2;
            if (history.length > MAX_BOUNCES * 2) {
                var l = history.length;
                var bottom = l - 10;
                var bounces = 0;
                for (var i = l; i >= bottom; i--) {
                    if (history[i] === history[i - 2]) {
                        bounces++;
                    }

                    if (bounces >= MAX_BOUNCES) {
                        // dont adjust height
                        return;
                    }
                }
            }

            // fix height of panel so it adheres to aspect ratio
            panel.scalable = false;
            panel.height = height;

            // available height for list
            var listAvailableHeight =
                // the height of the panel minus the label height
                height -
                currentLabelHeight -
                // the room we leave open between the end of the list and the panel bottom
                (listMarginBottom - listItemMargin.bottom) -
                // if we're full we need to leave some room between the top of the panel and the list
                (atMaxCapacity ? listMarginTop : 0);

            if (listHeight.visual > listAvailableHeight) {
                list.overflow = listAvailableHeight;
            } else {
                list.overflow = null;
            }

            // set container bounds (so pushes siblings downwards)
            root.height = height;
        } else if (bounds.fixedHeight) {
            // fixed height

            // fix height of panel
            panel.scalable = false;

            // available height for list
            var _listAvailableHeight =
                // the height of the panel minus the label height
                bounds.fixedHeight -
                currentLabelHeight -
                // the room we leave open between the end of the list and the panel bottom
                (listMarginBottom - listItemMargin.bottom) -
                // if we're full we need to leave some room between the top of the panel and the list
                (atMaxCapacity ? listMarginTop : 0);

            // set list height
            if (listHeight.visual > _listAvailableHeight) {
                list.overflow = _listAvailableHeight;
            } else {
                list.overflow = null;
            }

            // no need to set container bounds as these are handles by CSS fixed height
        } else if (bounds.cappedHeight) {
            // max-height

            // not a fixed height panel
            var isCappedHeight = visualHeight >= bounds.cappedHeight;
            var panelHeight = Math.min(bounds.cappedHeight, visualHeight);
            panel.scalable = true;
            panel.height = isCappedHeight
                ? panelHeight
                : panelHeight - listItemMargin.top - listItemMargin.bottom;

            // available height for list
            var _listAvailableHeight2 =
                // the height of the panel minus the label height
                panelHeight -
                currentLabelHeight -
                // the room we leave open between the end of the list and the panel bottom
                (listMarginBottom - listItemMargin.bottom) -
                // if we're full we need to leave some room between the top of the panel and the list
                (atMaxCapacity ? listMarginTop : 0);

            // set list height (if is overflowing)
            if (visualHeight > bounds.cappedHeight && listHeight.visual > _listAvailableHeight2) {
                list.overflow = _listAvailableHeight2;
            } else {
                list.overflow = null;
            }

            // set container bounds (so pushes siblings downwards)
            root.height = Math.min(
                bounds.cappedHeight,
                boundsHeight - listItemMargin.top - listItemMargin.bottom
            );
        } else {
            // flexible height

            // not a fixed height panel
            var itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;
            panel.scalable = true;
            panel.height = Math.max(labelHeight, visualHeight - itemMargin);

            // set container bounds (so pushes siblings downwards)
            root.height = Math.max(labelHeight, boundsHeight - itemMargin);
        }

        // move credits to bottom
        if (root.ref.credits && panel.heightCurrent)
            root.ref.credits.style.transform = 'translateY(' + panel.heightCurrent + 'px)';
    };

    var calculateListItemMargin = function calculateListItemMargin(root) {
        var item = root.ref.list.childViews[0].childViews[0];
        return item
            ? {
                  top: item.rect.element.marginTop,
                  bottom: item.rect.element.marginBottom,
              }
            : {
                  top: 0,
                  bottom: 0,
              };
    };

    var calculateListHeight = function calculateListHeight(root) {
        var visual = 0;
        var bounds = 0;

        // get file list reference
        var scrollList = root.ref.list;
        var itemList = scrollList.childViews[0];
        var visibleChildren = itemList.childViews.filter(function(child) {
            return child.rect.element.height;
        });
        var children = root
            .query('GET_ACTIVE_ITEMS')
            .map(function(item) {
                return visibleChildren.find(function(child) {
                    return child.id === item.id;
                });
            })
            .filter(function(item) {
                return item;
            });

        // no children, done!
        if (children.length === 0) return { visual: visual, bounds: bounds };

        var horizontalSpace = itemList.rect.element.width;
        var dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);

        var childRect = children[0].rect.element;

        var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
        var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;

        var itemWidth = childRect.width + itemHorizontalMargin;
        var itemHeight = childRect.height + itemVerticalMargin;

        var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;
        var removedItem = children.find(function(child) {
            return child.markedForRemoval && child.opacity < 0.45;
        })
            ? -1
            : 0;
        var verticalItemCount = children.length + newItem + removedItem;
        var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);

        // stack
        if (itemsPerRow === 1) {
            children.forEach(function(item) {
                var height = item.rect.element.height + itemVerticalMargin;
                bounds += height;
                visual += height * item.opacity;
            });
        }
        // grid
        else {
            bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;
            visual = bounds;
        }

        return { visual: visual, bounds: bounds };
    };

    var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(root) {
        var height = root.ref.measureHeight || null;
        var cappedHeight = parseInt(root.style.maxHeight, 10) || null;
        var fixedHeight = height === 0 ? null : height;

        return {
            cappedHeight: cappedHeight,
            fixedHeight: fixedHeight,
        };
    };

    var exceedsMaxFiles = function exceedsMaxFiles(root, items) {
        var allowReplace = root.query('GET_ALLOW_REPLACE');
        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');
        var totalItems = root.query('GET_TOTAL_ITEMS');
        var maxItems = root.query('GET_MAX_FILES');

        // total amount of items being dragged
        var totalBrowseItems = items.length;

        // if does not allow multiple items and dragging more than one item
        if (!allowMultiple && totalBrowseItems > 1) {
            return true;
        }

        // limit max items to one if not allowed to drop multiple items
        maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;

        // no more room?
        var hasMaxItems = isInt(maxItems);
        if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {
            root.dispatch('DID_THROW_MAX_FILES', {
                source: items,
                error: createResponse('warning', 0, 'Max files'),
            });

            return true;
        }

        return false;
    };

    var getDragIndex = function getDragIndex(list, children, position) {
        var itemList = list.childViews[0];
        return getItemIndexByPosition(itemList, children, {
            left: position.scopeLeft - itemList.rect.element.left,
            top:
                position.scopeTop -
                (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop),
        });
    };

    /**
     * Enable or disable file drop functionality
     */
    var toggleDrop = function toggleDrop(root) {
        var isAllowed = root.query('GET_ALLOW_DROP');
        var isDisabled = root.query('GET_DISABLED');
        var enabled = isAllowed && !isDisabled;
        if (enabled && !root.ref.hopper) {
            var hopper = createHopper(
                root.element,
                function(items) {
                    // allow quick validation of dropped items
                    var beforeDropFile =
                        root.query('GET_BEFORE_DROP_FILE') ||
                        function() {
                            return true;
                        };

                    // all items should be validated by all filters as valid
                    var dropValidation = root.query('GET_DROP_VALIDATION');
                    return dropValidation
                        ? items.every(function(item) {
                              return (
                                  applyFilters('ALLOW_HOPPER_ITEM', item, {
                                      query: root.query,
                                  }).every(function(result) {
                                      return result === true;
                                  }) && beforeDropFile(item)
                              );
                          })
                        : true;
                },
                {
                    filterItems: function filterItems(items) {
                        var ignoredFiles = root.query('GET_IGNORED_FILES');
                        return items.filter(function(item) {
                            if (isFile(item)) {
                                return !ignoredFiles.includes(item.name.toLowerCase());
                            }
                            return true;
                        });
                    },
                    catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),
                    requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT'),
                }
            );

            hopper.onload = function(items, position) {
                // get item children elements and sort based on list sort
                var list = root.ref.list.childViews[0];
                var visibleChildren = list.childViews.filter(function(child) {
                    return child.rect.element.height;
                });
                var children = root
                    .query('GET_ACTIVE_ITEMS')
                    .map(function(item) {
                        return visibleChildren.find(function(child) {
                            return child.id === item.id;
                        });
                    })
                    .filter(function(item) {
                        return item;
                    });

                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(
                    queue
                ) {
                    // these files don't fit so stop here
                    if (exceedsMaxFiles(root, queue)) return false;

                    // go
                    root.dispatch('ADD_ITEMS', {
                        items: queue,
                        index: getDragIndex(root.ref.list, children, position),
                        interactionMethod: InteractionMethod.DROP,
                    });
                });

                root.dispatch('DID_DROP', { position: position });

                root.dispatch('DID_END_DRAG', { position: position });
            };

            hopper.ondragstart = function(position) {
                root.dispatch('DID_START_DRAG', { position: position });
            };

            hopper.ondrag = debounce(function(position) {
                root.dispatch('DID_DRAG', { position: position });
            });

            hopper.ondragend = function(position) {
                root.dispatch('DID_END_DRAG', { position: position });
            };

            root.ref.hopper = hopper;

            root.ref.drip = root.appendChildView(root.createChildView(drip));
        } else if (!enabled && root.ref.hopper) {
            root.ref.hopper.destroy();
            root.ref.hopper = null;
            root.removeChildView(root.ref.drip);
        }
    };

    /**
     * Enable or disable browse functionality
     */
    var toggleBrowse = function toggleBrowse(root, props) {
        var isAllowed = root.query('GET_ALLOW_BROWSE');
        var isDisabled = root.query('GET_DISABLED');
        var enabled = isAllowed && !isDisabled;
        if (enabled && !root.ref.browser) {
            root.ref.browser = root.appendChildView(
                root.createChildView(
                    browser,
                    Object.assign({}, props, {
                        onload: function onload(items) {
                            applyFilterChain('ADD_ITEMS', items, {
                                dispatch: root.dispatch,
                            }).then(function(queue) {
                                // these files don't fit so stop here
                                if (exceedsMaxFiles(root, queue)) return false;

                                // add items!
                                root.dispatch('ADD_ITEMS', {
                                    items: queue,
                                    index: -1,
                                    interactionMethod: InteractionMethod.BROWSE,
                                });
                            });
                        },
                    })
                ),

                0
            );
        } else if (!enabled && root.ref.browser) {
            root.removeChildView(root.ref.browser);
            root.ref.browser = null;
        }
    };

    /**
     * Enable or disable paste functionality
     */
    var togglePaste = function togglePaste(root) {
        var isAllowed = root.query('GET_ALLOW_PASTE');
        var isDisabled = root.query('GET_DISABLED');
        var enabled = isAllowed && !isDisabled;
        if (enabled && !root.ref.paster) {
            root.ref.paster = createPaster();
            root.ref.paster.onload = function(items) {
                applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(function(
                    queue
                ) {
                    // these files don't fit so stop here
                    if (exceedsMaxFiles(root, queue)) return false;

                    // add items!
                    root.dispatch('ADD_ITEMS', {
                        items: queue,
                        index: -1,
                        interactionMethod: InteractionMethod.PASTE,
                    });
                });
            };
        } else if (!enabled && root.ref.paster) {
            root.ref.paster.destroy();
            root.ref.paster = null;
        }
    };

    /**
     * Route actions
     */
    var route$5 = createRoute({
        DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {
            var root = _ref5.root,
                props = _ref5.props;
            toggleBrowse(root, props);
        },
        DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {
            var root = _ref6.root;
            toggleDrop(root);
        },
        DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {
            var root = _ref7.root;
            togglePaste(root);
        },
        DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {
            var root = _ref8.root,
                props = _ref8.props;
            toggleDrop(root);
            togglePaste(root);
            toggleBrowse(root, props);
            var isDisabled = root.query('GET_DISABLED');
            if (isDisabled) {
                root.element.dataset.disabled = 'disabled';
            } else {
                // delete root.element.dataset.disabled; <= this does not work on iOS 10
                root.element.removeAttribute('data-disabled');
            }
        },
    });

    var root = createView({
        name: 'root',
        read: function read(_ref9) {
            var root = _ref9.root;
            if (root.ref.measure) {
                root.ref.measureHeight = root.ref.measure.offsetHeight;
            }
        },
        create: create$e,
        write: write$9,
        destroy: function destroy(_ref10) {
            var root = _ref10.root;
            if (root.ref.paster) {
                root.ref.paster.destroy();
            }
            if (root.ref.hopper) {
                root.ref.hopper.destroy();
            }
            root.element.removeEventListener('touchmove', prevent);
            root.element.removeEventListener('gesturestart', prevent);
        },
        mixins: {
            styles: ['height'],
        },
    });

    // creates the app
    var createApp = function createApp() {
        var initialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // let element
        var originalElement = null;

        // get default options
        var defaultOptions = getOptions();

        // create the data store, this will contain all our app info
        var store = createStore(
            // initial state (should be serializable)
            createInitialState(defaultOptions),

            // queries
            [queries, createOptionQueries(defaultOptions)],

            // action handlers
            [actions, createOptionActions(defaultOptions)]
        );

        // set initial options
        store.dispatch('SET_OPTIONS', { options: initialOptions });

        // kick thread if visibility changes
        var visibilityHandler = function visibilityHandler() {
            if (document.hidden) return;
            store.dispatch('KICK');
        };
        document.addEventListener('visibilitychange', visibilityHandler);

        // re-render on window resize start and finish
        var resizeDoneTimer = null;
        var isResizing = false;
        var isResizingHorizontally = false;
        var initialWindowWidth = null;
        var currentWindowWidth = null;
        var resizeHandler = function resizeHandler() {
            if (!isResizing) {
                isResizing = true;
            }
            clearTimeout(resizeDoneTimer);
            resizeDoneTimer = setTimeout(function() {
                isResizing = false;
                initialWindowWidth = null;
                currentWindowWidth = null;
                if (isResizingHorizontally) {
                    isResizingHorizontally = false;
                    store.dispatch('DID_STOP_RESIZE');
                }
            }, 500);
        };
        window.addEventListener('resize', resizeHandler);

        // render initial view
        var view = root(store, { id: getUniqueId() });

        //
        // PRIVATE API -------------------------------------------------------------------------------------
        //
        var isResting = false;
        var isHidden = false;

        var readWriteApi = {
            // necessary for update loop

            /**
             * Reads from dom (never call manually)
             * @private
             */
            _read: function _read() {
                // test if we're resizing horizontally
                // TODO: see if we can optimize this by measuring root rect
                if (isResizing) {
                    currentWindowWidth = window.innerWidth;
                    if (!initialWindowWidth) {
                        initialWindowWidth = currentWindowWidth;
                    }

                    if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {
                        store.dispatch('DID_START_RESIZE');
                        isResizingHorizontally = true;
                    }
                }

                if (isHidden && isResting) {
                    // test if is no longer hidden
                    isResting = view.element.offsetParent === null;
                }

                // if resting, no need to read as numbers will still all be correct
                if (isResting) return;

                // read view data
                view._read();

                // if is hidden we need to know so we exit rest mode when revealed
                isHidden = view.rect.element.hidden;
            },

            /**
             * Writes to dom (never call manually)
             * @private
             */
            _write: function _write(ts) {
                // get all actions from store
                var actions = store
                    .processActionQueue()

                    // filter out set actions (these will automatically trigger DID_SET)
                    .filter(function(action) {
                        return !/^SET_/.test(action.type);
                    });

                // if was idling and no actions stop here
                if (isResting && !actions.length) return;

                // some actions might trigger events
                routeActionsToEvents(actions);

                // update the view
                isResting = view._write(ts, actions, isResizingHorizontally);

                // will clean up all archived items
                removeReleasedItems(store.query('GET_ITEMS'));

                // now idling
                if (isResting) {
                    store.processDispatchQueue();
                }
            },
        };

        //
        // EXPOSE EVENTS -------------------------------------------------------------------------------------
        //
        var createEvent = function createEvent(name) {
            return function(data) {
                // create default event
                var event = {
                    type: name,
                };

                // no data to add
                if (!data) {
                    return event;
                }

                // copy relevant props
                if (data.hasOwnProperty('error')) {
                    event.error = data.error ? Object.assign({}, data.error) : null;
                }

                if (data.status) {
                    event.status = Object.assign({}, data.status);
                }

                if (data.file) {
                    event.output = data.file;
                }

                // only source is available, else add item if possible
                if (data.source) {
                    event.file = data.source;
                } else if (data.item || data.id) {
                    var item = data.item ? data.item : store.query('GET_ITEM', data.id);
                    event.file = item ? createItemAPI(item) : null;
                }

                // map all items in a possible items array
                if (data.items) {
                    event.items = data.items.map(createItemAPI);
                }

                // if this is a progress event add the progress amount
                if (/progress/.test(name)) {
                    event.progress = data.progress;
                }

                // copy relevant props
                if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {
                    event.origin = data.origin;
                    event.target = data.target;
                }

                return event;
            };
        };

        var eventRoutes = {
            DID_DESTROY: createEvent('destroy'),

            DID_INIT: createEvent('init'),

            DID_THROW_MAX_FILES: createEvent('warning'),

            DID_INIT_ITEM: createEvent('initfile'),
            DID_START_ITEM_LOAD: createEvent('addfilestart'),
            DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),
            DID_LOAD_ITEM: createEvent('addfile'),

            DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],

            DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],

            DID_THROW_ITEM_REMOVE_ERROR: [createEvent('error'), createEvent('removefile')],

            DID_PREPARE_OUTPUT: createEvent('preparefile'),

            DID_START_ITEM_PROCESSING: createEvent('processfilestart'),
            DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),
            DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),
            DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),
            DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),
            DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),

            DID_THROW_ITEM_PROCESSING_ERROR: [createEvent('error'), createEvent('processfile')],

            DID_REMOVE_ITEM: createEvent('removefile'),

            DID_UPDATE_ITEMS: createEvent('updatefiles'),

            DID_ACTIVATE_ITEM: createEvent('activatefile'),

            DID_REORDER_ITEMS: createEvent('reorderfiles'),
        };

        var exposeEvent = function exposeEvent(event) {
            // create event object to be dispatched
            var detail = Object.assign({ pond: exports }, event);
            delete detail.type;
            view.element.dispatchEvent(
                new CustomEvent('FilePond:' + event.type, {
                    // event info
                    detail: detail,

                    // event behaviour
                    bubbles: true,
                    cancelable: true,
                    composed: true, // triggers listeners outside of shadow root
                })
            );

            // event object to params used for `on()` event handlers and callbacks `oninit()`
            var params = [];

            // if is possible error event, make it the first param
            if (event.hasOwnProperty('error')) {
                params.push(event.error);
            }

            // file is always section
            if (event.hasOwnProperty('file')) {
                params.push(event.file);
            }

            // append other props
            var filtered = ['type', 'error', 'file'];
            Object.keys(event)
                .filter(function(key) {
                    return !filtered.includes(key);
                })
                .forEach(function(key) {
                    return params.push(event[key]);
                });

            // on(type, () => { })
            exports.fire.apply(exports, [event.type].concat(params));

            // oninit = () => {}
            var handler = store.query('GET_ON' + event.type.toUpperCase());
            if (handler) {
                handler.apply(void 0, params);
            }
        };

        var routeActionsToEvents = function routeActionsToEvents(actions) {
            if (!actions.length) return;
            actions
                .filter(function(action) {
                    return eventRoutes[action.type];
                })
                .forEach(function(action) {
                    var routes = eventRoutes[action.type];
                    (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {
                        // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init
                        if (action.type === 'DID_INIT_ITEM') {
                            exposeEvent(route(action.data));
                        } else {
                            setTimeout(function() {
                                exposeEvent(route(action.data));
                            }, 0);
                        }
                    });
                });
        };

        //
        // PUBLIC API -------------------------------------------------------------------------------------
        //
        var setOptions = function setOptions(options) {
            return store.dispatch('SET_OPTIONS', { options: options });
        };

        var getFile = function getFile(query) {
            return store.query('GET_ACTIVE_ITEM', query);
        };

        var prepareFile = function prepareFile(query) {
            return new Promise(function(resolve, reject) {
                store.dispatch('REQUEST_ITEM_PREPARE', {
                    query: query,
                    success: function success(item) {
                        resolve(item);
                    },
                    failure: function failure(error) {
                        reject(error);
                    },
                });
            });
        };

        var addFile = function addFile(source) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return new Promise(function(resolve, reject) {
                addFiles([{ source: source, options: options }], { index: options.index })
                    .then(function(items) {
                        return resolve(items && items[0]);
                    })
                    .catch(reject);
            });
        };

        var isFilePondFile = function isFilePondFile(obj) {
            return obj.file && obj.id;
        };

        var removeFile = function removeFile(query, options) {
            // if only passed options
            if (typeof query === 'object' && !isFilePondFile(query) && !options) {
                options = query;
                query = undefined;
            }

            // request item removal
            store.dispatch('REMOVE_ITEM', Object.assign({}, options, { query: query }));

            // see if item has been removed
            return store.query('GET_ACTIVE_ITEM', query) === null;
        };

        var addFiles = function addFiles() {
            for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
            ) {
                args[_key] = arguments[_key];
            }
            return new Promise(function(resolve, reject) {
                var sources = [];
                var options = {};

                // user passed a sources array
                if (isArray(args[0])) {
                    sources.push.apply(sources, args[0]);
                    Object.assign(options, args[1] || {});
                } else {
                    // user passed sources as arguments, last one might be options object
                    var lastArgument = args[args.length - 1];
                    if (typeof lastArgument === 'object' && !(lastArgument instanceof Blob)) {
                        Object.assign(options, args.pop());
                    }

                    // add rest to sources
                    sources.push.apply(sources, args);
                }

                store.dispatch('ADD_ITEMS', {
                    items: sources,
                    index: options.index,
                    interactionMethod: InteractionMethod.API,
                    success: resolve,
                    failure: reject,
                });
            });
        };

        var getFiles = function getFiles() {
            return store.query('GET_ACTIVE_ITEMS');
        };

        var processFile = function processFile(query) {
            return new Promise(function(resolve, reject) {
                store.dispatch('REQUEST_ITEM_PROCESSING', {
                    query: query,
                    success: function success(item) {
                        resolve(item);
                    },
                    failure: function failure(error) {
                        reject(error);
                    },
                });
            });
        };

        var prepareFiles = function prepareFiles() {
            for (
                var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
                _key2 < _len2;
                _key2++
            ) {
                args[_key2] = arguments[_key2];
            }
            var queries = Array.isArray(args[0]) ? args[0] : args;
            var items = queries.length ? queries : getFiles();
            return Promise.all(items.map(prepareFile));
        };

        var processFiles = function processFiles() {
            for (
                var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
                _key3 < _len3;
                _key3++
            ) {
                args[_key3] = arguments[_key3];
            }
            var queries = Array.isArray(args[0]) ? args[0] : args;
            if (!queries.length) {
                var files = getFiles().filter(function(item) {
                    return (
                        !(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) &&
                        item.status !== ItemStatus.PROCESSING &&
                        item.status !== ItemStatus.PROCESSING_COMPLETE &&
                        item.status !== ItemStatus.PROCESSING_REVERT_ERROR
                    );
                });

                return Promise.all(files.map(processFile));
            }
            return Promise.all(queries.map(processFile));
        };

        var removeFiles = function removeFiles() {
            for (
                var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;
                _key4 < _len4;
                _key4++
            ) {
                args[_key4] = arguments[_key4];
            }

            var queries = Array.isArray(args[0]) ? args[0] : args;

            var options;
            if (typeof queries[queries.length - 1] === 'object') {
                options = queries.pop();
            } else if (Array.isArray(args[0])) {
                options = args[1];
            }

            var files = getFiles();

            if (!queries.length)
                return Promise.all(
                    files.map(function(file) {
                        return removeFile(file, options);
                    })
                );

            // when removing by index the indexes shift after each file removal so we need to convert indexes to ids
            var mappedQueries = queries
                .map(function(query) {
                    return isNumber(query) ? (files[query] ? files[query].id : null) : query;
                })
                .filter(function(query) {
                    return query;
                });

            return mappedQueries.map(function(q) {
                return removeFile(q, options);
            });
        };

        var exports = Object.assign(
            {},

            on(),
            {},

            readWriteApi,
            {},

            createOptionAPI(store, defaultOptions),
            {
                /**
                 * Override options defined in options object
                 * @param options
                 */
                setOptions: setOptions,

                /**
                 * Load the given file
                 * @param source - the source of the file (either a File, base64 data uri or url)
                 * @param options - object, { index: 0 }
                 */
                addFile: addFile,

                /**
                 * Load the given files
                 * @param sources - the sources of the files to load
                 * @param options - object, { index: 0 }
                 */
                addFiles: addFiles,

                /**
                 * Returns the file objects matching the given query
                 * @param query { string, number, null }
                 */
                getFile: getFile,

                /**
                 * Upload file with given name
                 * @param query { string, number, null  }
                 */
                processFile: processFile,

                /**
                 * Request prepare output for file with given name
                 * @param query { string, number, null  }
                 */
                prepareFile: prepareFile,

                /**
                 * Removes a file by its name
                 * @param query { string, number, null  }
                 */
                removeFile: removeFile,

                /**
                 * Moves a file to a new location in the files list
                 */
                moveFile: function moveFile(query, index) {
                    return store.dispatch('MOVE_ITEM', { query: query, index: index });
                },

                /**
                 * Returns all files (wrapped in public api)
                 */
                getFiles: getFiles,

                /**
                 * Starts uploading all files
                 */
                processFiles: processFiles,

                /**
                 * Clears all files from the files list
                 */
                removeFiles: removeFiles,

                /**
                 * Starts preparing output of all files
                 */
                prepareFiles: prepareFiles,

                /**
                 * Sort list of files
                 */
                sort: function sort(compare) {
                    return store.dispatch('SORT', { compare: compare });
                },

                /**
                 * Browse the file system for a file
                 */
                browse: function browse() {
                    // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)
                    var input = view.element.querySelector('input[type=file]');
                    if (input) {
                        input.click();
                    }
                },

                /**
                 * Destroys the app
                 */
                destroy: function destroy() {
                    // request destruction
                    exports.fire('destroy', view.element);

                    // stop active processes (file uploads, fetches, stuff like that)
                    // loop over items and depending on states call abort for ongoing processes
                    store.dispatch('ABORT_ALL');

                    // destroy view
                    view._destroy();

                    // stop listening to resize
                    window.removeEventListener('resize', resizeHandler);

                    // stop listening to the visiblitychange event
                    document.removeEventListener('visibilitychange', visibilityHandler);

                    // dispatch destroy
                    store.dispatch('DID_DESTROY');
                },

                /**
                 * Inserts the plugin before the target element
                 */
                insertBefore: function insertBefore$1(element) {
                    return insertBefore(view.element, element);
                },

                /**
                 * Inserts the plugin after the target element
                 */
                insertAfter: function insertAfter$1(element) {
                    return insertAfter(view.element, element);
                },

                /**
                 * Appends the plugin to the target element
                 */
                appendTo: function appendTo(element) {
                    return element.appendChild(view.element);
                },

                /**
                 * Replaces an element with the app
                 */
                replaceElement: function replaceElement(element) {
                    // insert the app before the element
                    insertBefore(view.element, element);

                    // remove the original element
                    element.parentNode.removeChild(element);

                    // remember original element
                    originalElement = element;
                },

                /**
                 * Restores the original element
                 */
                restoreElement: function restoreElement() {
                    if (!originalElement) {
                        return; // no element to restore
                    }

                    // restore original element
                    insertAfter(originalElement, view.element);

                    // remove our element
                    view.element.parentNode.removeChild(view.element);

                    // remove reference
                    originalElement = null;
                },

                /**
                 * Returns true if the app root is attached to given element
                 * @param element
                 */
                isAttachedTo: function isAttachedTo(element) {
                    return view.element === element || originalElement === element;
                },

                /**
                 * Returns the root element
                 */
                element: {
                    get: function get() {
                        return view.element;
                    },
                },

                /**
                 * Returns the current pond status
                 */
                status: {
                    get: function get() {
                        return store.query('GET_STATUS');
                    },
                },
            }
        );

        // Done!
        store.dispatch('DID_INIT');

        // create actual api object
        return createObject(exports);
    };

    var createAppObject = function createAppObject() {
        var customOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // default options
        var defaultOptions = {};
        forin(getOptions(), function(key, value) {
            defaultOptions[key] = value[0];
        });

        // set app options
        var app = createApp(
            Object.assign(
                {},

                defaultOptions,
                {},

                customOptions
            )
        );

        // return the plugin instance
        return app;
    };

    var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {
        return string.charAt(0).toLowerCase() + string.slice(1);
    };

    var attributeNameToPropertyName = function attributeNameToPropertyName(attributeName) {
        return toCamels(attributeName.replace(/^data-/, ''));
    };

    var mapObject = function mapObject(object, propertyMap) {
        // remove unwanted
        forin(propertyMap, function(selector, mapping) {
            forin(object, function(property, value) {
                // create regexp shortcut
                var selectorRegExp = new RegExp(selector);

                // tests if
                var matches = selectorRegExp.test(property);

                // no match, skip
                if (!matches) {
                    return;
                }

                // if there's a mapping, the original property is always removed
                delete object[property];

                // should only remove, we done!
                if (mapping === false) {
                    return;
                }

                // move value to new property
                if (isString(mapping)) {
                    object[mapping] = value;
                    return;
                }

                // move to group
                var group = mapping.group;
                if (isObject(mapping) && !object[group]) {
                    object[group] = {};
                }

                object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ''))] = value;
            });

            // do submapping
            if (mapping.mapping) {
                mapObject(object[mapping.group], mapping.mapping);
            }
        });
    };

    var getAttributesAsObject = function getAttributesAsObject(node) {
        var attributeMapping =
            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        // turn attributes into object
        var attributes = [];
        forin(node.attributes, function(index) {
            attributes.push(node.attributes[index]);
        });

        var output = attributes
            .filter(function(attribute) {
                return attribute.name;
            })
            .reduce(function(obj, attribute) {
                var value = attr(node, attribute.name);

                obj[attributeNameToPropertyName(attribute.name)] =
                    value === attribute.name ? true : value;
                return obj;
            }, {});

        // do mapping of object properties
        mapObject(output, attributeMapping);

        return output;
    };

    var createAppAtElement = function createAppAtElement(element) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        // how attributes of the input element are mapped to the options for the plugin
        var attributeMapping = {
            // translate to other name
            '^class$': 'className',
            '^multiple$': 'allowMultiple',
            '^capture$': 'captureMethod',
            '^webkitdirectory$': 'allowDirectoriesOnly',

            // group under single property
            '^server': {
                group: 'server',
                mapping: {
                    '^process': {
                        group: 'process',
                    },

                    '^revert': {
                        group: 'revert',
                    },

                    '^fetch': {
                        group: 'fetch',
                    },

                    '^restore': {
                        group: 'restore',
                    },

                    '^load': {
                        group: 'load',
                    },
                },
            },

            // don't include in object
            '^type$': false,
            '^files$': false,
        };

        // add additional option translators
        applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);

        // create final options object by setting options object and then overriding options supplied on element
        var mergedOptions = Object.assign({}, options);

        var attributeOptions = getAttributesAsObject(
            element.nodeName === 'FIELDSET' ? element.querySelector('input[type=file]') : element,
            attributeMapping
        );

        // merge with options object
        Object.keys(attributeOptions).forEach(function(key) {
            if (isObject(attributeOptions[key])) {
                if (!isObject(mergedOptions[key])) {
                    mergedOptions[key] = {};
                }
                Object.assign(mergedOptions[key], attributeOptions[key]);
            } else {
                mergedOptions[key] = attributeOptions[key];
            }
        });

        // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields
        // these will then be automatically set to the initial files
        mergedOptions.files = (options.files || []).concat(
            Array.from(element.querySelectorAll('input:not([type=file])')).map(function(input) {
                return {
                    source: input.value,
                    options: {
                        type: input.dataset.type,
                    },
                };
            })
        );

        // build plugin
        var app = createAppObject(mergedOptions);

        // add already selected files
        if (element.files) {
            Array.from(element.files).forEach(function(file) {
                app.addFile(file);
            });
        }

        // replace the target element
        app.replaceElement(element);

        // expose
        return app;
    };

    // if an element is passed, we create the instance at that element, if not, we just create an up object
    var createApp$1 = function createApp() {
        return isNode(arguments.length <= 0 ? undefined : arguments[0])
            ? createAppAtElement.apply(void 0, arguments)
            : createAppObject.apply(void 0, arguments);
    };

    var PRIVATE_METHODS = ['fire', '_read', '_write'];

    var createAppAPI = function createAppAPI(app) {
        var api = {};

        copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);

        return api;
    };

    /**
     * Replaces placeholders in given string with replacements
     * @param string - "Foo {bar}""
     * @param replacements - { "bar": 10 }
     */
    var replaceInString = function replaceInString(string, replacements) {
        return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {
            return replacements[group];
        });
    };

    var createWorker = function createWorker(fn) {
        var workerBlob = new Blob(['(', fn.toString(), ')()'], {
            type: 'application/javascript',
        });

        var workerURL = URL.createObjectURL(workerBlob);
        var worker = new Worker(workerURL);

        return {
            transfer: function transfer(message, cb) {},
            post: function post(message, cb, transferList) {
                var id = getUniqueId();

                worker.onmessage = function(e) {
                    if (e.data.id === id) {
                        cb(e.data.message);
                    }
                };

                worker.postMessage(
                    {
                        id: id,
                        message: message,
                    },

                    transferList
                );
            },
            terminate: function terminate() {
                worker.terminate();
                URL.revokeObjectURL(workerURL);
            },
        };
    };

    var loadImage = function loadImage(url) {
        return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
                resolve(img);
            };
            img.onerror = function(e) {
                reject(e);
            };
            img.src = url;
        });
    };

    var renameFile = function renameFile(file, name) {
        var renamedFile = file.slice(0, file.size, file.type);
        renamedFile.lastModifiedDate = file.lastModifiedDate;
        renamedFile.name = name;
        return renamedFile;
    };

    var copyFile = function copyFile(file) {
        return renameFile(file, file.name);
    };

    // already registered plugins (can't register twice)
    var registeredPlugins = [];

    // pass utils to plugin
    var createAppPlugin = function createAppPlugin(plugin) {
        // already registered
        if (registeredPlugins.includes(plugin)) {
            return;
        }

        // remember this plugin
        registeredPlugins.push(plugin);

        // setup!
        var pluginOutline = plugin({
            addFilter: addFilter,
            utils: {
                Type: Type,
                forin: forin,
                isString: isString,
                isFile: isFile,
                toNaturalFileSize: toNaturalFileSize,
                replaceInString: replaceInString,
                getExtensionFromFilename: getExtensionFromFilename,
                getFilenameWithoutExtension: getFilenameWithoutExtension,
                guesstimateMimeType: guesstimateMimeType,
                getFileFromBlob: getFileFromBlob,
                getFilenameFromURL: getFilenameFromURL,
                createRoute: createRoute,
                createWorker: createWorker,
                createView: createView,
                createItemAPI: createItemAPI,
                loadImage: loadImage,
                copyFile: copyFile,
                renameFile: renameFile,
                createBlob: createBlob,
                applyFilterChain: applyFilterChain,
                text: text,
                getNumericAspectRatioFromString: getNumericAspectRatioFromString,
            },

            views: {
                fileActionButton: fileActionButton,
            },
        });

        // add plugin options to default options
        extendDefaultOptions(pluginOutline.options);
    };

    // feature detection used by supported() method
    var isOperaMini = function isOperaMini() {
        return Object.prototype.toString.call(window.operamini) === '[object OperaMini]';
    };
    var hasPromises = function hasPromises() {
        return 'Promise' in window;
    };
    var hasBlobSlice = function hasBlobSlice() {
        return 'slice' in Blob.prototype;
    };
    var hasCreateObjectURL = function hasCreateObjectURL() {
        return 'URL' in window && 'createObjectURL' in window.URL;
    };
    var hasVisibility = function hasVisibility() {
        return 'visibilityState' in document;
    };
    var hasTiming = function hasTiming() {
        return 'performance' in window;
    }; // iOS 8.x
    var hasCSSSupports = function hasCSSSupports() {
        return 'supports' in (window.CSS || {});
    }; // use to detect Safari 9+
    var isIE11 = function isIE11() {
        return /MSIE|Trident/.test(window.navigator.userAgent);
    };

    var supported = (function() {
        // Runs immediately and then remembers result for subsequent calls
        var isSupported =
            // Has to be a browser
            isBrowser() &&
            // Can't run on Opera Mini due to lack of everything
            !isOperaMini() &&
            // Require these APIs to feature detect a modern browser
            hasVisibility() &&
            hasPromises() &&
            hasBlobSlice() &&
            hasCreateObjectURL() &&
            hasTiming() &&
            // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)
            (hasCSSSupports() || isIE11());

        return function() {
            return isSupported;
        };
    })();

    /**
     * Plugin internal state (over all instances)
     */
    var state = {
        // active app instances, used to redraw the apps and to find the later
        apps: [],
    };

    // plugin name
    var name = 'filepond';

    /**
     * Public Plugin methods
     */
    var fn = function fn() {};
    exports.Status = {};
    exports.FileStatus = {};
    exports.FileOrigin = {};
    exports.OptionTypes = {};
    exports.create = fn;
    exports.destroy = fn;
    exports.parse = fn;
    exports.find = fn;
    exports.registerPlugin = fn;
    exports.getOptions = fn;
    exports.setOptions = fn;

    // if not supported, no API
    if (supported()) {
        // start painter and fire load event
        createPainter(
            function() {
                state.apps.forEach(function(app) {
                    return app._read();
                });
            },
            function(ts) {
                state.apps.forEach(function(app) {
                    return app._write(ts);
                });
            }
        );

        // fire loaded event so we know when FilePond is available
        var dispatch = function dispatch() {
            // let others know we have area ready
            document.dispatchEvent(
                new CustomEvent('FilePond:loaded', {
                    detail: {
                        supported: supported,
                        create: exports.create,
                        destroy: exports.destroy,
                        parse: exports.parse,
                        find: exports.find,
                        registerPlugin: exports.registerPlugin,
                        setOptions: exports.setOptions,
                    },
                })
            );

            // clean up event
            document.removeEventListener('DOMContentLoaded', dispatch);
        };

        if (document.readyState !== 'loading') {
            // move to back of execution queue, FilePond should have been exported by then
            setTimeout(function() {
                return dispatch();
            }, 0);
        } else {
            document.addEventListener('DOMContentLoaded', dispatch);
        }

        // updates the OptionTypes object based on the current options
        var updateOptionTypes = function updateOptionTypes() {
            return forin(getOptions(), function(key, value) {
                exports.OptionTypes[key] = value[1];
            });
        };

        exports.Status = Object.assign({}, Status);
        exports.FileOrigin = Object.assign({}, FileOrigin);
        exports.FileStatus = Object.assign({}, ItemStatus);

        exports.OptionTypes = {};
        updateOptionTypes();

        // create method, creates apps and adds them to the app array
        exports.create = function create() {
            var app = createApp$1.apply(void 0, arguments);
            app.on('destroy', exports.destroy);
            state.apps.push(app);
            return createAppAPI(app);
        };

        // destroys apps and removes them from the app array
        exports.destroy = function destroy(hook) {
            // returns true if the app was destroyed successfully
            var indexToRemove = state.apps.findIndex(function(app) {
                return app.isAttachedTo(hook);
            });
            if (indexToRemove >= 0) {
                // remove from apps
                var app = state.apps.splice(indexToRemove, 1)[0];

                // restore original dom element
                app.restoreElement();

                return true;
            }

            return false;
        };

        // parses the given context for plugins (does not include the context element itself)
        exports.parse = function parse(context) {
            // get all possible hooks
            var matchedHooks = Array.from(context.querySelectorAll('.' + name));

            // filter out already active hooks
            var newHooks = matchedHooks.filter(function(newHook) {
                return !state.apps.find(function(app) {
                    return app.isAttachedTo(newHook);
                });
            });

            // create new instance for each hook
            return newHooks.map(function(hook) {
                return exports.create(hook);
            });
        };

        // returns an app based on the given element hook
        exports.find = function find(hook) {
            var app = state.apps.find(function(app) {
                return app.isAttachedTo(hook);
            });
            if (!app) {
                return null;
            }
            return createAppAPI(app);
        };

        // adds a plugin extension
        exports.registerPlugin = function registerPlugin() {
            for (
                var _len = arguments.length, plugins = new Array(_len), _key = 0;
                _key < _len;
                _key++
            ) {
                plugins[_key] = arguments[_key];
            }

            // register plugins
            plugins.forEach(createAppPlugin);

            // update OptionTypes, each plugin might have extended the default options
            updateOptionTypes();
        };

        exports.getOptions = function getOptions$1() {
            var opts = {};
            forin(getOptions(), function(key, value) {
                opts[key] = value[0];
            });
            return opts;
        };

        exports.setOptions = function setOptions$1(opts) {
            if (isObject(opts)) {
                // update existing plugins
                state.apps.forEach(function(app) {
                    app.setOptions(opts);
                });

                // override defaults
                setOptions(opts);
            }

            // return new options
            return exports.getOptions();
        };
    }

    exports.supported = supported;

    Object.defineProperty(exports, '__esModule', { value: true });
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZmlsZXBvbmRfZGlzdF9maWxlcG9uZF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFO0FBQ0EsVUFBVSxDQUU0RDtBQUN0RSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdCQUF3QjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsa0JBQWtCO0FBQzdELFNBQVM7O0FBRVQ7QUFDQTtBQUNBLDZDQUE2QyxvQ0FBb0M7QUFDakYsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVB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Q0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7O0FBRW5DO0FBQ0Esa0RBQWtELDJCQUEyQjtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxV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Q0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RCxrQ0FBa0M7QUFDOUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MseUJBQXlCO0FBQ2pFLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELHdCQUF3QiwyQkFBMkI7QUFDbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLElBQUk7QUFDNUQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hELHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGFBQWE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSx1QkFBdUI7O0FBRXZCLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FB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O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDRDQUE0Qzs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUE4QztBQUNwRSxTQUFTO0FBQ1QsOEJBQThCLHNCQUFzQiwyQ0FBMkM7QUFDL0Y7QUFDQTtBQUNBLHNCQUFzQixpREFBaUQ7QUFDdkUsU0FBUztBQUNULHlCQUF5QixZQUFZO0FBQ3JDLHlCQUF5QixzQkFBc0IscUNBQXFDO0FBQ3BGLDJCQUEyQixzQkFBc0IsMkNBQTJDOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0NBQXdDO0FBQ3hDLGtEQUFrRDtBQUNsRCx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3Q0FBd0M7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRTs7QUFFQTtBQUNBLDRFQUE0RSxvQkFBb0I7O0FBRWhHO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLDRDQUE0Qzs7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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFx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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQsYUFBYTtBQUNoRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZCA0LjMwLjNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGZhY3RvcnkoZXhwb3J0cylcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpXG4gICAgICAgIDogKChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiksIGZhY3RvcnkoKGdsb2JhbC5GaWxlUG9uZCA9IHt9KSkpO1xufSkodGhpcywgZnVuY3Rpb24oZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpc05vZGUgPSBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTdG9yZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICB2YXIgcXVlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICAgIHZhciBhY3Rpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdmFyIHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcblxuICAgICAgICAvLyBjb250YWlucyBhbGwgYWN0aW9ucyBmb3IgbmV4dCBmcmFtZSwgaXMgY2xlYXIgd2hlbiBhY3Rpb25zIGFyZSByZXF1ZXN0ZWRcbiAgICAgICAgdmFyIGFjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHZhciBkaXNwYXRjaFF1ZXVlID0gW107XG5cbiAgICAgICAgLy8gcmV0dXJucyBhIGR1cGxpY2F0ZSBvZiB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmV0dXJucyBhIGR1cGxpY2F0ZSBvZiB0aGUgYWN0aW9ucyBhcnJheSBhbmQgY2xlYXJzIHRoZSBhY3Rpb25zIGFycmF5XG4gICAgICAgIHZhciBwcm9jZXNzQWN0aW9uUXVldWUgPSBmdW5jdGlvbiBwcm9jZXNzQWN0aW9uUXVldWUoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoYWN0aW9uUXVldWUpO1xuXG4gICAgICAgICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByb2Nlc3NlcyBhY3Rpb25zIHRoYXQgbWlnaHQgYmxvY2sgdGhlIG1haW4gVUkgdGhyZWFkXG4gICAgICAgIHZhciBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGRpc3BhdGNoUXVldWUpO1xuXG4gICAgICAgICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAvLyBub3cgZGlzcGF0Y2ggdGhlc2UgYWN0aW9uc1xuICAgICAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHlwZSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGRzIGEgbmV3IGFjdGlvbiwgY2FsbHMgaXRzIGhhbmRsZXIgYW5kXG4gICAgICAgIHZhciBkaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKHR5cGUsIGRhdGEsIGlzQmxvY2tpbmcpIHtcbiAgICAgICAgICAgIC8vIGlzIGJsb2NraW5nIGFjdGlvbiAoc2hvdWxkIG5ldmVyIGJsb2NrIGlmIGRvY3VtZW50IGlzIGhpZGRlbilcbiAgICAgICAgICAgIGlmIChpc0Jsb2NraW5nICYmICFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBhY3Rpb24gaGFzIGEgaGFuZGxlciwgaGFuZGxlIHRoZSBhY3Rpb25cbiAgICAgICAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbkhhbmRsZXJzW3R5cGVdKGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgYWRkIGFjdGlvblxuICAgICAgICAgICAgYWN0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoc3RyKSB7XG4gICAgICAgICAgICB2YXIgX3F1ZXJ5SGFuZGxlcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBxdWVyeUhhbmRsZXNbc3RyXVxuICAgICAgICAgICAgICAgID8gKF9xdWVyeUhhbmRsZXMgPSBxdWVyeUhhbmRsZXMpW3N0cl0uYXBwbHkoX3F1ZXJ5SGFuZGxlcywgYXJncylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICAgICAgICAgIHByb2Nlc3NBY3Rpb25RdWV1ZTogcHJvY2Vzc0FjdGlvblF1ZXVlLFxuICAgICAgICAgICAgcHJvY2Vzc0Rpc3BhdGNoUXVldWU6IHByb2Nlc3NEaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBxdWVyeUhhbmRsZXMgPSB7fTtcbiAgICAgICAgcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICBxdWVyeUhhbmRsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBxdWVyeShzdGF0ZSksIHt9LCBxdWVyeUhhbmRsZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYWN0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24oZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSksIHt9LCBhY3Rpb25IYW5kbGVycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgZm9yaW4gPSBmdW5jdGlvbiBmb3JpbihvYmosIGNiKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2Ioa2V5LCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uIGNyZWF0ZU9iamVjdChkZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgZm9yaW4oZGVmaW5pdGlvbiwgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIGRlZmluaXRpb25bcHJvcGVydHldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihub2RlLCBuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIHZhciBzdmdFbGVtZW50cyA9IFsnc3ZnJywgJ3BhdGgnXTsgLy8gb25seSBzdmcgZWxlbWVudHMgdXNlZFxuXG4gICAgdmFyIGlzU1ZHRWxlbWVudCA9IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudCh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnRzLmluY2x1ZGVzKHRhZyk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBpc1NWR0VsZW1lbnQodGFnKVxuICAgICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZylcbiAgICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNTVkdFbGVtZW50KHRhZykpIHtcbiAgICAgICAgICAgICAgICBhdHRyKGVsZW1lbnQsICdjbGFzcycsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcmluKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFyZW50LmNoaWxkcmVuW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kQ2hpbGRWaWV3ID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGRWaWV3KHBhcmVudCwgY2hpbGRWaWV3cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmlldywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoaW5kZXgsIDAsIHZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGRWaWV3KHBhcmVudCwgY2hpbGRWaWV3cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gY2hpbGQgdmlld3NcbiAgICAgICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHZpZXcuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSVNfQlJPV1NFUiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH0pKCk7XG4gICAgdmFyIGlzQnJvd3NlciA9IGZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuIElTX0JST1dTRVI7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0RWxlbWVudCA9IGlzQnJvd3NlcigpID8gY3JlYXRlRWxlbWVudCgnc3ZnJykgOiB7fTtcbiAgICB2YXIgZ2V0Q2hpbGRDb3VudCA9XG4gICAgICAgICdjaGlsZHJlbicgaW4gdGVzdEVsZW1lbnRcbiAgICAgICAgICAgID8gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfTtcblxuICAgIHZhciBnZXRWaWV3UmVjdCA9IGZ1bmN0aW9uIGdldFZpZXdSZWN0KGVsZW1lbnRSZWN0LCBjaGlsZFZpZXdzLCBvZmZzZXQsIHNjYWxlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gb2Zmc2V0WzBdIHx8IGVsZW1lbnRSZWN0LmxlZnQ7XG4gICAgICAgIHZhciB0b3AgPSBvZmZzZXRbMV0gfHwgZWxlbWVudFJlY3QudG9wO1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBib3R0b20gPSB0b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQgKiAoc2NhbGVbMV0gfHwgMSk7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB7XG4gICAgICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGl0c2VsZlxuICAgICAgICAgICAgZWxlbWVudDogT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudFJlY3QpLFxuXG4gICAgICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuLCBkb2VzIG5vdCBpbmNsdWRlIGFueSBtYXJnaW5zXG4gICAgICAgICAgICBpbm5lcjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnRSZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdHRvbTogZWxlbWVudFJlY3QuYm90dG9tLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBleHBhbmRlZCB0byBjb250YWluIGl0cyBjaGlsZHJlbiBpbmNsdWRpbmcgb3duIG1hcmdpbiBhbmQgY2hpbGQgbWFyZ2luc1xuICAgICAgICAgICAgLy8gbWFyZ2lucyB3aWxsIGJlIGFkZGVkIGFmdGVyIHdlJ3ZlIHJlY2FsY3VsYXRlZCB0aGUgc2l6ZVxuICAgICAgICAgICAgb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZXhwYW5kIHJlY3QgdG8gZml0IGFsbCBjaGlsZCByZWN0YW5nbGVzXG4gICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFjaGlsZFZpZXcuaXNSZWN0SWdub3JlZCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmlldy5yZWN0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkVmlld1JlY3QpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRSZWN0KHJlY3QuaW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3QuaW5uZXIpKTtcbiAgICAgICAgICAgICAgICBleHBhbmRSZWN0KHJlY3Qub3V0ZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3Qub3V0ZXIpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QuaW5uZXIpO1xuXG4gICAgICAgIC8vIGFwcGVuZCBhZGRpdGlvbmFsIG1hcmdpbiAodG9wIGFuZCBsZWZ0IG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluIHRvcCBhbmQgbGVmdCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICByZWN0Lm91dGVyLmJvdHRvbSArPSByZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuICAgICAgICByZWN0Lm91dGVyLnJpZ2h0ICs9IHJlY3QuZWxlbWVudC5tYXJnaW5SaWdodDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgb3V0ZXIgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0Lm91dGVyKTtcblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cGFuZFJlY3QgPSBmdW5jdGlvbiBleHBhbmRSZWN0KHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgLy8gYWRqdXN0IGZvciBwYXJlbnQgb2Zmc2V0XG4gICAgICAgIGNoaWxkLnRvcCArPSBwYXJlbnQudG9wO1xuICAgICAgICBjaGlsZC5yaWdodCArPSBwYXJlbnQubGVmdDtcbiAgICAgICAgY2hpbGQuYm90dG9tICs9IHBhcmVudC50b3A7XG4gICAgICAgIGNoaWxkLmxlZnQgKz0gcGFyZW50LmxlZnQ7XG5cbiAgICAgICAgaWYgKGNoaWxkLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pIHtcbiAgICAgICAgICAgIHBhcmVudC5ib3R0b20gPSBjaGlsZC5ib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQucmlnaHQgPiBwYXJlbnQucmlnaHQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IGNoaWxkLnJpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVSZWN0U2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QpIHtcbiAgICAgICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgICB9O1xuXG4gICAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgcG9zaXRpb24gaXMgYXQgZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0gdmVsb2NpdHlcbiAgICAgKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgdGhlcmVZZXQgPSBmdW5jdGlvbiB0aGVyZVlldChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBlcnJvck1hcmdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4wMDE7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhwb3NpdGlvbiAtIGRlc3RpbmF0aW9uKSA8IGVycm9yTWFyZ2luICYmIE1hdGguYWJzKHZlbG9jaXR5KSA8IGVycm9yTWFyZ2luO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcHJpbmcgYW5pbWF0aW9uXG4gICAgICovXG4gICAgdmFyIHNwcmluZyA9XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBmdW5jdGlvbiBzcHJpbmcoKSAvLyBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICAgICAgX3JlZiRzdGlmZm5lc3MgPSBfcmVmLnN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICBzdGlmZm5lc3MgPSBfcmVmJHN0aWZmbmVzcyA9PT0gdm9pZCAwID8gMC41IDogX3JlZiRzdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgX3JlZiRkYW1waW5nID0gX3JlZi5kYW1waW5nLFxuICAgICAgICAgICAgICAgIGRhbXBpbmcgPSBfcmVmJGRhbXBpbmcgPT09IHZvaWQgMCA/IDAuNzUgOiBfcmVmJGRhbXBpbmcsXG4gICAgICAgICAgICAgICAgX3JlZiRtYXNzID0gX3JlZi5tYXNzLFxuICAgICAgICAgICAgICAgIG1hc3MgPSBfcmVmJG1hc3MgPT09IHZvaWQgMCA/IDEwIDogX3JlZiRtYXNzO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHZhciByZXN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZXMgc3ByaW5nIHN0YXRlXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiByZXN0LCBkb24ndCBhbmltYXRlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWQgYXQgbGVhc3QgYSB0YXJnZXQgb3IgcG9zaXRpb24gdG8gZG8gc3ByaW5neSB0aGluZ3NcbiAgICAgICAgICAgICAgICBpZiAoIShpc051bWJlcih0YXJnZXQpICYmIGlzTnVtYmVyKHBvc2l0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBzcHJpbmcgZm9yY2VcbiAgICAgICAgICAgICAgICB2YXIgZiA9IC0ocG9zaXRpb24gLSB0YXJnZXQpICogc3RpZmZuZXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IGJ5IGFkZGluZyBmb3JjZSBiYXNlZCBvbiBtYXNzXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKz0gZiAvIG1hc3M7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gYnkgYWRkaW5nIHZlbG9jaXR5XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdmVsb2NpdHk7XG5cbiAgICAgICAgICAgICAgICAvLyBzbG93IGRvd24gYmFzZWQgb24gYW1vdW50IG9mIGRhbXBpbmdcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSAqPSBkYW1waW5nO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UndmUgYXJyaXZlZCBpZiB3ZSdyZSBuZWFyIHRhcmdldCBhbmQgb3VyIHZlbG9jaXR5IGlzIG5lYXIgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0aGVyZVlldChwb3NpdGlvbiwgdGFyZ2V0LCB2ZWxvY2l0eSkgfHwgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uZVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbmV3IHRhcmdldCB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBzZXRUYXJnZXQgPSBmdW5jdGlvbiBzZXRUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50bHkgaGFzIG5vIHBvc2l0aW9uLCBzZXQgdGFyZ2V0IGFuZCBwb3NpdGlvbiB0byB0aGlzIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbmV4dCB0YXJnZXQgdmFsdWUgd2lsbCBub3QgYmUgYW5pbWF0ZWQgdG9cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxldCBzdGFydCBtb3ZpbmcgdG8gdGFyZ2V0XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGF0IHRhcmdldFxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyByZXN0aW5nIGFzIHRhcmdldCBpcyBjdXJyZW50IHBvc2l0aW9uLCBzdG9wIG1vdmluZ1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHNldDogc2V0VGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG4gICAgdmFyIGVhc2VMaW5lYXIgPSBmdW5jdGlvbiBlYXNlTGluZWFyKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB2YXIgZWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICAgIH07XG5cbiAgICB2YXIgdHdlZW4gPVxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgICAgICBmdW5jdGlvbiB0d2VlbigpIC8vIG1ldGhvZCBkZWZpbml0aW9uXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IF9yZWYkZHVyYXRpb24gPT09IHZvaWQgMCA/IDUwMCA6IF9yZWYkZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgX3JlZiRlYXNpbmcgPSBfcmVmLmVhc2luZyxcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSBfcmVmJGVhc2luZyA9PT0gdm9pZCAwID8gZWFzZUluT3V0UXVhZCA6IF9yZWYkZWFzaW5nLFxuICAgICAgICAgICAgICAgIF9yZWYkZGVsYXkgPSBfcmVmLmRlbGF5LFxuICAgICAgICAgICAgICAgIGRlbGF5ID0gX3JlZiRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkZGVsYXk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIHZhciByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RpbmcgfHwgdGFyZ2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHMgLSBzdGFydCA8IGRlbGF5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB0ID0gdHMgLSBzdGFydCAtIGRlbGF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gZHVyYXRpb24gfHwgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHAgPSByZXZlcnNlID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSB0IC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZSgodCA+PSAwID8gZWFzaW5nKHJldmVyc2UgPyAxIC0gcCA6IHApIDogMCkgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG5lZWQgJ2FwaScgdG8gY2FsbCBvbnVwZGF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgdmFyIGFwaSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnNlID8gMCA6IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdHdlZW4gdG8gYSBzbWFsbGVyIHZhbHVlIGFuZCBoYXZlIGEgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IHR3ZWVuaW5nIHRvIGEgc21hbGxlciB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZ28hXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG4gICAgdmFyIGFuaW1hdG9yID0ge1xuICAgICAgICBzcHJpbmc6IHNwcmluZyxcbiAgICAgICAgdHdlZW46IHR3ZWVuLFxuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzcHJpbmcnLCBzdGlmZm5lc3M6IC41LCBkYW1waW5nOiAuNzUsIG1hc3M6IDEwIH07XG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHJhbnNsYXRpb246IHsgdHlwZTogJ3NwcmluZycsIC4uLiB9LCAuLi4gfVxuICAgICAgICAgICAgICAgICAgICAgICB7IHRyYW5zbGF0aW9uOiB7IHg6IHsgdHlwZTogJ3NwcmluZycsIC4uLiB9IH0gfVxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgdmFyIGNyZWF0ZUFuaW1hdG9yID0gZnVuY3Rpb24gY3JlYXRlQW5pbWF0b3IoZGVmaW5pdGlvbiwgY2F0ZWdvcnksIHByb3BlcnR5KSB7XG4gICAgICAgIC8vIGRlZmF1bHQgaXMgc2luZ2xlIGRlZmluaXRpb25cbiAgICAgICAgLy8gd2UgY2hlY2sgaWYgdHJhbnNmb3JtIGlzIHNldCwgaWYgc28sIHdlIGNoZWNrIGlmIHByb3BlcnR5IGlzIHNldFxuICAgICAgICB2YXIgZGVmID1cbiAgICAgICAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV1cbiAgICAgICAgICAgICAgICA6IGRlZmluaXRpb25bY2F0ZWdvcnldIHx8IGRlZmluaXRpb247XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZGVmID09PSAnc3RyaW5nJyA/IGRlZiA6IGRlZi50eXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZikgOiB7fTtcblxuICAgICAgICByZXR1cm4gYW5pbWF0b3JbdHlwZV0gPyBhbmltYXRvclt0eXBlXShwcm9wcykgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYWRkR2V0U2V0ID0gZnVuY3Rpb24gYWRkR2V0U2V0KGtleXMsIG9iaiwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICAgIG9iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuICAgICAgICBvYmouZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJvcHNba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBrZXkua2V5O1xuICAgICAgICAgICAgICAgICAgICBnZXR0ZXIgPSBrZXkuZ2V0dGVyIHx8IGdldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyID0ga2V5LnNldHRlciB8fCBzZXR0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9bbmFtZV0gJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZCB0byBzdGF0ZSxcbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAgIC8vIHNldHVwIGFuaW1hdG9yc1xuXG4gICAgdmFyIGFuaW1hdGlvbnMgPSBmdW5jdGlvbiBhbmltYXRpb25zKF9yZWYpIHtcbiAgICAgICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgICAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICAgICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgIC8vIGxpc3Qgb2YgYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAgICAgLy8gc2V0dXAgYW5pbWF0b3JzXG4gICAgICAgIGZvcmluKG1peGluQ29uZmlnLCBmdW5jdGlvbihwcm9wZXJ0eSwgYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBjcmVhdGVBbmltYXRvcihhbmltYXRpb24pO1xuICAgICAgICAgICAgaWYgKCFhbmltYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgYW5pbWF0b3IgdXBkYXRlcywgdXBkYXRlIHRoZSB2aWV3IHN0YXRlIHZhbHVlXG4gICAgICAgICAgICBhbmltYXRvci5vbnVwZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmlld1Byb3BzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc2V0IGFuaW1hdG9yIHRhcmdldFxuICAgICAgICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gaW5pdGlhbFByb3BzW3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIHNldHRlcjogZnVuY3Rpb24gc2V0dGVyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgYXQgdGFyZ2V0LCB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9wc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgICAgICBhZGRHZXRTZXQoW3Byb3BdLCBbdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEldLCB2aWV3UHJvcHMsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGxpc3QgZm9yIGVhc3kgdXBkYXRpbmcgZnJvbSB0aGUgX3dyaXRlIG1ldGhvZFxuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIGludGVybmFsIHdyaXRlIGFwaVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBUb0VuZFN0YXRlID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgICAgICAgICAgICAgIHZhciByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLnJlc3RpbmcpIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHt9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbiBhZGRFdmVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIG1peGluXG4gICAgdmFyIGxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhfcmVmKSB7XG4gICAgICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICAgICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3U3RhdGUgPSBfcmVmLnZpZXdTdGF0ZSxcbiAgICAgICAgICAgIHZpZXcgPSBfcmVmLnZpZXc7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcblxuICAgICAgICB2YXIgYWRkID0gYWRkRXZlbnQodmlldy5lbGVtZW50KTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IHJlbW92ZUV2ZW50KHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgdmlld0V4dGVybmFsQVBJLm9uID0gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhZGQodHlwZSwgZm4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZpZXdFeHRlcm5hbEFQSS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgICAgICAgICBldmVudHMuZmluZEluZGV4KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50eXBlID09PSB0eXBlICYmIGV2ZW50LmZuID09PSBmbjtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZW1vdmUodHlwZSwgZm4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGJ1c3lcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShldmVudC50eXBlLCBldmVudC5mbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhZGQgdG8gZXh0ZXJuYWwgYXBpIGFuZCBsaW5rIHRvIHByb3BzXG5cbiAgICB2YXIgYXBpcyA9IGZ1bmN0aW9uIGFwaXMoX3JlZikge1xuICAgICAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICAgICAgYWRkR2V0U2V0KG1peGluQ29uZmlnLCB2aWV3RXh0ZXJuYWxBUEksIHZpZXdQcm9wcyk7XG4gICAgfTtcblxuICAgIHZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIGFkZCB0byBzdGF0ZSxcbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAgIC8vIHNldCBpbml0aWFsIHN0YXRlIGJhc2VkIG9uIHByb3BzIGluIHZpZXdQcm9wc1xuICAgIC8vIGFwcGx5IGFzIHRyYW5zZm9ybXMgZWFjaCBmcmFtZVxuXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZVg6IDEsXG4gICAgICAgIHNjYWxlWTogMSxcbiAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgdHJhbnNsYXRlWTogMCxcbiAgICAgICAgcm90YXRlWDogMCxcbiAgICAgICAgcm90YXRlWTogMCxcbiAgICAgICAgcm90YXRlWjogMCxcbiAgICAgICAgb3JpZ2luWDogMCxcbiAgICAgICAgb3JpZ2luWTogMCxcbiAgICB9O1xuXG4gICAgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyhfcmVmKSB7XG4gICAgICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICAgICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEksXG4gICAgICAgICAgICB2aWV3ID0gX3JlZi52aWV3O1xuICAgICAgICAvLyBpbml0aWFsIHByb3BzXG4gICAgICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgIC8vIGN1cnJlbnQgcHJvcHNcbiAgICAgICAgdmFyIGN1cnJlbnRQcm9wcyA9IHt9O1xuXG4gICAgICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICAgICAgYWRkR2V0U2V0KG1peGluQ29uZmlnLCBbdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEldLCB2aWV3UHJvcHMpO1xuXG4gICAgICAgIC8vIG92ZXJyaWRlIHJlY3Qgb24gaW50ZXJuYWwgYW5kIGV4dGVybmFsIHJlY3QgZ2V0dGVyIHNvIGl0IHRha2VzIGluIGFjY291bnQgdHJhbnNmb3Jtc1xuICAgICAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2aWV3UHJvcHNbJ3RyYW5zbGF0ZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3RyYW5zbGF0ZVknXSB8fCAwXTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmlld1Byb3BzWydzY2FsZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3NjYWxlWSddIHx8IDBdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0UmVjdCA9IGZ1bmN0aW9uIGdldFJlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5yZWN0XG4gICAgICAgICAgICAgICAgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2aWV3SW50ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG4gICAgICAgIHZpZXdFeHRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcblxuICAgICAgICAvLyBhcHBseSB2aWV3IHByb3BzXG4gICAgICAgIG1peGluQ29uZmlnLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2aWV3UHJvcHNba2V5XSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzW2tleV0gOiBpbml0aWFsUHJvcHNba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIGFwaVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge1xuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCB2aWV3UHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyBlbGVtZW50IHRvIGNvcnJlY3QgcG9zaXRpb24gb24gc2NyZWVuXG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZXModmlldy5lbGVtZW50LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgbmV3IHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRQcm9wcywgT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgYnVzeVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHByb3BzSGF2ZUNoYW5nZWQgPSBmdW5jdGlvbiBwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgICAgLy8gZGlmZmVyZW50IGFtb3VudCBvZiBrZXlzXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjdXJyZW50UHJvcHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMobmV3UHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXRzIGFuYWx5emUgdGhlIGluZGl2aWR1YWwgcHJvcHNcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKG5ld1Byb3BzW3Byb3BdICE9PSBjdXJyZW50UHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGx5U3R5bGVzID0gZnVuY3Rpb24gYXBwbHlTdHlsZXMoZWxlbWVudCwgX3JlZjIpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBfcmVmMi5vcGFjaXR5LFxuICAgICAgICAgICAgcGVyc3BlY3RpdmUgPSBfcmVmMi5wZXJzcGVjdGl2ZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBfcmVmMi50cmFuc2xhdGVYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWSA9IF9yZWYyLnRyYW5zbGF0ZVksXG4gICAgICAgICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICAgICAgICByb3RhdGVYID0gX3JlZjIucm90YXRlWCxcbiAgICAgICAgICAgIHJvdGF0ZVkgPSBfcmVmMi5yb3RhdGVZLFxuICAgICAgICAgICAgcm90YXRlWiA9IF9yZWYyLnJvdGF0ZVosXG4gICAgICAgICAgICBvcmlnaW5YID0gX3JlZjIub3JpZ2luWCxcbiAgICAgICAgICAgIG9yaWdpblkgPSBfcmVmMi5vcmlnaW5ZLFxuICAgICAgICAgICAgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtcyA9ICcnO1xuICAgICAgICB2YXIgc3R5bGVzID0gJyc7XG5cbiAgICAgICAgLy8gaGFuZGxlIHRyYW5zZm9ybSBvcmlnaW5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChvcmlnaW5YKSB8fCBpc0RlZmluZWQob3JpZ2luWSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAndHJhbnNmb3JtLW9yaWdpbjogJyArIChvcmlnaW5YIHx8IDApICsgJ3B4ICcgKyAob3JpZ2luWSB8fCAwKSArICdweDsnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIG9yZGVyIGlzIHJlbGV2YW50XG4gICAgICAgIC8vIDAuIHBlcnNwZWN0aXZlXG4gICAgICAgIGlmIChpc0RlZmluZWQocGVyc3BlY3RpdmUpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9ICdwZXJzcGVjdGl2ZSgnICsgcGVyc3BlY3RpdmUgKyAncHgpICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiB0cmFuc2xhdGVcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0cmFuc2xhdGVYKSB8fCBpc0RlZmluZWQodHJhbnNsYXRlWSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgICAgICAgICAndHJhbnNsYXRlM2QoJyArICh0cmFuc2xhdGVYIHx8IDApICsgJ3B4LCAnICsgKHRyYW5zbGF0ZVkgfHwgMCkgKyAncHgsIDApICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBzY2FsZVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHNjYWxlWCkgfHwgaXNEZWZpbmVkKHNjYWxlWSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgICAgICAgICAnc2NhbGUzZCgnICtcbiAgICAgICAgICAgICAgICAoaXNEZWZpbmVkKHNjYWxlWCkgPyBzY2FsZVggOiAxKSArXG4gICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgKGlzRGVmaW5lZChzY2FsZVkpID8gc2NhbGVZIDogMSkgK1xuICAgICAgICAgICAgICAgICcsIDEpICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiByb3RhdGVcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyb3RhdGVaKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtcyArPSAncm90YXRlWignICsgcm90YXRlWiArICdyYWQpICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVgpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVYKCcgKyByb3RhdGVYICsgJ3JhZCkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocm90YXRlWSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgKz0gJ3JvdGF0ZVkoJyArIHJvdGF0ZVkgKyAncmFkKSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRyYW5zZm9ybXNcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gJ3RyYW5zZm9ybTonICsgdHJhbnNmb3JtcyArICc7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBvcGFjaXR5XG4gICAgICAgIGlmIChpc0RlZmluZWQob3BhY2l0eSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAnb3BhY2l0eTonICsgb3BhY2l0eSArICc7JztcblxuICAgICAgICAgICAgLy8gaWYgd2UgcmVhY2ggemVybywgd2UgbWFrZSB0aGUgZWxlbWVudCBpbmFjY2Vzc2libGVcbiAgICAgICAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9ICd2aXNpYmlsaXR5OmhpZGRlbjsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBiZWxvdyAxMDAlIG9wYWNpdHkgdGhpcyBlbGVtZW50IGNhbid0IGJlIGNsaWNrZWRcbiAgICAgICAgICAgIGlmIChvcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSAncG9pbnRlci1ldmVudHM6bm9uZTsnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGhlaWdodFxuICAgICAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB3aWR0aFxuICAgICAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgICAgICAgc3R5bGVzICs9ICd3aWR0aDonICsgd2lkdGggKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlc1xuICAgICAgICB2YXIgZWxlbWVudEN1cnJlbnRTdHlsZSA9IGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSB8fCAnJztcblxuICAgICAgICAvLyBpZiBuZXcgc3R5bGVzIGRvZXMgbm90IG1hdGNoIGN1cnJlbnQgc3R5bGVzLCBsZXRzIHVwZGF0ZSFcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8IHN0eWxlcyAhPT0gZWxlbWVudEN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVzO1xuICAgICAgICAgICAgLy8gc3RvcmUgY3VycmVudCBzdHlsZXMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSB0byBuZXcgc3R5bGVzIGxhdGVyIG9uXG4gICAgICAgICAgICAvLyBfbm90XyBnZXR0aW5nIHRoZSBzdHlsZSB2YWx1ZSBpcyBmYXN0ZXJcbiAgICAgICAgICAgIGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSA9IHN0eWxlcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgTWl4aW5zID0ge1xuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgICAgIGFwaXM6IGFwaXMsXG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVSZWN0ID0gZnVuY3Rpb24gdXBkYXRlUmVjdCgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgZWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgICAgaWYgKCFlbGVtZW50LmxheW91dENhbGN1bGF0ZWQpIHtcbiAgICAgICAgICAgIHJlY3QucGFkZGluZ1RvcCA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVjdC5tYXJnaW5Ub3AgPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3AsIDEwKSB8fCAwO1xuICAgICAgICAgICAgcmVjdC5tYXJnaW5SaWdodCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCkgfHwgMDtcbiAgICAgICAgICAgIHJlY3QubWFyZ2luQm90dG9tID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIHJlY3QubWFyZ2luTGVmdCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSB8fCAwO1xuICAgICAgICAgICAgZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3QubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICByZWN0LnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgIHJlY3Qud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMDtcblxuICAgICAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aDtcbiAgICAgICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHJlY3Quc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgcmVjdC5oaWRkZW4gPSBlbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVZpZXcgPVxuICAgICAgICAvLyBkZWZhdWx0IHZpZXcgZGVmaW5pdGlvblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWYkdGFnID0gX3JlZi50YWcsXG4gICAgICAgICAgICAgICAgdGFnID0gX3JlZiR0YWcgPT09IHZvaWQgMCA/ICdkaXYnIDogX3JlZiR0YWcsXG4gICAgICAgICAgICAgICAgX3JlZiRuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBfcmVmJG5hbWUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJG5hbWUsXG4gICAgICAgICAgICAgICAgX3JlZiRhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmJGF0dHJpYnV0ZXMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIF9yZWYkcmVhZCA9IF9yZWYucmVhZCxcbiAgICAgICAgICAgICAgICByZWFkID0gX3JlZiRyZWFkID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRyZWFkLFxuICAgICAgICAgICAgICAgIF9yZWYkd3JpdGUgPSBfcmVmLndyaXRlLFxuICAgICAgICAgICAgICAgIHdyaXRlID0gX3JlZiR3cml0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkd3JpdGUsXG4gICAgICAgICAgICAgICAgX3JlZiRjcmVhdGUgPSBfcmVmLmNyZWF0ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGUgPSBfcmVmJGNyZWF0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkY3JlYXRlLFxuICAgICAgICAgICAgICAgIF9yZWYkZGVzdHJveSA9IF9yZWYuZGVzdHJveSxcbiAgICAgICAgICAgICAgICBkZXN0cm95ID0gX3JlZiRkZXN0cm95ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkZXN0cm95LFxuICAgICAgICAgICAgICAgIF9yZWYkZmlsdGVyRnJhbWVBY3RpbyA9IF9yZWYuZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQsXG4gICAgICAgICAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQgPVxuICAgICAgICAgICAgICAgICAgICBfcmVmJGZpbHRlckZyYW1lQWN0aW8gPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbihjaGlsZCwgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3JlZiRmaWx0ZXJGcmFtZUFjdGlvLFxuICAgICAgICAgICAgICAgIF9yZWYkZGlkQ3JlYXRlVmlldyA9IF9yZWYuZGlkQ3JlYXRlVmlldyxcbiAgICAgICAgICAgICAgICBkaWRDcmVhdGVWaWV3ID0gX3JlZiRkaWRDcmVhdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRDcmVhdGVWaWV3LFxuICAgICAgICAgICAgICAgIF9yZWYkZGlkV3JpdGVWaWV3ID0gX3JlZi5kaWRXcml0ZVZpZXcsXG4gICAgICAgICAgICAgICAgZGlkV3JpdGVWaWV3ID0gX3JlZiRkaWRXcml0ZVZpZXcgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGRpZFdyaXRlVmlldyxcbiAgICAgICAgICAgICAgICBfcmVmJGlnbm9yZVJlY3QgPSBfcmVmLmlnbm9yZVJlY3QsXG4gICAgICAgICAgICAgICAgaWdub3JlUmVjdCA9IF9yZWYkaWdub3JlUmVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZVJlY3QsXG4gICAgICAgICAgICAgICAgX3JlZiRpZ25vcmVSZWN0VXBkYXRlID0gX3JlZi5pZ25vcmVSZWN0VXBkYXRlLFxuICAgICAgICAgICAgICAgIGlnbm9yZVJlY3RVcGRhdGUgPSBfcmVmJGlnbm9yZVJlY3RVcGRhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVSZWN0VXBkYXRlLFxuICAgICAgICAgICAgICAgIF9yZWYkbWl4aW5zID0gX3JlZi5taXhpbnMsXG4gICAgICAgICAgICAgICAgbWl4aW5zID0gX3JlZiRtaXhpbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtaXhpbnM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgLy8gZWFjaCB2aWV3IHJlcXVpcmVzIHJlZmVyZW5jZSB0byBzdG9yZVxuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIHJvb3QgZWxlbWVudCBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCAnZmlsZXBvbmQtLScgKyBuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0eWxlIHJlZmVyZW5jZSBzaG91bGQgYWxzbyBub3QgYmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHVwZGF0ZVJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVSZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlc3Qgc3RhdGVcbiAgICAgICAgICAgICAgICB2YXIgaXNSZXN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBwcmV0dHkgc2VsZiBleHBsYW5hdG9yeVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFZpZXdzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBsb2FkZWQgbWl4aW5zXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZU1peGlucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhdGUgdXNlZCBmb3IgZWFjaCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiB3cml0ZXJzIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoaXMgdmlld1xuICAgICAgICAgICAgICAgIHZhciB3cml0ZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICB3cml0ZSwgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHJlYWQsIC8vIGRlZmF1bHQgcmVhZGVyXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIHZhciBkZXN0cm95ZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICBkZXN0cm95LCAvLyBkZWZhdWx0IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29yZSB2aWV3IG1ldGhvZHNcbiAgICAgICAgICAgICAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGdldENoaWxkVmlld3MgPSBmdW5jdGlvbiBnZXRDaGlsZFZpZXdzKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3cy5jb25jYXQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRSZWZlcmVuY2UgPSBmdW5jdGlvbiBnZXRSZWZlcmVuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2aWV3LCBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVJlY3Q7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBfcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgY2hpbGQgdmlld3NcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuX3JlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9ICEoaWdub3JlUmVjdFVwZGF0ZSAmJiByZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wczogcHJvcHMsIHJlY3Q6IHJlY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlcihhcGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV3JpdGUgZGF0YSB0byBET01cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBfd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUodHMsIGZyYW1lQWN0aW9ucywgc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdGluZyA9IGZyYW1lQWN0aW9ucy5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGVyc1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVyUmVzdGluZyA9IHdyaXRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplOiBzaG91bGRPcHRpbWl6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVyUmVzdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbWl4aW5zIGlzIHN0aWxsIGJ1c3kgYWZ0ZXIgd3JpdGUgb3BlcmF0aW9uLCB3ZSBhcmUgbm90IHJlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaXhpblJlc3RpbmcgPSBtaXhpbi53cml0ZSh0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW5SZXN0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBjaGlsZCB2aWV3cyB0aGF0IGFyZSBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBjaGlsZCB2aWV3IGlzIG5vdCByZXN0aW5nLCB3ZSBhcmUgbm90IHJlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZXN0aW5nID0gY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQoY2hpbGQsIGZyYW1lQWN0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRSZXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgbmV3IGVsZW1lbnRzIHRvIERPTSBhbmQgdXBkYXRlIHRob3NlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHJlYWQgKG5lZWQgdG8ga25vdyB0aGUgc2l6ZSBvZiB0aGVzZSBlbGVtZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtY2FsbCB3cml0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl93cml0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGFkZGVkIHNvbXRoaW5nIHRvIHRoZSBkb20sIG5vIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcmVzdGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSByZXN0aW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpZFdyaXRlVmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBwYXJlbnQga25vdyBpZiB3ZSBhcmUgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKGZ1bmN0aW9uKG1peGluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWl4aW4uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVycy5mb3JFYWNoKGZ1bmN0aW9uKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVyKHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLl9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzaGFyZWRBUElcbiAgICAgICAgICAgICAgICB2YXIgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVmlld3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0Q2hpbGRWaWV3cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gcHJpdmF0ZSBBUEkgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbEFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3MgdG8gY3VzdG9tIGNoaWxkcmVuIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldFJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb20gbW9kaWZpZXJzXG4gICAgICAgICAgICAgICAgICAgIGlzOiBmdW5jdGlvbiBpcyhuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBuZWVkbGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2hpbGRWaWV3OiBjcmVhdGVDaGlsZFZpZXcoc3RvcmUpLFxuICAgICAgICAgICAgICAgICAgICBsaW5rVmlldzogZnVuY3Rpb24gbGlua1ZpZXcodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVubGlua1ZpZXc6IGZ1bmN0aW9uIHVubGlua1ZpZXcodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoY2hpbGRWaWV3cy5pbmRleE9mKHZpZXcpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkVmlldzogcmVtb3ZlQ2hpbGRWaWV3KGVsZW1lbnQsIGNoaWxkVmlld3MpLFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcldyaXRlcjogZnVuY3Rpb24gcmVnaXN0ZXJXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVycy5wdXNoKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVzdHJveWVyKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3llcnMucHVzaChkZXN0cm95ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlTGF5b3V0OiBmdW5jdGlvbiBpbnZhbGlkYXRlTGF5b3V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzIHRvIGRhdGEgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHN0b3JlLmRpc3BhdGNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnksXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBwdWJsaWMgdmlldyBBUEkgbWV0aG9kc1xuICAgICAgICAgICAgICAgIHZhciBleHRlcm5hbEFQSURlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBjaGlsZFZpZXdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGdldENoaWxkVmlld3MsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1Jlc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGlzUmVjdElnbm9yZWQ6IGZ1bmN0aW9uIGlzUmVjdElnbm9yZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlUmVjdDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX3JlYWQ6IF9yZWFkLFxuICAgICAgICAgICAgICAgICAgICBfd3JpdGU6IF93cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3k6IF9kZXN0cm95LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBtaXhpbiBBUEkgbWV0aG9kc1xuICAgICAgICAgICAgICAgIHZhciBtaXhpbkFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBtaXhpbiBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWl4aW5zKVxuICAgICAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHN0eWxlcyB0byB0aGUgYmFjayBvZiB0aGUgbWl4aW4gbGlzdCAoc28gYWRqdXN0bWVudHMgb2Ygb3RoZXIgbWl4aW5zIGFyZSBhcHBsaWVkIHRvIHRoZSBwcm9wcyBjb3JyZWN0bHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWl4aW5BUEkgPSBNaXhpbnNba2V5XSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW5Db25maWc6IG1peGluc1trZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1N0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEk6IGludGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3RXh0ZXJuYWxBUEk6IGV4dGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBjcmVhdGVPYmplY3QobWl4aW5BUElEZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW5BUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNaXhpbnMucHVzaChtaXhpbkFQSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc3RydWN0IHByaXZhdGUgYXBpXG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHZpZXdcbiAgICAgICAgICAgICAgICBjcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGNyZWF0ZWQgY2hpbGQgdmlld3MgdG8gcm9vdCBub2RlXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSBnZXRDaGlsZENvdW50KGVsZW1lbnQpOyAvLyBuZWVkIHRvIGtub3cgdGhlIGN1cnJlbnQgY2hpbGQgY291bnQgc28gYXBwZW5kaW5nIGhhcHBlbnMgaW4gY29ycmVjdCBvcmRlclxuICAgICAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgY2hpbGRDb3VudCArIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGwgZGlkIGNyZWF0ZVxuICAgICAgICAgICAgICAgIGRpZENyZWF0ZVZpZXcoaW50ZXJuYWxBUEkpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4dGVybmFsQVBJRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhaW50ZXIgPSBmdW5jdGlvbiBjcmVhdGVQYWludGVyKHJlYWQsIHdyaXRlKSB7XG4gICAgICAgIHZhciBmcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDYwO1xuXG4gICAgICAgIHZhciBuYW1lID0gJ19fZnJhbWVQYWludGVyJztcblxuICAgICAgICAvLyBzZXQgZ2xvYmFsIHBhaW50ZXJcbiAgICAgICAgaWYgKHdpbmRvd1tuYW1lXSkge1xuICAgICAgICAgICAgd2luZG93W25hbWVdLnJlYWRlcnMucHVzaChyZWFkKTtcbiAgICAgICAgICAgIHdpbmRvd1tuYW1lXS53cml0ZXJzLnB1c2god3JpdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93W25hbWVdID0ge1xuICAgICAgICAgICAgcmVhZGVyczogW3JlYWRdLFxuICAgICAgICAgICAgd3JpdGVyczogW3dyaXRlXSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFpbnRlciA9IHdpbmRvd1tuYW1lXTtcblxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAxMDAwIC8gZnBzO1xuICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgICAgIHZhciBpZCA9IG51bGw7XG4gICAgICAgIHZhciByZXF1ZXN0VGljayA9IG51bGw7XG4gICAgICAgIHZhciBjYW5jZWxUaWNrID0gbnVsbDtcblxuICAgICAgICB2YXIgc2V0VGltZXJUeXBlID0gZnVuY3Rpb24gc2V0VGltZXJUeXBlKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFRpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RUaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbFRpY2sgPSBmdW5jdGlvbiBjYW5jZWxUaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICAgICAgICBzZXRUaW1lclR5cGUoKTtcbiAgICAgICAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2sodHMpIHtcbiAgICAgICAgICAgIC8vIHF1ZXVlIG5leHQgdGlja1xuICAgICAgICAgICAgaWQgPSByZXF1ZXN0VGljayh0aWNrKTtcblxuICAgICAgICAgICAgLy8gbGltaXQgZnBzXG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHRzIC0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGRlbHRhIDw9IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxpZ24gbmV4dCBmcmFtZVxuICAgICAgICAgICAgbGFzdCA9IHRzIC0gKGRlbHRhICUgaW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlld1xuICAgICAgICAgICAgcGFpbnRlci5yZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhaW50ZXIud3JpdGVycy5mb3JFYWNoKGZ1bmN0aW9uKHdyaXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlKHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldFRpbWVyVHlwZSgpO1xuICAgICAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbFRpY2soaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJvdXRlID0gZnVuY3Rpb24gY3JlYXRlUm91dGUocm91dGVzLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgICAgICAgIF9yZWYkYWN0aW9ucyA9IF9yZWYuYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gX3JlZiRhY3Rpb25zID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkYWN0aW9ucyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfcmVmLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZSA9IF9yZWYuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlc1thY3Rpb24udHlwZV0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplOiBzaG91bGRPcHRpbWl6ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG4gICAgfTtcblxuICAgIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRyaW0gPSBmdW5jdGlvbiB0cmltKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgfTtcblxuICAgIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgICB2YXIgc3BsaXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcsJztcbiAgICAgICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgLnNwbGl0KHNwbGl0dGVyKVxuICAgICAgICAgICAgLm1hcCh0cmltKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNCb29sZWFuID0gZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9O1xuXG4gICAgdmFyIHRvQm9vbGVhbiA9IGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNCb29sZWFuKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUgPT09ICd0cnVlJztcbiAgICB9O1xuXG4gICAgdmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfTtcblxuICAgIHZhciB0b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogaXNTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICA/IHRvU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bYS16XSsvZ2ksICcnKVxuICAgICAgICAgICAgOiAwO1xuICAgIH07XG5cbiAgICB2YXIgdG9JbnQgPSBmdW5jdGlvbiB0b0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9OdW1iZXIodmFsdWUpLCAxMCk7XG4gICAgfTtcblxuICAgIHZhciB0b0Zsb2F0ID0gZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuICAgIH07XG5cbiAgICB2YXIgaXNJbnQgPSBmdW5jdGlvbiBpc0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG4gICAgfTtcblxuICAgIHZhciB0b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDtcbiAgICAgICAgLy8gaXMgaW4gYnl0ZXNcbiAgICAgICAgaWYgKGlzSW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXMgbmF0dXJhbCBmaWxlIHNpemVcbiAgICAgICAgdmFyIG5hdHVyYWxGaWxlU2l6ZSA9IHRvU3RyaW5nKHZhbHVlKS50cmltKCk7XG5cbiAgICAgICAgLy8gaWYgaXMgdmFsdWUgaW4gbWVnYWJ5dGVzXG4gICAgICAgIGlmICgvTUIkL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgICAgICBuYXR1cmFsRmlsZVNpemUgPSBuYXR1cmFsRmlsZVNpemUucmVwbGFjZSgvTUIkaS8sICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9JbnQobmF0dXJhbEZpbGVTaXplKSAqIGJhc2UgKiBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgdmFsdWUgaW4ga2lsb2J5dGVzXG4gICAgICAgIGlmICgvS0IvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9LQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpICogYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xuICAgIH07XG5cbiAgICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuXG4gICAgdmFyIHRvRnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHN0cmluZykge1xuICAgICAgICB2YXIgcmVmID0gc2VsZjtcbiAgICAgICAgdmFyIGxldmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgICAgICB3aGlsZSAoKGxldmVsID0gbGV2ZWxzLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICByZWYgPSByZWZbbGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgcHJvY2VzczogJ1BPU1QnLFxuICAgICAgICBwYXRjaDogJ1BBVENIJyxcbiAgICAgICAgcmV2ZXJ0OiAnREVMRVRFJyxcbiAgICAgICAgZmV0Y2g6ICdHRVQnLFxuICAgICAgICByZXN0b3JlOiAnR0VUJyxcbiAgICAgICAgbG9hZDogJ0dFVCcsXG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTZXJ2ZXJBUEkgPSBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJBUEkob3V0bGluZSkge1xuICAgICAgICB2YXIgYXBpID0ge307XG5cbiAgICAgICAgYXBpLnVybCA9IGlzU3RyaW5nKG91dGxpbmUpID8gb3V0bGluZSA6IG91dGxpbmUudXJsIHx8ICcnO1xuICAgICAgICBhcGkudGltZW91dCA9IG91dGxpbmUudGltZW91dCA/IHBhcnNlSW50KG91dGxpbmUudGltZW91dCwgMTApIDogMDtcbiAgICAgICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgICAgICBmb3JpbihtZXRob2RzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGFwaVtrZXldID0gY3JlYXRlQWN0aW9uKGtleSwgb3V0bGluZVtrZXldLCBtZXRob2RzW2tleV0sIGFwaS50aW1lb3V0LCBhcGkuaGVhZGVycyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBwcm9jZXNzIGlmIG5vIHVybCBvciBwcm9jZXNzIG9uIG91dGxpbmVcbiAgICAgICAgYXBpLnByb2Nlc3MgPSBvdXRsaW5lLnByb2Nlc3MgfHwgaXNTdHJpbmcob3V0bGluZSkgfHwgb3V0bGluZS51cmwgPyBhcGkucHJvY2VzcyA6IG51bGw7XG5cbiAgICAgICAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yIHJlbW92ZVxuICAgICAgICBhcGkucmVtb3ZlID0gb3V0bGluZS5yZW1vdmUgfHwgbnVsbDtcblxuICAgICAgICAvLyByZW1vdmUgZ2VuZXJpYyBoZWFkZXJzIGZyb20gYXBpIG9iamVjdFxuICAgICAgICBkZWxldGUgYXBpLmhlYWRlcnM7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihuYW1lLCBvdXRsaW5lLCBtZXRob2QsIHRpbWVvdXQsIGhlYWRlcnMpIHtcbiAgICAgICAgLy8gaXMgZXhwbGljaXRlbHkgc2V0IHRvIG51bGwgc28gZGlzYWJsZVxuICAgICAgICBpZiAob3V0bGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyBjdXN0b20gZnVuY3Rpb24sIGRvbmUhIERldiBoYW5kbGVzIGV2ZXJ5dGhpbmcuXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBhY3Rpb24gb2JqZWN0XG4gICAgICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICAgICAgICB1cmw6IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnID8gJz8nICsgbmFtZSArICc9JyA6ICcnLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICAgICAgICBvbmRhdGE6IG51bGwsXG4gICAgICAgICAgICBvbmVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgICAgICBpZiAoaXNTdHJpbmcob3V0bGluZSkpIHtcbiAgICAgICAgICAgIGFjdGlvbi51cmwgPSBvdXRsaW5lO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJ3cml0ZVxuICAgICAgICBPYmplY3QuYXNzaWduKGFjdGlvbiwgb3V0bGluZSk7XG5cbiAgICAgICAgLy8gc2VlIGlmIHNob3VsZCByZWZvcm1hdCBoZWFkZXJzO1xuICAgICAgICBpZiAoaXNTdHJpbmcoYWN0aW9uLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBhY3Rpb24uaGVhZGVycy5zcGxpdCgvOiguKykvKTtcbiAgICAgICAgICAgIGFjdGlvbi5oZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogcGFydHNbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRzWzFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGJvb2wgd2l0aENyZWRlbnRpYWxzXG4gICAgICAgIGFjdGlvbi53aXRoQ3JlZGVudGlhbHMgPSB0b0Jvb2xlYW4oYWN0aW9uLndpdGhDcmVkZW50aWFscyk7XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIHRvU2VydmVyQVBJID0gZnVuY3Rpb24gdG9TZXJ2ZXJBUEkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlckFQSSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBpc051bGwgPSBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGlzQVBJID0gZnVuY3Rpb24gaXNBUEkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNTdHJpbmcodmFsdWUudXJsKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUucHJvY2VzcykgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlLnJldmVydCkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlLnJlc3RvcmUpICYmXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZS5mZXRjaClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXlswLTldKyA/KD86R0J8TUJ8S0IpJC9naS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdieXRlcyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBUEkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FwaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgcmVwbGFjZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uIHJlcGxhY2VTaW5nbGVRdW90ZXMoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC97XFxzKicvZywgJ3tcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJ1xccyp9L2csICdcIn0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLydcXHMqOi9nLCAnXCI6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC86XFxzKicvZywgJzpcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvLFxccyonL2csICcsXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLydcXHMqLC9nLCAnXCIsJyk7XG4gICAgfTtcblxuICAgIHZhciBjb252ZXJzaW9uVGFibGUgPSB7XG4gICAgICAgIGFycmF5OiB0b0FycmF5LFxuICAgICAgICBib29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgICAgIGludDogZnVuY3Rpb24gaW50KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiB0b0Zsb2F0LFxuICAgICAgICBmbG9hdDogdG9GbG9hdCxcbiAgICAgICAgYnl0ZXM6IHRvQnl0ZXMsXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb246IGZ1bmN0aW9uIF9mdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvRnVuY3Rpb25SZWZlcmVuY2UodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXBsYWNlU2luZ2xlUXVvdGVzKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciBjb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8odmFsdWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRWYWx1ZUJ5VHlwZSA9IGZ1bmN0aW9uIGdldFZhbHVlQnlUeXBlKG5ld1ZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSkge1xuICAgICAgICAvLyBjYW4gYWx3YXlzIGFzc2lnbiBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIG5ldyB2YWx1ZVxuICAgICAgICB2YXIgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShuZXdWYWx1ZSk7XG5cbiAgICAgICAgLy8gaXMgdmFsaWQgdHlwZT9cbiAgICAgICAgaWYgKG5ld1ZhbHVlVHlwZSAhPT0gdmFsdWVUeXBlKSB7XG4gICAgICAgICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gY29udmVydFRvKG5ld1ZhbHVlLCB2YWx1ZVR5cGUpO1xuXG4gICAgICAgICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgICAgICAgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShjb252ZXJ0ZWRWYWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIG5vIHZhbGlkIGNvbnZlcnNpb25zIGZvdW5kXG4gICAgICAgICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVHJ5aW5nIHRvIGFzc2lnbiB2YWx1ZSB3aXRoIGluY29ycmVjdCB0eXBlIHRvIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiArXG4gICAgICAgICAgICAgICAgICAgICdcIiwgYWxsb3dlZCB0eXBlOiBcIicgK1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzaWduIG5ldyB2YWx1ZVxuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVPcHRpb24oZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gZ2V0VmFsdWVCeVR5cGUobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVPcHRpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgZm9yaW4ob3B0aW9ucywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbkRlZmluaXRpb24gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gY3JlYXRlT3B0aW9uKG9wdGlvbkRlZmluaXRpb25bMF0sIG9wdGlvbkRlZmluaXRpb25bMV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChvYmopO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFN0YXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIG1vZGVsXG4gICAgICAgICAgICBpdGVtczogW10sXG5cbiAgICAgICAgICAgIC8vIHRpbWVvdXQgdXNlZCBmb3IgY2FsbGluZyB1cGRhdGUgaXRlbXNcbiAgICAgICAgICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAgICAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIHN0YWNraW5nIG1ldGFkYXRhIHVwZGF0ZXNcbiAgICAgICAgICAgIGl0ZW1VcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAgICAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1F1ZXVlOiBbXSxcblxuICAgICAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGZyb21DYW1lbHMgPSBmdW5jdGlvbiBmcm9tQ2FtZWxzKHN0cmluZykge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLSc7XG4gICAgICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgICAgIC5zcGxpdCgvKD89W0EtWl0pLylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvbkFQSSA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkFQSShzdG9yZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdTRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3B0aW9uQWN0aW9ucyA9IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkFjdGlvbnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgZm9yaW4ob3B0aW9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgb2JqWydTRVRfJyArIG5hbWVdID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zW2tleV0gPSBhY3Rpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIG5vcGUsIGZhaWxlZFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdGhlIHZhbHVlIG9mIHRoaXMgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU0VUXycgKyBuYW1lLCB7IHZhbHVlOiBzdGF0ZS5vcHRpb25zW2tleV0gfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9wdGlvblF1ZXJpZXMgPSBmdW5jdGlvbiBjcmVhdGVPcHRpb25RdWVyaWVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBvYmpbJ0dFVF8nICsgZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKV0gPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSW50ZXJhY3Rpb25NZXRob2QgPSB7XG4gICAgICAgIEFQSTogMSxcbiAgICAgICAgRFJPUDogMixcbiAgICAgICAgQlJPV1NFOiAzLFxuICAgICAgICBQQVNURTogNCxcbiAgICAgICAgTk9ORTogNSxcbiAgICB9O1xuXG4gICAgdmFyIGdldFVuaXF1ZUlkID0gZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAgICAgICAuc3Vic3RyKDIsIDkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgID8gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gICAgfVxuXG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICAgIGZ1bmN0aW9uIF9qc3godHlwZSwgcHJvcHMsIGtleSwgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgICAgICAgICAgICAgMHhlYWM3O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgICAgIGlmICghcHJvcHMgJiYgY2hpbGRyZW5MZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB2b2lkIDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBrZXk6IGtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICcnICsga2V5LFxuICAgICAgICAgICAgcmVmOiBudWxsLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgX293bmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3luY0l0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBtZXRob2Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX0FzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgICAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrID0gYmFjay5uZXh0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcm9udCA9IGJhY2sgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gJ3JldHVybicgOiAnbm9ybWFsJywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZXR0bGUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgICAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgICB9O1xuXG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCd0aHJvdycsIGFyZyk7XG4gICAgfTtcblxuICAgIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3JldHVybicsIGFyZyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoaW5uZXIsIGF3YWl0V3JhcCkge1xuICAgICAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAod2FpdGluZykge1xuICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwdW1wKCduZXh0JywgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXIudGhyb3cgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoJ3JldHVybicsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAnbmV4dCcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZpbmVFbnVtZXJhYmxlUHJvcGVydGllcyhvYmosIGRlc2NzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZXNjcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBvYmplY3RTeW1ib2xzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICBfZXh0ZW5kcyA9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduIHx8XG4gICAgICAgICAgICBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKGVudW1lcmFibGVPbmx5KVxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgICAgICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICAgICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKSB7XG4gICAgICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgICAgICAgID8gb2JqXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG9iaixcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25ld0Fycm93Q2hlY2soaW5uZXJUaGlzLCBib3VuZFRoaXMpIHtcbiAgICAgICAgaWYgKGlubmVyVGhpcyAhPT0gYm91bmRUaGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgaW5zdGFudGlhdGUgYW4gYXJyb3cgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3REZXN0cnVjdHVyaW5nRW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGRlc3RydWN0dXJlIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICB2YXIga2V5LCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICAgICAgICB2YXIga2V5LCBpO1xuXG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgICAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBjYWxsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICAgICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlc2M7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkge1xuICAgICAgICB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcblxuICAgICAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgICAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdGVtcG9yYWxSZWYodmFsLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG5hbWUgKyAnXCIgaXMgcmVhZC1vbmx5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzTmFtZVREWkVycm9yKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBcIicgKyBuYW1lICsgJ1wiIGNhbm5vdCBiZSByZWZlcmVuY2VkIGluIGNvbXB1dGVkIHByb3BlcnR5IGtleXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIF90ZW1wb3JhbFVuZGVmaW5lZCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgICAgICAgcmV0dXJuIGFycjI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgICAgICB2YXIgX2FyciA9IFtdO1xuICAgICAgICB2YXIgX24gPSB0cnVlO1xuICAgICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgICAgICBfZSA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10gIT0gbnVsbCkgX2lbJ3JldHVybiddKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2FycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXRMb29zZShhcnIsIGkpIHtcbiAgICAgICAgdmFyIF9hcnIgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7ICkge1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zdGVwLnZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaXQubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgICAgICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG5cbiAgICAgICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoaGludCA9PT0gJ3N0cmluZycgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICAgICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsICdzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArXG4gICAgICAgICAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgICAgICAgICAnVG8gdXNlIHByb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaW4gc3BlYyBtb2RlIHdpdGggZGVjb3JhdG9ycywgd2FpdCBmb3IgJyArXG4gICAgICAgICAgICAgICAgJ3RoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgZGVjb3JhdG9ycyBpbiBzdGFnZSAyLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVzYyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IGRlY29yYXRvcnNcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGRlc2MsIGRlY29yYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgICAgICAgIH0sIGRlc2MpO1xuXG4gICAgICAgIGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgZGVzYyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG5cbiAgICB2YXIgaWQgPSAwO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VLZXkobmFtZSkge1xuICAgICAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VCYXNlKHJlY2VpdmVyLCBwcml2YXRlS2V5KSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlY2VpdmVyLCBwcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHVzZSBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkRGVzdHJ1Y3R1cmVTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgaWYgKCEoJ19fZGVzdHJPYmonIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5fX2Rlc3RyT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXQgdmFsdWUodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuX19kZXN0ck9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlRmllbGRTcGVjR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVGaWVsZFNwZWNTZXQocmVjZWl2ZXIsIGNsYXNzQ29uc3RydWN0b3IsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgbWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gY2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7XG4gICAgICAgIHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpO1xuXG4gICAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXBpID0gbWl4aW5zW2ldKGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7XG4gICAgICAgICAgICBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgfSwgc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgICAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgICAgICAgIGRlY29yYXRvcnNcbiAgICAgICAgKTtcbiAgICAgICAgYXBpLmluaXRpYWxpemVDbGFzc0VsZW1lbnRzKHIuRiwgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXREZWNvcmF0b3JzQXBpKCkge1xuICAgICAgICBfZ2V0RGVjb3JhdG9yc0FwaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbJ21ldGhvZCddLCBbJ2ZpZWxkJ11dLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uKE8sIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSAnb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBbJ21ldGhvZCcsICdmaWVsZCddLmZvckVhY2goZnVuY3Rpb24oa2luZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQua2luZCA9PT0ga2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09ICdzdGF0aWMnID8gRiA6IHByb3RvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmaW5lQ2xhc3NFbGVtZW50OiBmdW5jdGlvbihyZWNlaXZlciwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50cywgZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3duOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaGVycyA9IGZpbmlzaGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50LmtleSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKGVsZW1lbnRPYmplY3QpIHx8IGVsZW1lbnRPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFeHRyYXMgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZXh0cmFzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhcy5wdXNoLmFwcGx5KGV4dHJhcywgbmV3RXh0cmFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYXM6IGV4dHJhcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50c0FuZEZpbmlzaGVyID0gdGhpcy50b0NsYXNzRGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9ialxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgZWxlbWVudCAoJyArIGVsZW1lbnRzW2pdLmtleSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24oZWxlbWVudE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9BcnJheShlbGVtZW50T2JqZWN0cykubWFwKGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInLCAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZXh0cmFzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyAmJiBraW5kICE9PSAnZmllbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIGVpdGhlciBcIm1ldGhvZFwiIG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50ICE9PSAnc3RhdGljJyAmJiBwbGFjZW1lbnQgIT09ICdwcm90b3R5cGUnICYmIHBsYWNlbWVudCAhPT0gJ293bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFwicHJvdG90eXBlXCIgb3IgXCJvd25cIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIC5wbGFjZW1lbnQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2VsZW1lbnRzJywgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgJ2luaXRpYWxpemVyJywgJ0EgbWV0aG9kIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KGVsZW1lbnRPYmplY3QsICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlcixcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFzOiBleHRyYXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRGVzY3JpcHRvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcob2JqLmtpbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGNyZWF0ZWQgYSBjbGFzcyBkZXNjcmlwdG9yIHdpdGggLmtpbmQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2tleScsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdkZXNjcmlwdG9yJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosICdpbml0aWFsaXplcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosICdmaW5pc2hlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZXI6IGZpbmlzaGVyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuQ2xhc3NGaW5pc2hlcnM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmaW5pc2hlcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhbGxvd1Byb3BlcnR5OiBmdW5jdGlvbihvYmosIG5hbWUsIG9iamVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmplY3RUeXBlICsgXCIgY2FuJ3QgaGF2ZSBhIC5cIiArIG5hbWUgKyAnIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikge1xuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgaWYgKGRlZi5raW5kID09PSAnbWV0aG9kJykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIGdldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIHNldDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBraW5kOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdmaWVsZCcgOiAnbWV0aG9kJyxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcGxhY2VtZW50OiBkZWYuc3RhdGljID8gJ3N0YXRpYycgOiBkZWYua2luZCA9PT0gJ2ZpZWxkJyA/ICdvd24nIDogJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVmLmRlY29yYXRvcnMpIGVsZW1lbnQuZGVjb3JhdG9ycyA9IGRlZi5kZWNvcmF0b3JzO1xuICAgICAgICBpZiAoZGVmLmtpbmQgPT09ICdmaWVsZCcpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikge1xuICAgICAgICBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY29hbGVzY2VDbGFzc0VsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmXG4gICAgICAgICAgICAgICAgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG90aGVyO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnbWV0aG9kJyAmJiAob3RoZXIgPSBuZXdFbGVtZW50cy5maW5kKGlzU2FtZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRHVwbGljYXRlZCBtZXRob2RzICgnICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhlIHNhbWUgcHJvcGVydHkgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5rZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJykuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmRlY29yYXRvcnMgJiYgZWxlbWVudC5kZWNvcmF0b3JzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNEYXRhRGVzY3JpcHRvcihkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjICE9PSB1bmRlZmluZWQgJiYgIShkZXNjLnZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVzYy53cml0YWJsZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQocmVjZWl2ZXIsIHByaXZhdGVTZXQsIGZuKSB7XG4gICAgICAgIGlmICghcHJpdmF0ZVNldC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZFNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3dyYXBSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgICBfd3JhcFJlZ0V4cCA9IGZ1bmN0aW9uKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmFiZWxSZWdFeHAocmUsIGdyb3Vwcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9SZWdFeHAgPSBfd3JhcE5hdGl2ZVN1cGVyKFJlZ0V4cCk7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbiAgICAgICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIEJhYmVsUmVnRXhwKHJlLCBncm91cHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9SZWdFeHAuY2FsbCh0aGlzLCByZSk7XG5cbiAgICAgICAgICAgIF9ncm91cHMuc2V0KF90aGlzLCBncm91cHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgICAgIEJhYmVsUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQuZ3JvdXBzID0gYnVpbGRHcm91cHMocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gX2dyb3Vwcy5nZXQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdHIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbi5yZXBsYWNlKC9cXCQ8KFtePl0rKT4vZywgZnVuY3Rpb24oXywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckJyArIGdyb3Vwc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3Vic3RpdHV0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbGRHcm91cHMoYXJncywgX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBzdWJzdGl0dXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkR3JvdXBzKHJlc3VsdCwgcmUpIHtcbiAgICAgICAgICAgIHZhciBnID0gX2dyb3Vwcy5nZXQocmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZykucmVkdWNlKGZ1bmN0aW9uKGdyb3VwcywgbmFtZSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlSZW1vdmUgPSBmdW5jdGlvbiBhcnJheVJlbW92ZShhcnIsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihjYiwgc3luYykge1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBvZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQsIGNiKSB7XG4gICAgICAgICAgICBhcnJheVJlbW92ZShcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50ICYmIChsaXN0ZW5lci5jYiA9PT0gY2IgfHwgIWNiKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9maXJlID0gZnVuY3Rpb24gZmlyZShldmVudCwgYXJncywgc3luYykge1xuICAgICAgICAgICAgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2I7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc3luYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJlU3luYzogZnVuY3Rpb24gZmlyZVN5bmMoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9rZXkgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZmlyZShldmVudCwgYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24gZmlyZShldmVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2tleTIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgICAgICAgICAgICBfa2V5MisrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9maXJlKGV2ZW50LCBhcmdzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBjYjogY2IgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PbmNlOiBmdW5jdGlvbiBvbk9uY2UoZXZlbnQsIF9jYikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYjogZnVuY3Rpb24gY2IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYoZXZlbnQsIF9jYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2IuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZjogb2ZmLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IGZ1bmN0aW9uIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoXG4gICAgICAgIHNyYyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBleGNsdWRlZFxuICAgICkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFleGNsdWRlZC5pbmNsdWRlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBrZXkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgUFJJVkFURSA9IFtcbiAgICAgICAgJ2ZpcmUnLFxuICAgICAgICAncHJvY2VzcycsXG4gICAgICAgICdyZXZlcnQnLFxuICAgICAgICAnbG9hZCcsXG4gICAgICAgICdvbicsXG4gICAgICAgICdvZmYnLFxuICAgICAgICAnb25PbmNlJyxcbiAgICAgICAgJ3JldHJ5TG9hZCcsXG4gICAgICAgICdleHRlbmQnLFxuICAgICAgICAnYXJjaGl2ZScsXG4gICAgICAgICdhcmNoaXZlZCcsXG4gICAgICAgICdyZWxlYXNlJyxcbiAgICAgICAgJ3JlbGVhc2VkJyxcbiAgICAgICAgJ3JlcXVlc3RQcm9jZXNzaW5nJyxcbiAgICAgICAgJ2ZyZWV6ZScsXG4gICAgXTtcblxuICAgIHZhciBjcmVhdGVJdGVtQVBJID0gZnVuY3Rpb24gY3JlYXRlSXRlbUFQSShpdGVtKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcbiAgICAgICAgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChpdGVtLCBhcGksIFBSSVZBVEUpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUmVsZWFzZWRJdGVtcyA9IGZ1bmN0aW9uIHJlbW92ZVJlbGVhc2VkSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVsZWFzZWQpIHtcbiAgICAgICAgICAgICAgICBhcnJheVJlbW92ZShpdGVtcywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIEl0ZW1TdGF0dXMgPSB7XG4gICAgICAgIElOSVQ6IDEsXG4gICAgICAgIElETEU6IDIsXG4gICAgICAgIFBST0NFU1NJTkdfUVVFVUVEOiA5LFxuICAgICAgICBQUk9DRVNTSU5HOiAzLFxuICAgICAgICBQUk9DRVNTSU5HX0NPTVBMRVRFOiA1LFxuICAgICAgICBQUk9DRVNTSU5HX0VSUk9SOiA2LFxuICAgICAgICBQUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogMTAsXG4gICAgICAgIExPQURJTkc6IDcsXG4gICAgICAgIExPQURfRVJST1I6IDgsXG4gICAgfTtcblxuICAgIHZhciBGaWxlT3JpZ2luID0ge1xuICAgICAgICBJTlBVVDogMSxcbiAgICAgICAgTElNQk86IDIsXG4gICAgICAgIExPQ0FMOiAzLFxuICAgIH07XG5cbiAgICB2YXIgZ2V0Tm9uTnVtZXJpYyA9IGZ1bmN0aW9uIGdldE5vbk51bWVyaWMoc3RyKSB7XG4gICAgICAgIHJldHVybiAvW14wLTldKy8uZXhlYyhzdHIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBnZXROb25OdW1lcmljKCgxLjEpLnRvTG9jYWxlU3RyaW5nKCkpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGhvdXNhbmRzU2VwYXJhdG9yID0gZnVuY3Rpb24gZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCkge1xuICAgICAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgICAgIC8vIFdlIGNoZWNrIGFnYWluc3QgdGhlIG5vcm1hbCB0b1N0cmluZyBvdXRwdXQgYW5kIGlmIHRoZXkncmUgdGhlIHNhbWUgcmV0dXJuIGEgY29tbWEgd2hlbiBkZWNpbWFsIHNlcGFyYXRvciBpcyBhIGRvdFxuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IGdldERlY2ltYWxTZXBhcmF0b3IoKTtcbiAgICAgICAgdmFyIHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgPSAoMTAwMC4wKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB2YXIgdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvciA9ICgxMDAwLjApLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yICE9PSB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Tm9uTnVtZXJpYyh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaW1hbFNlcGFyYXRvciA9PT0gJy4nID8gJywnIDogJy4nO1xuICAgIH07XG5cbiAgICB2YXIgVHlwZSA9IHtcbiAgICAgICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgICAgICBJTlQ6ICdpbnQnLFxuICAgICAgICBOVU1CRVI6ICdudW1iZXInLFxuICAgICAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgICAgICBBUlJBWTogJ2FycmF5JyxcbiAgICAgICAgT0JKRUNUOiAnb2JqZWN0JyxcbiAgICAgICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgICAgIEFDVElPTjogJ2FjdGlvbicsXG4gICAgICAgIFNFUlZFUl9BUEk6ICdzZXJ2ZXJhcGknLFxuICAgICAgICBSRUdFWDogJ3JlZ2V4JyxcbiAgICB9O1xuXG4gICAgLy8gYWxsIHJlZ2lzdGVyZWQgZmlsdGVyc1xuICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAvLyBsb29wcyBvdmVyIG1hdGNoaW5nIGZpbHRlcnMgYW5kIHBhc3NlcyBvcHRpb25zIHRvIGVhY2ggZmlsdGVyLCByZXR1cm5pbmcgdGhlIG1hcHBlZCByZXN1bHRzXG4gICAgdmFyIGFwcGx5RmlsdGVyQ2hhaW4gPSBmdW5jdGlvbiBhcHBseUZpbHRlckNoYWluKGtleSwgdmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0ZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLmNiO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIG5vd1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciB0byBraWNrIHRoaW5ncyBvZlxuICAgICAgICAgICAgdmFyIGluaXRpYWxGaWx0ZXIgPSBtYXRjaGluZ0ZpbHRlcnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gY2hhaW4gZmlsdGVyc1xuICAgICAgICAgICAgbWF0Y2hpbmdGaWx0ZXJzXG4gICAgICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIHByb21pc2VzIHBhc3NpbmcgdmFsdWUgdG8gbmV4dCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCh2YWx1ZSwgdXRpbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBpbml0aWFsIGZpbHRlciwgd2lsbCByZXR1cm4gYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxGaWx0ZXIodmFsdWUsIHV0aWxzKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKGtleSwgdmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5rZXkgPT09IGtleTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5jYih2YWx1ZSwgdXRpbHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBsaXN0XG4gICAgdmFyIGFkZEZpbHRlciA9IGZ1bmN0aW9uIGFkZEZpbHRlcihrZXksIGNiKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzLnB1c2goeyBrZXk6IGtleSwgY2I6IGNiIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiBleHRlbmREZWZhdWx0T3B0aW9ucyhhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIGZvcmluKG9wdHMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGtleSBkb2VzIG5vdCBleGlzdCwgc28gdGhpcyBvcHRpb24gY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0T3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVswXSA9IGdldFZhbHVlQnlUeXBlKFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMF0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICBpZDogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBpbnB1dCBmaWVsZCBuYW1lIHRvIHVzZVxuICAgICAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGZpZWxkXG4gICAgICAgIGRpc2FibGVkOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgICAgIGNsYXNzTmFtZTogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICAvLyBpcyB0aGUgZmllbGQgcmVxdWlyZWRcbiAgICAgICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBBbGxvdyBtZWRpYSBjYXB0dXJlIHdoZW4gdmFsdWUgaXMgc2V0XG4gICAgICAgIGNhcHR1cmVNZXRob2Q6IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAgICAgLy8gLSBEb2VzIG5vdCB3b3JrIHdpdGggbXVsdGlwbGUgb24gYXBwbGUgZGV2aWNlc1xuICAgICAgICAvLyAtIElmIHNldCwgYWNjZXB0ZWRGaWxlVHlwZXMgbXVzdCBiZSBtYWRlIHRvIG1hdGNoIHdpdGggbWVkaWEgd2lsZGNhcmQgXCJpbWFnZS8qXCIsIFwiYXVkaW8vKlwiIG9yIFwidmlkZW8vKlwiXG5cbiAgICAgICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgICAgIGFsbG93U3luY0FjY2VwdEF0dHJpYnV0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gRmVhdHVyZSB0b2dnbGVzXG4gICAgICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgICAgIGFsbG93QnJvd3NlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgYnJvd3NpbmcgdGhlIGZpbGUgc3lzdGVtXG4gICAgICAgIGFsbG93UGFzdGU6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBwYXN0aW5nIGZpbGVzXG4gICAgICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgICAgICBhbGxvd1JlcGxhY2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBhIGZpbGUgb24gb3RoZXIgZmlsZSB0byByZXBsYWNlIGl0IChvbmx5IHdvcmtzIHdoZW4gbXVsdGlwbGUgaXMgc2V0IHRvIGZhbHNlKVxuICAgICAgICBhbGxvd1JldmVydDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHJldmVydCBmaWxlIHVwbG9hZFxuICAgICAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgICAgICBhbGxvd1Byb2Nlc3M6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byBwcm9jZXNzIGEgZmlsZSwgd2hlbiBzZXQgdG8gZmFsc2UsIHRoaXMgcmVtb3ZlcyB0aGUgZmlsZSB1cGxvYWQgYnV0dG9uXG4gICAgICAgIGFsbG93UmVvcmRlcjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyByZW9yZGVyaW5nIG9mIGZpbGVzXG4gICAgICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAgICAgLy8gVHJ5IHN0b3JlIGZpbGUgaWYgYHNlcnZlcmAgbm90IHNldFxuICAgICAgICBzdG9yZUFzRmlsZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIFJldmVydCBtb2RlXG4gICAgICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgICAgICAvLyBJbnB1dCByZXF1aXJlbWVudHNcbiAgICAgICAgbWF4RmlsZXM6IFtudWxsLCBUeXBlLklOVF0sIC8vIE1heCBudW1iZXIgb2YgZmlsZXNcbiAgICAgICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgICAgIC8vIFdoZXJlIHRvIHB1dCBmaWxlXG4gICAgICAgIGl0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb206IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTZXQgdG8gZmFsc2UgdG8gYWx3YXlzIGFkZCBpdGVtcyB0byBiZWdpbiBvciBlbmQgb2YgbGlzdFxuICAgICAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICBpdGVtSW5zZXJ0SW50ZXJ2YWw6IFs3NSwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIERyYWcgJ24gRHJvcCByZWxhdGVkXG4gICAgICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgICAgIGRyb3BPbkVsZW1lbnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBEcm9wIG5lZWRzIHRvIGhhcHBlbiBvbiBlbGVtZW50IChzZXQgdG8gZmFsc2UgdG8gYWxzbyBsb2FkIGRyb3BzIG91dHNpZGUgb2YgVXApXG4gICAgICAgIGRyb3BWYWxpZGF0aW9uOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZSBvciBkaXNhYmxlIHZhbGlkYXRpbmcgZmlsZXMgb24gZHJvcFxuICAgICAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAgICAgLy8gVXBsb2FkIHJlbGF0ZWRcbiAgICAgICAgaW5zdGFudFVwbG9hZDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIFNob3VsZCB1cGxvYWQgZmlsZXMgaW1tZWRpYXRlbHkgb24gZHJvcFxuICAgICAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG4gICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gaWYgdHJ1ZSB1cGxvYWRzIHRha2UgYXQgbGVhc3QgNzUwIG1zLCB0aGlzIGVuc3VyZXMgdGhlIHVzZXIgc2VlcyB0aGUgdXBsb2FkIHByb2dyZXNzIGdpdmluZyB0cnVzdCB0aGUgdXBsb2FkIGFjdHVhbGx5IGhhcHBlbmVkXG5cbiAgICAgICAgLy8gQ2h1bmtzXG4gICAgICAgIGNodW5rVXBsb2FkczogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgY2h1bmtlZCB1cGxvYWRzXG4gICAgICAgIGNodW5rRm9yY2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRm9yY2UgdXNlIG9mIGNodW5rIHVwbG9hZHMgZXZlbiBmb3IgZmlsZXMgc21hbGxlciB0aGFuIGNodW5rIHNpemVcbiAgICAgICAgY2h1bmtTaXplOiBbNTAwMDAwMCwgVHlwZS5JTlRdLCAvLyBTaXplIG9mIGNodW5rcyAoNU1CIGRlZmF1bHQpXG4gICAgICAgIGNodW5rUmV0cnlEZWxheXM6IFtbNTAwLCAxMDAwLCAzMDAwXSwgVHlwZS5BUlJBWV0sIC8vIEFtb3VudCBvZiB0aW1lcyB0byByZXRyeSB1cGxvYWQgb2YgYSBjaHVuayB3aGVuIGl0IGZhaWxzXG5cbiAgICAgICAgLy8gVGhlIHNlcnZlciBhcGkgZW5kIHBvaW50cyB0byB1c2UgZm9yIHVwbG9hZGluZyAoc2VlIGRvY3MpXG4gICAgICAgIHNlcnZlcjogW251bGwsIFR5cGUuU0VSVkVSX0FQSV0sXG5cbiAgICAgICAgLy8gRmlsZSBzaXplIGNhbGN1bGF0aW9ucywgY2FuIHNldCB0byAxMDI0LCB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgZGlzcGxheSwgcHJvcGVydGllcyB1c2UgZmlsZSBzaXplIGJhc2UgMTAwMFxuICAgICAgICBmaWxlU2l6ZUJhc2U6IFsxMDAwLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTGFiZWxzIGFuZCBzdGF0dXMgbWVzc2FnZXNcbiAgICAgICAgbGFiZWxGaWxlU2l6ZUJ5dGVzOiBbJ2J5dGVzJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplS2lsb2J5dGVzOiBbJ0tCJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplTWVnYWJ5dGVzOiBbJ01CJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVTaXplR2lnYWJ5dGVzOiBbJ0dCJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsRGVjaW1hbFNlcGFyYXRvcjogW2dldERlY2ltYWxTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcbiAgICAgICAgbGFiZWxUaG91c2FuZHNTZXBhcmF0b3I6IFtnZXRUaG91c2FuZHNTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcblxuICAgICAgICBsYWJlbElkbGU6IFtcbiAgICAgICAgICAgICdEcmFnICYgRHJvcCB5b3VyIGZpbGVzIG9yIDxzcGFuIGNsYXNzPVwiZmlsZXBvbmQtLWxhYmVsLWFjdGlvblwiPkJyb3dzZTwvc3Bhbj4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgbGFiZWxJbnZhbGlkRmllbGQ6IFsnRmllbGQgY29udGFpbnMgaW52YWxpZCBmaWxlcycsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlV2FpdGluZ0ZvclNpemU6IFsnV2FpdGluZyBmb3Igc2l6ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZTogWydTaXplIG5vdCBhdmFpbGFibGUnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUNvdW50U2luZ3VsYXI6IFsnZmlsZSBpbiBsaXN0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVDb3VudFBsdXJhbDogWydmaWxlcyBpbiBsaXN0JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVMb2FkaW5nOiBbJ0xvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZUFkZGVkOiBbJ0FkZGVkJywgVHlwZS5TVFJJTkddLCAvLyBhc3Npc3RpdmUgb25seVxuICAgICAgICBsYWJlbEZpbGVMb2FkRXJyb3I6IFsnRXJyb3IgZHVyaW5nIGxvYWQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVJlbW92ZWQ6IFsnUmVtb3ZlZCcsIFR5cGUuU1RSSU5HXSwgLy8gYXNzaXN0aXZlIG9ubHlcbiAgICAgICAgbGFiZWxGaWxlUmVtb3ZlRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxGaWxlUHJvY2Vzc2luZzogWydVcGxvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZTogWydVcGxvYWQgY29tcGxldGUnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdBYm9ydGVkOiBbJ1VwbG9hZCBjYW5jZWxsZWQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvcjogWydFcnJvciBkdXJpbmcgdXBsb2FkJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJldmVydCcsIFR5cGUuU1RSSU5HXSxcblxuICAgICAgICBsYWJlbFRhcFRvQ2FuY2VsOiBbJ3RhcCB0byBjYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsVGFwVG9SZXRyeTogWyd0YXAgdG8gcmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsVGFwVG9VbmRvOiBbJ3RhcCB0byB1bmRvJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsQnV0dG9uUmVtb3ZlSXRlbTogWydSZW1vdmUnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtTG9hZDogWydBYm9ydCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IFsnQ2FuY2VsJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvblVuZG9JdGVtUHJvY2Vzc2luZzogWydVbmRvJywgVHlwZS5TVFJJTkddLFxuICAgICAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgICAgIGxhYmVsQnV0dG9uUHJvY2Vzc0l0ZW06IFsnVXBsb2FkJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3aWR0aCBhbmQgaGVpZ2h0IHBsdXMgdmlld3BveCBhcmUgZXZlbiBudW1iZXJzIHNvIGljb25zIGFyZSBuaWNlbHkgY2VudGVyZWRcbiAgICAgICAgaWNvblJlbW92ZTogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgICAgIFR5cGUuU1RSSU5HLFxuICAgICAgICBdLFxuXG4gICAgICAgIGljb25Qcm9jZXNzOiBbXG4gICAgICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgICAgIFR5cGUuU1RSSU5HLFxuICAgICAgICBdLFxuXG4gICAgICAgIGljb25SZXRyeTogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgaWNvblVuZG86IFtcbiAgICAgICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgICAgICBUeXBlLlNUUklORyxcbiAgICAgICAgXSxcblxuICAgICAgICBpY29uRG9uZTogW1xuICAgICAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgb25pbml0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ud2FybmluZzogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9uYWN0aXZhdGVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9uaW5pdGZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hZGRmaWxlcHJvZ3Jlc3M6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25hZGRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlcHJvZ3Jlc3M6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZWFib3J0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcm9jZXNzZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnByb2Nlc3NmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgb25wcmVwYXJlZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBvbnVwZGF0ZWZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gaG9va3NcbiAgICAgICAgYmVmb3JlRHJvcEZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICAgICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgICAgICBiZWZvcmVSZW1vdmVGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIGJlZm9yZVByZXBhcmVGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gc3R5bGVzXG4gICAgICAgIHN0eWxlUGFuZWxMYXlvdXQ6IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgJ2ludGVncmF0ZWQnLCAnY29tcGFjdCcsICdjaXJjbGUnXG4gICAgICAgIHN0eWxlUGFuZWxBc3BlY3RSYXRpbzogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCBvciAnMzoyJyBvciAxXG4gICAgICAgIHN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbVBvc2l0aW9uOiBbJ2xlZnQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIHN0eWxlQnV0dG9uUHJvY2Vzc0l0ZW1Qb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgICAgIHN0eWxlUHJvZ3Jlc3NJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtQWxpZ246IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAvLyBjdXN0b20gaW5pdGlhbCBmaWxlcyBhcnJheVxuICAgICAgICBmaWxlczogW1tdLCBUeXBlLkFSUkFZXSxcblxuICAgICAgICAvLyBzaG93IHN1cHBvcnQgYnkgZGlzcGxheWluZyBjcmVkaXRzXG4gICAgICAgIGNyZWRpdHM6IFtbJ2h0dHBzOi8vcHFpbmEubmwvJywgJ1Bvd2VyZWQgYnkgUFFJTkEnXSwgVHlwZS5BUlJBWV0sXG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtQnlRdWVyeSA9IGZ1bmN0aW9uIGdldEl0ZW1CeVF1ZXJ5KGl0ZW1zLCBxdWVyeSkge1xuICAgICAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgICAgICBpZiAoaXNFbXB0eShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtc1swXSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVlcnkgaXMgaW5kZXhcbiAgICAgICAgaWYgKGlzSW50KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zW3F1ZXJ5XSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcXVlcnkgaXMgaXRlbSwgZ2V0IHRoZSBpZFxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc3VtZSBxdWVyeSBpcyBhIHN0cmluZyBhbmQgcmV0dXJuIGl0ZW0gYnkgaWRcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBxdWVyeTtcbiAgICAgICAgICAgIH0pIHx8IG51bGxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcgPSBmdW5jdGlvbiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0VtcHR5KGFzcGVjdFJhdGlvKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvOi8udGVzdChhc3BlY3RSYXRpbykpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMV0gLyBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhc3BlY3RSYXRpbyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRBY3RpdmVJdGVtcyA9IGZ1bmN0aW9uIGdldEFjdGl2ZUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVtLmFyY2hpdmVkO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFN0YXR1cyA9IHtcbiAgICAgICAgRU1QVFk6IDAsXG4gICAgICAgIElETEU6IDEsIC8vIHdhaXRpbmdcbiAgICAgICAgRVJST1I6IDIsIC8vIGEgZmlsZSBpcyBpbiBlcnJvciBzdGF0ZVxuICAgICAgICBCVVNZOiAzLCAvLyBidXN5IHByb2Nlc3Npbmcgb3IgbG9hZGluZ1xuICAgICAgICBSRUFEWTogNCwgLy8gYWxsIGZpbGVzIHVwbG9hZGVkXG4gICAgfTtcblxuICAgIHZhciByZXMgPSBudWxsO1xuICAgIHZhciBjYW5VcGRhdGVGaWxlSW5wdXQgPSBmdW5jdGlvbiBjYW5VcGRhdGVGaWxlSW5wdXQoKSB7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKTtcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuaXRlbXMuYWRkKG5ldyBGaWxlKFsnaGVsbG8gd29ybGQnXSwgJ1RoaXNfV29ya3MudHh0JykpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcbiAgICAgICAgICAgICAgICBlbC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgICAgICAgICByZXMgPSBlbC5maWxlcy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICB2YXIgSVRFTV9FUlJPUiA9IFtcbiAgICAgICAgSXRlbVN0YXR1cy5MT0FEX0VSUk9SLFxuICAgICAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1IsXG4gICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IsXG4gICAgXTtcblxuICAgIHZhciBJVEVNX0JVU1kgPSBbXG4gICAgICAgIEl0ZW1TdGF0dXMuTE9BRElORyxcbiAgICAgICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HLFxuICAgICAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVELFxuICAgICAgICBJdGVtU3RhdHVzLklOSVQsXG4gICAgXTtcblxuICAgIHZhciBJVEVNX1JFQURZID0gW0l0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURV07XG5cbiAgICB2YXIgaXNJdGVtSW5FcnJvclN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5FcnJvclN0YXRlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIElURU1fRVJST1IuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICAgIH07XG4gICAgdmFyIGlzSXRlbUluQnVzeVN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5CdXN5U3RhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gSVRFTV9CVVNZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgICB9O1xuICAgIHZhciBpc0l0ZW1JblJlYWR5U3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JblJlYWR5U3RhdGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gSVRFTV9SRUFEWS5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gICAgfTtcblxuICAgIHZhciBpc0FzeW5jID0gZnVuY3Rpb24gaXNBc3luYyhzdGF0ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIpICYmXG4gICAgICAgICAgICAoaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIucHJvY2VzcykgfHwgaXNGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJpZXMgPSBmdW5jdGlvbiBxdWVyaWVzKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBHRVRfU1RBVFVTOiBmdW5jdGlvbiBHRVRfU1RBVFVTKCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgICAgICAgICB2YXIgRU1QVFkgPSBTdGF0dXMuRU1QVFksXG4gICAgICAgICAgICAgICAgICAgIEVSUk9SID0gU3RhdHVzLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICBCVVNZID0gU3RhdHVzLkJVU1ksXG4gICAgICAgICAgICAgICAgICAgIElETEUgPSBTdGF0dXMuSURMRSxcbiAgICAgICAgICAgICAgICAgICAgUkVBRFkgPSBTdGF0dXMuUkVBRFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkVycm9yU3RhdGUpKSByZXR1cm4gRVJST1I7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkJ1c3lTdGF0ZSkpIHJldHVybiBCVVNZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zLnNvbWUoaXNJdGVtSW5SZWFkeVN0YXRlKSkgcmV0dXJuIFJFQURZO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIElETEU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfSVRFTTogZnVuY3Rpb24gR0VUX0lURU0ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9BQ1RJVkVfSVRFTTogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEl0ZW1CeVF1ZXJ5KGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSwgcXVlcnkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0FDVElWRV9JVEVNUzogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNUygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1TOiBmdW5jdGlvbiBHRVRfSVRFTVMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLml0ZW1zO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1fTkFNRTogZnVuY3Rpb24gR0VUX0lURU1fTkFNRShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZW5hbWUgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1fU0laRTogZnVuY3Rpb24gR0VUX0lURU1fU0laRShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZVNpemUgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX1NUWUxFUzogZnVuY3Rpb24gR0VUX1NUWUxFUygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGUub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvXnN0eWxlLy50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdGUub3B0aW9uc1tvcHRpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBHRVRfUEFORUxfQVNQRUNUX1JBVElPOiBmdW5jdGlvbiBHRVRfUEFORUxfQVNQRUNUX1JBVElPKCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1NoYXBlQ2lyY2xlID0gL2NpcmNsZS8udGVzdChzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxMYXlvdXQpO1xuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGlzU2hhcGVDaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyhzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxBc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPOiBmdW5jdGlvbiBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnMuc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9JVEVNU19CWV9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9JVEVNU19CWV9TVEFUVVMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zdGF0dXMgPT09IHN0YXR1cztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9UT1RBTF9JVEVNUzogZnVuY3Rpb24gR0VUX1RPVEFMX0lURU1TKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUOiBmdW5jdGlvbiBTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnMuc3RvcmVBc0ZpbGUgJiYgY2FuVXBkYXRlRmlsZUlucHV0KCkgJiYgIWlzQXN5bmMoc3RhdGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgSVNfQVNZTkM6IGZ1bmN0aW9uIElTX0FTWU5DKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FzeW5jKHN0YXRlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEdFVF9GSUxFX1NJWkVfTEFCRUxTOiBmdW5jdGlvbiBHRVRfRklMRV9TSVpFX0xBQkVMUyhxdWVyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsQnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0JZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEtpbG9ieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfS0lMT0JZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbE1lZ2FieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfTUVHQUJZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEdpZ2FieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfR0lHQUJZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaGFzUm9vbUZvckl0ZW0gPSBmdW5jdGlvbiBoYXNSb29tRm9ySXRlbShzdGF0ZSkge1xuICAgICAgICB2YXIgY291bnQgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuXG4gICAgICAgIC8vIGlmIGNhbm5vdCBoYXZlIG11bHRpcGxlIGl0ZW1zLCB0byBhZGQgb25lIGl0ZW0gaXQgc2hvdWxkIGN1cnJlbnRseSBub3QgY29udGFpbiBpdGVtc1xuICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYWxsb3dzIG11bHRpcGxlIGl0ZW1zLCB3ZSBjaGVjayBpZiBhIG1heCBpdGVtIGNvdW50IGhhcyBiZWVuIHNldCwgaWYgbm90LCB0aGVyZSdzIG5vIGxpbWl0XG4gICAgICAgIHZhciBtYXhGaWxlQ291bnQgPSBzdGF0ZS5vcHRpb25zLm1heEZpbGVzO1xuICAgICAgICBpZiAobWF4RmlsZUNvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNvdW50IGlzIHNtYWxsZXIgdGhhbiB0aGUgbWF4IGNvdW50LCBpZiBzbywgYW5vdGhlciBmaWxlIGNhbiBzdGlsbCBiZSBhZGRlZFxuICAgICAgICBpZiAoY291bnQgPCBtYXhGaWxlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbW9yZSByb29tIGZvciBhbm90aGVyIGZpbGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgbGltaXQgPSBmdW5jdGlvbiBsaW1pdCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKG1heCwgdmFsdWUpLCBtaW4pO1xuICAgIH07XG5cbiAgICB2YXIgYXJyYXlJbnNlcnQgPSBmdW5jdGlvbiBhcnJheUluc2VydChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgICB9O1xuXG4gICAgdmFyIGluc2VydEl0ZW0gPSBmdW5jdGlvbiBpbnNlcnRJdGVtKGl0ZW1zLCBpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaXNFbXB0eShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpbmRleCBpcyB1bmRlZmluZWQsIGFwcGVuZFxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXQgdGhlIGluZGV4IHRvIHRoZSBzaXplIG9mIHRoZSBpdGVtcyBhcnJheVxuICAgICAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBpdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGFkZCBpdGVtIHRvIGFycmF5XG4gICAgICAgIGFycmF5SW5zZXJ0KGl0ZW1zLCBpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cbiAgICB2YXIgaXNCYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gaXNCYXNlNjREYXRhVVJJKHN0cikge1xuICAgICAgICByZXR1cm4gL15cXHMqZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16LV0rPVthLXowLTktXSspPyk/KDtiYXNlNjQpPywoW2EtejAtOSEkJicsKCkqKzs9XFwtLl9+OkBcXC8/JVxcc10qKVxccyokL2kudGVzdChcbiAgICAgICAgICAgIHN0clxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZW5hbWVGcm9tVVJMID0gZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAgICAgLnBvcCgpXG4gICAgICAgICAgICAuc3BsaXQoJz8nKVxuICAgICAgICAgICAgLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIHZhciBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUgPSBmdW5jdGlvbiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5zcGxpdCgnLicpLnBvcCgpO1xuICAgIH07XG5cbiAgICB2YXIgZ3Vlc3N0aW1hdGVFeHRlbnNpb24gPSBmdW5jdGlvbiBndWVzc3RpbWF0ZUV4dGVuc2lvbih0eXBlKSB7XG4gICAgICAgIC8vIGlmIG5vIGV4dGVuc2lvbiBzdXBwbGllZCwgZXhpdCBoZXJlXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBzdWJ0eXBlXG4gICAgICAgIHZhciBzdWJ0eXBlID0gdHlwZS5zcGxpdCgnLycpLnBvcCgpO1xuXG4gICAgICAgIC8vIGlzIHN2ZyBzdWJ0eXBlXG4gICAgICAgIGlmICgvc3ZnLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL3ppcHxjb21wcmVzc2VkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ppcCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL3BsYWluLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3R4dCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL21zd29yZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgdmFsaWQgc3VidHlwZVxuICAgICAgICBpZiAoL1thLXpdKy8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHVzZSBqcGcgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoc3VidHlwZSA9PT0gJ2pwZWcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdqcGcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXR1cm4gc3VidHlwZVxuICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIHZhciBsZWZ0UGFkID0gZnVuY3Rpb24gbGVmdFBhZCh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gICAgICAgIHJldHVybiAocGFkZGluZyArIHZhbHVlKS5zbGljZSgtcGFkZGluZy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGF0ZVN0cmluZyA9IGZ1bmN0aW9uIGdldERhdGVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBsZWZ0UGFkKGRhdGUuZ2V0TW9udGgoKSArIDEsICcwMCcpICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBsZWZ0UGFkKGRhdGUuZ2V0RGF0ZSgpLCAnMDAnKSArXG4gICAgICAgICAgICAnXycgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldEhvdXJzKCksICcwMCcpICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBsZWZ0UGFkKGRhdGUuZ2V0TWludXRlcygpLCAnMDAnKSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbGVmdFBhZChkYXRlLmdldFNlY29uZHMoKSwgJzAwJylcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVGcm9tQmxvYiA9IGZ1bmN0aW9uIGdldEZpbGVGcm9tQmxvYihibG9iLCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgICAgdmFyIGZpbGUgPVxuICAgICAgICAgICAgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBibG9iLnNsaWNlKDAsIGJsb2Iuc2l6ZSwgdHlwZSlcbiAgICAgICAgICAgICAgICA6IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xuICAgICAgICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIC8vIGNvcHkgcmVsYXRpdmUgcGF0aFxuICAgICAgICBpZiAoYmxvYi5fcmVsYXRpdmVQYXRoKSBmaWxlLl9yZWxhdGl2ZVBhdGggPSBibG9iLl9yZWxhdGl2ZVBhdGg7XG5cbiAgICAgICAgLy8gaWYgYmxvYiBoYXMgbmFtZSBwcm9wZXJ0eSwgdXNlIGFzIGZpbGVuYW1lIGlmIG5vIGZpbGVuYW1lIHN1cHBsaWVkXG4gICAgICAgIGlmICghaXNTdHJpbmcoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGdldERhdGVTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGZpbGVuYW1lIHN1cHBsaWVkIGJ1dCBubyBleHRlbnNpb24gYW5kIGZpbGVuYW1lIGhhcyBleHRlbnNpb25cbiAgICAgICAgaWYgKGZpbGVuYW1lICYmIGV4dGVuc2lvbiA9PT0gbnVsbCAmJiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiB8fCBndWVzc3RpbWF0ZUV4dGVuc2lvbihmaWxlLnR5cGUpO1xuICAgICAgICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWUgKyAoZXh0ZW5zaW9uID8gJy4nICsgZXh0ZW5zaW9uIDogJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5CbG9iQnVpbGRlciA9XG4gICAgICAgICAgICB3aW5kb3cuQmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgICAgIHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICB3aW5kb3cuTVNCbG9iQnVpbGRlcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVCbG9iID0gZnVuY3Rpb24gY3JlYXRlQmxvYihhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgICAgICAgdmFyIEJCID0gZ2V0QmxvYkJ1aWxkZXIoKTtcblxuICAgICAgICBpZiAoQkIpIHtcbiAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCQigpO1xuICAgICAgICAgICAgYmIuYXBwZW5kKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBiYi5nZXRCbG9iKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUgPSBmdW5jdGlvbiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoXG4gICAgICAgIGJ5dGVTdHJpbmcsXG4gICAgICAgIG1pbWVUeXBlXG4gICAgKSB7XG4gICAgICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJsb2IoYWIsIG1pbWVUeXBlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICAgICAgcmV0dXJuICgvXmRhdGE6KC4rKTsvLmV4ZWMoZGF0YVVSSSkgfHwgW10pWzFdIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkge1xuICAgICAgICAvLyBnZXQgZGF0YSBwYXJ0IG9mIHN0cmluZyAocmVtb3ZlIGRhdGE6aW1hZ2UvanBlZy4uLiwpXG4gICAgICAgIHZhciBkYXRhID0gZGF0YVVSSS5zcGxpdCgnLCcpWzFdO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgd2hpdGVzcGFjZSBhcyB0aGF0IGNhdXNlcyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IgaW4gSUVcbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSB7XG4gICAgICAgIHJldHVybiBhdG9iKGdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSkge1xuICAgICAgICB2YXIgbWltZVR5cGUgPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpO1xuICAgICAgICB2YXIgYnl0ZVN0cmluZyA9IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcblxuICAgICAgICByZXR1cm4gZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlKGJ5dGVTdHJpbmcsIG1pbWVUeXBlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJLCBmaWxlbmFtZSwgZXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBnZXRGaWxlRnJvbUJsb2IoZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpLCBmaWxlbmFtZSwgbnVsbCwgZXh0ZW5zaW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVOYW1lRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgLy8gdGVzdCBpZiBpcyBjb250ZW50IGRpc3Bvc2l0aW9uIGhlYWRlciwgaWYgbm90IGV4aXRcbiAgICAgICAgaWYgKCEvXmNvbnRlbnQtZGlzcG9zaXRpb246L2kudGVzdChoZWFkZXIpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWUgcGFydHNcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBoZWFkZXJcbiAgICAgICAgICAgIC5zcGxpdCgvZmlsZW5hbWU9fGZpbGVuYW1lXFwqPS4rJycvKVxuICAgICAgICAgICAgLnNwbGljZSgxKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbO1wiJ117MCwyfSQvZywgJycpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aCA/IGRlY29kZVVSSShtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVTaXplRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldEZpbGVTaXplRnJvbUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgaWYgKC9jb250ZW50LWxlbmd0aDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyLm1hdGNoKC9bMC05XSsvKVswXTtcbiAgICAgICAgICAgIHJldHVybiBzaXplID8gcGFyc2VJbnQoc2l6ZSwgMTApIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyID0gZnVuY3Rpb24gZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIGlmICgveC1jb250ZW50LXRyYW5zZmVyLWlkOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgICAgdmFyIGlkID0gKGhlYWRlci5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gaWQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMgPSBmdW5jdGlvbiBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcm93cyA9IGhlYWRlcnMuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSByb3dzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7XG4gICAgICAgICAgICAgICAgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0RmlsZU5hbWVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmlsZUxvYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVMb2FkZXIoZmV0Y2hGbikge1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFByb2dyZXNzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3M7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlcXVlc3QgJiYgc3RhdGUucmVxdWVzdC5hYm9ydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBsb2FkIHNvdXJjZVxuICAgICAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAgICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICB2YXIgc291cmNlID0gc3RhdGUuc291cmNlO1xuXG4gICAgICAgICAgICBhcGkuZmlyZSgnaW5pdCcsIHNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgRmlsZXNcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBibG9icywgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmxvYihzb3VyY2UsIHNvdXJjZS5uYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBiYXNlIDY0LCBzZXQgZGVmYXVsdCBuYW1lIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgZ2V0RmlsZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWFsIGFzIGlmIGlzIGV4dGVybmFsIFVSTCwgbGV0J3MgbG9hZCBpdCFcbiAgICAgICAgICAgICAgICBsb2FkVVJMKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZHMgYSB1cmxcbiAgICAgICAgdmFyIGxvYWRVUkwgPSBmdW5jdGlvbiBsb2FkVVJMKHVybCkge1xuICAgICAgICAgICAgLy8gaXMgcmVtb3RlIHVybCBhbmQgbm8gZmV0Y2ggbWV0aG9kIHN1cHBsaWVkXG4gICAgICAgICAgICBpZiAoIWZldGNoRm4pIHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IFwiQ2FuJ3QgbG9hZCBVUkxcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogNDAwLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgLy8gbG9hZCBmaWxlXG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gZmV0Y2hGbihcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHVybiBibG9iIHJlc3BvbnNlIGludG8gYSBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZ2V0RmlsZUZyb21CbG9iKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGhhcyByZWNlaXZlZCBibG9iLCB3ZSBnbyB3aXRoIGJsb2IsIGlmIG5vIHJlc3BvbnNlLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iID8gcmVzcG9uc2UgOiByZXNwb25zZSA/IHJlc3BvbnNlLmJvZHkgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3RlZCBzb21lIG1ldGEgZGF0YSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2l6ZSA9IHRvdGFsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHByb2dyZXNzLCB3ZSdyZSBub3QgZ29pbmcgdG8gZmlyZSBwcm9ncmVzcyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IGN1cnJlbnQgLyB0b3RhbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgc3RhdGUucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVpbmZvID0gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgPyByZXNwb25zZSA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ21ldGEnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0ZS5zaXplIHx8IGZpbGVpbmZvLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZWluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZmlsZWluZm8uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSBPYmplY3QuYXNzaWduKHt9LCBvbigpLCB7XG4gICAgICAgICAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRlLnNvdXJjZSA9IHNvdXJjZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLCAvLyBmaWxlIGxvYWQgcHJvZ3Jlc3NcbiAgICAgICAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgZmlsZSBsb2FkXG4gICAgICAgICAgICBsb2FkOiBsb2FkLCAvLyBzdGFydCBsb2FkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBpc0dldCA9IGZ1bmN0aW9uIGlzR2V0KG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gL0dFVHxIRUFELy50ZXN0KG1ldGhvZCk7XG4gICAgfTtcblxuICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KGRhdGEsIHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXBpID0ge1xuICAgICAgICAgICAgb25oZWFkZXJzOiBmdW5jdGlvbiBvbmhlYWRlcnMoKSB7fSxcbiAgICAgICAgICAgIG9ucHJvZ3Jlc3M6IGZ1bmN0aW9uIG9ucHJvZ3Jlc3MoKSB7fSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgICAgICBvbnRpbWVvdXQ6IGZ1bmN0aW9uIG9udGltZW91dCgpIHt9LFxuICAgICAgICAgICAgb25lcnJvcjogZnVuY3Rpb24gb25lcnJvcigpIHt9LFxuICAgICAgICAgICAgb25hYm9ydDogZnVuY3Rpb24gb25hYm9ydCgpIHt9LFxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aW1lb3V0IGlkZW50aWZpZXIsIG9ubHkgdXNlZCB3aGVuIHRpbWVvdXQgaXMgZGVmaW5lZFxuICAgICAgICB2YXIgYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGVhZGVyc1JlY2VpdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBlbmNvZGUgdXJsXG4gICAgICAgIHVybCA9IGVuY29kZVVSSSh1cmwpO1xuXG4gICAgICAgIC8vIGlmIG1ldGhvZCBpcyBHRVQsIGFkZCBhbnkgcmVjZWl2ZWQgZGF0YSB0byB1cmxcblxuICAgICAgICBpZiAoaXNHZXQob3B0aW9ucy5tZXRob2QpICYmIGRhdGEpIHtcbiAgICAgICAgICAgIHVybCA9XG4gICAgICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgICAgIHVybCArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgcmVxdWVzdFxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgLy8gcHJvZ3Jlc3Mgb2YgbG9hZFxuICAgICAgICB2YXIgcHJvY2VzcyA9IGlzR2V0KG9wdGlvbnMubWV0aG9kKSA/IHhociA6IHhoci51cGxvYWQ7XG4gICAgICAgIHByb2Nlc3Mub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIG5vIHByb2dyZXNzIGV2ZW50IHdoZW4gYWJvcnRlZCAoIG9ucHJvZ3Jlc3MgaXMgY2FsbGVkIG9uY2UgYWZ0ZXIgYWJvcnQoKSApXG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXBpLm9ucHJvZ3Jlc3MoZS5sZW5ndGhDb21wdXRhYmxlLCBlLmxvYWRlZCwgZS50b3RhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdHJpZXMgdG8gZ2V0IGhlYWRlciBpbmZvIHRvIHRoZSBhcHAgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBub3QgaW50ZXJlc3RpbmcgaW4gdGhlc2Ugc3RhdGVzICgndW5zZW50JyBhbmQgJ29wZW5lbmQnIGFzIHRoZXkgZG9uJ3QgZ2l2ZSB1cyBhbnkgYWRkaXRpb25hbCBpbmZvKVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gc2VydmVyIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVhZGVyc1JlY2VpdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gd2UndmUgcHJvYmFibHkgcmVjZWl2ZWQgc29tZSB1c2VmdWwgZGF0YSBpbiByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICBhcGkub25oZWFkZXJzKHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZCBzdWNjZXNzZnVsXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlzIGNsYXNzaWZpZWQgYXMgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgYXBpLm9ubG9hZCh4aHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcGkub25lcnJvcih4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGVycm9yIGR1cmluZyBsb2FkXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpLm9uZXJyb3IoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXF1ZXN0IGFib3J0ZWRcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXBpLm9uYWJvcnQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5vbnRpbWVvdXQoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBvcGVuIHVwIG9wZW4gdXAhXG4gICAgICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgICAgIC8vIHNldCB0aW1lb3V0IGlmIGRlZmluZWQgKGRvIGl0IGFmdGVyIG9wZW4gc28gSUUxMSBwbGF5cyBiYWxsKVxuICAgICAgICBpZiAoaXNJbnQob3B0aW9ucy50aW1lb3V0KSkge1xuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgaGVhZGVyc1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5oZWFkZXJzW2tleV0pKTtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgdHlwZSBvZiByZXNwb25zZVxuICAgICAgICBpZiAob3B0aW9ucy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjcmVkZW50aWFsc1xuICAgICAgICBpZiAob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0J3Mgc2VuZCBvdXIgZGF0YVxuICAgICAgICB4aHIuc2VuZChkYXRhKTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZSh0eXBlLCBjb2RlLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVGltZW91dFJlc3BvbnNlID0gZnVuY3Rpb24gY3JlYXRlVGltZW91dFJlc3BvbnNlKGNiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgIGNiKGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdUaW1lb3V0JywgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBoYXNRUyA9IGZ1bmN0aW9uIGhhc1FTKHN0cikge1xuICAgICAgICByZXR1cm4gL1xcPy8udGVzdChzdHIpO1xuICAgIH07XG4gICAgdmFyIGJ1aWxkVVJMID0gZnVuY3Rpb24gYnVpbGRVUkwoKSB7XG4gICAgICAgIHZhciB1cmwgPSAnJztcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgcGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICB1cmwgKz0gaGFzUVModXJsKSAmJiBoYXNRUyhwYXJ0KSA/IHBhcnQucmVwbGFjZSgvXFw/LywgJyYnKSA6IHBhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmV0Y2hGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUZldGNoRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcGlVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgaGVhZGVycykge1xuICAgICAgICAgICAgLy8gZG8gbG9jYWwgb3IgcmVtb3RlIHJlcXVlc3QgYmFzZWQgb24gaWYgdGhlIHVybCBpcyBleHRlcm5hbFxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYicsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5tZXRob2QgPT09ICdIRUFEJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0RmlsZUZyb21CbG9iKG9ubG9hZCh4aHIucmVzcG9uc2UpLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMoY3JlYXRlUmVzcG9uc2UoJ2hlYWRlcnMnLCB4aHIuc3RhdHVzLCBudWxsLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBDaHVua1N0YXR1cyA9IHtcbiAgICAgICAgUVVFVUVEOiAwLFxuICAgICAgICBDT01QTEVURTogMSxcbiAgICAgICAgUFJPQ0VTU0lORzogMixcbiAgICAgICAgRVJST1I6IDMsXG4gICAgICAgIFdBSVRJTkc6IDQsXG4gICAgfTtcblxuICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDooKSA9PiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgLy8gYXBpVXJsLCBhY3Rpb24sIG5hbWUsIGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9uc1xuICAgIHZhciBwcm9jZXNzRmlsZUNodW5rZWQgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZUNodW5rZWQoXG4gICAgICAgIGFwaVVybCxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBuYW1lLFxuICAgICAgICBmaWxlLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbG9hZCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHByb2dyZXNzLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdHJhbnNmZXIsXG4gICAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgLy8gYWxsIGNodW5rc1xuICAgICAgICB2YXIgY2h1bmtzID0gW107XG4gICAgICAgIHZhciBjaHVua1RyYW5zZmVySWQgPSBvcHRpb25zLmNodW5rVHJhbnNmZXJJZCxcbiAgICAgICAgICAgIGNodW5rU2VydmVyID0gb3B0aW9ucy5jaHVua1NlcnZlcixcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgICAgICAgY2h1bmtSZXRyeURlbGF5cyA9IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cztcblxuICAgICAgICAvLyBkZWZhdWx0IHN0YXRlXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlcnZlcklkOiBjaHVua1RyYW5zZmVySWQsXG4gICAgICAgICAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgb25sb2FkIGhhbmRsZXJzXG4gICAgICAgIHZhciBvbmRhdGEgPVxuICAgICAgICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHhociwgbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCA9PT0gJ0hFQUQnID8geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdVcGxvYWQtT2Zmc2V0JykgOiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzZXJ2ZXIgaG9va1xuICAgICAgICB2YXIgcmVxdWVzdFRyYW5zZmVySWQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJJZChjYikge1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICAgICAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG9uZGF0YShmb3JtRGF0YSksXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXF1ZXN0VHJhbnNmZXJPZmZzZXQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJPZmZzZXQoY2IpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKHN0YXRlLnNlcnZlcklkKVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbi5oZWFkZXJzKTtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgcmVxdWVzdFVybCwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG9ubG9hZCh4aHIsIHJlcXVlc3RQYXJhbXMubWV0aG9kKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3JlYXRlIGNodW5rc1xuICAgICAgICB2YXIgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxhc3RDaHVua0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBmaWxlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtTaXplLCAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpO1xuICAgICAgICAgICAgY2h1bmtzW2ldID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICAgICAgcmV0cmllczogX3RvQ29uc3VtYWJsZUFycmF5KGNodW5rUmV0cnlEZWxheXMpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogQ2h1bmtTdGF0dXMuUVVFVUVELFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzID0gZnVuY3Rpb24gY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWQoc3RhdGUuc2VydmVySWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjYW5Qcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiBjYW5Qcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlFVRVVFRCB8fCBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiBwcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3NpbmcgaXMgcGF1c2VkLCB3YWl0IGhlcmVcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGdldCBuZXh0IGNodW5rIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsgfHwgY2h1bmtzLmZpbmQoY2FuUHJvY2Vzc0NodW5rKTtcblxuICAgICAgICAgICAgLy8gbm8gbW9yZSBjaHVua3MgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lP1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmV2ZXJ5KGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm8gY2h1bmsgdG8gaGFuZGxlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgcHJvY2Vzc2luZyB0aGlzIGNodW5rXG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HO1xuICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyBwYXJzaW5nIG9mIGZvcm1kYXRhXG4gICAgICAgICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5vbmRhdGEgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlci5vbmVycm9yIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaHVua1NlcnZlci5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gY2h1bmtTZXJ2ZXIuaGVhZGVycyhjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBjaHVua1NlcnZlci5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogY2h1bmsub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VwbG9hZC1OYW1lJzogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IChjaHVuay5yZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgb25kYXRhKGNodW5rLmRhdGEpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY2h1bmtTZXJ2ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZXF1ZXN0IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyBtb3JlIGNodW5rc1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGxlbmd0aENvbXB1dGFibGUsIGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGxlbmd0aENvbXB1dGFibGUgPyBsb2FkZWQgOiBudWxsO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNodW5rLmVycm9yID0gb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcikoeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5RVUVVRUQ7XG4gICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJldHJ5UHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIG5vIG1vcmUgcmV0cmllcyBsZWZ0XG4gICAgICAgICAgICBpZiAoY2h1bmsucmV0cmllcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gbmV3IHJldHJ5XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5XQUlUSU5HO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICAgICAgY2h1bmsudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICAgICAgICAgIH0sIGNodW5rLnJldHJpZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHJldHJ5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlVG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MgZnJhY3Rpb25cbiAgICAgICAgICAgIHZhciB0b3RhbEJ5dGVzVHJhbnNmZXJlZCA9IGNodW5rcy5yZWR1Y2UoZnVuY3Rpb24ocCwgY2h1bmspIHtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gbnVsbCB8fCBjaHVuay5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyBjaHVuay5wcm9ncmVzcztcbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAvLyBjYW4ndCBjb21wdXRlIHByb2dyZXNzXG4gICAgICAgICAgICBpZiAodG90YWxCeXRlc1RyYW5zZmVyZWQgPT09IG51bGwpIHJldHVybiBwcm9ncmVzcyhmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwcm9ncmVzcyB2YWx1ZXNcbiAgICAgICAgICAgIHZhciB0b3RhbFNpemUgPSBjaHVua3MucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBjaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCArIGNodW5rLnNpemU7XG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgLy8gY2FuIHVwZGF0ZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgICAgIHByb2dyZXNzKHRydWUsIHRvdGFsQnl0ZXNUcmFuc2ZlcmVkLCB0b3RhbFNpemUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByb2Nlc3MgbmV3IGNodW5rc1xuICAgICAgICB2YXIgcHJvY2Vzc0NodW5rcyA9IGZ1bmN0aW9uIHByb2Nlc3NDaHVua3MoKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxQcm9jZXNzaW5nID0gY2h1bmtzLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG90YWxQcm9jZXNzaW5nID49IDEpIHJldHVybjtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydENodW5rcyA9IGZ1bmN0aW9uIGFib3J0Q2h1bmtzKCkge1xuICAgICAgICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmsudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICBpZiAoIXN0YXRlLnNlcnZlcklkKSB7XG4gICAgICAgICAgICByZXF1ZXN0VHJhbnNmZXJJZChmdW5jdGlvbihzZXJ2ZXJJZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFzcyBiYWNrIHRvIGl0ZW0gc28gd2UgY2FuIHVzZSBpdCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyKHNlcnZlcklkKTtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIGludGVybmFsbHlcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJJZCA9IHNlcnZlcklkO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbWFyayBjaHVua3Mgd2l0aCBsb3dlciBvZmZzZXQgYXMgY29tcGxldGVcbiAgICAgICAgICAgICAgICBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLm9mZnNldCA8IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBjaHVuay5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWJvcnRDaHVua3MoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQ6KCkgPT4ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICB2YXIgY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKFxuICAgICAgICBhcGlVcmwsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyKSB7XG4gICAgICAgICAgICAvLyBubyBmaWxlIHJlY2VpdmVkXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gaWYgd2FzIHBhc3NlZCBhIGZpbGUsIGFuZCB3ZSBjYW4gY2h1bmsgaXQsIGV4aXQgaGVyZVxuICAgICAgICAgICAgdmFyIGNhbkNodW5rVXBsb2FkID0gb3B0aW9ucy5jaHVua1VwbG9hZHM7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiBmaWxlLnNpemUgPiBvcHRpb25zLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciB3aWxsQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiAoc2hvdWxkQ2h1bmtVcGxvYWQgfHwgb3B0aW9ucy5jaHVua0ZvcmNlKTtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYiAmJiB3aWxsQ2h1bmtVcGxvYWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NGaWxlQ2h1bmtlZChcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBsb2FkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlcixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHNldCBoYW5kbGVyc1xuICAgICAgICAgICAgdmFyIG9uZGF0YSA9XG4gICAgICAgICAgICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgICAgICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKGZpbGUsIG1ldGFkYXRhKSB8fCB7fVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBmb3JtZGF0YSBvYmplY3RcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFR1cm4gaW50byBhbiBhcnJheSBvZiBvYmplY3RzIHNvIG5vIG1hdHRlciB3aGF0IHRoZSBpbnB1dCwgd2UgY2FuIGhhbmRsZSBpdCB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgIChmaWxlIGluc3RhbmNlb2YgQmxvYiA/IFt7IG5hbWU6IG51bGwsIGZpbGU6IGZpbGUgfV0gOiBmaWxlKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5uYW1lID09PSBudWxsID8gaXRlbS5maWxlLm5hbWUgOiAnJyArIGl0ZW0ubmFtZSArIGl0ZW0uZmlsZS5uYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIG9uZGF0YShmb3JtRGF0YSksXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcGlVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gY3VzdG9tIGhhbmRsZXIgKHNob3VsZCBhbHNvIGhhbmRsZSBmaWxlLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MgYW5kIGFib3J0KVxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHZvaWQgMCwgW25hbWVdLmNvbmNhdChwYXJhbXMsIFtvcHRpb25zXSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBpbnRlcm5hbCBoYW5kbGVyXG4gICAgICAgIHJldHVybiBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24oYXBpVXJsLCBhY3Rpb24sIG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICB2YXIgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVSZXZlcnRGdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFwaVVybCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gaXMgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkLCByZXR1cm4gc3R1YiBmdW5jdGlvbiwgaW50ZXJmYWNlIHdpbGwgd29yaywgYnV0IGZpbGUgd29uJ3QgYmUgcmVtb3ZlZFxuICAgICAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih1bmlxdWVGaWxlSWQsIGxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgICAgICB2YXIgb25sb2FkID1cbiAgICAgICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIGludGVybmFsIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih1bmlxdWVGaWxlSWQsIGxvYWQsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIHVuaXF1ZUZpbGVJZCxcbiAgICAgICAgICAgICAgICBhcGlVcmwgKyBhY3Rpb24udXJsLFxuICAgICAgICAgICAgICAgIGFjdGlvbiAvLyBjb250YWlucyBtZXRob2QsIGhlYWRlcnMgYW5kIHdpdGhDcmVkZW50aWFscyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFJhbmRvbU51bWJlciA9IGZ1bmN0aW9uIGdldFJhbmRvbU51bWJlcigpIHtcbiAgICAgICAgdmFyIG1pbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIG1heCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgICAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGZ1bmN0aW9uIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihjYikge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciB0aWNrTWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAyNTtcbiAgICAgICAgdmFyIHRpY2tNYXggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDI1MDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gZ2V0UmFuZG9tTnVtYmVyKHRpY2tNaW4sIHRpY2tNYXgpO1xuXG4gICAgICAgICAgICBpZiAocnVudGltZSArIGRlbGF5ID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkZWxheSA9IHJ1bnRpbWUgKyBkZWxheSAtIGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBydW50aW1lIC8gZHVyYXRpb247XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMSB8fCBkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjYigxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNiKHByb2dyZXNzKTtcblxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQodGljaywgZGVsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHRpY2soKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVGaWxlUHJvY2Vzc29yID0gZnVuY3Rpb24gY3JlYXRlRmlsZVByb2Nlc3Nvcihwcm9jZXNzRm4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgcGVyY2VpdmVkUHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICBwZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXI6IG51bGwsXG4gICAgICAgICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgIHBlcmNlaXZlZER1cmF0aW9uOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICAgICAgcmVzcG9uc2U6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiA9IG9wdGlvbnMuYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb247XG5cbiAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGZpbGUsIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NGbiA9IGZ1bmN0aW9uIHByb2dyZXNzRm4oKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgbm90IHlldCBzdGFydGVkIHRoZSByZWFsIGRvd25sb2FkLCBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBtaWdodCBub3QgZ28gdGhyb3VnaCwgZm9yIGluc3RhbmNlLCB0aGVyZSBtaWdodCBiZSBzb21lIHNlcnZlciB0cm91YmxlXG4gICAgICAgICAgICAgICAgLy8gaWYgc3RhdGUucHJvZ3Jlc3MgaXMgbnVsbCwgdGhlIHNlcnZlciBkb2VzIG5vdCBhbGxvdyBjb21wdXRpbmcgcHJvZ3Jlc3MgYW5kIHdlIHNob3cgdGhlIHNwaW5uZXIgaW5zdGVhZFxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5kdXJhdGlvbiA9PT0gMCB8fCBzdGF0ZS5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UncmUgbm93IHByb2Nlc3NpbmcsIGZpcmUgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgYXBpLmdldFByb2dyZXNzKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlRm4gPSBmdW5jdGlvbiBjb21wbGV0ZUZuKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbG9hZC1wZXJjZWl2ZWQnLCBzdGF0ZS5yZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGxldCdzIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGFwaS5maXJlKCdzdGFydCcpO1xuXG4gICAgICAgICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHBlcmNlaXZlZCBwZXJmb3JtYW5jZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NGbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZha2UgcHJvZ3Jlc3MgaXMgZG9uZSwgYW5kIGEgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSd2ZSBub3QgeWV0IGNhbGxlZCB0aGUgY29tcGxldGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZXNwb25zZSAmJiBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9PT0gMSAmJiAhc3RhdGUuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHJhbmRvbSBkZWxheSBhcyBpbiBhIGxpc3Qgb2YgZmlsZXMgeW91IHN0YXJ0IG5vdGljaW5nXG4gICAgICAgICAgICAgICAgLy8gZmlsZXMgdXBsb2FkaW5nIGF0IHRoZSBleGFjdCBzYW1lIHNwZWVkXG4gICAgICAgICAgICAgICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gPyBnZXRSYW5kb21OdW1iZXIoNzUwLCAxNTAwKSA6IDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHJlcXVlc3Qgc28gd2UgY2FuIGFib3J0IGl0IGxhdGVyXG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gcHJvY2Vzc0ZuKFxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaWxlIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICBmaWxlLFxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1ldGFkYXRhIHRvIHNlbmQgYWxvbmdcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcblxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrcyAobG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIpXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBleHBlY3RzIHRoZSBib2R5IHRvIGJlIGEgc2VydmVyIGlkIGlmXG4gICAgICAgICAgICAgICAgLy8geW91IHdhbnQgdG8gbWFrZSB1c2Ugb2YgcmV2ZXJ0XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgcHV0IHRoZSByZXNwb25zZSBpbiBzdGF0ZSBzbyB3ZSBjYW4gYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IG91dHNpZGUgb2YgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBpc09iamVjdChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJycgKyByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgcHJvZ3Jlc3MgdG8gMSBhcyB3ZSdyZSBub3cgZG9uZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsIGxvYWQgaXMgZG9uZSBsZXQncyBzaGFyZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHJlYWxseSBkb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHBlcmNlaXZlZCBwcm9ncmVzcyBpcyAxICggd2FpdCBmb3IgcGVyY2VpdmVkIHByb2dyZXNzIHRvIGNvbXBsZXRlIClcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcHJvZ3Jlc3MgKCBudWxsIClcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIWFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gJiYgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIGVycm9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIHR5cGUsIGNvZGUsIGJvZHlcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWwgdXBkYXRlclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb3RoZXJzIGFib3V0IHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAnJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBhY3R1YWwgcHJvY2Vzc2luZyBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjb21wdXRhYmxlID8gY3VycmVudCAvIHRvdGFsIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIGFib3J0IGRvZXMgbm90IGV4cGVjdCBhIHZhbHVlXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIHRoZSBhYm9ydCBldmVudCBzbyB3ZSBjYW4gc3dpdGNoIHZpc3VhbHNcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2Fib3J0Jywgc3RhdGUucmVzcG9uc2UgPyBzdGF0ZS5yZXNwb25zZS5ib2R5IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpZCBmb3IgdGhpcyB0cmFuc2ZlclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHRyYW5zZmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgIC8vIG5vIHJlcXVlc3QgcnVubmluZywgY2FuJ3QgYWJvcnRcbiAgICAgICAgICAgIGlmICghc3RhdGUucmVxdWVzdCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBhYm9ydCBhY3R1YWwgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHN0YXRlLnJlcXVlc3QuYWJvcnQpIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcblxuICAgICAgICAgICAgLy8gaWYgaGFzIHJlc3BvbnNlIG9iamVjdCwgd2UndmUgY29tcGxldGVkIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0UHJvZ3Jlc3MgPSBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvblxuICAgICAgICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5wcm9ncmVzcyA/IE1hdGgubWluKHN0YXRlLnByb2dyZXNzLCBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcykgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzIHx8IG51bGw7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldER1cmF0aW9uID0gYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb25cbiAgICAgICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oc3RhdGUuZHVyYXRpb24sIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbih7fSwgb24oKSwge1xuICAgICAgICAgICAgcHJvY2VzczogcHJvY2VzcywgLy8gc3RhcnQgcHJvY2Vzc2luZyBmaWxlXG4gICAgICAgICAgICBhYm9ydDogYWJvcnQsIC8vIGFib3J0IGFjdGl2ZSBwcm9jZXNzIHJlcXVlc3RcbiAgICAgICAgICAgIGdldFByb2dyZXNzOiBnZXRQcm9ncmVzcyxcbiAgICAgICAgICAgIGdldER1cmF0aW9uOiBnZXREdXJhdGlvbixcbiAgICAgICAgICAgIHJlc2V0OiByZXNldCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVGaWxlU3R1YiA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVTdHViKHNvdXJjZSkge1xuICAgICAgICB2YXIgZGF0YSA9IFtzb3VyY2UubmFtZSwgc291cmNlLnNpemUsIHNvdXJjZS50eXBlXTtcblxuICAgICAgICAvLyBpcyBibG9iIG9yIGJhc2U2NCwgdGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgbmFtZVxuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYiB8fCBpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgZGF0YVswXSA9IHNvdXJjZS5uYW1lIHx8IGdldERhdGVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgLy8gaWYgaXMgYmFzZTY0IGRhdGEgdXJpIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgYW5kIHR5cGVcbiAgICAgICAgICAgIGRhdGFbMV0gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YVsyXSA9IGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgICAgICAgICAvLyB1cmxcbiAgICAgICAgICAgIGRhdGFbMF0gPSBnZXRGaWxlbmFtZUZyb21VUkwoc291cmNlKTtcbiAgICAgICAgICAgIGRhdGFbMV0gPSAwO1xuICAgICAgICAgICAgZGF0YVsyXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICAgICAgICBzaXplOiBkYXRhWzFdLFxuICAgICAgICAgICAgdHlwZTogZGF0YVsyXSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgaW5zdGFuY2VvZiBGaWxlIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgdmFsdWUubmFtZSkpO1xuICAgIH07XG5cbiAgICB2YXIgZGVlcENsb25lT2JqZWN0ID0gZnVuY3Rpb24gZGVlcENsb25lT2JqZWN0KHNyYykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHNyYykpIHJldHVybiBzcmM7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpc0FycmF5KHNyYykgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2ID0gc3JjW2tleV07XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHYgJiYgaXNPYmplY3QodikgPyBkZWVwQ2xvbmVPYmplY3QodikgOiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJdGVtID0gZnVuY3Rpb24gY3JlYXRlSXRlbSgpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgdmFyIHNlcnZlckZpbGVSZWZlcmVuY2UgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIGl0ZW0sIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGl0ZW0gYWNyb3NzIHZpZXdzXG4gICAgICAgIHZhciBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGl0ZW0gc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIC8vIGlzIGFyY2hpdmVkXG4gICAgICAgICAgICBhcmNoaXZlZDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIGlmIGlzIGZyb3plbiwgbm8gbG9uZ2VyIGZpcmVzIGV2ZW50c1xuICAgICAgICAgICAgZnJvemVuOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHZpZXdcbiAgICAgICAgICAgIHJlbGVhc2VkOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIGZpbGUgbW9kZWwgcmVmZXJlbmNlXG4gICAgICAgICAgICBmaWxlOiBmaWxlLFxuXG4gICAgICAgICAgICAvLyBpZCBvZiBmaWxlIG9uIHNlcnZlclxuICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogc2VydmVyRmlsZVJlZmVyZW5jZSxcblxuICAgICAgICAgICAgLy8gaWQgb2YgZmlsZSB0cmFuc2ZlciBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIHRyYW5zZmVySWQ6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIGlzIGFib3J0ZWRcbiAgICAgICAgICAgIHByb2Nlc3NpbmdBYm9ydGVkOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVtIHN0YXR1c1xuICAgICAgICAgICAgc3RhdHVzOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlID8gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIDogSXRlbVN0YXR1cy5JTklULFxuXG4gICAgICAgICAgICAvLyBhY3RpdmUgcHJvY2Vzc2VzXG4gICAgICAgICAgICBhY3RpdmVMb2FkZXI6IG51bGwsXG4gICAgICAgICAgICBhY3RpdmVQcm9jZXNzb3I6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgdXNlZCB3aGVuIGFib3J0IHByb2Nlc3NpbmcgaXMgY2FsbGVkIHRvIGxpbmsgYmFjayB0byB0aGUgcmVzb2x2ZSBtZXRob2RcbiAgICAgICAgdmFyIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVybmFsbHkgYWRkZWQgaXRlbSBtZXRhZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG5cbiAgICAgICAgLy8gaXRlbSBkYXRhXG4gICAgICAgIHZhciBzZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHN0YXRlLnN0YXR1cyA9IHN0YXR1cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmlyZSBldmVudCB1bmxlc3MgdGhlIGl0ZW0gaGFzIGJlZW4gYXJjaGl2ZWRcbiAgICAgICAgdmFyIGZpcmUgPSBmdW5jdGlvbiBmaXJlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucmVsZWFzZWQgfHwgc3RhdGUuZnJvemVuKSByZXR1cm47XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBpLmZpcmUuYXBwbHkoYXBpLCBbZXZlbnRdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaWxlIGRhdGFcbiAgICAgICAgdmFyIGdldEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlRXh0ZW5zaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShzdGF0ZS5maWxlLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0RmlsZVR5cGUgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLnR5cGU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRGaWxlU2l6ZSA9IGZ1bmN0aW9uIGdldEZpbGVTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGUuc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9naWMgdG8gbG9hZCBhIGZpbGVcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKHNvdXJjZSwgbG9hZGVyLCBvbmxvYWQpIHtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpdGVtIHNvdXJjZVxuICAgICAgICAgICAgc3RhdGUuc291cmNlID0gc291cmNlO1xuXG4gICAgICAgICAgICAvLyBzb3VyY2UgaXMga25vd25cbiAgICAgICAgICAgIGFwaS5maXJlU3luYygnaW5pdCcpO1xuXG4gICAgICAgICAgICAvLyBmaWxlIHN0dWIgaXMgYWxyZWFkeSB0aGVyZVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZpbGUpIHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZVN5bmMoJ2xvYWQtc2tpcCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGEgc3R1YiBmaWxlIG9iamVjdCB3aGlsZSBsb2FkaW5nIHRoZSBhY3R1YWwgZGF0YVxuICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGNyZWF0ZUZpbGVTdHViKHNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0cyBsb2FkaW5nXG4gICAgICAgICAgICBsb2FkZXIub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWluaXQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3ZSdldmUgcmVjZWl2ZWQgYSBzaXplIGluZGljYXRpb24sIGxldCdzIHVwZGF0ZSB0aGUgc3R1YlxuICAgICAgICAgICAgbG9hZGVyLm9uKCdtZXRhJywgZnVuY3Rpb24obWV0YSkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBzaXplIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgICAgIHN0YXRlLmZpbGUuc2l6ZSA9IG1ldGEuc2l6ZTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBuYW1lIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgICAgIHN0YXRlLmZpbGUuZmlsZW5hbWUgPSBtZXRhLmZpbGVuYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaGFzIHJlY2VpdmVkIHNvdXJjZSwgd2UgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChtZXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gbWV0YS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA9IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzaXplIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB0aGUgZmlsZSBpcyBub3cgbG9hZGluZyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgICAgICAgbG9hZGVyLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRElORyk7XG5cbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGFuIGVycm9yIHdhcyB0aHJvd24gd2hpbGUgbG9hZGluZyB0aGUgZmlsZSwgd2UgbmVlZCB0byBzd2l0Y2ggdG8gZXJyb3Igc3RhdGVcbiAgICAgICAgICAgIGxvYWRlci5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuXG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1yZXF1ZXN0LWVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVzZXIgb3IgYW5vdGhlciBwcm9jZXNzIGFib3J0ZWQgdGhlIGZpbGUgbG9hZCAoY2Fubm90IHJldHJ5KVxuICAgICAgICAgICAgbG9hZGVyLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklOSVQpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBkb25lIGxvYWRpbmdcbiAgICAgICAgICAgIGxvYWRlci5vbignbG9hZCcsIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBhcyB3ZSd2ZSBub3cgbG9hZGVkIHRoZSBmaWxlIHRoZSBsb2FkZXIgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNmdWxseVxuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gc3VjY2VzcyhyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IChwb3NzaWJseSkgdHJhbnNmb3JtZWQgZmlsZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlID0gaXNGaWxlKHJlc3VsdCkgPyByZXN1bHQgOiBzdGF0ZS5maWxlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTyAmJiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmlyZSgnbG9hZCcpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG9yaWdpbmFsIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtbWV0YScpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWZpbGUtZXJyb3InLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzZXJ2ZXIgZmlsZSByZWZlcmVuY2UsIHdlIGRvbid0IG5lZWQgdG8gY2FsbCB0aGUgb25sb2FkIG1ldGhvZFxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBubyBzZXJ2ZXIgaWQsIGxldCdzIGdpdmUgdGhpcyBmaWxlIHRoZSBmdWxsIHRyZWF0bWVudFxuICAgICAgICAgICAgICAgIG9ubG9hZChmaWxlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc2V0IGxvYWRlciBzb3VyY2UgZGF0YVxuICAgICAgICAgICAgbG9hZGVyLnNldFNvdXJjZShzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBzZXQgYXMgYWN0aXZlIGxvYWRlclxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbG9hZGVyO1xuXG4gICAgICAgICAgICAvLyBsb2FkIHRoZSBzb3VyY2UgZGF0YVxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmV0cnlMb2FkID0gZnVuY3Rpb24gcmV0cnlMb2FkKCkge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5hY3RpdmVMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydExvYWQgPSBmdW5jdGlvbiBhYm9ydExvYWQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgICAgICBmaXJlKCdsb2FkLWFib3J0Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9naWMgdG8gcHJvY2VzcyBhIGZpbGVcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHdhcyBhYm9ydGVkXG4gICAgICAgICAgICBpZiAoc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkcpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBhYm9ydCBjYWxsYmFja1xuICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gaWYgbm8gZmlsZSBsb2FkZWQgd2UnbGwgd2FpdCBmb3IgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgIGlmICghKHN0YXRlLmZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICAgIGFwaS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldHVwIHByb2Nlc3NvclxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdsb2FkJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdHJhbnNmZXIgaWRcbiAgICAgICAgICAgIHByb2Nlc3Nvci5vbigndHJhbnNmZXInLCBmdW5jdGlvbih0cmFuc2ZlcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gdHJhbnNmZXJJZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ2xvYWQtcGVyY2VpdmVkJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlciB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWNvbXBsZXRlJywgc2VydmVyRmlsZVJlZmVyZW5jZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3Mtc3RhcnQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1IpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzc29yLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgZmlsZSB3YXMgdXBsb2FkZWQgYnV0IHByb2Nlc3Npbmcgd2FzIGNhbmNlbGxlZCBkdXJpbmcgcGVyY2VpdmVkIHByb2Nlc3NvciB0aW1lIHN0b3JlIGZpbGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWFib3J0Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBoYXMgdGltZW91dCBzbyBkb2Vzbid0IGludGVyZmVyZSB3aXRoIHJlbW92ZSBhY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9jZXNzb3Iub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHdoZW4gc3VjY2Vzc2Z1bGx5IHRyYW5zZm9ybWVkXG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdhcyBhcmNoaXZlZCBpbiB0aGUgbWVhbiB0aW1lLCBkb24ndCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFyY2hpdmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGZpbGUhXG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3MoZmlsZSwgT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0cmFuc2Zvcm0gcGhhc2VcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGNvbnNvbGUuZXJyb3I7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGZpbGVcbiAgICAgICAgICAgIG9ucHJvY2VzcyhzdGF0ZS5maWxlLCBzdWNjZXNzLCBlcnJvcik7XG5cbiAgICAgICAgICAgIC8vIHNldCBhcyBhY3RpdmUgcHJvY2Vzc29yXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcXVlc3RQcm9jZXNzaW5nID0gZnVuY3Rpb24gcmVxdWVzdFByb2Nlc3NpbmcoKSB7XG4gICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhYm9ydFByb2Nlc3NpbmcgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuYWN0aXZlUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1hYm9ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGxvZ2ljIHRvIHJldmVydCBhIHByb2Nlc3NlZCBmaWxlXG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQocmV2ZXJ0RmlsZVVwbG9hZCwgZm9yY2VSZXZlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBhIGNvbXBsZXRlZCB1cGxvYWQgd2lsbCBoYXZlIGEgc2VydmVyRmlsZVJlZmVyZW5jZSwgYSBmYWlsZWQgY2h1bmtlZCB1cGxvYWQgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyBnZXR0aW5nIGEgc2VydmVySWQgc3VjY2VlZGVkIGJ1dCA+PTAgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCB3aWxsIGhhdmUgdHJhbnNmZXJJZCBzZXRcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyVHJhbnNmZXJJZCA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGF0ZS50cmFuc2ZlcklkO1xuXG4gICAgICAgICAgICAgICAgLy8gY2Fubm90IHJldmVydCB3aXRob3V0IGEgc2VydmVyIGlkIGZvciB0aGlzIHByb2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyVHJhbnNmZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZXZlcnQgdGhlIHVwbG9hZCAoZmlyZSBhbmQgZm9yZ2V0KVxuICAgICAgICAgICAgICAgIHJldmVydEZpbGVVcGxvYWQoXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgZmlsZSBzZXJ2ZXIgaWQgYW5kIHRyYW5zZmVyIGlkIGFzIG5vdyBpdCdzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNldCBlcnJvciBzdGF0ZSB3aGVuIHJldmVydGluZyBpcyBvcHRpb25hbCwgaXQgd2lsbCBhbHdheXMgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9oIG5vIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQtZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyZSBldmVudFxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcmV2ZXJ0Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBleHBvc2VkIG1ldGhvZHNcbiAgICAgICAgdmFyIF9zZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIHNldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciByb290ID0ga2V5c1swXTtcbiAgICAgICAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXRhID0gZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb21wYXJlIG9sZCB2YWx1ZSBhZ2FpbnN0IG5ldyB2YWx1ZSwgaWYgdGhleSdyZSB0aGUgc2FtZSwgd2UncmUgbm90IHVwZGF0aW5nXG4gICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZGF0YVtsYXN0XSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmFsdWVcbiAgICAgICAgICAgIGRhdGFbbGFzdF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gZmlyZSB1cGRhdGVcbiAgICAgICAgICAgIGZpcmUoJ21ldGFkYXRhLXVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBrZXk6IHJvb3QsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhW3Jvb3RdLFxuICAgICAgICAgICAgICAgIHNpbGVudDogc2lsZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1ldGFkYXRhID0gZnVuY3Rpb24gZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVlcENsb25lT2JqZWN0KGtleSA/IG1ldGFkYXRhW2tleV0gOiBtZXRhZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvcmlnaW4gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJJZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJJZDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS50cmFuc2ZlcklkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oc3RhdGUuZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGVFeHRlbnNpb246IHsgZ2V0OiBnZXRGaWxlRXh0ZW5zaW9uIH0sXG4gICAgICAgICAgICAgICAgZmlsZVR5cGU6IHsgZ2V0OiBnZXRGaWxlVHlwZSB9LFxuICAgICAgICAgICAgICAgIGZpbGVTaXplOiB7IGdldDogZ2V0RmlsZVNpemUgfSxcbiAgICAgICAgICAgICAgICBmaWxlOiB7IGdldDogZ2V0RmlsZSB9LFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLl9yZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGdldE1ldGFkYXRhOiBnZXRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YTogZnVuY3Rpb24gc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NldE1ldGFkYXRhKGtleSwgZGF0YVtrZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3NldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW1BUElbbmFtZV0gPSBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWJvcnRMb2FkOiBhYm9ydExvYWQsXG4gICAgICAgICAgICAgICAgcmV0cnlMb2FkOiByZXRyeUxvYWQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFByb2Nlc3Npbmc6IHJlcXVlc3RQcm9jZXNzaW5nLFxuICAgICAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZzogYWJvcnRQcm9jZXNzaW5nLFxuXG4gICAgICAgICAgICAgICAgbG9hZDogbG9hZCxcbiAgICAgICAgICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICAgICAgICAgIHJldmVydDogcmV2ZXJ0LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb24oKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcmVlemU6IGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5mcm96ZW4gPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVsZWFzZTogZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5yZWxlYXNlZCA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVsZWFzZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucmVsZWFzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGFyY2hpdmU6IGZ1bmN0aW9uIGFyY2hpdmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc3RhdGUuYXJjaGl2ZWQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyY2hpdmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmFyY2hpdmVkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGl0IGhlcmUgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgaW5zdGFudGx5IHNvIHdlIGNhbiBleHRlbmQgaXQgbGF0ZXJcbiAgICAgICAgdmFyIGl0ZW1BUEkgPSBjcmVhdGVPYmplY3QoYXBpKTtcblxuICAgICAgICByZXR1cm4gaXRlbUFQSTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEl0ZW1JbmRleEJ5UXVlcnkgPSBmdW5jdGlvbiBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBxdWVyeSkge1xuICAgICAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgICAgICBpZiAoaXNFbXB0eShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52YWxpZCBxdWVyaWVzXG4gICAgICAgIGlmICghaXNTdHJpbmcocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gaXRlbSBieSBpZCAob3IgLTEgaWYgbm90IGZvdW5kKVxuICAgICAgICByZXR1cm4gaXRlbXMuZmluZEluZGV4KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBxdWVyeTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtQnlJZCA9IGZ1bmN0aW9uIGdldEl0ZW1CeUlkKGl0ZW1zLCBpdGVtSWQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZ2V0SXRlbUluZGV4QnlRdWVyeShpdGVtcywgaXRlbUlkKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtc1tpbmRleF0gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGZldGNoQmxvYiA9IGZ1bmN0aW9uIGZldGNoQmxvYih1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChudWxsLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgIC8vIGdldCBoZWFkZXJzXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbGVuYW1lXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSByZXNwb25zZVxuICAgICAgICAgICAgbG9hZChcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZSgnbG9hZCcsIHhoci5zdGF0dXMsIGdldEZpbGVGcm9tQmxvYih4aHIucmVzcG9uc2UsIGZpbGVuYW1lKSwgaGVhZGVycylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICBlcnJvcihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCB4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgIGhlYWRlcnMoY3JlYXRlUmVzcG9uc2UoJ2hlYWRlcnMnLCB4aHIuc3RhdHVzLCBudWxsLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfTtcblxuICAgIHZhciBnZXREb21haW5Gcm9tVVJMID0gZnVuY3Rpb24gZ2V0RG9tYWluRnJvbVVSTCh1cmwpIHtcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgICAgICB1cmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIHVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ2Jsb2I6JywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFthLXpdKT86XFwvXFwvLywgJyQxJylcbiAgICAgICAgICAgIC5zcGxpdCgnLycpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgaXNFeHRlcm5hbFVSTCA9IGZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodXJsLmluZGV4T2YoJzonKSA+IC0xIHx8IHVybC5pbmRleE9mKCcvLycpID4gLTEpICYmXG4gICAgICAgICAgICBnZXREb21haW5Gcm9tVVJMKGxvY2F0aW9uLmhyZWYpICE9PSBnZXREb21haW5Gcm9tVVJMKHVybClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGR5bmFtaWNMYWJlbCA9IGZ1bmN0aW9uIGR5bmFtaWNMYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihsYWJlbCkgPyBsYWJlbC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cykgOiBsYWJlbDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGlzTW9ja0l0ZW0gPSBmdW5jdGlvbiBpc01vY2tJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFpc0ZpbGUoaXRlbS5maWxlKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RVcGRhdGVkID0gZnVuY3Rpb24gbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5saXN0VXBkYXRlVGltZW91dCk7XG4gICAgICAgIHN0YXRlLmxpc3RVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1TJywgeyBpdGVtczogZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgdmFyIG9wdGlvbmFsUHJvbWlzZSA9IGZ1bmN0aW9uIG9wdGlvbmFsUHJvbWlzZShmbikge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTtcbiAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICkge1xuICAgICAgICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBzb3J0SXRlbXMgPSBmdW5jdGlvbiBzb3J0SXRlbXMoc3RhdGUsIGNvbXBhcmUpIHtcbiAgICAgICAgc3RhdGUuaXRlbXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZShjcmVhdGVJdGVtQVBJKGEpLCBjcmVhdGVJdGVtQVBJKGIpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgaXRlbSBiYXNlZCBvbiBzdGF0ZVxuICAgIHZhciBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZSA9IGZ1bmN0aW9uIGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIF9yZWYkc3VjY2VzcyA9IF9yZWYuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gX3JlZiRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRzdWNjZXNzLFxuICAgICAgICAgICAgICAgIF9yZWYkZmFpbHVyZSA9IF9yZWYuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlID0gX3JlZiRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRmYWlsdXJlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydxdWVyeScsICdzdWNjZXNzJywgJ2ZhaWx1cmUnXSk7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbUhhbmRsZXIoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBhY3Rpb25zID0gZnVuY3Rpb24gYWN0aW9ucyhkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFib3J0cyBhbGwgb25nb2luZyBwcm9jZXNzZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQUJPUlRfQUxMOiBmdW5jdGlvbiBBQk9SVF9BTEwoKSB7XG4gICAgICAgICAgICAgICAgZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmZyZWV6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmFib3J0TG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIGluaXRpYWwgZmlsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRElEX1NFVF9GSUxFUzogZnVuY3Rpb24gRElEX1NFVF9GSUxFUyhfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmMiR2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyJHZhbHVlID09PSB2b2lkIDAgPyBbXSA6IF9yZWYyJHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIG1hcCB2YWx1ZXMgdG8gZmlsZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gdmFsdWUubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZmlsZS5zb3VyY2UgPyBmaWxlLnNvdXJjZSA6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBmaWxlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBsb29wIG92ZXIgZmlsZXMsIGlmIGZpbGUgaXMgaW4gbGlzdCwgbGVhdmUgaXQgYmUsIGlmIG5vdCwgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiBpdGVtcyBzaG91bGQgYmUgbW92ZWRcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlSXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG5cbiAgICAgICAgICAgICAgICBhY3RpdmVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRlbSBub3QgaXMgaW4gbmV3IHZhbHVlLCByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIWZpbGVzLmZpbmQoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLnNvdXJjZSA9PT0gaXRlbS5zb3VyY2UgfHwgZmlsZS5zb3VyY2UgPT09IGl0ZW0uZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbSwgcmVtb3ZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBmaWxlc1xuICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlsZSBpcyBhbHJlYWR5IGluIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlSXRlbXMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc291cmNlID09PSBmaWxlLnNvdXJjZSB8fCBpdGVtLmZpbGUgPT09IGZpbGUuc291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBpbiBsaXN0LCBhZGRcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUREX0lURU0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZmlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5OT05FLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQShfcmVmMykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9yZWYzLmlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IF9yZWYzLmNoYW5nZTtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2lsZW50KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaW4gY2xvc2Ugc3VjY2Vzc2lvbiB3ZSBjb21iaW5lZCBhbGwgY2FsbHMgdG9nZXRoZXIgdG8gc2F2ZSByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUuaXRlbVVwZGF0ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlJZChzdGF0ZS5pdGVtcywgaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcmV2ZXJ0IGFuZCBhdHRlbXB0IHRvIHVwbG9hZCB3aGVuIHdlJ3JlIHVwbG9hZGluZyB0byBhIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5KCdJU19BU1lOQycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgd2UgdXBkYXRlIHRoZSBvdXRwdXQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignU0hPVUxEX1BSRVBBUkVfT1VUUFVUJywgZmFsc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsdWdpbnMgZGV0ZXJtaW5lZCB0aGUgb3V0cHV0IGRhdGEgc2hvdWxkIGJlIHByZXBhcmVkIChvciBub3QpLCBjYW4gYmUgYWRqdXN0ZWQgd2l0aCBiZWZvcmVQcmVwYXJlT3V0cHV0IGhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlUHJlcGFyZUZpbGUgPSBxdWVyeSgnR0VUX0JFRk9SRV9QUkVQQVJFX0ZJTEUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlUHJlcGFyZUZpbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXQgPSBiZWZvcmVQcmVwYXJlRmlsZShpdGVtLCBzaG91bGRQcmVwYXJlT3V0cHV0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUHJlcGFyZU91dHB1dCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpZCwgZmlsZTogZmlsZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXMgbG9jYWwgaXRlbSB3ZSBuZWVkIHRvIGVuYWJsZSB1cGxvYWQgYnV0dG9uIHNvIGNoYW5nZSBjYW4gYmUgcHJvcGFnYXRlZCB0byBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGFzeW5jIHNjZW5hcmlvc1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgcHVzaCB0aGlzIGZvcndhcmQgYSBiaXQgc28gdGhlIGludGVyZmFjZSBpcyB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGRvVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6IGZ1bmN0aW9uKCkge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KGRvVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4oZG9VcGxvYWQgPyB1cGxvYWQgOiBmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBzaG91bGQgcmUtdXBsb2FkIHRoZSBmaWxlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV2ZXJ0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50bHkgdXBsb2FkaW5nLCBjYW5jZWwgdXBsb2FkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWJvcnQoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBNT1ZFX0lURU06IGZ1bmN0aW9uIE1PVkVfSVRFTShfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IF9yZWY0LnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF9yZWY0LmluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc3RhdGUuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSBpbmRleCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0YXRlLml0ZW1zLnNwbGljZShpbmRleCwgMCwgc3RhdGUuaXRlbXMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSlbMF0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgU09SVDogZnVuY3Rpb24gU09SVChfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gX3JlZjUuY29tcGFyZTtcbiAgICAgICAgICAgICAgICBzb3J0SXRlbXMoc3RhdGUsIGNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU09SVF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBBRERfSVRFTVM6IGZ1bmN0aW9uIEFERF9JVEVNUyhfcmVmNikge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IF9yZWY2Lml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF9yZWY2LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IF9yZWY2LmludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNiRzdWNjZXNzID0gX3JlZjYuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IF9yZWY2JHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNiRzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNiRmYWlsdXJlID0gX3JlZjYuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSA9IF9yZWY2JGZhaWx1cmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNiRmYWlsdXJlO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgdHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbEl0ZW1zID0gcXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAwIDogdG90YWxJdGVtcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlZEZpbGVzID0gcXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVmFsaWRGaWxlID0gZnVuY3Rpb24gaXNWYWxpZEZpbGUoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0ZpbGUoc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFpc0VtcHR5KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRJdGVtcyA9IGl0ZW1zLmZpbHRlcihpc1ZhbGlkRmlsZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB2YWxpZEl0ZW1zLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5zb3VyY2UgfHwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzb3VyY2Uub3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZmFpbHVyZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSBzb3VyY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAgICAgICAgICogQHBhcmFtIGludGVyYWN0aW9uTWV0aG9kXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFERF9JVEVNOiBmdW5jdGlvbiBBRERfSVRFTShfcmVmNykge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfcmVmNy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY3JGluZGV4ID0gX3JlZjcuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gX3JlZjckaW5kZXggPT09IHZvaWQgMCA/IC0xIDogX3JlZjckaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kID0gX3JlZjcuaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY3JHN1Y2Nlc3MgPSBfcmVmNy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gX3JlZjckc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY3JHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY3JGZhaWx1cmUgPSBfcmVmNy5mYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlID0gX3JlZjckZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY3JGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIF9yZWY3JG9wdGlvbnMgPSBfcmVmNy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gX3JlZjckb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmNyRvcHRpb25zO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHNvdXJjZSBzdXBwbGllZFxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgJ05vIHNvdXJjZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgaW52YWxpZCBmaWxlIGl0ZW1zLCB1c2VkIHRvIGZpbHRlciBkcm9wcGVkIGRpcmVjdG9yeSBjb250ZW50c1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaXNGaWxlKHNvdXJjZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5pZ25vcmVkRmlsZXMuaW5jbHVkZXMoc291cmNlLm5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbCBzaWxlbnRseVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB0aGVyZSdzIHN0aWxsIHJvb20gaW4gdGhlIGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Jvb21Gb3JJdGVtKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtdWx0aXBsZSBhbGxvd2VkLCB3ZSBjYW4ndCByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIG9ubHkgYSBzaW5nbGUgaXRlbSBpcyBhbGxvd2VkIGJ1dCB3ZSdyZSBub3QgYWxsb3dlZCB0byByZXBsYWNlIGl0IHdlIGV4aXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSAmJiAhc3RhdGUub3B0aW9ucy5hbGxvd1JlcGxhY2UpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfTUFYX0ZJTEVTJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBudWxsIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyByZXBsYWNlIHRoZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgIC8vIGlkIG9mIGZpcnN0IGl0ZW0gd2UncmUgYWJvdXQgdG8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlbSA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKVswXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBoYXMgYmVlbiBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNlcnZlciBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yY2VSZXZlcnQgPSBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJldmVydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBhZGQgbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTsgLy8gbm8gbmVlZCB0byBoYW5kbGUgdGhpcyBjYXRjaCBzdGF0ZSBmb3Igbm93XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZVJldmVydCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZpcnN0IGl0ZW0gYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogX2l0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgZGlkIHRoZSBmaWxlIG9yaWdpbmF0ZVxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09ICdsb2NhbCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MT0NBTFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnR5cGUgPT09ICdsaW1ibydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MSU1CT1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBGaWxlT3JpZ2luLklOUFVUO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGJsYW5rIGl0ZW1cbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNyZWF0ZUl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIGRpZCB0aGlzIGZpbGUgY29tZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbixcblxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBpbnB1dCBmaWxlIG5ldmVyIGhhcyBhIHNlcnZlciBmaWxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgbW9jayBkYXRhLCBpZiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBtZXRhIGRhdGFcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm1ldGFkYXRhIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldE1ldGFkYXRhKGtleSwgb3B0aW9ucy5tZXRhZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZWQgdGhlIGl0ZW0sIGxldCBwbHVnaW5zIGFkZCBtZXRob2RzXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdESURfQ1JFQVRFX0lURU0nLCBpdGVtLCB7IHF1ZXJ5OiBxdWVyeSwgZGlzcGF0Y2g6IGRpc3BhdGNoIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgdG8gaW5zZXJ0IG5ldyBpdGVtc1xuICAgICAgICAgICAgICAgIHZhciBpdGVtSW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgaW5kZXggaWYgaXMgbm90IGFsbG93ZWQgdG8gcGljayBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaXRlbUluc2VydExvY2F0aW9uID09PSAnYmVmb3JlJyA/IC0xIDogc3RhdGUuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtIHRvIGxpc3RcbiAgICAgICAgICAgICAgICBpbnNlcnRJdGVtKHN0YXRlLml0ZW1zLCBpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzb3J0IGl0ZW1zIGluIGxpc3RcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihpdGVtSW5zZXJ0TG9jYXRpb24pICYmIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0SXRlbXMoc3RhdGUsIGl0ZW1JbnNlcnRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGEgcXVpY2sgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIGlkXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gaXRlbS5pZDtcblxuICAgICAgICAgICAgICAgIC8vIG9ic2VydmUgaXRlbSBldmVudHNcbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdpbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfSU5JVF9JVEVNJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLWluaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TVEFSVF9JVEVNX0xPQUQnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtbWV0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEEnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtcHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1MnLCB7IGlkOiBpZCwgcHJvZ3Jlc3M6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZC1yZXF1ZXN0LWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1haW5TdGF0dXMgPSBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVMb2FkRXJyb3IpKGVycm9yKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBjbGllbnQgZXJyb3IsIG5vIHdheSB0byByZWNvdmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID49IDQwMCAmJiBlcnJvci5jb2RlIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBtYWluU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IGVycm9yLmNvZGUgKyAnICgnICsgZXJyb3IuYm9keSArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdCB0aGUgZmlsZSBzbyBjYW4gYmUgZGVhbHQgd2l0aCB0aHJvdWdoIEFQSVxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvciwgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHBvc3NpYmxlIHNlcnZlciBlcnJvciwgc28gbWlnaHQgYmUgcG9zc2libGUgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0xPQURfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBtYWluU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtZmlsZS1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9JTlZBTElEJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLnN0YXR1cywgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ2xvYWQtYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdsb2FkLXNraXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gc2hvdWxkIG5vdCBhZGQgdGhpcyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgaW50ZXJlc3RlZCBpbiBtZXRhZGF0YSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9uKCdtZXRhZGF0YS11cGRhdGUnLCBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEFEQVRBJywgeyBpZDogaWQsIGNoYW5nZTogY2hhbmdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBwbHVnaW5zIGRlY2lkZSBpZiB0aGUgb3V0cHV0IGRhdGEgc2hvdWxkIGJlIHByZXBhcmVkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW5zIHdlJ2xsIGRvIHRoaXMgYW5kIHdhaXQgZm9yIGlkbGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZVByZXBhcmVGaWxlID0gcXVlcnkoJ0dFVF9CRUZPUkVfUFJFUEFSRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZVByZXBhcmVGaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZENvbXBsZXRlID0gZnVuY3Rpb24gbG9hZENvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRQcmVwYXJlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlkbGUgc3RhdGUgYW5kIHRoZW4gcnVuIFBSRVBBUkVfT1VUUFVUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBsb2FkZWQsIGFsbG93IHBsdWdpbnMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gLSByZWFkIGRhdGEgKHF1aWNrbHkpXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYWRkIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0RJRF9MT0FEX0lURU0nLCBpdGVtLCB7IHF1ZXJ5OiBxdWVyeSwgZGlzcGF0Y2g6IGRpc3BhdGNoIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFByb21pc2UocXVlcnkoJ0dFVF9CRUZPUkVfQUREX0ZJTEUnKSwgY3JlYXRlSXRlbUFQSShpdGVtKSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAhZS5lcnJvciB8fCAhZS5zdGF0dXMpIHJldHVybiBoYW5kbGVBZGQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9JTlZBTElEJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGUuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXN0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXByb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTJywgeyBpZDogaWQsIHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvcikoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0LWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUHJvY2Vzc2luZ1JldmVydEVycm9yKShlcnJvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNlcnZlckZpbGVSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZDogaWQsIHZhbHVlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1hYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1yZXZlcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZDogaWQsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbGV0IHZpZXcga25vdyB0aGUgaXRlbSBoYXMgYmVlbiBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgbG9hZGluZyB0aGUgc291cmNlXG4gICAgICAgICAgICAgICAgdmFyIF9yZWY4ID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXIgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IF9yZWY4LnVybCxcbiAgICAgICAgICAgICAgICAgICAgbG9hZCA9IF9yZWY4LmxvYWQsXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBfcmVmOC5yZXN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaCA9IF9yZWY4LmZldGNoO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5sb2FkKFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2FkcyB0aGUgZmlsZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmaWxlIChzdHJpbmcsIGJhc2U2NCwgYmxvYiwgZmlsZSkgYW5kIGxvY2F0aW9uIG9mIGZpbGUgKGxvY2FsLCByZW1vdGUsIGxpbWJvKVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGaWxlTG9hZGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBpbnB1dCwgaWYgaXMgcmVtb3RlLCBzZWUgaWYgc2hvdWxkIHVzZSBjdXN0b20gZmV0Y2gsIGVsc2UgdXNlIGRlZmF1bHQgZmV0Y2hCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N0cmluZyhzb3VyY2UpICYmIGlzRXh0ZXJuYWxVUkwoc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBmZXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHJlbW90ZSB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmZXRjaEJsb2IgLy8gdHJ5IHRvIGZldGNoIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gbGltYm8gb3IgbG9jYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCByZXN0b3JlKSAvLyBsaW1ib1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGxvYWQpIC8vIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIGZpbGUgaXMgbG9hZGVkIHNvIGl0IGNhbiBiZSBwaXBlZCB0aHJvdWdoIHRoZSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBwcm9jZXNzIHRoZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdMT0FEX0ZJTEUnLCBmaWxlLCB7IHF1ZXJ5OiBxdWVyeSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBSRVFVRVNUX1BSRVBBUkVfT1VUUFVUOiBmdW5jdGlvbiBSRVFVRVNUX1BSRVBBUkVfT1VUUFVUKF9yZWY5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfcmVmOS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gX3JlZjkuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjkkZmFpbHVyZSA9IF9yZWY5LmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBfcmVmOSRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjkkZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAvLyBlcnJvciByZXNwb25zZSBpZiBpdGVtIGFyY2hpdmVkXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIHdhaXRpbmcgdG8gYmUgcHJlcGFyZWRcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgaXRlbS5maWxlLCB7IHF1ZXJ5OiBxdWVyeSwgaXRlbTogaXRlbSB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgcmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgYmVpbmcgcHJlcGFyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgQ09NUExFVEVfTE9BRF9JVEVNOiBmdW5jdGlvbiBDT01QTEVURV9MT0FEX0lURU0oX3JlZjEwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfcmVmMTAuaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9yZWYxMC5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZGF0YS5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBkYXRhLnNvdXJjZTtcblxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaXRlbXMgaW4gbGlzdFxuICAgICAgICAgICAgICAgIHZhciBpdGVtSW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxldCBpbnRlcmZhY2Uga25vdyB0aGUgaXRlbSBoYXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gaXRlbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbG9hZGVkIGFuZCBhZGRlZCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGl0ZW1zIHNvIGNhbiBub3cgYmUgc2FmZWx5IHJldHVybmVkIGZvciB1c2VcbiAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIHNlcnZlciBmaWxlIHdlIG5lZWQgdG8gc2hvdyBhIGRpZmZlcmVudCBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0xPQURfTE9DQUxfSVRFTScsIHsgaWQ6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpcyBhIHRlbXAgc2VydmVyIGZpbGUgd2UgcHJldmVudCBhc3luYyB1cGxvYWQgY2FsbCBoZXJlIChhcyB0aGUgZmlsZSBpcyBhbHJlYWR5IG9uIHRoZSBzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLnNlcnZlcklkIHx8IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlkIHdlIGFyZSBhbGxvd2VkIHRvIHVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseSwgbGV0cyBkbyBpdFxuICAgICAgICAgICAgICAgIGlmIChxdWVyeSgnSVNfQVNZTkMnKSAmJiBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBSRVRSWV9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IGxvYWRpbmcgdGhlIHNvdXJjZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgICAgICAgaXRlbS5yZXRyeUxvYWQoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX0lURU1fUFJFUEFSRTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0sIF9zdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGl0ZW0uaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5ub3QgYmUgcXVldWVkIChvciBpcyBhbHJlYWR5IHF1ZXVlZClcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZyA9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3Npbmcgd2VudCB3cm9uZyBlYXJsaWVyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1I7XG5cbiAgICAgICAgICAgICAgICAvLyBub3QgcmVhZHkgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzTm93ID0gZnVuY3Rpb24gcHJvY2Vzc05vdygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmhpZGRlbiA/IHByb2Nlc3NOb3coKSA6IHNldFRpbWVvdXQocHJvY2Vzc05vdywgMzIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgZG9uZSBwcm9jZXNzaW5nIG9yIHRyaWVkIHRvIHJldmVydCBidXQgZGlkbid0IHdvcmssIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pOyAvLyBkb24ndCBjb250aW51ZSB3aXRoIHByb2Nlc3NpbmcgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4ocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBxdWV1ZWQgZm9yIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGl0ZW0ucmVxdWVzdFByb2Nlc3NpbmcoKTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1BST0NFU1NfSVRFTScsIHsgcXVlcnk6IGl0ZW0sIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGZhaWx1cmU6IGZhaWx1cmUgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUFJPQ0VTU19JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhQYXJhbGxlbFVwbG9hZHMgPSBxdWVyeSgnR0VUX01BWF9QQVJBTExFTF9VUExPQURTJyk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQ3VycmVudFVwbG9hZHMgPSBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lORylcbiAgICAgICAgICAgICAgICAgICAgLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIGFuZCB3YWl0IHRpbGwgcXVldWUgaXMgZnJlZWQgdXBcbiAgICAgICAgICAgICAgICBpZiAodG90YWxDdXJyZW50VXBsb2FkcyA9PT0gbWF4UGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHF1ZXVlIGZvciBsYXRlciBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgaXQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3YXMgbm90IHF1ZXVlZCBvciBpcyBhbHJlYWR5IHByb2Nlc3NpbmcgZXhpdCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzTmV4dCA9IGZ1bmN0aW9uIHByb2Nlc3NOZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHF1ZXVldWQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlRW50cnkgPSBzdGF0ZS5wcm9jZXNzaW5nUXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBubyBpdGVtcyBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVldWVFbnRyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBpdGVtIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBxdWV1ZUVudHJ5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHF1ZXVlRW50cnkuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBxdWV1ZUVudHJ5LmZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtUmVmZXJlbmNlID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdGVtIHdhcyBhcmNoaXZlZCB3aGlsZSBpbiBxdWV1ZSwganVtcCB0byBuZXh0XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbVJlZmVyZW5jZSB8fCBpdGVtUmVmZXJlbmNlLmFyY2hpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZWQgaXRlbVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUk9DRVNTX0lURU0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBxdWVyeTogaWQsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGZhaWx1cmU6IGZhaWx1cmUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWNvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3JpZ2luIGlzIGxvY2FsLCBhbmQgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcsIHRyaWdnZXIgcmVtb3ZlIG9mIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHJldmVydCB3aWxsIHJlbW92ZSBmaWxlIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50VXBsb2FkID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50VXBsb2FkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihzZXJ2ZXIucmVtb3ZlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmVtb3ZlKGl0ZW0uc291cmNlLCBub29wLCBub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBpdGVtcyBwcm9jZXNzZWQ/IE5vIGVycm9ycz9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEl0ZW1zUHJvY2Vzc2VkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfSVRFTVNfQllfU1RBVFVTJywgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKS5sZW5ndGggPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxJdGVtc1Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgZmlsZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzdGF0ZS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGl0ZW0ucHJvY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmlsZVByb2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcnZlci5wcm9jZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rVHJhbnNmZXJJZDogaXRlbS50cmFuc2ZlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1NlcnZlcjogb3B0aW9ucy5zZXJ2ZXIucGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rVXBsb2Fkczogb3B0aW9ucy5jaHVua1VwbG9hZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rRm9yY2U6IG9wdGlvbnMuY2h1bmtGb3JjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtSZXRyeURlbGF5czogb3B0aW9ucy5jaHVua1JldHJ5RGVsYXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbjogcXVlcnkoJ0dFVF9BTExPV19NSU5JTVVNX1VQTE9BRF9EVVJBVElPTicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGFib3V0IHRvIGJlIHByb2Nlc3NlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgdHJhbnNmb3JtIGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZmlsZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBmaWxlLCB7IHF1ZXJ5OiBxdWVyeSwgaXRlbTogaXRlbSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGl0ZW0uaWQsIGZpbGU6IGZpbGUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFVFJZX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFUVVFU1RfUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQcm9taXNlKHF1ZXJ5KCdHRVRfQkVGT1JFX1JFTU9WRV9GSUxFJyksIGNyZWF0ZUl0ZW1BUEkoaXRlbSkpLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbW92ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVMRUFTRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVsZWFzZSgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIFJFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVGcm9tVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21WaWV3KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgaWQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJjaGl2ZSB0aGUgaXRlbSwgdGhpcyBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtQnlJZChzdGF0ZS5pdGVtcywgaWQpLmFyY2hpdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0ZWxsIHRoZSB2aWV3IHRoZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRU1PVkVfSVRFTScsIHsgZXJyb3I6IG51bGwsIGlkOiBpZCwgaXRlbTogaXRlbSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub3cgdGhlIGxpc3QgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bHkgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbG9jYWwgZmlsZSBhbmQgdGhlIGBzZXJ2ZXIucmVtb3ZlYCBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkLFxuICAgICAgICAgICAgICAgIC8vIHNlbmQgc291cmNlIHRoZXJlIHNvIGRldiBjYW4gcmVtb3ZlIGZpbGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXI7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihzZXJ2ZXIucmVtb3ZlKSAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlbW92ZSAhPT0gZmFsc2VcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TVEFSVF9JVEVNX1JFTU9WRScsIHsgaWQ6IGl0ZW0uaWQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlbW92ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZyb21WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCBzdGF0dXMsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVJlbW92ZUVycm9yKShzdGF0dXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpcyByZXF1ZXN0aW5nIHJldmVydCBhbmQgY2FuIHJldmVydCBuZWVkIHRvIGNhbGwgcmV2ZXJ0IGhhbmRsZXIgKG5vdCBjYWxsaW5nIHJlcXVlc3RfIGJlY2F1c2UgdGhhdCB3b3VsZCBhbHNvIHRyaWdnZXIgYmVmb3JlUmVtb3ZlSG9vaylcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMucmV2ZXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gIT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNlcnZlcklkICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2h1bmtlZCB1cGxvYWRzIGFyZSBlbmFibGVkIGFuZCB3ZSdyZSB1cGxvYWRpbmcgaW4gY2h1bmtzIGZvciB0aGlzIHNwZWNpZmljIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBmaWxlIGlzbid0IGJpZyBlbm91Z2ggZm9yIGNodW5rZWQgdXBsb2FkcyBidXQgY2h1bmtGb3JjZSBpcyBzZXQgdGhlbiBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgYmVmb3JlIHJlbW92aW5nIGZyb20gdGhlIHZpZXcuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5vcHRpb25zLmNodW5rVXBsb2FkcyAmJiBpdGVtLmZpbGUuc2l6ZSA+IHN0YXRlLm9wdGlvbnMuY2h1bmtTaXplKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm9wdGlvbnMuY2h1bmtVcGxvYWRzICYmIHN0YXRlLm9wdGlvbnMuY2h1bmtGb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjYW4gbm93IHNhZmVseSByZW1vdmUgZnJvbSB2aWV3XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIEFCT1JUX0lURU1fTE9BRDogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFib3J0TG9hZCgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgIEFCT1JUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIGlzIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VydmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWJvcnRcbiAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGluc3RhbnQgdXBsb2FkaW5nLCByZXZlcnQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbnN0YW50IHVwbG9hZGluZyB0aGUgZmlsZSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBpZiB3ZSByZXZlcnQsXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgYSBiZWZvcmUgcmVtb3ZlIGZpbGUgaG9vayBpcyBkZWZpbmVkIHdlIG5lZWQgdG8gcnVuIGl0IG5vd1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVSZXZlcnQgPSBmdW5jdGlvbiBoYW5kbGVSZXZlcnQoc2hvdWxkUmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gcXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RSZW1vdmVSZXN1bHQgPSBmbihjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdFJlbW92ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydChyZXF1ZXN0UmVtb3ZlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RSZW1vdmVSZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4oaGFuZGxlUmV2ZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQgfHwgaXNNb2NrSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgU0VUX09QVElPTlM6IGZ1bmN0aW9uIFNFVF9PUFRJT05TKF9yZWYxMSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3JlZjExLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBrZXlzIHBhc3NlZFxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgcHJpb3JpdGl6ZWQga2V5ZWQgdG8gaW5jbHVkZSAocmVtb3ZlIG9uY2Ugbm90IGluIG9wdGlvbnMgb2JqZWN0KVxuICAgICAgICAgICAgICAgIHZhciBwcmlvcml0aXplZE9wdGlvbktleXMgPSBQcmlvcml0aXplZE9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uS2V5cy5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgdGhlIGtleXMsIHByaW9yaXRpemVkIGZpcnN0LCB0aGVuIHJlc3RcbiAgICAgICAgICAgICAgICB2YXIgb3JkZXJlZE9wdGlvbktleXMgPSBbXS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIF90b0NvbnN1bWFibGVBcnJheShwcmlvcml0aXplZE9wdGlvbktleXMpLFxuICAgICAgICAgICAgICAgICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFwcmlvcml0aXplZE9wdGlvbktleXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gZGlzcGF0Y2ggc2V0IGV2ZW50IGZvciBlYWNoIG9wdGlvblxuICAgICAgICAgICAgICAgIG9yZGVyZWRPcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdTRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIFByaW9yaXRpemVkT3B0aW9ucyA9IFsnc2VydmVyJ107XG5cbiAgICB2YXIgZm9ybWF0RmlsZW5hbWUgPSBmdW5jdGlvbiBmb3JtYXRGaWxlbmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRWxlbWVudCQxID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0ZXh0Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgICAgIHZhciBhbmdsZUluUmFkaWFucyA9ICgoKGFuZ2xlSW5EZWdyZWVzICUgMzYwKSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpLFxuICAgICAgICAgICAgeTogY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc2NyaWJlQXJjID0gZnVuY3Rpb24gZGVzY3JpYmVBcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYXJjU3dlZXApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIFsnTScsIHN0YXJ0LngsIHN0YXJ0LnksICdBJywgcmFkaXVzLCByYWRpdXMsIDAsIGFyY1N3ZWVwLCAwLCBlbmQueCwgZW5kLnldLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgdmFyIHBlcmNlbnRhZ2VBcmMgPSBmdW5jdGlvbiBwZXJjZW50YWdlQXJjKHgsIHksIHJhZGl1cywgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGFyY1N3ZWVwID0gMTtcbiAgICAgICAgaWYgKHRvID4gZnJvbSAmJiB0byAtIGZyb20gPD0gMC41KSB7XG4gICAgICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiB0byAmJiBmcm9tIC0gdG8gPj0gMC41KSB7XG4gICAgICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlQXJjKFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICBNYXRoLm1pbigwLjk5OTksIGZyb20pICogMzYwLFxuICAgICAgICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICAgICAgICBhcmNTd2VlcFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIC8vIHN0YXJ0IGF0IDBcbiAgICAgICAgcHJvcHMuc3BpbiA9IGZhbHNlO1xuICAgICAgICBwcm9wcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHByb3BzLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgIC8vIHN2Z1xuICAgICAgICB2YXIgc3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG4gICAgICAgIHJvb3QucmVmLnBhdGggPSBjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgICAgICB9KTtcblxuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdC5yZWYucGF0aCk7XG5cbiAgICAgICAgcm9vdC5yZWYuc3ZnID0gc3ZnO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5hbGlnbikge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB3aWR0aCBvZiBzdHJva2VcbiAgICAgICAgdmFyIHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHNpemUgb2YgcmluZ1xuICAgICAgICB2YXIgc2l6ZSA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuXG4gICAgICAgIC8vIHJpbmcgc3RhdGVcbiAgICAgICAgdmFyIHJpbmdGcm9tID0gMDtcbiAgICAgICAgdmFyIHJpbmdUbyA9IDA7XG5cbiAgICAgICAgLy8gbm93IGluIGJ1c3kgbW9kZVxuICAgICAgICBpZiAocHJvcHMuc3Bpbikge1xuICAgICAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICAgICAgcmluZ1RvID0gMC41O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICAgICAgcmluZ1RvID0gcHJvcHMucHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYXJjIHBhdGhcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcGVyY2VudGFnZUFyYyhzaXplLCBzaXplLCBzaXplIC0gcmluZ1N0cm9rZVdpZHRoLCByaW5nRnJvbSwgcmluZ1RvKTtcblxuICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ2QnLCBjb29yZGluYXRlcyk7XG5cbiAgICAgICAgLy8gaGlkZSB3aGlsZSBjb250YWlucyAwIHZhbHVlXG4gICAgICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS1vcGFjaXR5JywgcHJvcHMuc3BpbiB8fCBwcm9wcy5wcm9ncmVzcyA+IDAgPyAxIDogMCk7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICB0YWc6ICdkaXYnLFxuICAgICAgICBuYW1lOiAncHJvZ3Jlc3MtaW5kaWNhdG9yJyxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICAgIHdyaXRlOiB3cml0ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ3Byb2dyZXNzJywgJ3NwaW4nLCAnYWxpZ24nXSxcbiAgICAgICAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNTAwIH0sXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgICAgIHN0aWZmbmVzczogMC45NSxcbiAgICAgICAgICAgICAgICAgICAgZGFtcGluZzogMC42NSxcbiAgICAgICAgICAgICAgICAgICAgbWFzczogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlJDEgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IChwcm9wcy5pY29uIHx8ICcnKSArICgnPHNwYW4+JyArIHByb3BzLmxhYmVsICsgJzwvc3Bhbj4nKTtcblxuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQxID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkO1xuICAgICAgICB2YXIgc2hvdWxkRGlzYWJsZSA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpIHx8IHByb3BzLm9wYWNpdHkgPT09IDA7XG5cbiAgICAgICAgaWYgKHNob3VsZERpc2FibGUgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGREaXNhYmxlICYmIGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGZpbGVBY3Rpb25CdXR0b24gPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnYnV0dG9uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgIH0sXG5cbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgbmFtZTogJ2ZpbGUtYWN0aW9uLWJ1dHRvbicsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogWydsYWJlbCddLFxuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDEsXG4gICAgfSk7XG5cbiAgICB2YXIgdG9OYXR1cmFsRmlsZVNpemUgPSBmdW5jdGlvbiB0b05hdHVyYWxGaWxlU2l6ZShieXRlcykge1xuICAgICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9XG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcuJztcbiAgICAgICAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEwMDA7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgICAgdmFyIF9vcHRpb25zJGxhYmVsQnl0ZXMgPSBvcHRpb25zLmxhYmVsQnl0ZXMsXG4gICAgICAgICAgICBsYWJlbEJ5dGVzID0gX29wdGlvbnMkbGFiZWxCeXRlcyA9PT0gdm9pZCAwID8gJ2J5dGVzJyA6IF9vcHRpb25zJGxhYmVsQnl0ZXMsXG4gICAgICAgICAgICBfb3B0aW9ucyRsYWJlbEtpbG9ieXQgPSBvcHRpb25zLmxhYmVsS2lsb2J5dGVzLFxuICAgICAgICAgICAgbGFiZWxLaWxvYnl0ZXMgPSBfb3B0aW9ucyRsYWJlbEtpbG9ieXQgPT09IHZvaWQgMCA/ICdLQicgOiBfb3B0aW9ucyRsYWJlbEtpbG9ieXQsXG4gICAgICAgICAgICBfb3B0aW9ucyRsYWJlbE1lZ2FieXQgPSBvcHRpb25zLmxhYmVsTWVnYWJ5dGVzLFxuICAgICAgICAgICAgbGFiZWxNZWdhYnl0ZXMgPSBfb3B0aW9ucyRsYWJlbE1lZ2FieXQgPT09IHZvaWQgMCA/ICdNQicgOiBfb3B0aW9ucyRsYWJlbE1lZ2FieXQsXG4gICAgICAgICAgICBfb3B0aW9ucyRsYWJlbEdpZ2FieXQgPSBvcHRpb25zLmxhYmVsR2lnYWJ5dGVzLFxuICAgICAgICAgICAgbGFiZWxHaWdhYnl0ZXMgPSBfb3B0aW9ucyRsYWJlbEdpZ2FieXQgPT09IHZvaWQgMCA/ICdHQicgOiBfb3B0aW9ucyRsYWJlbEdpZ2FieXQ7XG5cbiAgICAgICAgLy8gbm8gbmVnYXRpdmUgYnl0ZSBzaXplc1xuICAgICAgICBieXRlcyA9IE1hdGgucm91bmQoTWF0aC5hYnMoYnl0ZXMpKTtcblxuICAgICAgICB2YXIgS0IgPSBiYXNlO1xuICAgICAgICB2YXIgTUIgPSBiYXNlICogYmFzZTtcbiAgICAgICAgdmFyIEdCID0gYmFzZSAqIGJhc2UgKiBiYXNlO1xuXG4gICAgICAgIC8vIGp1c3QgYnl0ZXNcbiAgICAgICAgaWYgKGJ5dGVzIDwgS0IpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlcyArICcgJyArIGxhYmVsQnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBraWxvYnl0ZXNcbiAgICAgICAgaWYgKGJ5dGVzIDwgTUIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGJ5dGVzIC8gS0IpICsgJyAnICsgbGFiZWxLaWxvYnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZWdhYnl0ZXNcbiAgICAgICAgaWYgKGJ5dGVzIDwgR0IpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVEZWNpbWFsc1doZW5aZXJvKGJ5dGVzIC8gTUIsIDEsIGRlY2ltYWxTZXBhcmF0b3IpICsgJyAnICsgbGFiZWxNZWdhYnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnaWdhYnl0ZXNcbiAgICAgICAgcmV0dXJuIHJlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBHQiwgMiwgZGVjaW1hbFNlcGFyYXRvcikgKyAnICcgKyBsYWJlbEdpZ2FieXRlcztcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZURlY2ltYWxzV2hlblplcm8gPSBmdW5jdGlvbiByZW1vdmVEZWNpbWFsc1doZW5aZXJvKHZhbHVlLCBkZWNpbWFsQ291bnQsIHNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIC50b0ZpeGVkKGRlY2ltYWxDb3VudClcbiAgICAgICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydCAhPT0gJzAnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkMiA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAvLyBmaWxlbmFtZVxuICAgICAgICB2YXIgZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICAgICAgZmlsZU5hbWUuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLWluZm8tbWFpbic7XG4gICAgICAgIC8vIGhpZGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAgICAgLy8gdGhlIGZpbGUgaXMgY29udGFpbmVkIGluIGEgZmllbGRzZXQgd2l0aCBsZWdlbmQgdGhhdCBjb250YWlucyB0aGUgZmlsZW5hbWVcbiAgICAgICAgLy8gbm8gbmVlZCB0byByZWFkIGl0IHR3aWNlXG4gICAgICAgIGF0dHIoZmlsZU5hbWUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZmlsZU5hbWUpO1xuICAgICAgICByb290LnJlZi5maWxlTmFtZSA9IGZpbGVOYW1lO1xuXG4gICAgICAgIC8vIGZpbGVzaXplXG4gICAgICAgIHZhciBmaWxlU2l6ZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgICAgICBmaWxlU2l6ZS5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtaW5mby1zdWInO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGZpbGVTaXplKTtcbiAgICAgICAgcm9vdC5yZWYuZmlsZVNpemUgPSBmaWxlU2l6ZTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgdGV4dChmaWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfV0FJVElOR19GT1JfU0laRScpKTtcbiAgICAgICAgdGV4dChmaWxlTmFtZSwgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSkpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsZSA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgdGV4dChcbiAgICAgICAgICAgIHJvb3QucmVmLmZpbGVTaXplLFxuICAgICAgICAgICAgdG9OYXR1cmFsRmlsZVNpemUoXG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSxcbiAgICAgICAgICAgICAgICAnLicsXG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9CQVNFJyksXG4gICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9MQUJFTFMnLCByb290LnF1ZXJ5KVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRleHQocm9vdC5yZWYuZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGVTaXplT25FcnJvciA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGVTaXplT25FcnJvcihfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAvLyBpZiBzaXplIGlzIGF2YWlsYWJsZSBkb24ndCBmYWxsYmFjayB0byB1bmtub3duIHNpemUgbWVzc2FnZVxuICAgICAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZpbGUoeyByb290OiByb290LCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX05PVF9BVkFJTEFCTEUnKSk7XG4gICAgfTtcblxuICAgIHZhciBmaWxlSW5mbyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZmlsZS1pbmZvJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZUZpbGUsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQTogdXBkYXRlRmlsZSxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgfSksXG5cbiAgICAgICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIHRvUGVyY2VudGFnZSA9IGZ1bmN0aW9uIHRvUGVyY2VudGFnZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkMyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuXG4gICAgICAgIC8vIG1haW4gc3RhdHVzXG4gICAgICAgIHZhciBtYWluID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIG1haW4uY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLXN0YXR1cy1tYWluJztcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChtYWluKTtcbiAgICAgICAgcm9vdC5yZWYubWFpbiA9IG1haW47XG5cbiAgICAgICAgLy8gc3ViIHN0YXR1c1xuICAgICAgICB2YXIgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgICAgIHN1Yi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1Yic7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ViKTtcbiAgICAgICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgICAgIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MoeyByb290OiByb290LCBhY3Rpb246IHsgcHJvZ3Jlc3M6IG51bGwgfSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBkaWRTZXRJdGVtTG9hZFByb2dyZXNzKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgdmFyIHRpdGxlID1cbiAgICAgICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgICAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9MT0FESU5HJykgKyAnICcgKyB0b1BlcmNlbnRhZ2UoYWN0aW9uLnByb2dyZXNzKSArICclJztcblxuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICAgICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkU2V0SXRlbVByb2Nlc3NQcm9ncmVzcyA9IGZ1bmN0aW9uIGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB2YXIgdGl0bGUgPVxuICAgICAgICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSArXG4gICAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcykgK1xuICAgICAgICAgICAgICAgICAgJyUnO1xuXG4gICAgICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gICAgfTtcblxuICAgIHZhciBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZEFib3J0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1JFVFJZJykpO1xuICAgIH07XG5cbiAgICB2YXIgZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQ09NUExFVEUnKSk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1VORE8nKSk7XG4gICAgfTtcblxuICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCAnJyk7XG4gICAgICAgIHRleHQocm9vdC5yZWYuc3ViLCAnJyk7XG4gICAgfTtcblxuICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9yZWY4KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjgucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY4LmFjdGlvbjtcbiAgICAgICAgdGV4dChyb290LnJlZi5tYWluLCBhY3Rpb24uc3RhdHVzLm1haW4pO1xuICAgICAgICB0ZXh0KHJvb3QucmVmLnN1YiwgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICAgIH07XG5cbiAgICB2YXIgZmlsZVN0YXR1cyA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZmlsZS1zdGF0dXMnLFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogY2xlYXIsXG4gICAgICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY2xlYXIsXG4gICAgICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGRpZEFib3J0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MsXG4gICAgICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyxcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGVycm9yLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogZXJyb3IsXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiBlcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogZXJyb3IsXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDMsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gICAgICovXG5cbiAgICB2YXIgQnV0dG9ucyA9IHtcbiAgICAgICAgQWJvcnRJdGVtTG9hZDoge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRCcsXG4gICAgICAgICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLWxvYWQnLFxuICAgICAgICAgICAgYWxpZ246ICdMT0FEX0lORElDQVRPUl9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIFJldHJ5SXRlbUxvYWQ6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX0xPQUQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9SRVRSWScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tbG9hZCcsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZW1vdmVJdGVtOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVNT1ZFX0lURU0nLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVRVUVTVF9SRU1PVkVfSVRFTScsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVNT1ZFJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmVtb3ZlLWl0ZW0nLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nLCAvLyBsZWZ0XG4gICAgICAgIH0sXG4gICAgICAgIFByb2Nlc3NJdGVtOiB7XG4gICAgICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9QUk9DRVNTJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcHJvY2Vzcy1pdGVtJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIEFib3J0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIFJldHJ5SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGljb246ICdHRVRfSUNPTl9SRVRSWScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgICAgICB9LFxuICAgICAgICBSZXZlcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1VORE9fSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICBpY29uOiAnR0VUX0lDT05fVU5ETycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJywgLy8gcmlnaHRcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gbWFrZSBhIGxpc3Qgb2YgYnV0dG9ucywgd2UgY2FuIHRoZW4gcmVtb3ZlIGJ1dHRvbnMgZnJvbSB0aGlzIGxpc3QgaWYgdGhleSdyZSBkaXNhYmxlZFxuICAgIHZhciBCdXR0b25LZXlzID0gW107XG4gICAgZm9yaW4oQnV0dG9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIEJ1dHRvbktleXMucHVzaChrZXkpO1xuICAgIH0pO1xuXG4gICAgdmFyIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQocm9vdCkge1xuICAgICAgICBpZiAoZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkgPT09ICdyaWdodCcpIHJldHVybiAwO1xuICAgICAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gYnV0dG9uUmVjdC5oaWRkZW4gPyBudWxsIDogYnV0dG9uUmVjdC53aWR0aCArIGJ1dHRvblJlY3QubGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZUJ1dHRvbldpZHRoID0gZnVuY3Rpb24gY2FsY3VsYXRlQnV0dG9uV2lkdGgocm9vdCkge1xuICAgICAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQucmVjdC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gYnV0dG9uUmVjdC53aWR0aDtcbiAgICB9O1xuXG4gICAgLy8gRm9yY2Ugb24gZnVsbCBwaXhlbHMgc28gdGV4dCBzdGF5cyBjcmlwc1xuICAgIHZhciBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQocm9vdCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudC5oZWlnaHQgLyA0KTtcbiAgICB9O1xuICAgIHZhciBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0KHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQubGVmdCAvIDIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyk7XG4gICAgfTtcbiAgICB2YXIgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuICAgIH07XG4gICAgdmFyIGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50ID0gZnVuY3Rpb24gZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicpO1xuICAgIH07XG5cbiAgICB2YXIgRGVmYXVsdFN0eWxlID0ge1xuICAgICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV0cnlJdGVtTG9hZDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgfSxcbiAgICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgICAgIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvcjogeyBvcGFjaXR5OiAwLCBzY2FsZVg6IDAuNzUsIHNjYWxlWTogMC43NSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICB9O1xuXG4gICAgdmFyIElkbGVTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICB9O1xuXG4gICAgdmFyIFByb2Nlc3NpbmdTdHlsZSA9IHtcbiAgICAgICAgYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfTtcblxuICAgIHZhciBTdHlsZU1hcCA9IHtcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDoge1xuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9MT0FEOiB7XG4gICAgICAgICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGxvYWRQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRToge1xuICAgICAgICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDEsIGFsaWduOiBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudCB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IHtcbiAgICAgICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAwLCBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgfSxcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEsIHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgRElEX0xPQURfSVRFTTogSWRsZVN0eWxlLFxuICAgICAgICBESURfTE9BRF9MT0NBTF9JVEVNOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjoge1xuICAgICAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogSWRsZVN0eWxlLFxuICAgIH07XG5cbiAgICAvLyBjb21wbGV0ZSBpbmRpY2F0b3Igdmlld1xuICAgIHZhciBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IHJvb3QucXVlcnkoJ0dFVF9JQ09OX0RPTkUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogJ3Byb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9yJyxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuICAgIHZhciBjcmVhdGUkNCA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgICAgICAvLyBjb3B5IEJ1dHRvbnMgb2JqZWN0XG4gICAgICAgIHZhciBMb2NhbEJ1dHRvbnMgPSBPYmplY3Qua2V5cyhCdXR0b25zKS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICAgICAgcHJldltjdXJyXSA9IE9iamVjdC5hc3NpZ24oe30sIEJ1dHRvbnNbY3Vycl0pO1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgICAgICB2YXIgYWxsb3dSZXZlcnQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVWRVJUJyk7XG5cbiAgICAgICAgLy8gYWxsb3cgcmVtb3ZlIGZpbGVcbiAgICAgICAgdmFyIGFsbG93UmVtb3ZlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFTU9WRScpO1xuXG4gICAgICAgIC8vIGFsbG93IHByb2Nlc3NpbmcgdXBsb2FkXG4gICAgICAgIHZhciBhbGxvd1Byb2Nlc3MgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUFJPQ0VTUycpO1xuXG4gICAgICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgICAgICB2YXIgaW5zdGFudFVwbG9hZCA9IHJvb3QucXVlcnkoJ0dFVF9JTlNUQU5UX1VQTE9BRCcpO1xuXG4gICAgICAgIC8vIGlzIGFzeW5jIHNldCB1cFxuICAgICAgICB2YXIgaXNBc3luYyA9IHJvb3QucXVlcnkoJ0lTX0FTWU5DJyk7XG5cbiAgICAgICAgLy8gc2hvdWxkIGFsaWduIHJlbW92ZSBpdGVtIGJ1dHRvbnNcbiAgICAgICAgdmFyIGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiA9IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fQUxJR04nKTtcblxuICAgICAgICAvLyBlbmFibGVkIGJ1dHRvbnMgYXJyYXlcbiAgICAgICAgdmFyIGJ1dHRvbkZpbHRlcjtcbiAgICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcmV2ZXJ0IGJ1dHRvblxuICAgICAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEvUmV2ZXJ0SXRlbVByb2Nlc3NpbmcvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcHJvY2VzcyBidXR0b25cbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3NJdGVtfFJldHJ5SXRlbVByb2Nlc3Npbmd8QWJvcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBwcm9jZXNzIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gcHJvY2VzcyBjb250cm9scyBhdmFpbGFibGVcbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuYWJsZWRCdXR0b25zID0gYnV0dG9uRmlsdGVyID8gQnV0dG9uS2V5cy5maWx0ZXIoYnV0dG9uRmlsdGVyKSA6IEJ1dHRvbktleXMuY29uY2F0KCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGljb24gYW5kIGxhYmVsIGZvciByZXZlcnQgYnV0dG9uIHdoZW4gaW5zdGFudCB1cGxvYWRpbmdcbiAgICAgICAgaWYgKGluc3RhbnRVcGxvYWQgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5sYWJlbCA9ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJztcbiAgICAgICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5pY29uID0gJ0dFVF9JQ09OX1JFTU9WRSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBidXR0b24gKHJldmVydCkgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGFsaWduIGNlbnRlclxuICAgICAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dQcm9jZXNzKSB7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0RJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgICAgICdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgICAgICdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsXG4gICAgICAgICAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFN0eWxlTWFwW2tleV0uc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFN0eWxlTWFwWydESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJ10uc3RhdHVzLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVCdXR0b25XaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdmUgcmVtb3ZlIGJ1dHRvbiB0byByaWdodFxuICAgICAgICBpZiAoYWxpZ25SZW1vdmVJdGVtQnV0dG9uICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10uYWxpZ24gPSAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJztcbiAgICAgICAgICAgIHZhciBfbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgICAgIF9tYXAuaW5mby50cmFuc2xhdGVYID0gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQ7XG4gICAgICAgICAgICBfbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICAgICAgX21hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG93L2hpZGUgUmVtb3ZlSXRlbSBidXR0b25cbiAgICAgICAgaWYgKCFhbGxvd1JlbW92ZSkge1xuICAgICAgICAgICAgTG9jYWxCdXR0b25zWydSZW1vdmVJdGVtJ10uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBidXR0b24gdmlld3NcbiAgICAgICAgZm9yaW4oTG9jYWxCdXR0b25zLCBmdW5jdGlvbihrZXksIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgICAgICAgIHZhciBidXR0b25WaWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUFjdGlvbkJ1dHRvbiwge1xuICAgICAgICAgICAgICAgIGxhYmVsOiByb290LnF1ZXJ5KGRlZmluaXRpb24ubGFiZWwpLFxuICAgICAgICAgICAgICAgIGljb246IHJvb3QucXVlcnkoZGVmaW5pdGlvbi5pY29uKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhcHBlbmRlZD9cbiAgICAgICAgICAgIGlmIChlbmFibGVkQnV0dG9ucy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvZ2dsZVxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHBvc2l0aW9uIGF0dHJpYnV0ZVxuICAgICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KCdHRVRfU1RZTEVfJyArIGRlZmluaXRpb24uYWxpZ24pO1xuXG4gICAgICAgICAgICAvLyBhZGQgY2xhc3NcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGRlZmluaXRpb24uY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goZGVmaW5pdGlvbi5hY3Rpb24sIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNldCByZWZlcmVuY2VcbiAgICAgICAgICAgIHJvb3QucmVmWydidXR0b24nICsga2V5XSA9IGJ1dHRvblZpZXc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrbWFya1xuICAgICAgICByb290LnJlZi5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcpXG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yLmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgICAgICAnR0VUX1NUWUxFX0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGZpbGUgaW5mbyB2aWV3XG4gICAgICAgIHJvb3QucmVmLmluZm8gPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlSW5mbywgeyBpZDogaWQgfSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBmaWxlIHN0YXR1cyB2aWV3XG4gICAgICAgIHJvb3QucmVmLnN0YXR1cyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVTdGF0dXMsIHsgaWQ6IGlkIH0pKTtcblxuICAgICAgICAvLyBhZGQgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgICB2YXIgbG9hZEluZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyksXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGxvYWRJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWxvYWQtaW5kaWNhdG9yJyk7XG4gICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvciA9IGxvYWRJbmRpY2F0b3JWaWV3O1xuXG4gICAgICAgIHZhciBwcm9ncmVzc0luZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yID0gcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3O1xuXG4gICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHN0eWxlc1xuICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDIgPSBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjMuYWN0aW9ucyxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUoeyByb290OiByb290LCBhY3Rpb25zOiBhY3Rpb25zLCBwcm9wczogcHJvcHMgfSk7XG5cbiAgICAgICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHlsZU1hcFthY3Rpb24udHlwZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGRlZmluZSBuZXcgYWN0aXZlIHN0eWxlc1xuICAgICAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG5cbiAgICAgICAgICAgIHZhciBzdHlsZXNUb0FwcGx5ID0gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICAgICAgZm9yaW4oRGVmYXVsdFN0eWxlLCBmdW5jdGlvbihuYW1lLCBkZWZhdWx0U3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSByb290LnJlZltuYW1lXTtcblxuICAgICAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgc3R5bGVzIGZvciB0aGlzIGNvbnRyb2xcbiAgICAgICAgICAgICAgICBmb3JpbihkZWZhdWx0U3R5bGVzLCBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzVG9BcHBseVtuYW1lXSAmJiB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5wdXNoKHsgY29udHJvbDogY29udHJvbCwga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYWN0aXZlIHN0eWxlcyB0byBlbGVtZW50XG4gICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IF9yZWY0LmNvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5ID0gX3JlZjQua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3JlZjQudmFsdWU7XG4gICAgICAgICAgICBjb250cm9sW2tleV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShyb290KSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORyhcbiAgICAgICAgICAgIF9yZWY1XG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgICAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVByb2Nlc3NpbmcubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRDogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1JFTU9WQUwoXG4gICAgICAgICAgICBfcmVmN1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1SZW1vdmFsLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORyhfcmVmOCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogZnVuY3Rpb24gRElEX1NUQVJUX0lURU1fTE9BRChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiBmdW5jdGlvbiBESURfU1RBUlRfSVRFTV9SRU1PVkUoX3JlZjEwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTKF9yZWYxMSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTEucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMTEuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTKF9yZWYxMikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTIucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMTIuYWN0aW9uO1xuICAgICAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciBmaWxlID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJDQsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQyLFxuICAgICAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAnZmlsZScsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlJDUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICAvLyBmaWxlbmFtZVxuICAgICAgICByb290LnJlZi5maWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnbGVnZW5kJyk7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmlsZU5hbWUpO1xuXG4gICAgICAgIC8vIGZpbGUgYXBwZW5kZWRcbiAgICAgICAgcm9vdC5yZWYuZmlsZSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGUsIHsgaWQ6IHByb3BzLmlkIH0pKTtcblxuICAgICAgICAvLyBkYXRhIGhhcyBtb3ZlZCB0byBkYXRhLmpzXG4gICAgICAgIHJvb3QucmVmLmRhdGEgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBzdG9yYWdlXG4gICAgICovXG4gICAgdmFyIGRpZExvYWRJdGVtID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgICAgICB0ZXh0KHJvb3QucmVmLmZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gICAgfTtcblxuICAgIHZhciBmaWxlV3JhcHBlciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ1LFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0sXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICAgICAgbmFtZTogJ2ZpbGUtd3JhcHBlcicsXG4gICAgfSk7XG5cbiAgICB2YXIgUEFORUxfU1BSSU5HX1BST1BTID0geyB0eXBlOiAnc3ByaW5nJywgZGFtcGluZzogMC42LCBtYXNzOiA3IH07XG5cbiAgICB2YXIgY3JlYXRlJDYgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWTogUEFORUxfU1BSSU5HX1BST1BTLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICAgICAgY3JlYXRlU2VjdGlvbihyb290LCBzZWN0aW9uLCBwcm9wcy5uYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS0nICsgcHJvcHMubmFtZSk7XG5cbiAgICAgICAgcm9vdC5yZWYuc2NhbGFibGUgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciB2aWV3Q29uc3RydWN0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgICAgIG5hbWU6ICdwYW5lbC0nICsgc2VjdGlvbi5uYW1lICsgJyBmaWxlcG9uZC0tJyArIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIG1peGluczogc2VjdGlvbi5taXhpbnMsXG4gICAgICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHZpZXdDb25zdHJ1Y3Rvciwgc2VjdGlvbi5wcm9wcyk7XG5cbiAgICAgICAgcm9vdC5yZWZbc2VjdGlvbi5uYW1lXSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHZpZXcpO1xuICAgIH07XG5cbiAgICB2YXIgd3JpdGUkMyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG5cbiAgICAgICAgLy8gdXBkYXRlIHNjYWxhYmxlIHN0YXRlXG4gICAgICAgIGlmIChyb290LnJlZi5zY2FsYWJsZSA9PT0gbnVsbCB8fCBwcm9wcy5zY2FsYWJsZSAhPT0gcm9vdC5yZWYuc2NhbGFibGUpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gaXNCb29sZWFuKHByb3BzLnNjYWxhYmxlKSA/IHByb3BzLnNjYWxhYmxlIDogdHJ1ZTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoZWlnaHQsIGNhbid0IHNldFxuICAgICAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBjaGlsZCByZWN0c1xuICAgICAgICB2YXIgdG9wUmVjdCA9IHJvb3QucmVmLnRvcC5yZWN0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBib3R0b21SZWN0ID0gcm9vdC5yZWYuYm90dG9tLnJlY3QuZWxlbWVudDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgaGVpZ2h0IG5ldmVyIGlzIHNtYWxsZXIgdGhhbiBib3R0b20gYW5kIHRvcCBzZWNpdG9uIGhlaWdodHMgY29tYmluZWQgKHdpbGwgcHJvYmFibHkgbmV2ZXIgaGFwcGVuLCBidXQgd2hvIGtub3dzKVxuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgodG9wUmVjdC5oZWlnaHQgKyBib3R0b21SZWN0LmhlaWdodCwgcHJvcHMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICAgICAgcm9vdC5yZWYuY2VudGVyLnRyYW5zbGF0ZVkgPSB0b3BSZWN0LmhlaWdodDtcblxuICAgICAgICAvLyBzY2FsZSBjZW50ZXIgcGFydFxuICAgICAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICAgICAgcm9vdC5yZWYuY2VudGVyLnNjYWxlWSA9IChoZWlnaHQgLSB0b3BSZWN0LmhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0KSAvIDEwMDtcblxuICAgICAgICAvLyBvZmZzZXQgYm90dG9tIHBhcnRcbiAgICAgICAgcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkgPSBoZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdwYW5lbCcsXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAgICAgcmV0dXJuIChwcm9wcy5oZWlnaHRDdXJyZW50ID0gcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogd3JpdGUkMyxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkNixcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICBhcGlzOiBbJ2hlaWdodCcsICdoZWlnaHRDdXJyZW50JywgJ3NjYWxhYmxlJ10sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlRHJhZ0hlbHBlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdIZWxwZXIoaXRlbXMpIHtcbiAgICAgICAgdmFyIGl0ZW1JZHMgPSBpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SW5kZXg6IGZ1bmN0aW9uIHNldEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbUluZGV4OiBmdW5jdGlvbiBnZXRJdGVtSW5kZXgoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtSWRzLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgSVRFTV9UUkFOU0xBVEVfU1BSSU5HID0ge1xuICAgICAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICAgICAgc3RpZmZuZXNzOiAwLjc1LFxuICAgICAgICBkYW1waW5nOiAwLjQ1LFxuICAgICAgICBtYXNzOiAxMCxcbiAgICB9O1xuXG4gICAgdmFyIElURU1fU0NBTEVfU1BSSU5HID0gJ3NwcmluZyc7XG5cbiAgICB2YXIgU3RhdGVNYXAgPSB7XG4gICAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6ICdidXN5JyxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogJ2xvYWQtaW52YWxpZCcsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6ICdsb2FkLWVycm9yJyxcbiAgICAgICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6ICdyZW1vdmUtZXJyb3InLFxuICAgICAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6ICdidXN5JyxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiAncHJvY2Vzc2luZycsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogJ3Byb2Nlc3NpbmctZXJyb3InLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogJ3Byb2Nlc3NpbmctcmV2ZXJ0LWVycm9yJyxcbiAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiAnaWRsZScsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgICAqL1xuICAgIHZhciBjcmVhdGUkNyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIC8vIHNlbGVjdFxuICAgICAgICByb290LnJlZi5oYW5kbGVDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByb290LmRpc3BhdGNoKCdESURfQUNUSVZBVEVfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCBpZFxuICAgICAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWl0ZW0tJyArIHByb3BzLmlkO1xuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAgICAgLy8gZmlsZSB2aWV3XG4gICAgICAgIHJvb3QucmVmLmNvbnRhaW5lciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZVdyYXBwZXIsIHsgaWQ6IHByb3BzLmlkIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZmlsZSBwYW5lbFxuICAgICAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHBhbmVsLCB7IG5hbWU6ICdpdGVtLXBhbmVsJyB9KSk7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBzdGFydCBoZWlnaHRcbiAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcblxuICAgICAgICAvLyBieSBkZWZhdWx0IG5vdCBtYXJrZWQgZm9yIHJlbW92YWxcbiAgICAgICAgcHJvcHMubWFya2VkRm9yUmVtb3ZhbCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIG5vdCBhbGxvd2VkIHRvIHJlb3JkZXIgZmlsZSBpdGVtcywgZXhpdCBoZXJlXG4gICAgICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFT1JERVInKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldCB0byBpZGxlIHNvIHNob3dzIGdyYWIgY3Vyc29yXG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcblxuICAgICAgICB2YXIgZ3JhYiA9IGZ1bmN0aW9uIGdyYWIoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IGUucGFnZVksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0ge1xuICAgICAgICAgICAgICAgIHg6IHJvb3QudHJhbnNsYXRlWCxcbiAgICAgICAgICAgICAgICB5OiByb290LnRyYW5zbGF0ZVksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnQ2VudGVyID0ge1xuICAgICAgICAgICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICB5OiBlLm9mZnNldFksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZHJhZ1N0YXRlID0gY3JlYXRlRHJhZ0hlbHBlcihyb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykpO1xuXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfR1JBQl9JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZTogZHJhZ1N0YXRlIH0pO1xuXG4gICAgICAgICAgICB2YXIgZHJhZyA9IGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgICAgICAgICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGRyYWdnZWQgc3RvcCBsaXN0ZW5pbmcgdG8gY2xpY2tzLCB3aWxsIHJlLWFkZCB3aGVuIGRvbmUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQueCAqIHByb3BzLmRyYWdPZmZzZXQueCArXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQueSAqIHByb3BzLmRyYWdPZmZzZXQueTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDE2ICYmICFyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJBR19JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZTogZHJhZ1N0YXRlIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuXG4gICAgICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgZ3JhYik7XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSQxID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfVVBEQVRFX1BBTkVMX0hFSUdIVDogZnVuY3Rpb24gRElEX1VQREFURV9QQU5FTF9IRUlHSFQoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICAgICAgICByb290LmhlaWdodCA9IGFjdGlvbi5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgd3JpdGUkNCA9IGNyZWF0ZVJvdXRlKFxuICAgICAgICB7XG4gICAgICAgICAgICBESURfR1JBQl9JVEVNOiBmdW5jdGlvbiBESURfR1JBQl9JVEVNKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJvb3QudHJhbnNsYXRlWCxcbiAgICAgICAgICAgICAgICAgICAgeTogcm9vdC50cmFuc2xhdGVZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRElEX0RSQUdfSVRFTTogZnVuY3Rpb24gRElEX0RSQUdfSVRFTShfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJhZyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRElEX0RST1BfSVRFTTogZnVuY3Rpb24gRElEX0RST1BfSVRFTShfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJvcCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNi5hY3Rpb25zLFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjYucHJvcHMsXG4gICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmNi5zaG91bGRPcHRpbWl6ZTtcblxuICAgICAgICAgICAgaWYgKHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3Quc2NhbGVYIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgICAgICAgICAuY29uY2F0KClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAuZmluZChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0YXRlTWFwW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBzZXQgc2FtZSBzdGF0ZSB0d2ljZVxuICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSAhPT0gcHJvcHMuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBwcm9wcy5jdXJyZW50U3RhdGUgPSBhY3Rpb24udHlwZTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBzdGF0ZVxuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmZpbGVwb25kSXRlbVN0YXRlID0gU3RhdGVNYXBbcHJvcHMuY3VycmVudFN0YXRlXSB8fCAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICAgICAgdmFyIGFzcGVjdFJhdGlvID1cbiAgICAgICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKSB8fCByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgICAgICBpZiAoIWFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgcm91dGUkMSh7IHJvb3Q6IHJvb3QsIGFjdGlvbnM6IGFjdGlvbnMsIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QuaGVpZ2h0ICYmIHJvb3QucmVmLmNvbnRhaW5lci5yZWN0LmVsZW1lbnQuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IHJvb3QucmVmLmNvbnRhaW5lci5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzeW5jIHBhbmVsIGhlaWdodCB3aXRoIGl0ZW0gaGVpZ2h0XG4gICAgICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSByb290LmhlaWdodDtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgaXRlbSA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ3LFxuICAgICAgICB3cml0ZTogd3JpdGUkNCxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmNykge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICAgICAgICAgIHByb3BzID0gX3JlZjcucHJvcHM7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdSRUxFQVNFX0lURU0nLCB7IHF1ZXJ5OiBwcm9wcy5pZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFnOiAnbGknLFxuICAgICAgICBuYW1lOiAnaXRlbScsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgYXBpczogW1xuICAgICAgICAgICAgICAgICdpZCcsXG4gICAgICAgICAgICAgICAgJ2ludGVyYWN0aW9uTWV0aG9kJyxcbiAgICAgICAgICAgICAgICAnbWFya2VkRm9yUmVtb3ZhbCcsXG4gICAgICAgICAgICAgICAgJ3NwYXduRGF0ZScsXG4gICAgICAgICAgICAgICAgJ2RyYWdDZW50ZXInLFxuICAgICAgICAgICAgICAgICdkcmFnT3JpZ2luJyxcbiAgICAgICAgICAgICAgICAnZHJhZ09mZnNldCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknLCAnaGVpZ2h0J10sXG5cbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogSVRFTV9TQ0FMRV9TUFJJTkcsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IElURU1fVFJBTlNMQVRFX1NQUklORyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAxNTAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0SXRlbXNQZXJSb3cgPSBmdW5jdGlvbihob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCkge1xuICAgICAgICAvLyBhZGQgb25lIHBpeGVsIGxlZXdheSwgd2hlbiB1c2luZyBwZXJjZW50YWdlcyBmb3IgaXRlbSB3aWR0aCB0b3RhbCBpdGVtcyBjYW4gYmUgMS45OSBwZXIgcm93XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKGhvcml6b250YWxTcGFjZSArIDEpIC8gaXRlbVdpZHRoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbih2aWV3LCBjaGlsZHJlbiwgcG9zaXRpb25JblZpZXcpIHtcbiAgICAgICAgaWYgKCFwb3NpdGlvbkluVmlldykgcmV0dXJuO1xuXG4gICAgICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSB2aWV3LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgLy8gY29uc3QgY2hpbGRyZW4gPSB2aWV3LmNoaWxkVmlld3M7XG4gICAgICAgIHZhciBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gLTEsIGRvbid0IG1vdmUgaXRlbXMgdG8gYWNjb21vZGF0ZSAoZWl0aGVyIGFkZCB0byB0b3Agb3IgYm90dG9tKVxuICAgICAgICBpZiAobCA9PT0gMCB8fCBwb3NpdGlvbkluVmlldy50b3AgPCBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQudG9wKSByZXR1cm4gLTE7XG5cbiAgICAgICAgLy8gbGV0J3MgZ2V0IHRoZSBpdGVtIHdpZHRoXG4gICAgICAgIHZhciBpdGVtID0gY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBpdGVtUmVjdCA9IGl0ZW0ucmVjdC5lbGVtZW50O1xuICAgICAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5MZWZ0ICsgaXRlbVJlY3QubWFyZ2luUmlnaHQ7XG4gICAgICAgIHZhciBpdGVtV2lkdGggPSBpdGVtUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAgICAgLy8gc3RhY2tcbiAgICAgICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRNaWQgPSBjaGlsZC5yZWN0Lm91dGVyLnRvcCArIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkTWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdyaWRcbiAgICAgICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGl0ZW1SZWN0Lm1hcmdpblRvcCArIGl0ZW1SZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBpdGVtUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgIGZvciAodmFyIF9pbmRleCA9IDA7IF9pbmRleCA8IGw7IF9pbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhYID0gX2luZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICAgICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcihfaW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgaXRlbVRvcCA9IG9mZnNldFkgLSBpdGVtUmVjdC5tYXJnaW5Ub3A7XG4gICAgICAgICAgICB2YXIgaXRlbVJpZ2h0ID0gb2Zmc2V0WCArIGl0ZW1XaWR0aDtcbiAgICAgICAgICAgIHZhciBpdGVtQm90dG9tID0gb2Zmc2V0WSArIGl0ZW1IZWlnaHQgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkluVmlldy50b3AgPCBpdGVtQm90dG9tICYmIHBvc2l0aW9uSW5WaWV3LnRvcCA+IGl0ZW1Ub3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JblZpZXcubGVmdCA8IGl0ZW1SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luZGV4ICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gX2luZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsO1xuICAgIH07XG5cbiAgICB2YXIgZHJvcEFyZWFEaW1lbnNpb25zID0ge1xuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBnZXQgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQgc2V0SGVpZ2h0KHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy5oZWlnaHQgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgc2V0V2lkdGgodmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMud2lkdGggPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uIHNldERpbWVuc2lvbnMoaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IGhlaWdodCA9PT0gMCkgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB3aWR0aCA9PT0gMCkgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJDggPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgICAgLy8gbmVlZCB0byBzZXQgcm9sZSB0byBsaXN0IGFzIG90aGVyd2lzZSBpdCB3b24ndCBiZSByZWFkIGFzIGEgbGlzdCBieSBWb2ljZU92ZXJcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2xpc3QnKTtcblxuICAgICAgICByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZSA9IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbVxuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGFjdGlvblxuICAgICAqL1xuICAgIHZhciBhZGRJdGVtVmlldyA9IGZ1bmN0aW9uIGFkZEl0ZW1WaWV3KF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgICAgICAgaW5kZXggPSBhY3Rpb24uaW5kZXgsXG4gICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IGFjdGlvbi5pbnRlcmFjdGlvbk1ldGhvZDtcblxuICAgICAgICByb290LnJlZi5hZGRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgc3Bhd25EYXRlID0gbm93O1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDE7XG5cbiAgICAgICAgaWYgKGludGVyYWN0aW9uTWV0aG9kICE9PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIHZhciBjb29sZG93biA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9JTlRFUlZBTCcpO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBub3cgLSByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZTtcbiAgICAgICAgICAgIHNwYXduRGF0ZSA9IGRpc3QgPCBjb29sZG93biA/IG5vdyArIChjb29sZG93biAtIGRpc3QpIDogbm93O1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGUgPSBzcGF3bkRhdGU7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgICAgICAvLyB2aWV3IHR5cGVcbiAgICAgICAgICAgICAgICBpdGVtLFxuXG4gICAgICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNwYXduRGF0ZTogc3Bhd25EYXRlLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgbW92ZUl0ZW0gPSBmdW5jdGlvbiBtb3ZlSXRlbShpdGVtLCB4LCB5KSB7XG4gICAgICAgIHZhciB2eCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgICAgdmFyIHZ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxO1xuICAgICAgICAvLyBzZXQgdG8gbnVsbCB0byByZW1vdmUgYW5pbWF0aW9uIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgIGlmIChpdGVtLmRyYWdPZmZzZXQpIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gaXRlbS5kcmFnT3JpZ2luLnggKyBpdGVtLmRyYWdPZmZzZXQueDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IGl0ZW0uZHJhZ09yaWdpbi55ICsgaXRlbS5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDEuMDI1O1xuICAgICAgICAgICAgaXRlbS5zY2FsZVkgPSAxLjAyNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuXG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGl0ZW0uc3Bhd25EYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgaXMgZGVmYXVsdCBzY2FsZSBldmVyeSBmcmFtZVxuICAgICAgICAgICAgICAgIGl0ZW0uc2NhbGVYID0gMTtcbiAgICAgICAgICAgICAgICBpdGVtLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICAgICAgaXRlbS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaW50cm9JdGVtVmlldyA9IGZ1bmN0aW9uIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KSB7XG4gICAgICAgIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkRST1ApIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gdnggKiAyMDtcblxuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSB2eSAqIDEwO1xuXG4gICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDAuODtcbiAgICAgICAgICAgIGl0ZW0uc2NhbGVZID0gMC44O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSAzMDtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gMzA7XG4gICAgICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgaXRlbVxuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGFjdGlvblxuICAgICAqL1xuICAgIHZhciByZW1vdmVJdGVtVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1WaWV3KF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdmFyIGlkID0gYWN0aW9uLmlkO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICAgICAgdmFyIHZpZXcgPSByb290LmNoaWxkVmlld3MuZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFuaW1hdGUgdmlldyBvdXQgb2Ygdmlld1xuICAgICAgICB2aWV3LnNjYWxlWCA9IDAuOTtcbiAgICAgICAgdmlldy5zY2FsZVkgPSAwLjk7XG4gICAgICAgIHZpZXcub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgLy8gbWFyayBmb3IgcmVtb3ZhbFxuICAgICAgICB2aWV3Lm1hcmtlZEZvclJlbW92YWwgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbUhlaWdodCA9IGZ1bmN0aW9uIGdldEl0ZW1IZWlnaHQoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbSAqIDAuNSArXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICogMC41XG4gICAgICAgICk7XG4gICAgfTtcbiAgICB2YXIgZ2V0SXRlbVdpZHRoID0gZnVuY3Rpb24gZ2V0SXRlbVdpZHRoKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjaGlsZC5yZWN0LmVsZW1lbnQud2lkdGggK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkxlZnQgKiAwLjUgK1xuICAgICAgICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0ICogMC41XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkcmFnSXRlbSA9IGZ1bmN0aW9uIGRyYWdJdGVtKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICAgICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgICAgICAgZHJhZ1N0YXRlID0gYWN0aW9uLmRyYWdTdGF0ZTtcblxuICAgICAgICAvLyByZWZlcmVuY2UgdG8gaXRlbVxuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogaWQgfSk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgICAgICB2YXIgdmlldyA9IHJvb3QuY2hpbGRWaWV3cy5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGlkO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbnVtSXRlbXMgPSByb290LmNoaWxkVmlld3MubGVuZ3RoO1xuICAgICAgICB2YXIgb2xkSW5kZXggPSBkcmFnU3RhdGUuZ2V0SXRlbUluZGV4KGl0ZW0pO1xuXG4gICAgICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm47XG5cbiAgICAgICAgdmFyIGRyYWdQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHZpZXcuZHJhZ09yaWdpbi54ICsgdmlldy5kcmFnT2Zmc2V0LnggKyB2aWV3LmRyYWdDZW50ZXIueCxcbiAgICAgICAgICAgIHk6IHZpZXcuZHJhZ09yaWdpbi55ICsgdmlldy5kcmFnT2Zmc2V0LnkgKyB2aWV3LmRyYWdDZW50ZXIueSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgZHJhZyBhcmVhIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgICAgICB2YXIgZHJhZ1dpZHRoID0gZ2V0SXRlbVdpZHRoKHZpZXcpO1xuXG4gICAgICAgIC8vIGdldCByb3dzIGFuZCBjb2x1bW5zIChUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgcm93IGFuZCBvbmUgY29sdW1uIGlmIGEgZmlsZSBpcyBwcmVzZW50KVxuICAgICAgICB2YXIgY29scyA9IE1hdGguZmxvb3Iocm9vdC5yZWN0Lm91dGVyLndpZHRoIC8gZHJhZ1dpZHRoKTtcbiAgICAgICAgaWYgKGNvbHMgPiBudW1JdGVtcykgY29scyA9IG51bUl0ZW1zO1xuXG4gICAgICAgIC8vIHJvd3MgYXJlIHVzZWQgdG8gZmluZCB3aGVuIHdlIGhhdmUgbGVmdCB0aGUgcHJldmlldyBhcmVhIGJvdW5kaW5nIGJveFxuICAgICAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IobnVtSXRlbXMgLyBjb2xzICsgMSk7XG5cbiAgICAgICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldEhlaWdodCA9IGRyYWdIZWlnaHQgKiByb3dzO1xuICAgICAgICBkcm9wQXJlYURpbWVuc2lvbnMuc2V0V2lkdGggPSBkcmFnV2lkdGggKiBjb2xzO1xuXG4gICAgICAgIC8vIGdldCBuZXcgaW5kZXggb2YgZHJhZ2dlZCBpdGVtXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnkgLyBkcmFnSGVpZ2h0KSxcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnggLyBkcmFnV2lkdGgpLFxuICAgICAgICAgICAgZ2V0R3JpZEluZGV4OiBmdW5jdGlvbiBnZXRHcmlkSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueSA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi54ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldFdpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi54IDwgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKiBjb2xzICsgdGhpcy54O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbEluZGV4OiBmdW5jdGlvbiBnZXRDb2xJbmRleCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmlldy5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gY2hpbGRyZW4uZmluZEluZGV4KGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gdmlldztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0hlaWdodCA9IGdldEl0ZW1IZWlnaHQodmlldyk7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGw7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRCb3R0b20gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUb3AgPSBjaGlsZEJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCb3R0b20gPSBjaGlsZFRvcCArIGNoaWxkSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZEJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZFRvcCArIGRyYWdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBuZXcgaW5kZXhcbiAgICAgICAgdmFyIGluZGV4ID0gY29scyA+IDEgPyBsb2NhdGlvbi5nZXRHcmlkSW5kZXgoKSA6IGxvY2F0aW9uLmdldENvbEluZGV4KCk7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHZpZXcsIGluZGV4OiBpbmRleCB9KTtcblxuICAgICAgICAvLyBpZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gY2hhbmdlZCwgZGlzcGF0Y2ggcmVvcmRlciBhY3Rpb25cbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGRyYWdTdGF0ZS5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICBkcmFnU3RhdGUuc2V0SW5kZXgoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFT1JERVJfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9sZEluZGV4LFxuICAgICAgICAgICAgICAgIHRhcmdldDogaW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhY3Rpb24gcm91dGVzXG4gICAgICovXG4gICAgdmFyIHJvdXRlJDIgPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9BRERfSVRFTTogYWRkSXRlbVZpZXcsXG4gICAgICAgIERJRF9SRU1PVkVfSVRFTTogcmVtb3ZlSXRlbVZpZXcsXG4gICAgICAgIERJRF9EUkFHX0lURU06IGRyYWdJdGVtLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gdmlld1xuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIGFjdGlvbnNcbiAgICAgKiBAcGFyYW0gcHJvcHNcbiAgICAgKi9cbiAgICB2YXIgd3JpdGUkNSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICAgICAgICBhY3Rpb25zID0gX3JlZjUuYWN0aW9ucyxcbiAgICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjUuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUkMih7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcbiAgICAgICAgdmFyIGRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgICAgICAvLyBhdmFpbGFibGUgc3BhY2Ugb24gaG9yaXpvbnRhbCBheGlzXG4gICAgICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcblxuICAgICAgICAvLyBvbmx5IGRyYXcgY2hpbGRyZW4gdGhhdCBoYXZlIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzb3J0IGJhc2VkIG9uIGN1cnJlbnQgYWN0aXZlIGl0ZW1zXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHJvb3RcbiAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4XG4gICAgICAgIHZhciBkcmFnSW5kZXggPSBkcmFnQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgID8gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihyb290LCBjaGlsZHJlbiwgZHJhZ0Nvb3JkaW5hdGVzKVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIC8vIGFkZCBpbmRleCBpcyB1c2VkIHRvIHJlc2VydmUgdGhlIGRyb3BwZWQvYWRkZWQgaXRlbSBpbmRleCB0aWxsIHRoZSBhY3R1YWwgaXRlbSBpcyByZW5kZXJlZFxuICAgICAgICB2YXIgYWRkSW5kZXggPSByb290LnJlZi5hZGRJbmRleCB8fCBudWxsO1xuXG4gICAgICAgIC8vIGFkZCBpbmRleCBubyBsb25nZXIgbmVlZGVkIHRpbGwgcG9zc2libHkgbmV4dCBkcmF3XG4gICAgICAgIHJvb3QucmVmLmFkZEluZGV4ID0gbnVsbDtcblxuICAgICAgICB2YXIgZHJhZ0luZGV4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHJlbW92ZUluZGV4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGFkZEluZGV4T2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkcmVuWzBdLnJlY3QuZWxlbWVudDtcbiAgICAgICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgICAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcbiAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgIHZhciBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgICAgICAvLyBzdGFja1xuICAgICAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHZhciBkcmFnT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gaW5kZXggLSBkcmFnSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IC1pdGVtVmVydGljYWxNYXJnaW4gKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5tYXJrZWRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVJdGVtKGNoaWxkLCAwLCBvZmZzZXRZICsgZHJhZ09mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc3VhbEhlaWdodCA9IGl0ZW1IZWlnaHQgKiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCA/IGNoaWxkLm9wYWNpdHkgOiAxKTtcblxuICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gdmlzdWFsSGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ3JpZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2WCA9IDA7XG4gICAgICAgICAgICB2YXIgcHJldlkgPSAwO1xuXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZHJhZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdJbmRleE9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBhZGRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRJbmRleE9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5tYXJrZWRGb3JSZW1vdmFsICYmIGNoaWxkLm9wYWNpdHkgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSW5kZXhPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzdWFsSW5kZXggPSBpbmRleCArIGFkZEluZGV4T2Zmc2V0ICsgZHJhZ0luZGV4T2Zmc2V0ICsgcmVtb3ZlSW5kZXhPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhYID0gdmlzdWFsSW5kZXggJSBpdGVtc1BlclJvdztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcih2aXN1YWxJbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gaW5kZXhZICogaXRlbUhlaWdodDtcblxuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3JYID0gTWF0aC5zaWduKG9mZnNldFggLSBwcmV2WCk7XG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvclkgPSBNYXRoLnNpZ24ob2Zmc2V0WSAtIHByZXZZKTtcblxuICAgICAgICAgICAgICAgIHByZXZYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IG9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSwgdmVjdG9yWCwgdmVjdG9yWSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIGFjdGlvbnMgdGhhdCBhcmUgbWVhbnQgc3BlY2lmaWNhbGx5IGZvciBhIGNlcnRhaW4gY2hpbGQgb2YgdGhlIGxpc3RcbiAgICAgKiBAcGFyYW0gY2hpbGRcbiAgICAgKiBAcGFyYW0gYWN0aW9uc1xuICAgICAqL1xuICAgIHZhciBmaWx0ZXJTZXRJdGVtQWN0aW9ucyA9IGZ1bmN0aW9uIGZpbHRlclNldEl0ZW1BY3Rpb25zKGNoaWxkLCBhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25zLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIGFjdGlvbiBoYXMgYW4gaWQsIGZpbHRlciBvdXQgYWN0aW9ucyB0aGF0IGRvbid0IGhhdmUgdGhpcyBjaGlsZCBpZFxuICAgICAgICAgICAgaWYgKGFjdGlvbi5kYXRhICYmIGFjdGlvbi5kYXRhLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBhY3Rpb24uZGF0YS5pZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cgYWxsIG90aGVyIGFjdGlvbnNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3QgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUkOCxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDUsXG4gICAgICAgIHRhZzogJ3VsJyxcbiAgICAgICAgbmFtZTogJ2xpc3QnLFxuICAgICAgICBkaWRXcml0ZVZpZXc6IGZ1bmN0aW9uIGRpZFdyaXRlVmlldyhfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICAgICAgcm9vdC5jaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3Lm1hcmtlZEZvclJlbW92YWwgJiYgdmlldy5vcGFjaXR5ID09PSAwICYmIHZpZXcucmVzdGluZztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQ6IGZpbHRlclNldEl0ZW1BY3Rpb25zLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIGFwaXM6IFsnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlJDkgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgICAgcm9vdC5yZWYubGlzdCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3QpKTtcbiAgICAgICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHN0b3JlRHJhZ0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24gc3RvcmVEcmFnQ29vcmRpbmF0ZXMoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT05fRlJFRURPTScpKSByZXR1cm47XG4gICAgICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQgLSByb290LnJlZi5saXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgICAgICAgdG9wOlxuICAgICAgICAgICAgICAgIGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAgICAgKHJvb3QucmVjdC5vdXRlci50b3AgKyByb290LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyByb290LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY2xlYXJEcmFnQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjbGVhckRyYWdDb29yZGluYXRlcyhfcmVmMykge1xuICAgICAgICB2YXIgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlJDMgPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9EUkFHOiBzdG9yZURyYWdDb29yZGluYXRlcyxcbiAgICAgICAgRElEX0VORF9EUkFHOiBjbGVhckRyYWdDb29yZGluYXRlcyxcbiAgICB9KTtcblxuICAgIHZhciB3cml0ZSQ2ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNC5hY3Rpb25zO1xuXG4gICAgICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICAgICAgcm91dGUkMyh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcblxuICAgICAgICAvLyBjdXJyZW50IGRyYWcgcG9zaXRpb25cbiAgICAgICAgcm9vdC5yZWYubGlzdC5kcmFnQ29vcmRpbmF0ZXMgPSBwcm9wcy5kcmFnQ29vcmRpbmF0ZXM7XG5cbiAgICAgICAgLy8gaWYgY3VycmVudGx5IG92ZXJmbG93aW5nIGJ1dCBubyBsb25nZXIgcmVjZWl2ZWQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKHByb3BzLm92ZXJmbG93aW5nICYmICFwcm9wcy5vdmVyZmxvdykge1xuICAgICAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgb3ZlcmZsb3cgc3RhdGVcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJyc7XG4gICAgICAgICAgICByb290LmhlaWdodCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyBub3Qgb3ZlcmZsb3dpbmcgY3VycmVudGx5IGJ1dCBkb2VzIHJlY2VpdmUgb3ZlcmZsb3cgdmFsdWVcbiAgICAgICAgaWYgKHByb3BzLm92ZXJmbG93KSB7XG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChwcm9wcy5vdmVyZmxvdyk7XG4gICAgICAgICAgICBpZiAobmV3SGVpZ2h0ICE9PSByb290LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHByb3BzLm92ZXJmbG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICdvdmVyZmxvdyc7XG4gICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxpc3RTY3JvbGxlciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSQ5LFxuICAgICAgICB3cml0ZTogd3JpdGUkNixcbiAgICAgICAgbmFtZTogJ2xpc3Qtc2Nyb2xsZXInLFxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgIGFwaXM6IFsnb3ZlcmZsb3cnLCAnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgICAgICAgICBzdHlsZXM6IFsnaGVpZ2h0JywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2YXIgYXR0clRvZ2dsZSA9IGZ1bmN0aW9uIGF0dHJUb2dnbGUoZWxlbWVudCwgbmFtZSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyc7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCBlbmFibGVkVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0RmlsZUlucHV0ID0gZnVuY3Rpb24gcmVzZXRGaWxlSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgLy8gbm8gdmFsdWUsIG5vIG5lZWQgdG8gcmVzZXRcbiAgICAgICAgaWYgKCFpbnB1dCB8fCBpbnB1dC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gZm9yIElFMTBcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBxdWlja2x5IGFwcGVuZCBpbnB1dCB0byB0ZW1wIGZvcm0gYW5kIHJlc2V0IGZvcm1cbiAgICAgICAgICAgIHZhciBmb3JtID0gY3JlYXRlRWxlbWVudCQxKCdmb3JtJyk7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGlucHV0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgcmVmID0gaW5wdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcblxuICAgICAgICAgICAgLy8gcmUtaW5qZWN0IGlucHV0IHdoZXJlIGl0IG9yaWdpbmFsbHkgd2FzXG4gICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5wdXQsIHJlZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkYSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIC8vIHNldCBpZCBzbyBjYW4gYmUgcmVmZXJlbmNlZCBmcm9tIG91dHNpZGUgbGFiZWxzXG4gICAgICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0tYnJvd3Nlci0nICsgcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gc2V0IG5hbWUgb2YgZWxlbWVudCAoaXMgcmVtb3ZlZCB3aGVuIGEgdmFsdWUgaXMgc2V0KVxuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ25hbWUnLCByb290LnF1ZXJ5KCdHRVRfTkFNRScpKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGxpbmsgdGhpcyBlbGVtZW50IHRvIHRoZSBzdGF0dXMgZWxlbWVudFxuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtY29udHJvbHMnLCAnZmlsZXBvbmQtLWFzc2lzdGFudC0nICsgcHJvcHMuaWQpO1xuXG4gICAgICAgIC8vIHNldCBsYWJlbCwgd2UgdXNlIGxhYmVsbGVkIGJ5IGFzIG90aGVyd2lzZSB0aGUgc2NyZWVucmVhZGVyIGRvZXMgbm90IHJlYWQgdGhlIFwiYnJvd3NlXCIgdGV4dCBpbiB0aGUgbGFiZWwgKGFzIGl0IGhhcyB0YWJpbmRleDogMClcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgICAgICAvLyBzZXQgY29uZmlndXJhYmxlIHByb3BzXG4gICAgICAgIHNldEFjY2VwdGVkRmlsZVR5cGVzKHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTJykgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZUFsbG93TXVsdGlwbGUoeyByb290OiByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpIH0gfSk7XG4gICAgICAgIHRvZ2dsZURpcmVjdG9yeUZpbHRlcih7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWScpIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVEaXNhYmxlZCh7IHJvb3Q6IHJvb3QgfSk7XG4gICAgICAgIHRvZ2dsZVJlcXVpcmVkKHsgcm9vdDogcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSB9IH0pO1xuICAgICAgICBzZXRDYXB0dXJlTWV0aG9kKHsgcm9vdDogcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQ0FQVFVSRV9NRVRIT0QnKSB9IH0pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICByb290LnJlZi5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QuZWxlbWVudC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBmaWxlcyBhbmQgbW92ZSB2YWx1ZSBvZiB3ZWJraXRSZWxhdGl2ZVBhdGggcGF0aCB0byBfcmVsYXRpdmVQYXRoXG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBBcnJheS5mcm9tKHJvb3QuZWxlbWVudC5maWxlcykubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3ZSBhZGQgYSBsaXR0bGUgZGVsYXkgc28gdGhlIE9TIGZpbGUgc2VsZWN0IHdpbmRvdyBjYW4gbW92ZSBvdXQgb2YgdGhlIHdheSBiZWZvcmUgd2UgYWRkIG91ciBmaWxlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGxvYWQgZmlsZXNcbiAgICAgICAgICAgICAgICBwcm9wcy5vbmxvYWQoZmlsZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaW5wdXQsIGl0J3MganVzdCBmb3IgZXhwb3NpbmcgYSBtZXRob2QgdG8gZHJvcCBmaWxlcywgc2hvdWxkIG5vdCByZXRhaW4gYW55IHN0YXRlXG4gICAgICAgICAgICAgICAgcmVzZXRGaWxlSW5wdXQocm9vdC5lbGVtZW50KTtcbiAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJvb3QucmVmLmhhbmRsZUNoYW5nZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRBY2NlcHRlZEZpbGVUeXBlcyA9IGZ1bmN0aW9uIHNldEFjY2VwdGVkRmlsZVR5cGVzKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfU1lOQ19BQ0NFUFRfQVRUUklCVVRFJykpIHJldHVybjtcbiAgICAgICAgYXR0clRvZ2dsZShcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgICAgICdhY2NlcHQnLFxuICAgICAgICAgICAgISFhY3Rpb24udmFsdWUsXG4gICAgICAgICAgICBhY3Rpb24udmFsdWUgPyBhY3Rpb24udmFsdWUuam9pbignLCcpIDogJydcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvZ2dsZUFsbG93TXVsdGlwbGUgPSBmdW5jdGlvbiB0b2dnbGVBbGxvd011bHRpcGxlKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdtdWx0aXBsZScsIGFjdGlvbi52YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIgPSBmdW5jdGlvbiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3dlYmtpdGRpcmVjdG9yeScsIGFjdGlvbi52YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVEaXNhYmxlZCA9IGZ1bmN0aW9uIHRvZ2dsZURpc2FibGVkKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgdmFyIGRvZXNBbGxvd0Jyb3dzZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19CUk9XU0UnKTtcbiAgICAgICAgdmFyIGRpc2FibGVGaWVsZCA9IGlzRGlzYWJsZWQgfHwgIWRvZXNBbGxvd0Jyb3dzZTtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsIGRpc2FibGVGaWVsZCk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVSZXF1aXJlZCA9IGZ1bmN0aW9uIHRvZ2dsZVJlcXVpcmVkKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgICAgLy8gd2FudCB0byByZW1vdmUgcmVxdWlyZWQsIGFsd2F5cyBwb3NzaWJsZVxuICAgICAgICBpZiAoIWFjdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3YW50IHRvIG1ha2UgcmVxdWlyZWQsIG9ubHkgcG9zc2libGUgd2hlbiB6ZXJvIGl0ZW1zXG4gICAgICAgIGVsc2UgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID09PSAwKSB7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldENhcHR1cmVNZXRob2QgPSBmdW5jdGlvbiBzZXRDYXB0dXJlTWV0aG9kKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgICAgYXR0clRvZ2dsZShcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgICAgICdjYXB0dXJlJyxcbiAgICAgICAgICAgICEhYWN0aW9uLnZhbHVlLFxuICAgICAgICAgICAgYWN0aW9uLnZhbHVlID09PSB0cnVlID8gJycgOiBhY3Rpb24udmFsdWVcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVJlcXVpcmVkU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlUmVxdWlyZWRTdGF0dXMoX3JlZjgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgICB2YXIgZWxlbWVudCA9IHJvb3QuZWxlbWVudDtcbiAgICAgICAgLy8gYWx3YXlzIHJlbW92ZSB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIHdoZW4gbW9yZSB0aGFuIHplcm8gaXRlbXNcbiAgICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID4gMCkge1xuICAgICAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIG5hbWUgYXR0cmlidXRlXG4gICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgdHJ1ZSwgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgdmFsaWRhdGlvbiBtZXNzYWdlc1xuICAgICAgICAgICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIG9ubHkgYWRkIHJlcXVpcmVkIGlmIHRoZSBmaWVsZCBoYXMgYmVlbiBkZWVtZWQgcmVxdWlyZWRcbiAgICAgICAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSkge1xuICAgICAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzKF9yZWY5KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgICAgaWYgKCFzaG91bGRDaGVja1ZhbGlkaXR5KSByZXR1cm47XG4gICAgICAgIHJvb3QuZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eShyb290LnF1ZXJ5KCdHRVRfTEFCRUxfSU5WQUxJRF9GSUVMRCcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGJyb3dzZXIgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgdGFnOiAnaW5wdXQnLFxuICAgICAgICBuYW1lOiAnYnJvd3NlcicsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRhLFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgICAgICBESURfUkVNT1ZFX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyxcblxuICAgICAgICAgICAgRElEX1NFVF9ESVNBQkxFRDogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgICAgICBESURfU0VUX0FMTE9XX0JST1dTRTogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgICAgICBESURfU0VUX0FMTE9XX0RJUkVDVE9SSUVTX09OTFk6IHRvZ2dsZURpcmVjdG9yeUZpbHRlcixcbiAgICAgICAgICAgIERJRF9TRVRfQUxMT1dfTVVMVElQTEU6IHRvZ2dsZUFsbG93TXVsdGlwbGUsXG4gICAgICAgICAgICBESURfU0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVM6IHNldEFjY2VwdGVkRmlsZVR5cGVzLFxuICAgICAgICAgICAgRElEX1NFVF9DQVBUVVJFX01FVEhPRDogc2V0Q2FwdHVyZU1ldGhvZCxcbiAgICAgICAgICAgIERJRF9TRVRfUkVRVUlSRUQ6IHRvZ2dsZVJlcXVpcmVkLFxuICAgICAgICB9KSxcbiAgICB9KTtcblxuICAgIHZhciBLZXkgPSB7XG4gICAgICAgIEVOVEVSOiAxMyxcbiAgICAgICAgU1BBQ0U6IDMyLFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlJGIgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGxhYmVsIGFuZCBsaW5rIGl0IHRvIHRoZSBmaWxlIGJyb3dzZXJcbiAgICAgICAgdmFyIGxhYmVsID0gY3JlYXRlRWxlbWVudCQxKCdsYWJlbCcpO1xuICAgICAgICBhdHRyKGxhYmVsLCAnZm9yJywgJ2ZpbGVwb25kLS1icm93c2VyLScgKyBwcm9wcy5pZCk7XG5cbiAgICAgICAgLy8gdXNlIGZvciBsYWJlbGluZyBmaWxlIGlucHV0IChhcmlhLWxhYmVsbGVkYnkgb24gZmlsZSBpbnB1dClcbiAgICAgICAgYXR0cihsYWJlbCwgJ2lkJywgJ2ZpbGVwb25kLS1kcm9wLWxhYmVsLScgKyBwcm9wcy5pZCk7XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgbGFiZWwgZm9yIHNjcmVlbnJlYWRlcnMsIHRoZSBpbnB1dCBlbGVtZW50IHdpbGwgcmVhZCB0aGUgY29udGVudHMgb2YgdGhlIGxhYmVsIHdoZW4gaXQncyBmb2N1c3NlZC4gSWYgd2UgZG9uJ3Qgc2V0IGFyaWEtaGlkZGVuIHRoZSBzY3JlZW5yZWFkZXIgd2lsbCBhbHNvIG5hdmlnYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgbGFiZWwgc2VwYXJhdGVseSBmcm9tIHRoZSBpbnB1dC5cbiAgICAgICAgYXR0cihsYWJlbCwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBoYW5kbGUga2V5c1xuICAgICAgICByb290LnJlZi5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGlzQWN0aXZhdGlvbktleSA9IGUua2V5Q29kZSA9PT0gS2V5LkVOVEVSIHx8IGUua2V5Q29kZSA9PT0gS2V5LlNQQUNFO1xuICAgICAgICAgICAgaWYgKCFpc0FjdGl2YXRpb25LZXkpIHJldHVybjtcbiAgICAgICAgICAgIC8vIHN0b3BzIGZyb20gdHJpZ2dlcmluZyB0aGUgZWxlbWVudCBhIHNlY29uZCB0aW1lXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIGNsaWNrIGxpbmsgKHdpbGwgdGhlbiBpbiB0dXJuIGFjdGl2YXRlIGZpbGUgaW5wdXQpXG4gICAgICAgICAgICByb290LnJlZi5sYWJlbC5jbGljaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGlzTGFiZWxDbGljayA9IGUudGFyZ2V0ID09PSBsYWJlbCB8fCBsYWJlbC5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gY2xpY2sgdHdpY2VcbiAgICAgICAgICAgIGlmIChpc0xhYmVsQ2xpY2spIHJldHVybjtcblxuICAgICAgICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgcHJvcHMuY2FwdGlvbik7XG5cbiAgICAgICAgLy8gYWRkIVxuICAgICAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgcm9vdC5yZWYubGFiZWwgPSBsYWJlbDtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUxhYmVsVmFsdWUgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCB2YWx1ZSkge1xuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGNsaWNrYWJsZSA9IGxhYmVsLnF1ZXJ5U2VsZWN0b3IoJy5maWxlcG9uZC0tbGFiZWwtYWN0aW9uJyk7XG4gICAgICAgIGlmIChjbGlja2FibGUpIHtcbiAgICAgICAgICAgIGF0dHIoY2xpY2thYmxlLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRyb3BMYWJlbCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBuYW1lOiAnZHJvcC1sYWJlbCcsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGIsXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgICAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgICAgIERJRF9TRVRfTEFCRUxfSURMRTogZnVuY3Rpb24gRElEX1NFVF9MQUJFTF9JRExFKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgICAgICAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShyb290LnJlZi5sYWJlbCwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknLCAndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgbmFtZTogJ2RyaXAtYmxvYicsXG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdmFyIGFkZEJsb2IgPSBmdW5jdGlvbiBhZGRCbG9iKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICAgIHZhciBjZW50ZXJYID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG4gICAgICAgIHZhciBjZW50ZXJZID0gcm9vdC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHJvb3QucmVmLmJsb2IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJsb2IsIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlWDogMi41LFxuICAgICAgICAgICAgICAgIHNjYWxlWTogMi41LFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogY2VudGVyWSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBtb3ZlQmxvYiA9IGZ1bmN0aW9uIG1vdmVCbG9iKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgICAgICBhZGRCbG9iKHsgcm9vdDogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWSA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcDtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAxO1xuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIHZhciBoaWRlQmxvYiA9IGZ1bmN0aW9uIGhpZGVCbG9iKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdDtcbiAgICAgICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cGxvZGVCbG9iID0gZnVuY3Rpb24gZXhwbG9kZUJsb2IoX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByb290LnJlZi5ibG9iLnNjYWxlWCA9IDIuNTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQ3ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmNS5hY3Rpb25zO1xuICAgICAgICByb3V0ZSQ0KHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuICAgICAgICB2YXIgYmxvYiA9IHJvb3QucmVmLmJsb2I7XG5cbiAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoID09PSAwICYmIGJsb2IgJiYgYmxvYi5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgICAgICAgIHJvb3QucmVmLmJsb2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSQ0ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgICAgIERJRF9EUk9QOiBleHBsb2RlQmxvYixcbiAgICAgICAgRElEX0VORF9EUkFHOiBoaWRlQmxvYixcbiAgICB9KTtcblxuICAgIHZhciBkcmlwID0gY3JlYXRlVmlldyh7XG4gICAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgICAgIG5hbWU6ICdkcmlwJyxcbiAgICAgICAgd3JpdGU6IHdyaXRlJDcsXG4gICAgfSk7XG5cbiAgICB2YXIgc2V0SW5wdXRGaWxlcyA9IGZ1bmN0aW9uIHNldElucHV0RmlsZXMoZWxlbWVudCwgZmlsZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIERhdGFUcmFuc2ZlciBpbnN0YW5jZSBhbmQgYWRkIGEgbmV3bHkgY3JlYXRlZCBmaWxlXG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpO1xuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLml0ZW1zLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaWxlKFtmaWxlXSwgZmlsZS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSBEYXRhVHJhbnNmZXIgZmlsZXMgbGlzdCB0byB0aGUgZmlsZSBpbnB1dFxuICAgICAgICAgICAgZWxlbWVudC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkYyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgICByZXR1cm4gKHJvb3QucmVmLmZpZWxkcyA9IHt9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpZWxkID0gZnVuY3Rpb24gZ2V0RmllbGQocm9vdCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucmVmLmZpZWxkc1tpZF07XG4gICAgfTtcblxuICAgIHZhciBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMgPSBmdW5jdGlvbiBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCkge1xuICAgICAgICByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZGlkUmVvcmRlckl0ZW1zID0gZnVuY3Rpb24gZGlkUmVvcmRlckl0ZW1zKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgICAgcmV0dXJuIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZEFkZEl0ZW0gPSBmdW5jdGlvbiBkaWRBZGRJdGVtKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdmFyIGZpbGVJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgICAgICB2YXIgaXNMb2NhbEZpbGUgPSBmaWxlSXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUw7XG4gICAgICAgIHZhciBzaG91bGRVc2VGaWxlSW5wdXQgPSAhaXNMb2NhbEZpbGUgJiYgcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJyk7XG4gICAgICAgIHZhciBkYXRhQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCQxKCdpbnB1dCcpO1xuICAgICAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSBzaG91bGRVc2VGaWxlSW5wdXQgPyAnZmlsZScgOiAnaGlkZGVuJztcbiAgICAgICAgZGF0YUNvbnRhaW5lci5uYW1lID0gcm9vdC5xdWVyeSgnR0VUX05BTUUnKTtcbiAgICAgICAgZGF0YUNvbnRhaW5lci5kaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXSA9IGRhdGFDb250YWluZXI7XG4gICAgICAgIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZExvYWRJdGVtJDEgPSBmdW5jdGlvbiBkaWRMb2FkSXRlbShfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgICAgIGlmICghZmllbGQpIHJldHVybjtcblxuICAgICAgICAvLyBzdG9yZSBzZXJ2ZXIgcmVmIGluIGhpZGRlbiBpbnB1dFxuICAgICAgICBpZiAoYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGwpIGZpZWxkLnZhbHVlID0gYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgLy8gc3RvcmUgZmlsZSBpdGVtIGluIGZpbGUgaW5wdXRcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQnKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmaWxlSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgc2V0SW5wdXRGaWxlcyhmaWVsZCwgW2ZpbGVJdGVtLmZpbGVdKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFByZXBhcmVPdXRwdXQgPSBmdW5jdGlvbiBkaWRQcmVwYXJlT3V0cHV0KF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgICAgLy8gdGhpcyB0aW1lb3V0IHB1c2hlcyB0aGUgaGFuZGxlciBhZnRlciAnbG9hZCdcbiAgICAgICAgaWYgKCFyb290LnF1ZXJ5KCdTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQnKSkgcmV0dXJuO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICAgICAgICAgIHNldElucHV0RmlsZXMoZmllbGQsIFthY3Rpb24uZmlsZV0pO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFNldERpc2FibGVkID0gZnVuY3Rpb24gZGlkU2V0RGlzYWJsZWQoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgICByb290LmVsZW1lbnQuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZFJlbW92ZUl0ZW0gPSBmdW5jdGlvbiBkaWRSZW1vdmVJdGVtKF9yZWY3KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZmllbGQucGFyZW50Tm9kZSkgZmllbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmaWVsZCk7XG4gICAgICAgIGRlbGV0ZSByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXTtcbiAgICB9O1xuXG4gICAgLy8gb25seSBydW5zIGZvciBzZXJ2ZXIgZmlsZXMgKHNvIGRvZXNuJ3QgZGVhbCB3aXRoIGZpbGUgaW5wdXQpXG4gICAgdmFyIGRpZERlZmluZVZhbHVlID0gZnVuY3Rpb24gZGlkRGVmaW5lVmFsdWUoX3JlZjgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjguYWN0aW9uO1xuICAgICAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgICAgIGlmIChhY3Rpb24udmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGZpZWxkIHZhbHVlXG4gICAgICAgICAgICBmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZXQgZmllbGQgdmFsdWVcbiAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgICB9O1xuXG4gICAgdmFyIHdyaXRlJDggPSBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9TRVRfRElTQUJMRUQ6IGRpZFNldERpc2FibGVkLFxuICAgICAgICBESURfQUREX0lURU06IGRpZEFkZEl0ZW0sXG4gICAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtJDEsXG4gICAgICAgIERJRF9SRU1PVkVfSVRFTTogZGlkUmVtb3ZlSXRlbSxcbiAgICAgICAgRElEX0RFRklORV9WQUxVRTogZGlkRGVmaW5lVmFsdWUsXG4gICAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogZGlkUHJlcGFyZU91dHB1dCxcbiAgICAgICAgRElEX1JFT1JERVJfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbiAgICAgICAgRElEX1NPUlRfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbiAgICB9KTtcblxuICAgIHZhciBkYXRhID0gY3JlYXRlVmlldyh7XG4gICAgICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRjLFxuICAgICAgICB3cml0ZTogd3JpdGUkOCxcbiAgICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHZhciBnZXRSb290Tm9kZSA9IGZ1bmN0aW9uIGdldFJvb3ROb2RlKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuICdnZXRSb290Tm9kZScgaW4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xuICAgIH07XG5cbiAgICB2YXIgaW1hZ2VzID0gWydqcGcnLCAnanBlZycsICdwbmcnLCAnZ2lmJywgJ2JtcCcsICd3ZWJwJywgJ3N2ZycsICd0aWZmJ107XG4gICAgdmFyIHRleHQkMSA9IFsnY3NzJywgJ2NzdicsICdodG1sJywgJ3R4dCddO1xuICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHppcDogJ3ppcHxjb21wcmVzc2VkJyxcbiAgICAgICAgZXB1YjogJ2FwcGxpY2F0aW9uL2VwdWIremlwJyxcbiAgICB9O1xuXG4gICAgdmFyIGd1ZXNzdGltYXRlTWltZVR5cGUgPSBmdW5jdGlvbiBndWVzc3RpbWF0ZU1pbWVUeXBlKCkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChpbWFnZXMuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnaW1hZ2UvJyArXG4gICAgICAgICAgICAgICAgKGV4dGVuc2lvbiA9PT0gJ2pwZycgPyAnanBlZycgOiBleHRlbnNpb24gPT09ICdzdmcnID8gJ3N2Zyt4bWwnIDogZXh0ZW5zaW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCQxLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dC8nICsgZXh0ZW5zaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFtleHRlbnNpb25dIHx8ICcnO1xuICAgIH07XG5cbiAgICB2YXIgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zID0gZnVuY3Rpb24gcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IGxpbmtzIGZyb20gdHJhbnNmZXIsIGlmIGZvdW5kIHdlJ2xsIGV4aXQgaW1tZWRpYXRlbHkgKHVubGVzcyBhIGZpbGUgaXMgaW4gdGhlIGRhdGFUcmFuc2ZlciBhcyB3ZWxsLCB0aGlzIGlzIGJlY2F1c2UgRmlyZWZveCBjb3VsZCByZXByZXNlbnQgdGhlIGZpbGUgYXMgYSBVUkwgYW5kIGEgZmlsZSBvYmplY3QgYXQgdGhlIHNhbWUgdGltZSlcbiAgICAgICAgICAgIHZhciBsaW5rcyA9IGdldExpbmtzKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoICYmICFoYXNGaWxlcyhkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobGlua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBmaWxlcyBmcm9tIHRoZSB0cmFuc2ZlclxuICAgICAgICAgICAgZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKS50aGVuKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBkYXRhdHJhbnNmZXIgaGFzIGZpbGVzXG4gICAgICovXG4gICAgdmFyIGhhc0ZpbGVzID0gZnVuY3Rpb24gaGFzRmlsZXMoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIuZmlsZXMpIHJldHVybiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBmaWxlcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICAgICAqL1xuICAgIHZhciBnZXRGaWxlcyA9IGZ1bmN0aW9uIGdldEZpbGVzKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHRyYW5zZmVyIGl0ZW1zIGFzIHByb21pc2VzXG4gICAgICAgICAgICB2YXIgcHJvbWlzZWRGaWxlcyA9IChkYXRhVHJhbnNmZXIuaXRlbXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5pdGVtcykgOiBbXSlcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGtlZXAgZmlsZSBzeXN0ZW0gaXRlbXMgKGZpbGVzIGFuZCBkaXJlY3RvcmllcylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmlsZVN5c3RlbUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIC8vIG1hcCBlYWNoIGl0ZW0gdG8gcHJvbWlzZVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaWYgaXMgZW1wdHksIHNlZSBpZiB3ZSBjYW4gZXh0cmFjdCBzb21lIGluZm8gZnJvbSB0aGUgZmlsZXMgcHJvcGVydHkgYXMgYSBmYWxsYmFja1xuICAgICAgICAgICAgaWYgKCFwcm9taXNlZEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRlc3QgZm9yIGRpcmVjdG9yaWVzIChzaG91bGQgbm90IGJlIGFsbG93ZWQpXG4gICAgICAgICAgICAgICAgLy8gVXNlIEZpbGVSZWFkZXIsIHByb2JsZW0gaXMgdGhhdCB0aGUgZmlsZXMgcHJvcGVydHkgZ2V0cyBsb3N0IGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhVHJhbnNmZXIuZmlsZXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcykgOiBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZWRGaWxlcylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXR1cm5lZEZpbGVHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkRmlsZUdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoLmFwcGx5KGZpbGVzLCBncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbmUgKGZpbHRlciBvdXQgZW1wdHkgZmlsZXMpIVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLl9yZWxhdGl2ZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpc0ZpbGVTeXN0ZW1JdGVtID0gZnVuY3Rpb24gaXNGaWxlU3lzdGVtSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpc0VudHJ5KGl0ZW0pKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBnZXRBc0VudHJ5KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmlzRmlsZSB8fCBlbnRyeS5pc0RpcmVjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZSc7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlc0Zyb21JdGVtID0gZnVuY3Rpb24gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgZ2V0RmlsZXNJbkRpcmVjdG9yeShnZXRBc0VudHJ5KGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoW2l0ZW0uZ2V0QXNGaWxlKCldKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlc0luRGlyZWN0b3J5ID0gZnVuY3Rpb24gZ2V0RmlsZXNJbkRpcmVjdG9yeShlbnRyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gdGhlIHRvdGFsIGVudHJpZXMgdG8gcmVhZFxuICAgICAgICAgICAgdmFyIGRpckNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIGZpbGVDb3VudGVyID0gMDtcblxuICAgICAgICAgICAgdmFyIHJlc29sdmVJZkRvbmUgPSBmdW5jdGlvbiByZXNvbHZlSWZEb25lKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlQ291bnRlciA9PT0gMCAmJiBkaXJDb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHRoZSByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciByZWFkRW50cmllcyA9IGZ1bmN0aW9uIHJlYWRFbnRyaWVzKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZGlyQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdG9yeVJlYWRlciA9IGRpckVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0b3JpZXMgYXJlIHJldHVybmVkIGluIGJhdGNoZXMsIHdlIG5lZWQgdG8gcHJvY2VzcyBhbGwgYmF0Y2hlcyBiZWZvcmUgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIHZhciByZWFkQmF0Y2ggPSBmdW5jdGlvbiByZWFkQmF0Y2goKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJDb3VudGVyLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmVhZCBtb3JlIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFkIGFzIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRGaWxlID0gY29ycmVjdE1pc3NpbmdGaWxlVHlwZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5mdWxsUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRGaWxlLl9yZWxhdGl2ZVBhdGggPSBlbnRyeS5mdWxsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goY29ycmVjdGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlQ291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBuZXh0IGJhdGNoIG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBmaXJzdCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgIHJlYWRCYXRjaCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ28hXG4gICAgICAgICAgICByZWFkRW50cmllcyhlbnRyeSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY29ycmVjdE1pc3NpbmdGaWxlVHlwZSA9IGZ1bmN0aW9uIGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS50eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIHZhciBkYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgICAgICB2YXIgbmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgdmFyIHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShmaWxlLm5hbWUpKTtcbiAgICAgICAgaWYgKCF0eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgdHlwZSk7XG4gICAgICAgIGZpbGUubmFtZSA9IG5hbWU7XG4gICAgICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IGRhdGU7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG5cbiAgICB2YXIgaXNEaXJlY3RvcnlFbnRyeSA9IGZ1bmN0aW9uIGlzRGlyZWN0b3J5RW50cnkoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXNFbnRyeShpdGVtKSAmJiAoZ2V0QXNFbnRyeShpdGVtKSB8fCB7fSkuaXNEaXJlY3Rvcnk7XG4gICAgfTtcblxuICAgIHZhciBpc0VudHJ5ID0gZnVuY3Rpb24gaXNFbnRyeShpdGVtKSB7XG4gICAgICAgIHJldHVybiAnd2Via2l0R2V0QXNFbnRyeScgaW4gaXRlbTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEFzRW50cnkgPSBmdW5jdGlvbiBnZXRBc0VudHJ5KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBsaW5rcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICAgICAqL1xuICAgIHZhciBnZXRMaW5rcyA9IGZ1bmN0aW9uIGdldExpbmtzKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGxvb2sgaW4gbWV0YSBkYXRhIHByb3BlcnR5XG4gICAgICAgICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBub3BlIG5vcGUgbm9wZSAocHJvYmFibHkgSUUgdHJvdWJsZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgfTtcblxuICAgIHZhciBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEgPSBmdW5jdGlvbiBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHZhciBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3VybCcpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEgPSBmdW5jdGlvbiBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBkYXRhLm1hdGNoKC9zcmNcXHMqPVxccypcIiguKz8pXCIvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFttYXRjaGVzWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIHZhciBkcmFnTkRyb3BPYnNlcnZlcnMgPSBbXTtcblxuICAgIHZhciBldmVudFBvc2l0aW9uID0gZnVuY3Rpb24gZXZlbnRQb3NpdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlTGVmdDogZS5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VUb3A6IGUucGFnZVksXG4gICAgICAgICAgICBzY29wZUxlZnQ6IGUub2Zmc2V0WCB8fCBlLmxheWVyWCxcbiAgICAgICAgICAgIHNjb3BlVG9wOiBlLm9mZnNldFkgfHwgZS5sYXllclksXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEcmFnTkRyb3BDbGllbnQgPSBmdW5jdGlvbiBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHNjb3BlVG9PYnNlcnZlLFxuICAgICAgICBmaWx0ZXJFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IGdldERyYWdORHJvcE9ic2VydmVyKHNjb3BlVG9PYnNlcnZlKTtcblxuICAgICAgICB2YXIgY2xpZW50ID0ge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIGZpbHRlckVsZW1lbnQ6IGZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIG9uZHJvcDogZnVuY3Rpb24gb25kcm9wKCkge30sXG4gICAgICAgICAgICBvbmVudGVyOiBmdW5jdGlvbiBvbmVudGVyKCkge30sXG4gICAgICAgICAgICBvbmRyYWc6IGZ1bmN0aW9uIG9uZHJhZygpIHt9LFxuICAgICAgICAgICAgb25leGl0OiBmdW5jdGlvbiBvbmV4aXQoKSB7fSxcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICAgICAgICBhbGxvd2Ryb3A6IGZ1bmN0aW9uIGFsbG93ZHJvcCgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5kZXN0cm95ID0gb2JzZXJ2ZXIuYWRkTGlzdGVuZXIoY2xpZW50KTtcblxuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIgPSBmdW5jdGlvbiBnZXREcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KSB7XG4gICAgICAgIC8vIHNlZSBpZiBhbHJlYWR5IGV4aXN0cywgaWYgc28sIHJldHVyblxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBkcmFnTkRyb3BPYnNlcnZlcnMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG9ic2VydmVyLCBkb2VzIG5vdCB5ZXQgZXhpc3QgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICB2YXIgbmV3T2JzZXJ2ZXIgPSBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KTtcbiAgICAgICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnB1c2gobmV3T2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gbmV3T2JzZXJ2ZXI7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNsaWVudHMgPSBbXTtcblxuICAgICAgICB2YXIgcm91dGVzID0ge1xuICAgICAgICAgICAgZHJhZ2VudGVyOiBkcmFnZW50ZXIsXG4gICAgICAgICAgICBkcmFnb3ZlcjogZHJhZ292ZXIsXG4gICAgICAgICAgICBkcmFnbGVhdmU6IGRyYWdsZWF2ZSxcbiAgICAgICAgICAgIGRyb3A6IGRyb3AsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0ge307XG5cbiAgICAgICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCwgY3JlYXRlSGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjbGllbnRzKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTGlzdGVuZXIoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGFzIGNsaWVudFxuICAgICAgICAgICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlbW92ZUxpc3RlbmVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudHMuc3BsaWNlKGNsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBtb3JlIGNsaWVudHMsIGNsZWFuIHVwIG9ic2VydmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnNwbGljZShkcmFnTkRyb3BPYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Jpbihyb3V0ZXMsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH07XG5cbiAgICB2YXIgZWxlbWVudEZyb21Qb2ludCA9IGZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQocm9vdCwgcG9pbnQpIHtcbiAgICAgICAgaWYgKCEoJ2VsZW1lbnRGcm9tUG9pbnQnIGluIHJvb3QpKSB7XG4gICAgICAgICAgICByb290ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QuZWxlbWVudEZyb21Qb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KGUsIHRhcmdldCkge1xuICAgICAgICAvLyBnZXQgcm9vdFxuICAgICAgICB2YXIgcm9vdCA9IGdldFJvb3ROb2RlKHRhcmdldCk7XG5cbiAgICAgICAgLy8gZ2V0IGVsZW1lbnQgYXQgcG9zaXRpb25cbiAgICAgICAgLy8gaWYgcm9vdCBpcyBub3QgYWN0dWFsIHNoYWRvdyBET00gYW5kIGRvZXMgbm90IGhhdmUgZWxlbWVudEZyb21Qb2ludCBtZXRob2QsIHVzZSB0aGUgb25lIG9uIGRvY3VtZW50XG4gICAgICAgIHZhciBlbGVtZW50QXRQb3NpdGlvbiA9IGVsZW1lbnRGcm9tUG9pbnQocm9vdCwge1xuICAgICAgICAgICAgeDogZS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIHk6IGUucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRlc3QgaWYgdGFyZ2V0IGlzIHRoZSBlbGVtZW50IG9yIGlmIG9uZSBvZiBpdHMgY2hpbGRyZW4gaXNcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRBdFBvc2l0aW9uID09PSB0YXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnRBdFBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGluaXRpYWxUYXJnZXQgPSBudWxsO1xuXG4gICAgdmFyIHNldERyb3BFZmZlY3QgPSBmdW5jdGlvbiBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgZWZmZWN0KSB7XG4gICAgICAgIC8vIGlzIGluIHRyeSBjYXRjaCBhcyBJRTExIHdpbGwgdGhyb3cgZXJyb3IgaWYgbm90XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGVmZmVjdDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9O1xuXG4gICAgdmFyIGRyYWdlbnRlciA9IGZ1bmN0aW9uIGRyYWdlbnRlcihyb290LCBjbGllbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGluaXRpYWxUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgICAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIG9uZW50ZXIgPSBjbGllbnQub25lbnRlcjtcblxuICAgICAgICAgICAgICAgIGlmIChpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBlbnRlciBldmVudFxuICAgICAgICAgICAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZHJhZ292ZXIgPSBmdW5jdGlvbiBkcmFnb3Zlcihyb290LCBjbGllbnRzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBvdmVyRHJvcFRhcmdldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY2xpZW50cy5zb21lKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyRWxlbWVudCA9IGNsaWVudC5maWx0ZXJFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGNsaWVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lbnRlciA9IGNsaWVudC5vbmVudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25leGl0ID0gY2xpZW50Lm9uZXhpdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZHJhZyA9IGNsaWVudC5vbmRyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2Ryb3AgPSBjbGllbnQuYWxsb3dkcm9wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UgY2FuIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdjb3B5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdHJhbnNmZXIgb2YgdGhlc2UgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbG93c1RyYW5zZmVyID0gYWxsb3dkcm9wKGl0ZW1zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBjYW4gYmUgZHJvcHBlZCBvbiBwYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dzVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0dGluZyB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlckRyb3BUYXJnZXQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYWQgbm8gcHJldmlvdXMgc3RhdGUsIG1lYW5zIHdlIGFyZSBlbnRlcmluZyB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lbnRlcihldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBvdmVyIGVsZW1lbnQgKG5vIG1hdHRlciBpZiBpdCBhbGxvd3MgdGhlIGRyb3Agb3Igbm90KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ292ZXInO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBhbGxvdyB0cmFuc2ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgb25kcmFnKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG92ZXIgYW4gZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhb3ZlckRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBqdXN0IGxlZnQgdGhpcyBjbGllbnQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3Aocm9vdCwgY2xpZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG5cbiAgICAgICAgICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gY2xpZW50LmZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmRyb3AgPSBjbGllbnQub25kcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25leGl0ID0gY2xpZW50Lm9uZXhpdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZHJvcCA9IGNsaWVudC5hbGxvd2Ryb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBmaWx0ZXJpbmcgb24gZWxlbWVudCB3ZSBuZWVkIHRvIGJlIG92ZXIgdGhlIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHRyYW5zZmVyIGZvciB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZHJvcChpdGVtcykpIHJldHVybiBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGRyb3AgdGhlc2UgaXRlbXMgb24gdGhpcyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgb25kcm9wKGV2ZW50UG9zaXRpb24oZSksIGl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZHJhZ2xlYXZlID0gZnVuY3Rpb24gZHJhZ2xlYXZlKHJvb3QsIGNsaWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvbmV4aXQgPSBjbGllbnQub25leGl0O1xuXG4gICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSG9wcGVyID0gZnVuY3Rpb24gY3JlYXRlSG9wcGVyKHNjb3BlLCB2YWxpZGF0ZUl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGlzIG5vdyBob3BwZXIgc2NvcGVcbiAgICAgICAgc2NvcGUuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWhvcHBlcicpO1xuXG4gICAgICAgIC8vIHNob3J0Y3V0c1xuICAgICAgICB2YXIgY2F0Y2hlc0Ryb3BzT25QYWdlID0gb3B0aW9ucy5jYXRjaGVzRHJvcHNPblBhZ2UsXG4gICAgICAgICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQgPSBvcHRpb25zLnJlcXVpcmVzRHJvcE9uRWxlbWVudCxcbiAgICAgICAgICAgIF9vcHRpb25zJGZpbHRlckl0ZW1zID0gb3B0aW9ucy5maWx0ZXJJdGVtcyxcbiAgICAgICAgICAgIGZpbHRlckl0ZW1zID1cbiAgICAgICAgICAgICAgICBfb3B0aW9ucyRmaWx0ZXJJdGVtcyA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBfb3B0aW9ucyRmaWx0ZXJJdGVtcztcblxuICAgICAgICAvLyBjcmVhdGUgYSBkbmQgY2xpZW50XG4gICAgICAgIHZhciBjbGllbnQgPSBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGNhdGNoZXNEcm9wc09uUGFnZSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IHNjb3BlLFxuICAgICAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3VycmVudCBjbGllbnQgc3RhdGVcbiAgICAgICAgdmFyIGxhc3RTdGF0ZSA9ICcnO1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gJyc7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lcyBpZiBhIGZpbGUgbWF5IGJlIGRyb3BwZWRcbiAgICAgICAgY2xpZW50LmFsbG93ZHJvcCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBjYW4sIHRocm93IGVycm9yIHRvIGluZGljYXRlIHRoZSBpdGVtcyBjYW5ub3QgYnkgZHJvcHBlZFxuXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJdGVtcyhmaWx0ZXJJdGVtcyhpdGVtcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmRyb3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgaXRlbXMpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVySXRlbXMoaXRlbXMpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlSXRlbXMoZmlsdGVyZWRJdGVtcykpIHtcbiAgICAgICAgICAgICAgICBhcGkub25kcmFnZW5kKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9ICdkcmFnLWRyb3AnO1xuXG4gICAgICAgICAgICBhcGkub25sb2FkKGZpbHRlcmVkSXRlbXMsIHBvc2l0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbGllbnQub25kcmFnID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGFwaS5vbmRyYWcocG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmVudGVyID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9ICdkcmFnLW92ZXInO1xuXG4gICAgICAgICAgICBhcGkub25kcmFnc3RhcnQocG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsaWVudC5vbmV4aXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZXhpdCc7XG5cbiAgICAgICAgICAgIGFwaS5vbmRyYWdlbmQocG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICB1cGRhdGVIb3BwZXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlSG9wcGVyU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAhPT0gY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRhdGFzZXQuaG9wcGVyU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgICAgICAgIG9uZHJhZ3N0YXJ0OiBmdW5jdGlvbiBvbmRyYWdzdGFydCgpIHt9LFxuICAgICAgICAgICAgb25kcmFnOiBmdW5jdGlvbiBvbmRyYWcoKSB7fSxcbiAgICAgICAgICAgIG9uZHJhZ2VuZDogZnVuY3Rpb24gb25kcmFnZW5kKCkge30sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgY2xpZW50XG4gICAgICAgICAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbmluZyA9IGZhbHNlO1xuICAgIHZhciBsaXN0ZW5lcnMkMSA9IFtdO1xuXG4gICAgdmFyIGhhbmRsZVBhc3RlID0gZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSkge1xuICAgICAgICAvLyBpZiBpcyBwYXN0aW5nIGluIGlucHV0IG9yIHRleHRhcmVhIGFuZCB0aGUgdGFyZ2V0IGlzIG91dHNpZGUgb2YgYSBmaWxlcG9uZCBzY29wZSwgaWdub3JlXG4gICAgICAgIHZhciBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChhY3RpdmVFbCAmJiAvdGV4dGFyZWF8aW5wdXQvaS50ZXN0KGFjdGl2ZUVsLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgLy8gdGVzdCB0ZXh0YXJlYSBvciBpbnB1dCBpcyBjb250YWluZWQgaW4gZmlsZXBvbmQgcm9vdFxuICAgICAgICAgICAgdmFyIGluU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gYWN0aXZlRWw7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZmlsZXBvbmQtLXJvb3QnKSkge1xuICAgICAgICAgICAgICAgICAgICBpblNjb3BlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW5TY29wZSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGUuY2xpcGJvYXJkRGF0YSkudGhlbihmdW5jdGlvbihmaWxlcykge1xuICAgICAgICAgICAgLy8gbm8gZmlsZXMgcmVjZWl2ZWRcbiAgICAgICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHJlY2VpdmVkIGZpbGVzXG4gICAgICAgICAgICBsaXN0ZW5lcnMkMS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGZpbGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihjYikge1xuICAgICAgICAvLyBjYW4ndCBhZGQgdHdpY2VcbiAgICAgICAgaWYgKGxpc3RlbmVycyQxLmluY2x1ZGVzKGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGluaXRpYWwgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXJzJDEucHVzaChjYik7XG5cbiAgICAgICAgLy8gc2V0dXAgcGFzdGUgbGlzdGVuZXIgZm9yIGVudGlyZSBwYWdlXG4gICAgICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgIH07XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBmdW5jdGlvbiB1bmxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgICBhcnJheVJlbW92ZShsaXN0ZW5lcnMkMSwgbGlzdGVuZXJzJDEuaW5kZXhPZihsaXN0ZW5lcikpO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwXG4gICAgICAgIGlmIChsaXN0ZW5lcnMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgICAgICAgICAgbGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhc3RlciA9IGZ1bmN0aW9uIGNyZWF0ZVBhc3RlcigpIHtcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoZmlsZXMpIHtcbiAgICAgICAgICAgIGFwaS5vbmxvYWQoZmlsZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHVubGlzdGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbihjYik7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAgICovXG4gICAgdmFyIGNyZWF0ZSRkID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0tYXNzaXN0YW50LScgKyBwcm9wcy5pZDtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ3N0YXR1cycpO1xuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLXJlbGV2YW50JywgJ2FkZGl0aW9ucycpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gbnVsbDtcblxuICAgIHZhciBmaWxlbmFtZXMgPSBbXTtcblxuICAgIHZhciBhc3Npc3QgPSBmdW5jdGlvbiBhc3Npc3Qocm9vdCwgbWVzc2FnZSkge1xuICAgICAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIH07XG5cbiAgICB2YXIgY2xlYXIkMSA9IGZ1bmN0aW9uIGNsZWFyKHJvb3QpIHtcbiAgICAgICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfTtcblxuICAgIHZhciBsaXN0TW9kaWZpZWQgPSBmdW5jdGlvbiBsaXN0TW9kaWZpZWQocm9vdCwgZmlsZW5hbWUsIGxhYmVsKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgICAgICBhc3Npc3QoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFiZWwgK1xuICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIHRvdGFsICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgICh0b3RhbCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1NJTkdVTEFSJylcbiAgICAgICAgICAgICAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9DT1VOVF9QTFVSQUwnKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjbGVhciBncm91cCBhZnRlciBzZXQgYW1vdW50IG9mIHRpbWUgc28gdGhlIHN0YXR1cyBpcyBub3QgcmVhZCB0d2ljZVxuICAgICAgICBjbGVhclRpbWVvdXQobm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0KTtcbiAgICAgICAgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyJDEocm9vdCk7XG4gICAgICAgIH0sIDE1MDApO1xuICAgIH07XG5cbiAgICB2YXIgaXNVc2luZ0ZpbGVQb25kID0gZnVuY3Rpb24gaXNVc2luZ0ZpbGVQb25kKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QuZWxlbWVudC5wYXJlbnROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbUFkZGVkID0gZnVuY3Rpb24gaXRlbUFkZGVkKF9yZWYyKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICAgICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgZmlsZW5hbWVzLnB1c2goaXRlbS5maWxlbmFtZSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCk7XG4gICAgICAgIGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsaXN0TW9kaWZpZWQocm9vdCwgZmlsZW5hbWVzLmpvaW4oJywgJyksIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0FEREVEJykpO1xuXG4gICAgICAgICAgICBmaWxlbmFtZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfSwgNzUwKTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1SZW1vdmVkID0gZnVuY3Rpb24gaXRlbVJlbW92ZWQoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICBpZiAoIWlzVXNpbmdGaWxlUG9uZChyb290KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBhY3Rpb24uaXRlbTtcbiAgICAgICAgbGlzdE1vZGlmaWVkKHJvb3QsIGl0ZW0uZmlsZW5hbWUsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1JFTU9WRUQnKSk7XG4gICAgfTtcblxuICAgIHZhciBpdGVtUHJvY2Vzc2VkID0gZnVuY3Rpb24gaXRlbVByb2Nlc3NlZChfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgICAgIC8vIHdpbGwgYWxzbyBub3RpZnkgdGhlIHVzZXIgd2hlbiBGaWxlUG9uZCBpcyBub3QgYmVpbmcgdXNlZCwgYXMgdGhlIHVzZXIgbWlnaHQgYmUgb2NjdXBpZWQgd2l0aCBvdGhlciBhY3Rpdml0aWVzIHdoaWxlIHVwbG9hZGluZyBhIGZpbGVcblxuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICAgICAgdmFyIGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19DT01QTEVURScpO1xuXG4gICAgICAgIGFzc2lzdChyb290LCBmaWxlbmFtZSArICcgJyArIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgdmFyIGl0ZW1Qcm9jZXNzZWRVbmRvID0gZnVuY3Rpb24gaXRlbVByb2Nlc3NlZFVuZG8oX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgICAgYWN0aW9uID0gX3JlZjUuYWN0aW9uO1xuICAgICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICAgICAgdmFyIGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJyk7XG5cbiAgICAgICAgYXNzaXN0KHJvb3QsIGZpbGVuYW1lICsgJyAnICsgbGFiZWwpO1xuICAgIH07XG5cbiAgICB2YXIgaXRlbUVycm9yID0gZnVuY3Rpb24gaXRlbUVycm9yKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG5cbiAgICAgICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgICAgIGFzc2lzdChyb290LCBhY3Rpb24uc3RhdHVzLm1haW4gKyAnICcgKyBmaWxlbmFtZSArICcgJyArIGFjdGlvbi5zdGF0dXMuc3ViKTtcbiAgICB9O1xuXG4gICAgdmFyIGFzc2lzdGFudCA9IGNyZWF0ZVZpZXcoe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSRkLFxuICAgICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgICAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICAgICAgRElEX0xPQURfSVRFTTogaXRlbUFkZGVkLFxuICAgICAgICAgICAgRElEX1JFTU9WRV9JVEVNOiBpdGVtUmVtb3ZlZCxcbiAgICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWQsXG5cbiAgICAgICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuICAgICAgICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuXG4gICAgICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGl0ZW1FcnJvcixcbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgfSksXG5cbiAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgIG5hbWU6ICdhc3Npc3RhbnQnLFxuICAgIH0pO1xuXG4gICAgdmFyIHRvQ2FtZWxzID0gZnVuY3Rpb24gdG9DYW1lbHMoc3RyaW5nKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICctJztcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoc2VwYXJhdG9yICsgJy4nLCAnZycpLCBmdW5jdGlvbihzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWIuY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XG4gICAgICAgIHZhciBpbW1pZGlhdGVPbmx5ID1cbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICAgIF9rZXkrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBEYXRlLm5vdygpIC0gbGFzdDtcblxuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBpbnRlcnZhbCBhbmQgZGlzdFxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlOiBpZiBkaXN0YW5jZSBpcyAxMCBtcyBhbmQgaW50ZXJ2YWwgaXMgMTYgbXMsXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGFuIGFkZGl0aW9uYWwgNm1zIGJlZm9yZSBjYWxsaW5nIHRoZSBmdW5jdGlvbilcbiAgICAgICAgICAgICAgICBpZiAoIWltbWlkaWF0ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGludGVydmFsIC0gZGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnbyFcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgTUFYX0ZJTEVTX0xJTUlUID0gMTAwMDAwMDtcblxuICAgIHZhciBwcmV2ZW50ID0gZnVuY3Rpb24gcHJldmVudChlKSB7XG4gICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGUkZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAvLyBBZGQgaWRcbiAgICAgICAgdmFyIGlkID0gcm9vdC5xdWVyeSgnR0VUX0lEJyk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gaWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY2xhc3NOYW1lXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSByb290LnF1ZXJ5KCdHRVRfQ0xBU1NfTkFNRScpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmllbGQgbGFiZWxcbiAgICAgICAgcm9vdC5yZWYubGFiZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KFxuICAgICAgICAgICAgICAgIGRyb3BMYWJlbCxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfSURMRScpLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gTGlzdCBvZiBpdGVtc1xuICAgICAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhsaXN0U2Nyb2xsZXIsIHsgdHJhbnNsYXRlWTogbnVsbCB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJhY2tncm91bmQgcGFuZWxcbiAgICAgICAgcm9vdC5yZWYucGFuZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhwYW5lbCwgeyBuYW1lOiAncGFuZWwtcm9vdCcgfSkpO1xuXG4gICAgICAgIC8vIEFzc2lzdGFudCBub3RpZmllcyBhc3Npc3RpdmUgdGVjaCB3aGVuIGNvbnRlbnQgY2hhbmdlc1xuICAgICAgICByb290LnJlZi5hc3Npc3RhbnQgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGFzc2lzdGFudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgcm9vdC5yZWYuZGF0YSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRhdGEsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSkpO1xuXG4gICAgICAgIC8vIE1lYXN1cmUgKHRlc3RzIGlmIGZpeGVkIGhlaWdodCB3YXMgc2V0KVxuICAgICAgICAvLyBET0NUWVBFIG5lZWRzIHRvIGJlIHNldCBmb3IgdGhpcyB0byB3b3JrXG4gICAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBjcmVhdGVFbGVtZW50JDEoJ2RpdicpO1xuICAgICAgICByb290LnJlZi5tZWFzdXJlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLm1lYXN1cmUpO1xuXG4gICAgICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSByb290IGhlaWdodCBvciBmaXhlZCBoZWlnaHQgc3RhdHVzXG4gICAgICAgIHJvb3QucmVmLmJvdW5kcyA9IG51bGw7XG5cbiAgICAgICAgLy8gYXBwbHkgaW5pdGlhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIHJvb3QucXVlcnkoJ0dFVF9TVFlMRVMnKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eShzdHlsZS52YWx1ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHdpZHRoIGNoYW5nZWRcbiAgICAgICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCA9IGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFU0laRV9ST09UJyk7XG4gICAgICAgIH0sIDI1MCk7XG5cbiAgICAgICAgLy8gaGlzdG9yeSBvZiB1cGRhdGVzXG4gICAgICAgIHJvb3QucmVmLnByZXZpb3VzQXNwZWN0UmF0aW8gPSBudWxsO1xuICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG5cbiAgICAgICAgLy8gcHJldmVudCBzY3JvbGxpbmcgYW5kIHpvb21pbmcgb24gaU9TIChvbmx5IGlmIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLCBmb3IgdGhlbiB3ZSBjYW4gZW5hYmxlIHJlb3JkZXIpXG4gICAgICAgIHZhciBjYW5Ib3ZlciA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocG9pbnRlcjogZmluZSkgYW5kIChob3ZlcjogaG92ZXIpJykubWF0Y2hlcztcbiAgICAgICAgdmFyIGhhc1BvaW50ZXJFdmVudHMgPSAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3c7XG4gICAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpICYmIGhhc1BvaW50ZXJFdmVudHMgJiYgIWNhbkhvdmVyKSB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdnZXN0dXJlc3RhcnQnLCBwcmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjcmVkaXRzXG4gICAgICAgIHZhciBjcmVkaXRzID0gcm9vdC5xdWVyeSgnR0VUX0NSRURJVFMnKTtcbiAgICAgICAgdmFyIGhhc0NyZWRpdHMgPSBjcmVkaXRzLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgaWYgKGhhc0NyZWRpdHMpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgZnJhZy5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWNyZWRpdHMnO1xuICAgICAgICAgICAgZnJhZy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICAgIGZyYWcuaHJlZiA9IGNyZWRpdHNbMF07XG4gICAgICAgICAgICBmcmFnLnRhYmluZGV4ID0gLTE7XG4gICAgICAgICAgICBmcmFnLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgZnJhZy5yZWwgPSAnbm9vcGVuZXIgbm9yZWZlcnJlcic7XG4gICAgICAgICAgICBmcmFnLnRleHRDb250ZW50ID0gY3JlZGl0c1sxXTtcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHJvb3QucmVmLmNyZWRpdHMgPSBmcmFnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSQ5ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcyxcbiAgICAgICAgICAgIGFjdGlvbnMgPSBfcmVmMy5hY3Rpb25zO1xuICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgIHJvdXRlJDUoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG5cbiAgICAgICAgLy8gYXBwbHkgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXkRJRF9TRVRfU1RZTEVfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eShhY3Rpb24uZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9yZWY0LmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b0NhbWVscyh0eXBlLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpLCAnXycpO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0W25hbWVdID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICByb290LmludmFsaWRhdGVMYXlvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb290LnJlY3QuZWxlbWVudC5oaWRkZW4pIHJldHVybjtcblxuICAgICAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQud2lkdGggIT09IHJvb3QucmVmLndpZHRoUHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLndpZHRoUHJldmlvdXMgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGJveCBib3VuZHMsIHdlIGRvIHRoaXMgb25seSBvbmNlXG4gICAgICAgIHZhciBib3VuZHMgPSByb290LnJlZi5ib3VuZHM7XG4gICAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgICAgICBib3VuZHMgPSByb290LnJlZi5ib3VuZHMgPSBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQocm9vdCk7XG5cbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgbWVhc3VyZSBlbGVtZW50XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG4gICAgICAgICAgICByb290LnJlZi5tZWFzdXJlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VzIHRvIHZhcmlvdXMgaGlnaCBsZXZlbCBwYXJ0cyBvZiB0aGUgdXBsb2FkIHRvb2xcbiAgICAgICAgdmFyIF9yb290JHJlZiA9IHJvb3QucmVmLFxuICAgICAgICAgICAgaG9wcGVyID0gX3Jvb3QkcmVmLmhvcHBlcixcbiAgICAgICAgICAgIGxhYmVsID0gX3Jvb3QkcmVmLmxhYmVsLFxuICAgICAgICAgICAgbGlzdCA9IF9yb290JHJlZi5saXN0LFxuICAgICAgICAgICAgcGFuZWwgPSBfcm9vdCRyZWYucGFuZWw7XG5cbiAgICAgICAgLy8gc2V0cyBjb3JyZWN0IHN0YXRlIHRvIGhvcHBlciBzY29wZVxuICAgICAgICBpZiAoaG9wcGVyKSB7XG4gICAgICAgICAgICBob3BwZXIudXBkYXRlSG9wcGVyU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJvb2wgdG8gaW5kaWNhdGUgaWYgd2UncmUgZnVsbCBvciBub3RcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgICB2YXIgaXNNdWx0aUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gaXNNdWx0aUl0ZW0gPyByb290LnF1ZXJ5KCdHRVRfTUFYX0ZJTEVTJykgfHwgTUFYX0ZJTEVTX0xJTUlUIDogMTtcbiAgICAgICAgdmFyIGF0TWF4Q2FwYWNpdHkgPSB0b3RhbEl0ZW1zID09PSBtYXhJdGVtcztcblxuICAgICAgICAvLyBhY3Rpb24gdXNlZCB0byBhZGQgaXRlbVxuICAgICAgICB2YXIgYWRkQWN0aW9uID0gYWN0aW9ucy5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi50eXBlID09PSAnRElEX0FERF9JVEVNJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgcmVhY2hlZCBtYXggY2FwYWNpdHkgYW5kIHdlJ3ZlIGp1c3QgcmVhY2hlZCBpdFxuICAgICAgICBpZiAoYXRNYXhDYXBhY2l0eSAmJiBhZGRBY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGdldCBpbnRlcmFjdGlvbiB0eXBlXG4gICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb25NZXRob2QgPSBhZGRBY3Rpb24uZGF0YS5pbnRlcmFjdGlvbk1ldGhvZDtcblxuICAgICAgICAgICAgLy8gaGlkZSBsYWJlbFxuICAgICAgICAgICAgbGFiZWwub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChpc011bHRpSXRlbSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAtNDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSA0MDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDQwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAzMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWF0TWF4Q2FwYWNpdHkpIHtcbiAgICAgICAgICAgIGxhYmVsLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDA7XG4gICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0SXRlbU1hcmdpbiA9IGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luKHJvb3QpO1xuXG4gICAgICAgIHZhciBsaXN0SGVpZ2h0ID0gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KTtcblxuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSBsYWJlbC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB2YXIgY3VycmVudExhYmVsSGVpZ2h0ID0gIWlzTXVsdGlJdGVtIHx8IGF0TWF4Q2FwYWNpdHkgPyAwIDogbGFiZWxIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpc3RNYXJnaW5Ub3AgPSBhdE1heENhcGFjaXR5ID8gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wIDogMDtcbiAgICAgICAgdmFyIGxpc3RNYXJnaW5Cb3R0b20gPSB0b3RhbEl0ZW1zID09PSAwID8gMCA6IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcblxuICAgICAgICB2YXIgdmlzdWFsSGVpZ2h0ID1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LnZpc3VhbCArIGxpc3RNYXJnaW5Cb3R0b207XG4gICAgICAgIHZhciBib3VuZHNIZWlnaHQgPVxuICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0ICsgbGlzdE1hcmdpblRvcCArIGxpc3RIZWlnaHQuYm91bmRzICsgbGlzdE1hcmdpbkJvdHRvbTtcblxuICAgICAgICAvLyBsaW5rIGxpc3QgdG8gbGFiZWwgYm90dG9tIHBvc2l0aW9uXG4gICAgICAgIGxpc3QudHJhbnNsYXRlWSA9XG4gICAgICAgICAgICBNYXRoLm1heCgwLCBjdXJyZW50TGFiZWxIZWlnaHQgLSBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3ApIC0gbGlzdEl0ZW1NYXJnaW4udG9wO1xuXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgLy8gZml4ZWQgYXNwZWN0IHJhdGlvXG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBoZWlnaHQgYmFzZWQgb24gd2lkdGhcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIGhpc3RvcnkgaWYgYXNwZWN0IHJhdGlvIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8gIT09IHJvb3QucmVmLnByZXZpb3VzQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGlzIHdpZHRoXG4gICAgICAgICAgICB2YXIgaGlzdG9yeSA9IHJvb3QucmVmLnVwZGF0ZUhpc3Rvcnk7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2god2lkdGgpO1xuXG4gICAgICAgICAgICB2YXIgTUFYX0JPVU5DRVMgPSAyO1xuICAgICAgICAgICAgaWYgKGhpc3RvcnkubGVuZ3RoID4gTUFYX0JPVU5DRVMgKiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBoaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gbCAtIDEwO1xuICAgICAgICAgICAgICAgIHZhciBib3VuY2VzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbDsgaSA+PSBib3R0b207IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeVtpXSA9PT0gaGlzdG9yeVtpIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5jZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuY2VzID49IE1BWF9CT1VOQ0VTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb250IGFkanVzdCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbCBzbyBpdCBhZGhlcmVzIHRvIGFzcGVjdCByYXRpb1xuICAgICAgICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhbmVsLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICAgICAgdmFyIGxpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgICAgICBoZWlnaHQgLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RIZWlnaHQudmlzdWFsID4gbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICAgICAgICByb290LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZHMuZml4ZWRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGZpeGVkIGhlaWdodFxuXG4gICAgICAgICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsXG4gICAgICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgICAgICB2YXIgX2xpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgICAgICBib3VuZHMuZml4ZWRIZWlnaHQgLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0XG4gICAgICAgICAgICBpZiAobGlzdEhlaWdodC52aXN1YWwgPiBfbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IGNvbnRhaW5lciBib3VuZHMgYXMgdGhlc2UgYXJlIGhhbmRsZXMgYnkgQ1NTIGZpeGVkIGhlaWdodFxuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kcy5jYXBwZWRIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIG1heC1oZWlnaHRcblxuICAgICAgICAgICAgLy8gbm90IGEgZml4ZWQgaGVpZ2h0IHBhbmVsXG4gICAgICAgICAgICB2YXIgaXNDYXBwZWRIZWlnaHQgPSB2aXN1YWxIZWlnaHQgPj0gYm91bmRzLmNhcHBlZEhlaWdodDtcbiAgICAgICAgICAgIHZhciBwYW5lbEhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5jYXBwZWRIZWlnaHQsIHZpc3VhbEhlaWdodCk7XG4gICAgICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBwYW5lbC5oZWlnaHQgPSBpc0NhcHBlZEhlaWdodFxuICAgICAgICAgICAgICAgID8gcGFuZWxIZWlnaHRcbiAgICAgICAgICAgICAgICA6IHBhbmVsSGVpZ2h0IC0gbGlzdEl0ZW1NYXJnaW4udG9wIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgICAgICB2YXIgX2xpc3RBdmFpbGFibGVIZWlnaHQyID1cbiAgICAgICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgcGFuZWxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0IChpZiBpcyBvdmVyZmxvd2luZylcbiAgICAgICAgICAgIGlmICh2aXN1YWxIZWlnaHQgPiBib3VuZHMuY2FwcGVkSGVpZ2h0ICYmIGxpc3RIZWlnaHQudmlzdWFsID4gX2xpc3RBdmFpbGFibGVIZWlnaHQyKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IF9saXN0QXZhaWxhYmxlSGVpZ2h0MjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBib3VuZHMuY2FwcGVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdW5kc0hlaWdodCAtIGxpc3RJdGVtTWFyZ2luLnRvcCAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZsZXhpYmxlIGhlaWdodFxuXG4gICAgICAgICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgICAgICAgIHZhciBpdGVtTWFyZ2luID0gdG90YWxJdGVtcyA+IDAgPyBsaXN0SXRlbU1hcmdpbi50b3AgKyBsaXN0SXRlbU1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIHZpc3VhbEhlaWdodCAtIGl0ZW1NYXJnaW4pO1xuXG4gICAgICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIGJvdW5kc0hlaWdodCAtIGl0ZW1NYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSBjcmVkaXRzIHRvIGJvdHRvbVxuICAgICAgICBpZiAocm9vdC5yZWYuY3JlZGl0cyAmJiBwYW5lbC5oZWlnaHRDdXJyZW50KVxuICAgICAgICAgICAgcm9vdC5yZWYuY3JlZGl0cy5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgnICsgcGFuZWwuaGVpZ2h0Q3VycmVudCArICdweCknO1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4gPSBmdW5jdGlvbiBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbihyb290KSB7XG4gICAgICAgIHZhciBpdGVtID0gcm9vdC5yZWYubGlzdC5jaGlsZFZpZXdzWzBdLmNoaWxkVmlld3NbMF07XG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHRvcDogaXRlbS5yZWN0LmVsZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgYm90dG9tOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlTGlzdEhlaWdodCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUxpc3RIZWlnaHQocm9vdCkge1xuICAgICAgICB2YXIgdmlzdWFsID0gMDtcbiAgICAgICAgdmFyIGJvdW5kcyA9IDA7XG5cbiAgICAgICAgLy8gZ2V0IGZpbGUgbGlzdCByZWZlcmVuY2VcbiAgICAgICAgdmFyIHNjcm9sbExpc3QgPSByb290LnJlZi5saXN0O1xuICAgICAgICB2YXIgaXRlbUxpc3QgPSBzY3JvbGxMaXN0LmNoaWxkVmlld3NbMF07XG4gICAgICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSBpdGVtTGlzdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG5vIGNoaWxkcmVuLCBkb25lIVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4geyB2aXN1YWw6IHZpc3VhbCwgYm91bmRzOiBib3VuZHMgfTtcblxuICAgICAgICB2YXIgaG9yaXpvbnRhbFNwYWNlID0gaXRlbUxpc3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICB2YXIgZHJhZ0luZGV4ID0gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihpdGVtTGlzdCwgY2hpbGRyZW4sIHNjcm9sbExpc3QuZHJhZ0Nvb3JkaW5hdGVzKTtcblxuICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuXG4gICAgICAgIHZhciBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICAgICAgdmFyIGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpbkxlZnQgKyBjaGlsZFJlY3QubWFyZ2luUmlnaHQ7XG5cbiAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICAgICAgdmFyIG5ld0l0ZW0gPSB0eXBlb2YgZHJhZ0luZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBkcmFnSW5kZXggPj0gMCA/IDEgOiAwO1xuICAgICAgICB2YXIgcmVtb3ZlZEl0ZW0gPSBjaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC40NTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgdmFyIHZlcnRpY2FsSXRlbUNvdW50ID0gY2hpbGRyZW4ubGVuZ3RoICsgbmV3SXRlbSArIHJlbW92ZWRJdGVtO1xuICAgICAgICB2YXIgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAgICAgLy8gc3RhY2tcbiAgICAgICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICAgICAgICAgIGJvdW5kcyArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmlzdWFsICs9IGhlaWdodCAqIGl0ZW0ub3BhY2l0eTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyaWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3VuZHMgPSBNYXRoLmNlaWwodmVydGljYWxJdGVtQ291bnQgLyBpdGVtc1BlclJvdykgKiBpdGVtSGVpZ2h0O1xuICAgICAgICAgICAgdmlzdWFsID0gYm91bmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmlzdWFsOiB2aXN1YWwsIGJvdW5kczogYm91bmRzIH07XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQocm9vdCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZUhlaWdodCB8fCBudWxsO1xuICAgICAgICB2YXIgY2FwcGVkSGVpZ2h0ID0gcGFyc2VJbnQocm9vdC5zdHlsZS5tYXhIZWlnaHQsIDEwKSB8fCBudWxsO1xuICAgICAgICB2YXIgZml4ZWRIZWlnaHQgPSBoZWlnaHQgPT09IDAgPyBudWxsIDogaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYXBwZWRIZWlnaHQ6IGNhcHBlZEhlaWdodCxcbiAgICAgICAgICAgIGZpeGVkSGVpZ2h0OiBmaXhlZEhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGV4Y2VlZHNNYXhGaWxlcyA9IGZ1bmN0aW9uIGV4Y2VlZHNNYXhGaWxlcyhyb290LCBpdGVtcykge1xuICAgICAgICB2YXIgYWxsb3dSZXBsYWNlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFUExBQ0UnKTtcbiAgICAgICAgdmFyIGFsbG93TXVsdGlwbGUgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpO1xuXG4gICAgICAgIC8vIHRvdGFsIGFtb3VudCBvZiBpdGVtcyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHZhciB0b3RhbEJyb3dzZUl0ZW1zID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGlmIGRvZXMgbm90IGFsbG93IG11bHRpcGxlIGl0ZW1zIGFuZCBkcmFnZ2luZyBtb3JlIHRoYW4gb25lIGl0ZW1cbiAgICAgICAgaWYgKCFhbGxvd011bHRpcGxlICYmIHRvdGFsQnJvd3NlSXRlbXMgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgICAgICBtYXhJdGVtcyA9IGFsbG93TXVsdGlwbGUgPyBtYXhJdGVtcyA6IGFsbG93UmVwbGFjZSA/IG1heEl0ZW1zIDogMTtcblxuICAgICAgICAvLyBubyBtb3JlIHJvb20/XG4gICAgICAgIHZhciBoYXNNYXhJdGVtcyA9IGlzSW50KG1heEl0ZW1zKTtcbiAgICAgICAgaWYgKGhhc01heEl0ZW1zICYmIHRvdGFsSXRlbXMgKyB0b3RhbEJyb3dzZUl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBnZXREcmFnSW5kZXggPSBmdW5jdGlvbiBnZXREcmFnSW5kZXgobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpdGVtTGlzdCA9IGxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgcmV0dXJuIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCB7XG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5zY29wZUxlZnQgLSBpdGVtTGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgICAgIHRvcDpcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAgICAgKGxpc3QucmVjdC5vdXRlci50b3AgKyBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyBsaXN0LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZmlsZSBkcm9wIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICB2YXIgdG9nZ2xlRHJvcCA9IGZ1bmN0aW9uIHRvZ2dsZURyb3Aocm9vdCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RST1AnKTtcbiAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgICAgIHZhciBob3BwZXIgPSBjcmVhdGVIb3BwZXIoXG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHF1aWNrIHZhbGlkYXRpb24gb2YgZHJvcHBlZCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlRHJvcEZpbGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBpdGVtcyBzaG91bGQgYmUgdmFsaWRhdGVkIGJ5IGFsbCBmaWx0ZXJzIGFzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcm9wVmFsaWRhdGlvbiA9IHJvb3QucXVlcnkoJ0dFVF9EUk9QX1ZBTElEQVRJT04nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BWYWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGl0ZW1zLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdBTExPV19IT1BQRVJfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHJvb3QucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZXZlcnkoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgJiYgYmVmb3JlRHJvcEZpbGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJJdGVtcyhpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHJvb3QucXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaWxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlOiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9QQUdFJyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudDogcm9vdC5xdWVyeSgnR0VUX0RST1BfT05fRUxFTUVOVCcpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcywgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgaXRlbSBjaGlsZHJlbiBlbGVtZW50cyBhbmQgc29ydCBiYXNlZCBvbiBsaXN0IHNvcnRcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gbGlzdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgcXVldWVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXREcmFnSW5kZXgocm9vdC5yZWYubGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG5cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1NUQVJUX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhvcHBlci5vbmRyYWcgPSBkZWJvdW5jZShmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaG9wcGVyLm9uZHJhZ2VuZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIgPSBob3BwZXI7XG5cbiAgICAgICAgICAgIHJvb3QucmVmLmRyaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhkcmlwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgcm9vdC5yZWYuaG9wcGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmRyaXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGJyb3dzZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZUJyb3dzZSA9IGZ1bmN0aW9uIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcykge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICAgICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlcixcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYuYnJvd3Nlcik7XG4gICAgICAgICAgICByb290LnJlZi5icm93c2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgdmFyIHRvZ2dsZVBhc3RlID0gZnVuY3Rpb24gdG9nZ2xlUGFzdGUocm9vdCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BBU1RFJyk7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgICAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBjcmVhdGVQYXN0ZXIoKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3Rlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4oZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbXMhXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5QQVNURSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3RlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm91dGUgYWN0aW9uc1xuICAgICAqL1xuICAgIHZhciByb3V0ZSQ1ID0gY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfU0VUX0FMTE9XX0JST1dTRTogZnVuY3Rpb24gRElEX1NFVF9BTExPV19CUk9XU0UoX3JlZjUpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX1NFVF9BTExPV19EUk9QOiBmdW5jdGlvbiBESURfU0VUX0FMTE9XX0RST1AoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9TRVRfQUxMT1dfUEFTVEU6IGZ1bmN0aW9uIERJRF9TRVRfQUxMT1dfUEFTVEUoX3JlZjcpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgICAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgICAgICB9LFxuICAgICAgICBESURfU0VUX0RJU0FCTEVEOiBmdW5jdGlvbiBESURfU0VUX0RJU0FCTEVEKF9yZWY4KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfcmVmOC5wcm9wcztcbiAgICAgICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgICAgICB0b2dnbGVQYXN0ZShyb290KTtcbiAgICAgICAgICAgIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcyk7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZCA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZDsgPD0gdGhpcyBkb2VzIG5vdCB3b3JrIG9uIGlPUyAxMFxuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHZhciByb290ID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6ICdyb290JyxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgICAgICAgaWYgKHJvb3QucmVmLm1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5tZWFzdXJlSGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlJGUsXG4gICAgICAgIHdyaXRlOiB3cml0ZSQ5LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgICAgICAgIGlmIChyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1peGluczoge1xuICAgICAgICAgICAgc3R5bGVzOiBbJ2hlaWdodCddLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlcyB0aGUgYXBwXG4gICAgdmFyIGNyZWF0ZUFwcCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgLy8gbGV0IGVsZW1lbnRcbiAgICAgICAgdmFyIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgICAgICAgICAgLy8gaW5pdGlhbCBzdGF0ZSAoc2hvdWxkIGJlIHNlcmlhbGl6YWJsZSlcbiAgICAgICAgICAgIGNyZWF0ZUluaXRpYWxTdGF0ZShkZWZhdWx0T3B0aW9ucyksXG5cbiAgICAgICAgICAgIC8vIHF1ZXJpZXNcbiAgICAgICAgICAgIFtxdWVyaWVzLCBjcmVhdGVPcHRpb25RdWVyaWVzKGRlZmF1bHRPcHRpb25zKV0sXG5cbiAgICAgICAgICAgIC8vIGFjdGlvbiBoYW5kbGVyc1xuICAgICAgICAgICAgW2FjdGlvbnMsIGNyZWF0ZU9wdGlvbkFjdGlvbnMoZGVmYXVsdE9wdGlvbnMpXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIG9wdGlvbnNcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1NFVF9PUFRJT05TJywgeyBvcHRpb25zOiBpbml0aWFsT3B0aW9ucyB9KTtcblxuICAgICAgICAvLyBraWNrIHRocmVhZCBpZiB2aXNpYmlsaXR5IGNoYW5nZXNcbiAgICAgICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSByZXR1cm47XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICAgICAgdmFyIHJlc2l6ZURvbmVUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgICAgIHZhciBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplRG9uZVRpbWVyKTtcbiAgICAgICAgICAgIHJlc2l6ZURvbmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNpemluZ0hvcml6b250YWxseSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgLy8gcmVuZGVyIGluaXRpYWwgdmlld1xuICAgICAgICB2YXIgdmlldyA9IHJvb3Qoc3RvcmUsIHsgaWQ6IGdldFVuaXF1ZUlkKCkgfSk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUFJJVkFURSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICB2YXIgaXNSZXN0aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgIHZhciByZWFkV3JpdGVBcGkgPSB7XG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVhZHMgZnJvbSBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVhZDogZnVuY3Rpb24gX3JlYWQoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZXNpemluZyBob3Jpem9udGFsbHlcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbWVhc3VyaW5nIHJvb3QgcmVjdFxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFdpbmRvd1dpZHRoID0gY3VycmVudFdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ICYmIGN1cnJlbnRXaW5kb3dXaWR0aCAhPT0gaW5pdGlhbFdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUQVJUX1JFU0laRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaXNSZXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXMgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3LmVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0aW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyByZWFkIHZpZXcgZGF0YVxuICAgICAgICAgICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGlzIGhpZGRlbiB3ZSBuZWVkIHRvIGtub3cgc28gd2UgZXhpdCByZXN0IG1vZGUgd2hlbiByZXZlYWxlZFxuICAgICAgICAgICAgICAgIGlzSGlkZGVuID0gdmlldy5yZWN0LmVsZW1lbnQuaGlkZGVuO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZXMgdG8gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3dyaXRlOiBmdW5jdGlvbiBfd3JpdGUodHMpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGFjdGlvbnMgZnJvbSBzdG9yZVxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25zID0gc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLnByb2Nlc3NBY3Rpb25RdWV1ZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBzZXQgYWN0aW9ucyAodGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRElEX1NFVClcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhL15TRVRfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB3YXMgaWRsaW5nIGFuZCBubyBhY3Rpb25zIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcgJiYgIWFjdGlvbnMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgICAgICAgICByb3V0ZUFjdGlvbnNUb0V2ZW50cyhhY3Rpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld1xuICAgICAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY2xlYW4gdXAgYWxsIGFyY2hpdmVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgcmVtb3ZlUmVsZWFzZWRJdGVtcyhzdG9yZS5xdWVyeSgnR0VUX0lURU1TJykpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHJvY2Vzc0Rpc3BhdGNoUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVYUE9TRSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICB2YXIgY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGV2ZW50XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmVycm9yID0gZGF0YS5lcnJvciA/IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuZXJyb3IpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQub3V0cHV0ID0gZGF0YS5maWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc291cmNlIGlzIGF2YWlsYWJsZSwgZWxzZSBhZGQgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5maWxlID0gZGF0YS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLml0ZW0gfHwgZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGEuaXRlbSA/IGRhdGEuaXRlbSA6IHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTScsIGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5maWxlID0gaXRlbSA/IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1hcCBhbGwgaXRlbXMgaW4gYSBwb3NzaWJsZSBpdGVtcyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lml0ZW1zID0gZGF0YS5pdGVtcy5tYXAoY3JlYXRlSXRlbUFQSSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgICAgICAgICAgaWYgKC9wcm9ncmVzcy8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdvcmlnaW4nKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCd0YXJnZXQnKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW4gPSBkYXRhLm9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZGF0YS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXZlbnRSb3V0ZXMgPSB7XG4gICAgICAgICAgICBESURfREVTVFJPWTogY3JlYXRlRXZlbnQoJ2Rlc3Ryb3knKSxcblxuICAgICAgICAgICAgRElEX0lOSVQ6IGNyZWF0ZUV2ZW50KCdpbml0JyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19NQVhfRklMRVM6IGNyZWF0ZUV2ZW50KCd3YXJuaW5nJyksXG5cbiAgICAgICAgICAgIERJRF9JTklUX0lURU06IGNyZWF0ZUV2ZW50KCdpbml0ZmlsZScpLFxuICAgICAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogY3JlYXRlRXZlbnQoJ2FkZGZpbGVzdGFydCcpLFxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgICAgIERJRF9MT0FEX0lURU06IGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncmVtb3ZlZmlsZScpXSxcblxuICAgICAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBjcmVhdGVFdmVudCgncHJlcGFyZWZpbGUnKSxcblxuICAgICAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlc3RhcnQnKSxcbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVwcm9ncmVzcycpLFxuICAgICAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlYWJvcnQnKSxcbiAgICAgICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpLFxuICAgICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lOR19BTEw6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXMnKSxcbiAgICAgICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVyZXZlcnQnKSxcblxuICAgICAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKV0sXG5cbiAgICAgICAgICAgIERJRF9SRU1PVkVfSVRFTTogY3JlYXRlRXZlbnQoJ3JlbW92ZWZpbGUnKSxcblxuICAgICAgICAgICAgRElEX1VQREFURV9JVEVNUzogY3JlYXRlRXZlbnQoJ3VwZGF0ZWZpbGVzJyksXG5cbiAgICAgICAgICAgIERJRF9BQ1RJVkFURV9JVEVNOiBjcmVhdGVFdmVudCgnYWN0aXZhdGVmaWxlJyksXG5cbiAgICAgICAgICAgIERJRF9SRU9SREVSX0lURU1TOiBjcmVhdGVFdmVudCgncmVvcmRlcmZpbGVzJyksXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cG9zZUV2ZW50ID0gZnVuY3Rpb24gZXhwb3NlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBldmVudCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgdmFyIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBwb25kOiBleHBvcnRzIH0sIGV2ZW50KTtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXRhaWwudHlwZTtcbiAgICAgICAgICAgIHZpZXcuZWxlbWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6JyArIGV2ZW50LnR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgaW5mb1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudCBiZWhhdmlvdXJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zZWQ6IHRydWUsIC8vIHRyaWdnZXJzIGxpc3RlbmVycyBvdXRzaWRlIG9mIHNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IG9iamVjdCB0byBwYXJhbXMgdXNlZCBmb3IgYG9uKClgIGV2ZW50IGhhbmRsZXJzIGFuZCBjYWxsYmFja3MgYG9uaW5pdCgpYFxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBpZiBpcyBwb3NzaWJsZSBlcnJvciBldmVudCwgbWFrZSBpdCB0aGUgZmlyc3QgcGFyYW1cbiAgICAgICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdmaWxlJykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChldmVudC5maWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwZW5kIG90aGVyIHByb3BzXG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBbJ3R5cGUnLCAnZXJyb3InLCAnZmlsZSddO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWx0ZXJlZC5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucHVzaChldmVudFtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb24odHlwZSwgKCkgPT4geyB9KVxuICAgICAgICAgICAgZXhwb3J0cy5maXJlLmFwcGx5KGV4cG9ydHMsIFtldmVudC50eXBlXS5jb25jYXQocGFyYW1zKSk7XG5cbiAgICAgICAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHN0b3JlLnF1ZXJ5KCdHRVRfT04nICsgZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvdXRlQWN0aW9uc1RvRXZlbnRzID0gZnVuY3Rpb24gcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocm91dGVzKSA/IHJvdXRlcyA6IFtyb3V0ZXNdKS5mb3JFYWNoKGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGZhbnRhc3RpYywgYnV0IGJlY2F1c2Ugb2YgdGhlIHN0YWNraW5nIG9mIHNldHRpbWVvdXRzIHBsdWdpbnMgY2FuIGhhbmRsZSB0aGUgZGlkX2xvYWQgYmVmb3JlIHRoZSBkaWRfaW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRElEX0lOSVRfSVRFTScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBQVUJMSUMgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJlcGFyZUZpbGUgPSBmdW5jdGlvbiBwcmVwYXJlRmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJFUEFSRScsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkRmlsZSA9IGZ1bmN0aW9uIGFkZEZpbGUoc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgYWRkRmlsZXMoW3sgc291cmNlOiBzb3VyY2UsIG9wdGlvbnM6IG9wdGlvbnMgfV0sIHsgaW5kZXg6IG9wdGlvbnMuaW5kZXggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNGaWxlUG9uZEZpbGUgPSBmdW5jdGlvbiBpc0ZpbGVQb25kRmlsZShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsZSAmJiBvYmouaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZpbGUgPSBmdW5jdGlvbiByZW1vdmVGaWxlKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBpZiBvbmx5IHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiAhaXNGaWxlUG9uZEZpbGUocXVlcnkpICYmICFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGl0ZW0gcmVtb3ZhbFxuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBxdWVyeTogcXVlcnkgfSkpO1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KSA9PT0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkRmlsZXMgPSBmdW5jdGlvbiBhZGRGaWxlcygpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gdXNlciBwYXNzZWQgYSBzb3VyY2VzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoLmFwcGx5KHNvdXJjZXMsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIHNvdXJjZXMgYXMgYXJndW1lbnRzLCBsYXN0IG9uZSBtaWdodCBiZSBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEFyZ3VtZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgIShsYXN0QXJndW1lbnQgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCByZXN0IHRvIHNvdXJjZXNcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoLmFwcGx5KHNvdXJjZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkFQSSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEZpbGVzID0gZnVuY3Rpb24gZ2V0RmlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJvY2Vzc0ZpbGUgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZShxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJlcGFyZUZpbGVzID0gZnVuY3Rpb24gcHJlcGFyZUZpbGVzKCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwO1xuICAgICAgICAgICAgICAgIF9rZXkyIDwgX2xlbjI7XG4gICAgICAgICAgICAgICAgX2tleTIrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBxdWVyaWVzLmxlbmd0aCA/IHF1ZXJpZXMgOiBnZXRGaWxlcygpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChwcmVwYXJlRmlsZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcm9jZXNzRmlsZXMgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7XG4gICAgICAgICAgICAgICAgX2tleTMgPCBfbGVuMztcbiAgICAgICAgICAgICAgICBfa2V5MysrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBnZXRGaWxlcygpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLklETEUgJiYgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVzLm1hcChwcm9jZXNzRmlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXJpZXMubWFwKHByb2Nlc3NGaWxlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZpbGVzID0gZnVuY3Rpb24gcmVtb3ZlRmlsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7XG4gICAgICAgICAgICAgICAgX2tleTQgPCBfbGVuNDtcbiAgICAgICAgICAgICAgICBfa2V5NCsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcmllc1txdWVyaWVzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyaWVzLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGdldEZpbGVzKCk7XG5cbiAgICAgICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgICAgICBmaWxlcy5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUoZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gd2hlbiByZW1vdmluZyBieSBpbmRleCB0aGUgaW5kZXhlcyBzaGlmdCBhZnRlciBlYWNoIGZpbGUgcmVtb3ZhbCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaW5kZXhlcyB0byBpZHNcbiAgICAgICAgICAgIHZhciBtYXBwZWRRdWVyaWVzID0gcXVlcmllc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHF1ZXJ5KSA/IChmaWxlc1txdWVyeV0gPyBmaWxlc1txdWVyeV0uaWQgOiBudWxsKSA6IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXBwZWRRdWVyaWVzLm1hcChmdW5jdGlvbihxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUocSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgb24oKSxcbiAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICByZWFkV3JpdGVBcGksXG4gICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT3ZlcnJpZGUgb3B0aW9ucyBkZWZpbmVkIGluIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCB0aGUgZ2l2ZW4gZmlsZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgc291cmNlIG9mIHRoZSBmaWxlIChlaXRoZXIgYSBGaWxlLCBiYXNlNjQgZGF0YSB1cmkgb3IgdXJsKVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhZGRGaWxlOiBhZGRGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCB0aGUgZ2l2ZW4gZmlsZXNcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc291cmNlcyAtIHRoZSBzb3VyY2VzIG9mIHRoZSBmaWxlcyB0byBsb2FkXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFkZEZpbGVzOiBhZGRGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGZpbGUgb2JqZWN0cyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnlcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0RmlsZTogZ2V0RmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVwbG9hZCBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZpbGU6IHByb2Nlc3NGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVxdWVzdCBwcmVwYXJlIG91dHB1dCBmb3IgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXBhcmVGaWxlOiBwcmVwYXJlRmlsZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYSBmaWxlIGJ5IGl0cyBuYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW1vdmVGaWxlOiByZW1vdmVGaWxlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbW92ZUZpbGU6IGZ1bmN0aW9uIG1vdmVGaWxlKHF1ZXJ5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHF1ZXJ5LCBpbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYWxsIGZpbGVzICh3cmFwcGVkIGluIHB1YmxpYyBhcGkpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0RmlsZXM6IGdldEZpbGVzLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3RhcnRzIHVwbG9hZGluZyBhbGwgZmlsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcm9jZXNzRmlsZXM6IHByb2Nlc3NGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbW92ZUZpbGVzOiByZW1vdmVGaWxlcyxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFN0YXJ0cyBwcmVwYXJpbmcgb3V0cHV0IG9mIGFsbCBmaWxlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXBhcmVGaWxlczogcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU29ydCBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU09SVCcsIHsgY29tcGFyZTogY29tcGFyZSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQnJvd3NlIHRoZSBmaWxlIHN5c3RlbSBmb3IgYSBmaWxlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnJvd3NlOiBmdW5jdGlvbiBicm93c2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIHRyaWdnZXIgZGlyZWN0bHkgYXMgdXNlciBhY3Rpb24gbmVlZHMgdG8gYmUgdHJhY2VhYmxlIChpcyBub3QgdHJhY2VhYmxlIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERlc3Ryb3lzIHRoZSBhcHBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGRlc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuZmlyZSgnZGVzdHJveScsIHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGl0ZW1zIGFuZCBkZXBlbmRpbmcgb24gc3RhdGVzIGNhbGwgYWJvcnQgZm9yIG9uZ29pbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBQk9SVF9BTEwnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlIHZpc2libGl0eWNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0RJRF9ERVNUUk9ZJyk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEluc2VydHMgdGhlIHBsdWdpbiBiZWZvcmUgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUkMShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbiBpbnNlcnRBZnRlciQxKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEFmdGVyKHZpZXcuZWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFwcGVuZHMgdGhlIHBsdWdpbiB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hcHBlbmRDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXBsYWNlcyBhbiBlbGVtZW50IHdpdGggdGhlIGFwcFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlcGxhY2VFbGVtZW50OiBmdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgYXBwIGJlZm9yZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXN0b3JlRWxlbWVudDogZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vIGVsZW1lbnQgdG8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEFmdGVyKG9yaWdpbmFsRWxlbWVudCwgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3VyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdmlldy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwIHJvb3QgaXMgYXR0YWNoZWQgdG8gZ2l2ZW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXNBdHRhY2hlZFRvOiBmdW5jdGlvbiBpc0F0dGFjaGVkVG8oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50ID09PSBlbGVtZW50IHx8IG9yaWdpbmFsRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9uZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9TVEFUVVMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERvbmUhXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfSU5JVCcpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhY3R1YWwgYXBpIG9iamVjdFxuICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4cG9ydHMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQXBwT2JqZWN0ID0gZnVuY3Rpb24gY3JlYXRlQXBwT2JqZWN0KCkge1xuICAgICAgICB2YXIgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldID0gdmFsdWVbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCBhcHAgb3B0aW9uc1xuICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICB7fSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHt9LFxuXG4gICAgICAgICAgICAgICAgY3VzdG9tT3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgfTtcblxuICAgIHZhciBsb3dlckNhc2VGaXJzdExldHRlciA9IGZ1bmN0aW9uIGxvd2VyQ2FzZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICB2YXIgYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQ2FtZWxzKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgvXmRhdGEtLywgJycpKTtcbiAgICB9O1xuXG4gICAgdmFyIG1hcE9iamVjdCA9IGZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIHByb3BlcnR5TWFwKSB7XG4gICAgICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgICAgICBmb3Jpbihwcm9wZXJ0eU1hcCwgZnVuY3Rpb24oc2VsZWN0b3IsIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGZvcmluKG9iamVjdCwgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHJlZ2V4cCBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclJlZ0V4cCA9IG5ldyBSZWdFeHAoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVzdHMgaWZcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2gsIHNraXBcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBtYXBwaW5nLCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgaXMgYWx3YXlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IHJlbW92ZSwgd2UgZG9uZSFcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdmFsdWUgdG8gbmV3IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFttYXBwaW5nXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBncm91cFxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1hcHBpbmcpICYmICFvYmplY3RbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtncm91cF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmplY3RbZ3JvdXBdW2xvd2VyQ2FzZUZpcnN0TGV0dGVyKHByb3BlcnR5LnJlcGxhY2Uoc2VsZWN0b3JSZWdFeHAsICcnKSldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgICAgICAgaWYgKG1hcHBpbmcubWFwcGluZykge1xuICAgICAgICAgICAgICAgIG1hcE9iamVjdChvYmplY3RbbWFwcGluZy5ncm91cF0sIG1hcHBpbmcubWFwcGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXR0cmlidXRlc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0FzT2JqZWN0KG5vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU1hcHBpbmcgPVxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvcmluKG5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChub2RlLmF0dHJpYnV0ZXNbaW5kZXhdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyKG5vZGUsIGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgIG9ialthdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBhdHRyaWJ1dGUubmFtZSA/IHRydWUgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgIC8vIGRvIG1hcHBpbmcgb2Ygb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFwcEF0RWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcEF0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAvLyBob3cgYXR0cmlidXRlcyBvZiB0aGUgaW5wdXQgZWxlbWVudCBhcmUgbWFwcGVkIHRvIHRoZSBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG4gICAgICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID0ge1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIG90aGVyIG5hbWVcbiAgICAgICAgICAgICdeY2xhc3MkJzogJ2NsYXNzTmFtZScsXG4gICAgICAgICAgICAnXm11bHRpcGxlJCc6ICdhbGxvd011bHRpcGxlJyxcbiAgICAgICAgICAgICdeY2FwdHVyZSQnOiAnY2FwdHVyZU1ldGhvZCcsXG4gICAgICAgICAgICAnXndlYmtpdGRpcmVjdG9yeSQnOiAnYWxsb3dEaXJlY3Rvcmllc09ubHknLFxuXG4gICAgICAgICAgICAvLyBncm91cCB1bmRlciBzaW5nbGUgcHJvcGVydHlcbiAgICAgICAgICAgICdec2VydmVyJzoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnc2VydmVyJyxcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICdecHJvY2Vzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ3JldmVydCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15mZXRjaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICdecmVzdG9yZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBpbiBvYmplY3RcbiAgICAgICAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICAgICAgICdeZmlsZXMkJzogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgICAgIGFwcGx5RmlsdGVycygnU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGZpbmFsIG9wdGlvbnMgb2JqZWN0IGJ5IHNldHRpbmcgb3B0aW9ucyBvYmplY3QgYW5kIHRoZW4gb3ZlcnJpZGluZyBvcHRpb25zIHN1cHBsaWVkIG9uIGVsZW1lbnRcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXNBc09iamVjdChcbiAgICAgICAgICAgIGVsZW1lbnQubm9kZU5hbWUgPT09ICdGSUVMRFNFVCcgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKSA6IGVsZW1lbnQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVNYXBwaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbWVyZ2Ugd2l0aCBvcHRpb25zIG9iamVjdFxuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGF0dHJpYnV0ZU9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG1lcmdlZE9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVyZ2VkT3B0aW9uc1trZXldLCBhdHRyaWJ1dGVPcHRpb25zW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSBhdHRyaWJ1dGVPcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHBhcmVudCBpcyBhIGZpZWxkc2V0LCBnZXQgZmlsZXMgZnJvbSBwYXJlbnQgYnkgc2VsZWN0aW5nIGFsbCBpbnB1dCBmaWVsZHMgdGhhdCBhcmUgbm90IGZpbGUgdXBsb2FkIGZpZWxkc1xuICAgICAgICAvLyB0aGVzZSB3aWxsIHRoZW4gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGluaXRpYWwgZmlsZXNcbiAgICAgICAgbWVyZ2VkT3B0aW9ucy5maWxlcyA9IChvcHRpb25zLmZpbGVzIHx8IFtdKS5jb25jYXQoXG4gICAgICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPWZpbGVdKScpKS5tYXAoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGlucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYnVpbGQgcGx1Z2luXG4gICAgICAgIHZhciBhcHAgPSBjcmVhdGVBcHBPYmplY3QobWVyZ2VkT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWRkIGFscmVhZHkgc2VsZWN0ZWQgZmlsZXNcbiAgICAgICAgaWYgKGVsZW1lbnQuZmlsZXMpIHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5maWxlcykuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgYXBwLmFkZEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGFwcC5yZXBsYWNlRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9O1xuXG4gICAgLy8gaWYgYW4gZWxlbWVudCBpcyBwYXNzZWQsIHdlIGNyZWF0ZSB0aGUgaW5zdGFuY2UgYXQgdGhhdCBlbGVtZW50LCBpZiBub3QsIHdlIGp1c3QgY3JlYXRlIGFuIHVwIG9iamVjdFxuICAgIHZhciBjcmVhdGVBcHAkMSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZShhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pXG4gICAgICAgICAgICA/IGNyZWF0ZUFwcEF0RWxlbWVudC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIDogY3JlYXRlQXBwT2JqZWN0LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIFBSSVZBVEVfTUVUSE9EUyA9IFsnZmlyZScsICdfcmVhZCcsICdfd3JpdGUnXTtcblxuICAgIHZhciBjcmVhdGVBcHBBUEkgPSBmdW5jdGlvbiBjcmVhdGVBcHBBUEkoYXBwKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fTtcblxuICAgICAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGFwcCwgYXBpLCBQUklWQVRFX01FVEhPRFMpO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHBsYWNlaG9sZGVycyBpbiBnaXZlbiBzdHJpbmcgd2l0aCByZXBsYWNlbWVudHNcbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gICAgICogQHBhcmFtIHJlcGxhY2VtZW50cyAtIHsgXCJiYXJcIjogMTAgfVxuICAgICAqL1xuICAgIHZhciByZXBsYWNlSW5TdHJpbmcgPSBmdW5jdGlvbiByZXBsYWNlSW5TdHJpbmcoc3RyaW5nLCByZXBsYWNlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oPzp7KFthLXpBLVpdKyl9KS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudHNbZ3JvdXBdO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgICAgICB2YXIgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFsnKCcsIGZuLnRvU3RyaW5nKCksICcpKCknXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmZXI6IGZ1bmN0aW9uIHRyYW5zZmVyKG1lc3NhZ2UsIGNiKSB7fSxcbiAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlckxpc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gdGVybWluYXRlKCkge1xuICAgICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmFtZUZpbGUgPSBmdW5jdGlvbiByZW5hbWVGaWxlKGZpbGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlbmFtZWRGaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIGZpbGUudHlwZSk7XG4gICAgICAgIHJlbmFtZWRGaWxlLmxhc3RNb2RpZmllZERhdGUgPSBmaWxlLmxhc3RNb2RpZmllZERhdGU7XG4gICAgICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gcmVuYW1lZEZpbGU7XG4gICAgfTtcblxuICAgIHZhciBjb3B5RmlsZSA9IGZ1bmN0aW9uIGNvcHlGaWxlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmFtZUZpbGUoZmlsZSwgZmlsZS5uYW1lKTtcbiAgICB9O1xuXG4gICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkIHBsdWdpbnMgKGNhbid0IHJlZ2lzdGVyIHR3aWNlKVxuICAgIHZhciByZWdpc3RlcmVkUGx1Z2lucyA9IFtdO1xuXG4gICAgLy8gcGFzcyB1dGlscyB0byBwbHVnaW5cbiAgICB2YXIgY3JlYXRlQXBwUGx1Z2luID0gZnVuY3Rpb24gY3JlYXRlQXBwUGx1Z2luKHBsdWdpbikge1xuICAgICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbWVtYmVyIHRoaXMgcGx1Z2luXG4gICAgICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgICAgICAvLyBzZXR1cCFcbiAgICAgICAgdmFyIHBsdWdpbk91dGxpbmUgPSBwbHVnaW4oe1xuICAgICAgICAgICAgYWRkRmlsdGVyOiBhZGRGaWx0ZXIsXG4gICAgICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgICAgIFR5cGU6IFR5cGUsXG4gICAgICAgICAgICAgICAgZm9yaW46IGZvcmluLFxuICAgICAgICAgICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgICAgICAgICBpc0ZpbGU6IGlzRmlsZSxcbiAgICAgICAgICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZTogdG9OYXR1cmFsRmlsZVNpemUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUluU3RyaW5nOiByZXBsYWNlSW5TdHJpbmcsXG4gICAgICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lOiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZTogZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgICAgICAgICBnZXRGaWxlRnJvbUJsb2I6IGdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkw6IGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgICAgICAgICBjcmVhdGVSb3V0ZTogY3JlYXRlUm91dGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlV29ya2VyOiBjcmVhdGVXb3JrZXIsXG4gICAgICAgICAgICAgICAgY3JlYXRlVmlldzogY3JlYXRlVmlldyxcbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtQVBJOiBjcmVhdGVJdGVtQVBJLFxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZTogbG9hZEltYWdlLFxuICAgICAgICAgICAgICAgIGNvcHlGaWxlOiBjb3B5RmlsZSxcbiAgICAgICAgICAgICAgICByZW5hbWVGaWxlOiByZW5hbWVGaWxlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUJsb2I6IGNyZWF0ZUJsb2IsXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbjogYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmc6IGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgICAgIGZpbGVBY3Rpb25CdXR0b246IGZpbGVBY3Rpb25CdXR0b24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgcGx1Z2luIG9wdGlvbnMgdG8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGV4dGVuZERlZmF1bHRPcHRpb25zKHBsdWdpbk91dGxpbmUub3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgc3VwcG9ydGVkKCkgbWV0aG9kXG4gICAgdmFyIGlzT3BlcmFNaW5pID0gZnVuY3Rpb24gaXNPcGVyYU1pbmkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93Lm9wZXJhbWluaSkgPT09ICdbb2JqZWN0IE9wZXJhTWluaV0nO1xuICAgIH07XG4gICAgdmFyIGhhc1Byb21pc2VzID0gZnVuY3Rpb24gaGFzUHJvbWlzZXMoKSB7XG4gICAgICAgIHJldHVybiAnUHJvbWlzZScgaW4gd2luZG93O1xuICAgIH07XG4gICAgdmFyIGhhc0Jsb2JTbGljZSA9IGZ1bmN0aW9uIGhhc0Jsb2JTbGljZSgpIHtcbiAgICAgICAgcmV0dXJuICdzbGljZScgaW4gQmxvYi5wcm90b3R5cGU7XG4gICAgfTtcbiAgICB2YXIgaGFzQ3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gaGFzQ3JlYXRlT2JqZWN0VVJMKCkge1xuICAgICAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdjcmVhdGVPYmplY3RVUkwnIGluIHdpbmRvdy5VUkw7XG4gICAgfTtcbiAgICB2YXIgaGFzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIGhhc1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIHJldHVybiAndmlzaWJpbGl0eVN0YXRlJyBpbiBkb2N1bWVudDtcbiAgICB9O1xuICAgIHZhciBoYXNUaW1pbmcgPSBmdW5jdGlvbiBoYXNUaW1pbmcoKSB7XG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2UnIGluIHdpbmRvdztcbiAgICB9OyAvLyBpT1MgOC54XG4gICAgdmFyIGhhc0NTU1N1cHBvcnRzID0gZnVuY3Rpb24gaGFzQ1NTU3VwcG9ydHMoKSB7XG4gICAgICAgIHJldHVybiAnc3VwcG9ydHMnIGluICh3aW5kb3cuQ1NTIHx8IHt9KTtcbiAgICB9OyAvLyB1c2UgdG8gZGV0ZWN0IFNhZmFyaSA5K1xuICAgIHZhciBpc0lFMTEgPSBmdW5jdGlvbiBpc0lFMTEoKSB7XG4gICAgICAgIHJldHVybiAvTVNJRXxUcmlkZW50Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUnVucyBpbW1lZGlhdGVseSBhbmQgdGhlbiByZW1lbWJlcnMgcmVzdWx0IGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICAgIHZhciBpc1N1cHBvcnRlZCA9XG4gICAgICAgICAgICAvLyBIYXMgdG8gYmUgYSBicm93c2VyXG4gICAgICAgICAgICBpc0Jyb3dzZXIoKSAmJlxuICAgICAgICAgICAgLy8gQ2FuJ3QgcnVuIG9uIE9wZXJhIE1pbmkgZHVlIHRvIGxhY2sgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgICAgIWlzT3BlcmFNaW5pKCkgJiZcbiAgICAgICAgICAgIC8vIFJlcXVpcmUgdGhlc2UgQVBJcyB0byBmZWF0dXJlIGRldGVjdCBhIG1vZGVybiBicm93c2VyXG4gICAgICAgICAgICBoYXNWaXNpYmlsaXR5KCkgJiZcbiAgICAgICAgICAgIGhhc1Byb21pc2VzKCkgJiZcbiAgICAgICAgICAgIGhhc0Jsb2JTbGljZSgpICYmXG4gICAgICAgICAgICBoYXNDcmVhdGVPYmplY3RVUkwoKSAmJlxuICAgICAgICAgICAgaGFzVGltaW5nKCkgJiZcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgbmVlZCBDU1NTdXBwb3J0cyBidXQgaXMgYSBnb29kIHdheSB0byBkZXRlY3QgU2FmYXJpIDkrICh3ZSBkbyB3YW50IHRvIHN1cHBvcnQgSUUxMSB0aG91Z2gpXG4gICAgICAgICAgICAoaGFzQ1NTU3VwcG9ydHMoKSB8fCBpc0lFMTEoKSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBQbHVnaW4gaW50ZXJuYWwgc3RhdGUgKG92ZXIgYWxsIGluc3RhbmNlcylcbiAgICAgKi9cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIC8vIGFjdGl2ZSBhcHAgaW5zdGFuY2VzLCB1c2VkIHRvIHJlZHJhdyB0aGUgYXBwcyBhbmQgdG8gZmluZCB0aGUgbGF0ZXJcbiAgICAgICAgYXBwczogW10sXG4gICAgfTtcblxuICAgIC8vIHBsdWdpbiBuYW1lXG4gICAgdmFyIG5hbWUgPSAnZmlsZXBvbmQnO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIFBsdWdpbiBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7fTtcbiAgICBleHBvcnRzLlN0YXR1cyA9IHt9O1xuICAgIGV4cG9ydHMuRmlsZVN0YXR1cyA9IHt9O1xuICAgIGV4cG9ydHMuRmlsZU9yaWdpbiA9IHt9O1xuICAgIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGZuO1xuICAgIGV4cG9ydHMuZGVzdHJveSA9IGZuO1xuICAgIGV4cG9ydHMucGFyc2UgPSBmbjtcbiAgICBleHBvcnRzLmZpbmQgPSBmbjtcbiAgICBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luID0gZm47XG4gICAgZXhwb3J0cy5nZXRPcHRpb25zID0gZm47XG4gICAgZXhwb3J0cy5zZXRPcHRpb25zID0gZm47XG5cbiAgICAvLyBpZiBub3Qgc3VwcG9ydGVkLCBubyBBUElcbiAgICBpZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgLy8gc3RhcnQgcGFpbnRlciBhbmQgZmlyZSBsb2FkIGV2ZW50XG4gICAgICAgIGNyZWF0ZVBhaW50ZXIoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHAuX3JlYWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbih0cykge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5fd3JpdGUodHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGZpcmUgbG9hZGVkIGV2ZW50IHNvIHdlIGtub3cgd2hlbiBGaWxlUG9uZCBpcyBhdmFpbGFibGVcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6bG9hZGVkJywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZDogc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiBleHBvcnRzLmNyZWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGV4cG9ydHMuZGVzdHJveSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiBleHBvcnRzLnBhcnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluZDogZXhwb3J0cy5maW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW46IGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBleHBvcnRzLnNldE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFuIHVwIGV2ZW50XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgdG8gYmFjayBvZiBleGVjdXRpb24gcXVldWUsIEZpbGVQb25kIHNob3VsZCBoYXZlIGJlZW4gZXhwb3J0ZWQgYnkgdGhlblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZXMgdGhlIE9wdGlvblR5cGVzIG9iamVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgICAgIHZhciB1cGRhdGVPcHRpb25UeXBlcyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvblR5cGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuT3B0aW9uVHlwZXNba2V5XSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZXhwb3J0cy5TdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0dXMpO1xuICAgICAgICBleHBvcnRzLkZpbGVPcmlnaW4gPSBPYmplY3QuYXNzaWduKHt9LCBGaWxlT3JpZ2luKTtcbiAgICAgICAgZXhwb3J0cy5GaWxlU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgSXRlbVN0YXR1cyk7XG5cbiAgICAgICAgZXhwb3J0cy5PcHRpb25UeXBlcyA9IHt9O1xuICAgICAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBtZXRob2QsIGNyZWF0ZXMgYXBwcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBhcHAgYXJyYXlcbiAgICAgICAgZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgICAgICB2YXIgYXBwID0gY3JlYXRlQXBwJDEuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXBwLm9uKCdkZXN0cm95JywgZXhwb3J0cy5kZXN0cm95KTtcbiAgICAgICAgICAgIHN0YXRlLmFwcHMucHVzaChhcHApO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlc3Ryb3lzIGFwcHMgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBhcHAgYXJyYXlcbiAgICAgICAgZXhwb3J0cy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShob29rKSB7XG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgdGhlIGFwcCB3YXMgZGVzdHJveWVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSBzdGF0ZS5hcHBzLmZpbmRJbmRleChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGFwcHNcbiAgICAgICAgICAgICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSlbMF07XG5cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGRvbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhcnNlcyB0aGUgZ2l2ZW4gY29udGV4dCBmb3IgcGx1Z2lucyAoZG9lcyBub3QgaW5jbHVkZSB0aGUgY29udGV4dCBlbGVtZW50IGl0c2VsZilcbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbGwgcG9zc2libGUgaG9va3NcbiAgICAgICAgICAgIHZhciBtYXRjaGVkSG9va3MgPSBBcnJheS5mcm9tKGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBuYW1lKSk7XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYWxyZWFkeSBhY3RpdmUgaG9va3NcbiAgICAgICAgICAgIHZhciBuZXdIb29rcyA9IG1hdGNoZWRIb29rcy5maWx0ZXIoZnVuY3Rpb24obmV3SG9vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhuZXdIb29rKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIGZvciBlYWNoIGhvb2tcbiAgICAgICAgICAgIHJldHVybiBuZXdIb29rcy5tYXAoZnVuY3Rpb24oaG9vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYW4gYXBwIGJhc2VkIG9uIHRoZSBnaXZlbiBlbGVtZW50IGhvb2tcbiAgICAgICAgZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gZmluZChob29rKSB7XG4gICAgICAgICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHAuaXNBdHRhY2hlZFRvKGhvb2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFwcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgICAgIGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgT3B0aW9uVHlwZXMsIGVhY2ggcGx1Z2luIG1pZ2h0IGhhdmUgZXh0ZW5kZWQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBleHBvcnRzLmdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zJDEoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0c1trZXldID0gdmFsdWVbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMkMShvcHRzKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0cykpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcGx1Z2luc1xuICAgICAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLnNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBuZXcgb3B0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9